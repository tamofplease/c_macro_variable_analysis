<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/parser/parse_utilcmd.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_utilcmd.c
 *	  Perform parse analysis work for various utility commands
 *
 * Formerly we did this work during parse_analyze() in analyze.c.  However
 * that is fairly unsafe in the presence of querytree caching, since any
 * database state that we depend on in making the transformations might be
 * obsolete by the time the utility command is executed; and utility commands
 * have no infrastructure for holding locks or rechecking plan validity.
 * Hence these functions are now called at the start of execution of their
 * respective utility commands.
 *
 * NOTE: in general we must avoid scribbling on the passed-in raw parse
 * tree, since it might be in a plan cache.  The simplest solution is
 * a quick copyObject() call before manipulating the query tree.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *	src/backend/parser/parse_utilcmd.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/comment.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_utilcmd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>


<comment type="block">/* POLAR: mark I am creating rule which is used for filting unsafe functions */</comment>
<decl_stmt><decl><type><name>bool</name></type> <name>polar_creating_rule</name></decl>;</decl_stmt>

<comment type="block">/* State shared by transformCreateStmt and its subroutines */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>			<comment type="block">/* overall parser state */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl>;</decl_stmt>		<comment type="block">/* "CREATE [FOREIGN] TABLE" or "ALTER TABLE" */</comment>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relation</name></decl>;</decl_stmt>		<comment type="block">/* relation to create */</comment>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>			<comment type="block">/* opened/locked rel, if ALTER */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inhRelations</name></decl>;</decl_stmt>	<comment type="block">/* relations to inherit from */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isforeign</name></decl>;</decl_stmt>		<comment type="block">/* true if CREATE/ALTER FOREIGN TABLE */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isalter</name></decl>;</decl_stmt>		<comment type="block">/* true if altering existing table */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasoids</name></decl>;</decl_stmt>		<comment type="block">/* does relation have an OID column? */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>		<comment type="block">/* ColumnDef items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ckconstraints</name></decl>;</decl_stmt>	<comment type="block">/* CHECK constraints */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>fkconstraints</name></decl>;</decl_stmt>	<comment type="block">/* FOREIGN KEY constraints */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>ixconstraints</name></decl>;</decl_stmt>	<comment type="block">/* index-creating constraints */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>inh_indexes</name></decl>;</decl_stmt>	<comment type="block">/* cloned indexes from INCLUDING INDEXES */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>extstats</name></decl>;</decl_stmt>		<comment type="block">/* cloned extended statistics */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>blist</name></decl>;</decl_stmt>			<comment type="block">/* "before list" of things to do before
								 * creating the table */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>alist</name></decl>;</decl_stmt>			<comment type="block">/* "after list" of things to do after creating
								 * the table */</comment>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>pkey</name></decl>;</decl_stmt>			<comment type="block">/* PRIMARY KEY index, if any */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ispartitioned</name></decl>;</decl_stmt>	<comment type="block">/* true if table is partitioned */</comment>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>partbound</name></decl>;</decl_stmt>	<comment type="block">/* transformed FOR VALUES */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ofType</name></decl>;</decl_stmt>			<comment type="block">/* true if statement contains OF typename */</comment>
}</block></struct></type> <name>CreateStmtContext</name>;</typedef>

<comment type="block">/* State shared by transformCreateSchemaStmt and its subroutines */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>stmtType</name></decl>;</decl_stmt>		<comment type="block">/* "CREATE SCHEMA" or "ALTER SCHEMA" */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>		<comment type="block">/* name of schema */</comment>
	<decl_stmt><decl><type><name>RoleSpec</name>   <modifier>*</modifier></type><name>authrole</name></decl>;</decl_stmt>		<comment type="block">/* owner of schema */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sequences</name></decl>;</decl_stmt>		<comment type="block">/* CREATE SEQUENCE items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tables</name></decl>;</decl_stmt>			<comment type="block">/* CREATE TABLE items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>views</name></decl>;</decl_stmt>			<comment type="block">/* CREATE VIEW items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>		<comment type="block">/* CREATE INDEX items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>triggers</name></decl>;</decl_stmt>		<comment type="block">/* CREATE TRIGGER items */</comment>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>grants</name></decl>;</decl_stmt>			<comment type="block">/* GRANT items */</comment>
}</block></struct></type> <name>CreateSchemaStmtContext</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformColumnDefinition</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
						  <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformTableConstraint</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
						 <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformTableLikeClause</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
						 <parameter><decl><type><name>TableLikeClause</name> <modifier>*</modifier></type><name>table_like_clause</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformOfType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
				<parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type><name>generateClonedExtStatsStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>heapRelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>source_statsid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_collation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_opclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformIndexConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>transformIndexConstraint</name><parameter_list>(<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>,
						 <parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformExtendedStatistics</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformFKConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>isAddConstraint</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformCheckConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformConstraintAttrs</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintList</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformColumnType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setSchemaName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>context_schema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>stmt_schema_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>transformPartitionCmd</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validateInfiniteBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>blist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type><name>transformPartitionBoundValue</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>colType</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>colTypmod</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * transformCreateStmt -
 *	  parse analysis for CREATE TABLE
 *
 * Returns a List of utility commands to be done in sequence.  One of these
 * will be the transformed CreateStmt, but there may be additional actions
 * to be done before and after the actual DefineRelation() call.
 *
 * SQL allows constraints to be scattered all over, so thumb through
 * the columns and collect all constraints into one place.
 * If there are any implied indices (e.g. UNIQUE or PRIMARY KEY)
 * then expand those into multiple IndexStmt blocks.
 *	  - thomas 1997-12-02
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCreateStmt</name><parameter_list>(<parameter><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_alist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>existing_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>like_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_foreign_table</name> <init>= <expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must not scribble on the passed-in CreateStmt, so copy it.  (This is
	 * overkill, but easy.)
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the creation namespace.  This also checks permissions on the
	 * target namespace, locks it against concurrent drops, checks for a
	 * preexisting relation in that namespace with the same name, and updates
	 * stmt-&gt;relation-&gt;relpersistence if the selected namespace is temporary.
	 */</comment>
	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespaceid</name> <operator>=</operator>
		<call><name>RangeVarGetAndCheckCreationNamespace</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>existing_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation already exists and the user specified "IF NOT EXISTS",
	 * bail out with a NOTICE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>existing_relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists, skipping"</literal></expr></argument>,
						<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the target relation name isn't schema-qualified, make it so.  This
	 * prevents some corner cases in which added-on rewritten commands might
	 * think they should apply to other relations that have the same name and
	 * are earlier in the search path.  But a local temp table is effectively
	 * specified to be in pg_temp, so no need for anything extra in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>==</operator> <name>NULL</name>
		<operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up CreateStmtContext */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateForeignTableStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"CREATE FOREIGN TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"CREATE TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inhRelations</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isalter</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>fkconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ixconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inh_indexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>extstats</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ispartitioned</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>partbound</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ofType</name></name> <operator>=</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Notice that we allow OIDs here only for plain tables, even though
	 * foreign tables also support them.  This is necessary because the
	 * default_with_oids GUC must apply only to plain tables and not any other
	 * relkind; doing otherwise would break existing pg_dump files.  We could
	 * allow explicit "WITH OIDS" while not allowing default_with_oids to
	 * affect other relkinds, but it would complicate interpretOidsOption(),
	 * and right now there's no WITH OIDS option in CREATE FOREIGN TABLE
	 * anyway.
	 */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>hasoids</name></name> <operator>=</operator> <call><name>interpretOidsOption</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>cxt</name><operator>.</operator><name>isforeign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name> <operator>||</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* grammar enforces */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>transformOfType</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>ofTypename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>partspec</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>inhRelations</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stmt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create partitioned table as inheritance child"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Run through each primary element in the table creation clause. Separate
	 * column defs from constraints, and do preliminary analysis.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>elements</argument>, <argument>stmt-&gt;tableElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>element</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><call><name>transformColumnDefinition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<expr_stmt><expr><call><name>transformTableConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<expr_stmt><expr><name>like_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>transformTableLikeClause</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>TableLikeClause</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * If we had any LIKE tables, they may require creation of an OID column
	 * even though the command's own WITH clause didn't ask for one (or,
	 * perhaps, even specifically rejected having one).  Insert a WITH option
	 * to ensure that happens.  We prepend to the list because the first oid
	 * option will be honored, and we want to override anything already there.
	 * (But note that DefineRelation will override this again to add an OID
	 * column if one appears in an inheritance parent table.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>like_found</name> <operator>&amp;&amp;</operator> <name><name>cxt</name><operator>.</operator><name>hasoids</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"oids"</literal></expr></argument>,
										  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * transformIndexConstraints wants cxt.alist to contain only index
	 * statements, so transfer anything we already have into save_alist.
	 */</comment>
	<expr_stmt><expr><name>save_alist</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>alist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess constraints that give rise to index definitions.
	 */</comment>
	<expr_stmt><expr><call><name>transformIndexConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess foreign-key constraints.
	 */</comment>
	<expr_stmt><expr><call><name>transformFKConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess check constraints.
	 */</comment>
	<expr_stmt><expr><call><name>transformCheckConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><name>is_foreign_table</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Postprocess extended statistics.
	 */</comment>
	<expr_stmt><expr><call><name>transformExtendedStatistics</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Output results.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tableElts</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>columns</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>save_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * generateSerialExtraStmts
 *		Generate CREATE SEQUENCE and ALTER SEQUENCE ... OWNED BY statements
 *		to create the sequence for a serial or identity column.
 *
 * This includes determining the name the sequence will have.  The caller
 * can ask to get back the name components by passing non-null pointers
 * for snamespace_p and sname_p.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>generateSerialExtraStmts</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>seqtypid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>seqoptions</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>for_identity</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>snamespace_p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sname_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>option</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>nameEl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>snamespaceid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>seqstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>altseqstmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>attnamelist</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine namespace and name to use for the sequence.
	 *
	 * First, check if a sequence name was passed in as an option.  This is
	 * used by pg_dump.  Else, generate a name.
	 *
	 * Although we use ChooseRelationName, it's not guaranteed that the
	 * selected sequence name won't conflict; given sufficiently long field
	 * names, two different serial columns in the same table could be assigned
	 * the same sequence name, and we'd not notice since we aren't creating
	 * the sequence quite yet.  In practice this seems quite unlikely to be a
	 * problem, especially since few people would need two serial columns in
	 * one table.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>option</argument>, <argument>seqoptions</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>defel</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>defel</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"sequence_name"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nameEl</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting or redundant options"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>nameEl</name> <operator>=</operator> <name>defel</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>nameEl</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rv</name> <init>= <expr><call><name>makeRangeVarFromNameList</name><argument_list>(<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>nameEl</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <name><name>rv</name><operator>-&gt;</operator><name>schemaname</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>snamespace</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Given unqualified SEQUENCE NAME, select namespace */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>sname</name> <operator>=</operator> <name><name>rv</name><operator>-&gt;</operator><name>relname</name></name></expr>;</expr_stmt>
		<comment type="block">/* Remove the SEQUENCE NAME item from seqoptions */</comment>
		<expr_stmt><expr><name>seqoptions</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>seqoptions</name></expr></argument>, <argument><expr><name>nameEl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>snamespaceid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RangeVarAdjustRelationPersistence</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>snamespace</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>snamespaceid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sname</name> <operator>=</operator> <call><name>ChooseRelationName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>,
								   <argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>,
								   <argument><expr><literal type="string">"seq"</literal></expr></argument>,
								   <argument><expr><name>snamespaceid</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s will create implicit sequence \"%s\" for serial column \"%s.%s\""</literal></expr></argument>,
					<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>stmtType</name></name></expr></argument>, <argument><expr><name>sname</name></expr></argument>,
					<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a CREATE SEQUENCE command to create the sequence object, and add
	 * it to the list of things to be done before this CREATE/ALTER TABLE.
	 */</comment>
	<expr_stmt><expr><name>seqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>for_identity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>seqoptions</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If a sequence data type was specified, add it to the options.  Prepend
	 * to the list rather than append; in case a user supplied their own AS
	 * clause, the "redundant options" error will point to their occurrence,
	 * not our synthetic one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>seqtypid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"as"</literal></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>seqtypid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is ALTER ADD COLUMN, make sure the sequence will be owned by
	 * the table's owner.  The current user might be someone else (perhaps a
	 * superuser, or someone who's only a member of the owning role), but the
	 * SEQUENCE OWNED BY mechanisms will bleat unless table and sequence have
	 * exactly the same owning role.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>ownerId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>blist</name></name></expr></argument>, <argument><expr><name>seqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the identity sequence name that we decided on.  ALTER TABLE ...
	 * ADD COLUMN ... IDENTITY needs this so that it can fill the new column
	 * with values from the sequence, while the association of the sequence
	 * with the table is not set until after the ALTER TABLE.
	 */</comment>
	<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>identitySequence</name></name> <operator>=</operator> <name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build an ALTER SEQUENCE ... OWNED BY command to mark the sequence as
	 * owned by this column, and add it to the list of things to be done after
	 * this CREATE/ALTER TABLE.
	 */</comment>
	<expr_stmt><expr><name>altseqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attnamelist</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"owned_by"</literal></expr></argument>,
												 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>attnamelist</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>for_identity</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>altseqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>snamespace_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>snamespace_p</name> <operator>=</operator> <name>snamespace</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sname_p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>sname_p</name> <operator>=</operator> <name>sname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformColumnDefinition -
 *		transform a single ColumnDef within CREATE TABLE
 *		Also used in ALTER TABLE ADD COLUMN
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformColumnDefinition</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_serial</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_nullable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_default</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_identity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>clist</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check for SERIAL pseudo-types */</comment>
	<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name>
		<operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal>
		<operator>&amp;&amp;</operator> <operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>pct_type</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"smallserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT2OID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial4"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"bigserial"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
				 <call><name>strcmp</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><literal type="string">"serial8"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_serial</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>INT8OID</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We have to reject "serial[]" explicitly, because once we've set
		 * typeid, LookupTypeName won't notice arrayBounds.  We don't need any
		 * special coding for serial(typmod) though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_serial</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>arrayBounds</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array of serial is not implemented"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Do necessary work on the column type declaration */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>transformColumnType</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>column</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Special actions for SERIAL pseudo-types */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_serial</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>snamespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qstring</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>snamenode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>castnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCall</name>   <modifier>*</modifier></type><name>funccallnode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>column</name></expr></argument>,
								 <argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>typeOid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>snamespace</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create appropriate constraints for SERIAL.  We do this in full,
		 * rather than shortcutting, so that we will detect any conflicting
		 * constraints the user wrote (like a different DEFAULT).
		 *
		 * Create an expression tree representing the function call
		 * nextval('sequencename').  We cannot reduce the raw tree to cooked
		 * form until after the sequence is created, but there's no need to do
		 * so.
		 */</comment>
		<expr_stmt><expr><name>qstring</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>snamespace</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snamenode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snamenode</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snamenode</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>val</name><operator>.</operator><name>str</name></name> <operator>=</operator> <name>qstring</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snamenode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>castnode</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castnode</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>SystemTypeName</name><argument_list>(<argument><expr><literal type="string">"regclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castnode</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>snamenode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>castnode</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>funccallnode</name> <operator>=</operator> <call><name>makeFuncCall</name><argument_list>(<argument><expr><call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"nextval"</literal></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>castnode</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>constraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>funccallnode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>constraint</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_NOTNULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Process column constraints, if any... */</comment>
	<expr_stmt><expr><call><name>transformConstraintAttrs</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>constraints</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saw_default</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saw_identity</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>clist</argument>, <argument>column-&gt;constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name>clist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_NULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>saw_nullable</name> <operator>&amp;&amp;</operator> <name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL declarations for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>saw_nullable</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting NULL/NOT NULL declarations for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_nullable</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>saw_default</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple default values specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
									<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>raw_expr</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_default</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_IDENTITY</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Type</name></type>		<name>ctype</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ofType</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"identity columns are not supported on typed tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>partbound</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"identity columns are not supported on partitions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>typeOid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>saw_identity</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple identity specifications for column \"%s\" of table \"%s\""</literal></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
													<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>column</name></expr></argument>,
											 <argument><expr><name>typeOid</name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>generated_when</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>saw_identity</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* FALL THRU */</comment>

			<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
				<comment type="block">/* grammar does not allow EXCLUDE as a column constraint */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"column exclusion constraints are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
												<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Fill in the current attribute's name and throw it into the
				 * list of FK constraints to be processed later.
				 */</comment>
				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>fk_attrs</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
			<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
				<comment type="block">/* transformConstraintAttrs took care of these */</comment>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<if_stmt><if>if <condition>(<expr><name>saw_default</name> <operator>&amp;&amp;</operator> <name>saw_identity</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"both default and identity specified for column \"%s\" of table \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If needed, generate ALTER FOREIGN TABLE ALTER COLUMN statement to add
	 * per-column foreign data wrapper options to this column after creation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>fdwoptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AlterColumnGenericOptions</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>column</name><operator>-&gt;</operator><name>fdwoptions</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>behavior</name></name> <operator>=</operator> <name>DROP_RESTRICT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_FOREIGN_TABLE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformTableConstraint
 *		transform a Constraint node within CREATE TABLE or ALTER TABLE
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformTableConstraint</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unique constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ispartitioned</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"exclusion constraints are not supported on partitioned tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ixconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"foreign key constraints are not supported on foreign tables"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
											<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name></expr></argument>, <argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_NULL</name></expr>:</case>
		<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
		<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
		<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid context for constraint type %d"</literal></expr></argument>,
				 <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
				 <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * transformTableLikeClause
 *
 * Change the LIKE &lt;srctable&gt; portion of a CREATE TABLE statement into
 * column definitions which recreate the user defined column portions of
 * &lt;srctable&gt;.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformTableLikeClause</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>TableLikeClause</name> <modifier>*</modifier></type><name>table_like_clause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>parent_attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>constr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseCallbackState</name></type> <name>pcbstate</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>setup_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
									  <argument><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we could support LIKE in many cases, but worry about it another day */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>isforeign</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LIKE is not supported for creating foreign tables"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>relation_openrv</name><argument_list>(<argument><expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table, view, materialized view, composite type, or foreign table"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>cancel_parser_errposition_callback</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pcbstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for privileges
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_type_aclcheck</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									 <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_TYPE</name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>constr</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize column number map for map_variable_attnos().  We need this
	 * since dropped columns in the source table aren't copied, so the new
	 * table can have different column numbers.
	 */</comment>
	<expr_stmt><expr><name>attmap</name> <operator>=</operator> <operator>(</operator><name>AttrNumber</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttrNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Insert the copied attributes into the cxt for the new table definition.
	 */</comment>
	<for>for <control>(<init><expr><name>parent_attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>parent_attno</name> <operator>&lt;=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition>
		 <incr><expr><name>parent_attno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attribute</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDesc</name></expr></argument>,
													<argument><expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attributeName</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Ignore dropped columns in the parent.  attmap entry is left zero.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Create a new column, which is marked as NOT inherited.
		 *
		 * For constraints, ONLY the NOT NULL constraint is inherited by the
		 * new column definition per SQL99.
		 */</comment>
		<expr_stmt><expr><name>def</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>attributeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add to column list
		 */</comment>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>attmap</name><index>[<expr><name>parent_attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copy default, if present and the default has been requested
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_DEFAULTS</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>this_default</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>attrdef</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* Find default in constraint structure */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>constr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attrdef</name> <operator>=</operator> <name><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adnum</name> <operator>==</operator> <name>parent_attno</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>this_default</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>attrdef</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>this_default</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If default expr could contain any vars, we'd need to fix 'em,
			 * but it can't; so default is ready to apply to child.
			 */</comment>

			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>this_default</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Copy identity if requested
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attribute</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_IDENTITY</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seq_options</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * find sequence owned by old column; extract sequence parameters;
			 * build new create sequence command
			 */</comment>
			<expr_stmt><expr><name>seq_relid</name> <operator>=</operator> <call><name>getOwnedSequence</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>seq_options</name> <operator>=</operator> <call><name>sequence_options</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>def</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>seq_options</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attidentity</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Likewise, copy storage if requested */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_STORAGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <name><name>attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Likewise, copy comment if requested */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>,
								  <argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><name><name>attribute</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_COLUMN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We use oids if at least one LIKE'ed table has oids. */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>hasoids</name></name> <operator>|=</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy CHECK constraints if requested, being careful to adjust attribute
	 * numbers so they match the child.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_CONSTRAINTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ccnum</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>ccnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ccnum</name> <operator>&lt;</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</condition> <incr><expr><name>ccnum</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccname</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>ccnum</name></expr>]</index></name><operator>.</operator><name>ccname</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccbin</name> <init>= <expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>check</name><index>[<expr><name>ccnum</name></expr>]</index></name><operator>.</operator><name>ccbin</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ccbin_node</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ccbin_node</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><name>ccbin</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											 <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>,
											 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We reject whole-row variables because the whole point of LIKE
			 * is that the new table's rowtype might later diverge from the
			 * parent's.  So, while translation might be possible right now,
			 * it wouldn't be possible to guarantee it would work in future.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Constraint \"%s\" contains a whole-row reference to table \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>ccname</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>conname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>ccname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>ccbin_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy comment on constraint */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><call><name>get_relation_constraint_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
																  <argument><expr><name><name>n</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>ConstraintRelationId</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommentStmt</name> <modifier>*</modifier></type><name>stmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CommentStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>objtype</name></name> <operator>=</operator> <name>OBJECT_TABCONSTRAINT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>object</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>comment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, copy indexes if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_INDEXES</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parent_indexes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_indexes</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parent_indexes</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>parent_index_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>parent_index</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index_stmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>parent_index</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>parent_index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Build CREATE INDEX statement to recreate the parent_index */</comment>
			<expr_stmt><expr><name>index_stmt</name> <operator>=</operator> <call><name>generateClonedIndexStmt</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
												 <argument><expr><name>parent_index</name></expr></argument>,
												 <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name><name>tupleDesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy comment on index, if requested */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>parent_index_oid</name></expr></argument>, <argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We make use of IndexStmt's idxcomment option, so as not to
				 * need to know now what name the index will have.
				 */</comment>
				<expr_stmt><expr><name><name>index_stmt</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Save it in the inh_indexes list for the time being */</comment>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>inh_indexes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>inh_indexes</name></name></expr></argument>, <argument><expr><name>index_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>parent_index</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise, copy extended statistics if requested
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_STATISTICS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>parent_extstats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent_extstats</name> <operator>=</operator> <call><name>RelationGetStatExtList</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parent_extstats</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>parent_stat_oid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>stats_stmt</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stats_stmt</name> <operator>=</operator> <call><name>generateClonedExtStatsStmt</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>,
													<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>parent_stat_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Copy comment on statistics object, if requested */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>table_like_clause</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>CREATE_TABLE_LIKE_COMMENTS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>GetComment</name><argument_list>(<argument><expr><name>parent_stat_oid</name></expr></argument>, <argument><expr><name>StatisticExtRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We make use of CreateStatsStmt's stxcomment option, so as
				 * not to need to know now what name the statistics will have.
				 */</comment>
				<expr_stmt><expr><name><name>stats_stmt</name><operator>-&gt;</operator><name>stxcomment</name></name> <operator>=</operator> <name>comment</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>extstats</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>extstats</name></name></expr></argument>, <argument><expr><name>stats_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>parent_extstats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Close the parent rel, but keep our AccessShareLock on it until xact
	 * commit.  That will prevent someone else from deleting or ALTERing the
	 * parent before the child is committed.
	 */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformOfType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>ofTypename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ofTypeId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>ofTypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>typenameType</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ofTypename</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>check_of_type</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ofTypeId</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ofTypename</name><operator>-&gt;</operator><name>typeOid</name></name> <operator>=</operator> <name>ofTypeId</name></expr>;</expr_stmt> <comment type="block">/* cached for later */</comment>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>ofTypeId</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>typeName</name></name> <operator>=</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_from_type</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>storage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>collClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>DecrTupleDescRefCount</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate an IndexStmt node using information from an already existing index
 * "source_idx", for the rel identified either by heapRel or heapRelid.
 *
 * Attribute numbers should be adjusted according to attmap.
 */</comment>
<function><type><name>IndexStmt</name> <modifier>*</modifier></type>
<name>generateClonedIndexStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>heapRelid</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>source_idx</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attmap_length</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>constraintOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>source_relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idxrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_am</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>idxrelrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>idxrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_am</name></type>	<name>amrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>indrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keyno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>keycoltype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>heapRel</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapRelid</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name>heapRel</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapRelid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch pg_class tuple of source index.  We can't use the copy in the
	 * relcache entry because it doesn't include optional fields.
	 */</comment>
	<expr_stmt><expr><name>ht_idxrel</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>idxrelrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch pg_index tuple for source index from relcache entry */</comment>
	<expr_stmt><expr><name>ht_idx</name> <operator>=</operator> <name><name>source_idx</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>idxrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indrelid</name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fetch the pg_am tuple of the index' access method */</comment>
	<expr_stmt><expr><name>ht_am</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AMOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for access method %u"</literal></expr></argument>,
			 <argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_am</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract indcollation from the pg_index tuple */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indcollation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indcollation</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract indclass from the pg_index tuple */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Begin building the IndexStmt */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>heapRel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>relationId</name></name> <operator>=</operator> <name>heapRelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>amrec</name><operator>-&gt;</operator><name>amname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <call><name>get_tablespace_name</name><argument_list>(<argument><expr><name><name>idxrelrec</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* don't need transformIndexStmt */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't try to preserve the name of the source index; instead, just
	 * let DefineIndex() choose a reasonable name.  (If we tried to preserve
	 * the name, we'd get duplicate-relation-name failures unless the source
	 * table was in a different schema.)
	 */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the index is marked PRIMARY or has an exclusion condition, it's
	 * certainly from a constraint; else, if it's not marked UNIQUE, it
	 * certainly isn't.  If it is or might be from a constraint, we have to
	 * fetch the pg_constraint record.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>||</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintId</name> <init>= <expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>source_relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_constr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conrec</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>constraintOid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>constraintOid</name> <operator>=</operator> <name>constraintId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>ht_constr</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>,
					 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>conrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>conrec</name><operator>-&gt;</operator><name>condeferrable</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>conrec</name><operator>-&gt;</operator><name>condeferred</name></name></expr>;</expr_stmt>

			<comment type="block">/* If it's an exclusion constraint, we need the operator names */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>idxrec</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>nElems</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conrec</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_EXCLUSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Extract operator OIDs from the pg_constraint tuple */</comment>
				<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>ht_constr</name></expr></argument>,
										<argument><expr><name>Anum_pg_constraint_conexclop</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conexclop for constraint %u"</literal></expr></argument>,
						 <argument><expr><name>constraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>elems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>operid</name> <init>= <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name><name>elems</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>,
											  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>,
							 <argument><expr><name>operid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>operform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>oprname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* For simplicity we always schema-qualify the op name */</comment>
					<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>namelist</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>,
													<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_constr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Get the index expressions, if any */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprsString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprsString</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexprs</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>indexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Build the list of IndexElem */</comment>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>indexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>idxrec</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>opt</name> <init>= <expr><name><name>source_idx</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index column */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expressional index */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>,
										   <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>attmap_length</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* As in transformTableLikeClause, reject whole-row variables */</comment>
			<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" contains a whole-row table reference."</literal></expr></argument>,
								   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>indexkey</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Copy the original index column name */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the collation name, if non-default */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>get_collation</name><argument_list>(<argument><expr><name><name>indcollation</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>keycoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add the operator class name, if non-default */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <call><name>get_opclass</name><argument_list>(<argument><expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></argument>, <argument><expr><name>keycoltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>;</expr_stmt>

		<comment type="block">/* Adjust options if necessary */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>source_idx</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>amcanorder</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If it supports sort ordering, copy DESC and NULLS opts. Don't
			 * set non-default settings unnecessarily, though, so as to
			 * improve the chance of recognizing equivalence to constraint
			 * indexes.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_DESC</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_DESC</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_LAST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>&amp;</operator> <name>INDOPTION_NULLS_FIRST</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_FIRST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Handle included columns separately */</comment>
	<for>for <control>(<init><expr><name>keyno</name> <operator>=</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</init> <condition><expr><name>keyno</name> <operator>&lt;</operator> <name><name>idxrec</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>keyno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>idxrec</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>keyno</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name>keyno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index column */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>keycoltype</name> <operator>=</operator> <call><name>get_atttype</name><argument_list>(<argument><expr><name>indrelid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>attname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"expressions are not supported in included columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Copy the original index column name */</comment>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Copy reloptions if any */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>ht_idxrel</name></expr></argument>,
							<argument><expr><name>Anum_pg_class_reloptions</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>untransformRelOptions</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If it's a partial index, decompile and append the predicate */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>ht_idx</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indpred</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pred_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>pred_tree</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>

		<comment type="block">/* Convert text string to node tree */</comment>
		<expr_stmt><expr><name>pred_str</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pred_tree</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name>pred_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Adjust Vars to match new table's column numbering */</comment>
		<expr_stmt><expr><name>pred_tree</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><name>pred_tree</name></expr></argument>,
										<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>attmap_length</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* As in transformTableLikeClause, reject whole-row variables */</comment>
		<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot convert whole-row table reference"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Index \"%s\" contains a whole-row table reference."</literal></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>source_idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <name>pred_tree</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_idxrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_am</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a CreateStatsStmt node using information from an already existing
 * extended statistic "source_statsid", for the rel identified by heapRel and
 * heapRelid.
 */</comment>
<function><type><specifier>static</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type>
<name>generateClonedExtStatsStmt</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>heapRel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>heapRelid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>source_statsid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>statsrec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStatsStmt</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>stat_types</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>def_names</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>heapRel</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch pg_statistic_ext tuple of source statistics object.
	 */</comment>
	<expr_stmt><expr><name>ht_stats</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>source_statsid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_stats</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>source_statsid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>statsrec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine which statistics types exist */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><name>ht_stats</name></expr></argument>,
							<argument><expr><name>Anum_pg_statistic_ext_stxkind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CHAROID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stxkind is not a 1-D char array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>enabled</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_NDISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_types</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"ndistinct"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>STATS_EXT_DEPENDENCIES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stat_types</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"dependencies"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized statistics kind %c"</literal></expr></argument>, <argument><expr><name><name>enabled</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Determine which columns the statistics are on */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>statsrec</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>statsrec</name><operator>-&gt;</operator><name>stxkeys</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name>heapRelid</name></expr></argument>,
														 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>def_names</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>def_names</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* finally, build the output node */</comment>
	<expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateStatsStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>defnames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stat_types</name></name> <operator>=</operator> <name>stat_types</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>exprs</name></name> <operator>=</operator> <name>def_names</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>relations</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stxcomment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_stats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stats</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_collation		- fetch qualified name of a collation
 *
 * If collation is InvalidOid or is the default for the given actual_datatype,
 * then the return value is NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_collation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_coll</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>coll_rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>coll_name</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* easy case */</comment>
	<if_stmt><if>if <condition>(<expr><name>collation</name> <operator>==</operator> <call><name>get_typcollation</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* just let it default */</comment>

	<expr_stmt><expr><name>ht_coll</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>coll_rec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For simplicity, we always schema-qualify the name */</comment>
	<expr_stmt><expr><name>nsp_name</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>coll_rec</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>coll_name</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>coll_rec</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nsp_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>coll_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass			- fetch qualified name of an index operator class
 *
 * If the opclass is the default for the given actual_datatype, then
 * the return value is NIL.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_opclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>actual_datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht_opc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opc_rec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ht_opc</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opc_rec</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name>actual_datatype</name></expr></argument>, <argument><expr><name><name>opc_rec</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>opclass</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* For simplicity, we always schema-qualify the name */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nsp_name</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>opc_rec</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opc_name</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opc_rec</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>nsp_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>opc_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ht_opc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformIndexConstraints
 *		Handle UNIQUE, PRIMARY KEY, EXCLUDE constraints, which create indexes.
 *		We also merge in any index definitions arising from
 *		LIKE ... INCLUDING INDEXES.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformIndexConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Run through the constraints that need to generate an index. For PRIMARY
	 * KEY, mark each column as NOT NULL and create an index. For UNIQUE or
	 * EXCLUDE, create an index as for PRIMARY KEY, but do not insist on NOT
	 * NULL.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cxt-&gt;ixconstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>||</operator>
			   <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_UNIQUE</name> <operator>||</operator>
			   <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_EXCLUSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>transformIndexConstraint</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>, <argument><expr><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Add in any indexes defined by LIKE ... INCLUDING INDEXES */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cxt-&gt;inh_indexes</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple primary keys for table \"%s\" are not allowed"</literal></expr></argument>,
								<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>indexlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Scan the index list and remove any redundant index specifications. This
	 * can happen if, for instance, the user writes UNIQUE PRIMARY KEY. A
	 * strict reading of SQL would suggest raising an error instead, but that
	 * strikes me as too anal-retentive. - tgl 2001-02-14
	 *
	 * XXX in ALTER TABLE case, it'd be nice to look for duplicate
	 * pre-existing indexes, too.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Make sure we keep the PKEY index in preference to others... */</comment>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keep</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if it's pkey, it's already in cxt-&gt;alist */</comment>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<macro><name>foreach</name><argument_list>(<argument>k</argument>, <argument>cxt-&gt;alist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>priorindex</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>equal</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strcmp</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>, <argument><expr><name><name>priorindex</name><operator>-&gt;</operator><name>accessMethod</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>index</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>==</operator> <name><name>priorindex</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>&amp;&amp;</operator>
				<name><name>index</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>==</operator> <name><name>priorindex</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>priorindex</name><operator>-&gt;</operator><name>unique</name></name> <operator>|=</operator> <name><name>index</name><operator>-&gt;</operator><name>unique</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If the prior index is as yet unnamed, and this one is
				 * named, then transfer the name to the prior index. This
				 * ensures that if we have named and unnamed constraints,
				 * we'll use (at least one of) the names for the index.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>priorindex</name><operator>-&gt;</operator><name>idxname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>priorindex</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>idxname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>keep</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name>keep</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * transformIndexConstraint
 *		Transform one UNIQUE, PRIMARY KEY, or EXCLUDE constraint for
 *		transformIndexConstraints.
 */</comment>
<function><type><specifier>static</specifier> <name>IndexStmt</name> <modifier>*</modifier></type>
<name>transformIndexConstraint</name><parameter_list>(<parameter><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name></decl></parameter>, <parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>=</operator> <operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTR_EXCLUSION</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name> <operator>=</operator> <operator>(</operator><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple primary keys for table \"%s\" are not allowed"</literal></expr></argument>,
							<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>pkey</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In ALTER TABLE case, a primary index might already exist, but
		 * DefineIndex will check for it.
		 */</comment>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* DefineIndex will choose name */</comment>

	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>accessMethod</name></name> <operator>=</operator> <ternary><condition><expr><name><name>constraint</name><operator>-&gt;</operator><name>access_method</name></name></expr> ?</condition><then> <expr><name><name>constraint</name><operator>-&gt;</operator><name>access_method</name></name></expr> </then><else>: <expr><name>DEFAULT_INDEX_TYPE</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>options</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tableSpace</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>indexspace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <name><name>constraint</name><operator>-&gt;</operator><name>where_clause</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>idxcomment</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>oldNode</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>if_not_exists</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's ALTER TABLE ADD CONSTRAINT USING INDEX, look up the index and
	 * verify it's usable, then extract the implied column name list.  (We
	 * will not actually need the column name list at runtime, but we need it
	 * now to check for duplicate column entries below.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>indexname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>index_name</name> <init>= <expr><name><name>constraint</name><operator>-&gt;</operator><name>indexname</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>heap_rel</name> <init>= <expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>index_oid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>index_rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index_form</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* Grammar should not allow this with explicit column list */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Grammar should only allow PRIMARY and UNIQUE constraints */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name> <operator>||</operator>
			   <name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_UNIQUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Must be ALTER, not CREATE, but grammar doesn't enforce that */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cxt</name><operator>-&gt;</operator><name>isalter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use an existing index in CREATE TABLE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Look for the index in the same schema as the table */</comment>
		<expr_stmt><expr><name>index_oid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>index_name</name></expr></argument>, <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>heap_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Open the index (this will throw an error if it is not an index) */</comment>
		<expr_stmt><expr><name>index_rel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index_form</name> <operator>=</operator> <name><name>index_rel</name><operator>-&gt;</operator><name>rd_index</name></name></expr>;</expr_stmt>

		<comment type="block">/* Check that it does not have an associated constraint already */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_index_constraint</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is already associated with a constraint"</literal></expr></argument>,
							<argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Perform validity checks on the index */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index_form</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heap_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not belong to table \"%s\""</literal></expr></argument>,
							<argument><expr><name>index_name</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heap_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IndexIsValid</name><argument_list>(<argument><expr><name>index_form</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not valid"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index_form</name><operator>-&gt;</operator><name>indisunique</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a unique index"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" contains expressions"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a partial index"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * It's probably unsafe to change a deferred index to non-deferred. (A
		 * non-constraint index couldn't be deferred anyway, so this case
		 * should never occur; no need to sweat, but let's check it.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index_form</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>constraint</name><operator>-&gt;</operator><name>deferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is a deferrable index"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a non-deferrable constraint using a deferrable index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Insist on it being a btree.  That's the only kind that supports
		 * uniqueness at the moment anyway; but we must have an index that
		 * exactly matches what you'd get from plain ADD CONSTRAINT syntax,
		 * else dump and reload will produce a different index (breaking
		 * pg_upgrade in particular).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <call><name>get_index_am_oid</name><argument_list>(<argument><expr><name>DEFAULT_INDEX_TYPE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not a btree"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Must get indclass the hard way */</comment>
		<expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_indextuple</name></name></expr></argument>,
										<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>index_form</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type>		<name>attnum</name> <init>= <expr><name><name>index_form</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>defopclass</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We shouldn't see attnum == 0 here, since we already rejected
			 * expression indexes.  If we do, SystemAttributeDefinition will
			 * throw an error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attnum</name> <operator>&lt;=</operator> <name><name>heap_rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>attform</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>heap_rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>attform</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>,
													<argument><expr><name><name>heap_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attform</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>index_form</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Insist on default opclass and sort options.  While the
				 * index would still work as a constraint with non-default
				 * settings, it might not provide exactly the same uniqueness
				 * semantics as you'd get from a normally-created constraint;
				 * and there's also the dump/reload problem mentioned above.
				 */</comment>
				<expr_stmt><expr><name>defopclass</name> <operator>=</operator> <call><name>GetDefaultOpClass</name><argument_list>(<argument><expr><name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
											   <argument><expr><name><name>index_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>defopclass</name> <operator>||</operator>
					<name><name>index_rel</name><operator>-&gt;</operator><name>rd_indoption</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not have default sorting behavior"</literal></expr></argument>, <argument><expr><name>index_name</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot create a primary key or unique constraint using such an index."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>including</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>including</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Close the index relation but keep the lock */</comment>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>index_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexOid</name></name> <operator>=</operator> <name>index_oid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it's an EXCLUDE constraint, the grammar returns a list of pairs of
	 * IndexElems and operator names.  We have to break that apart into
	 * separate lists.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_EXCLUSION</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint-&gt;exclusions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pair</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <call><name>lsecond_node</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name>pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>excludeOpNames</name></name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>

	<comment type="block">/*
	 * For UNIQUE and PRIMARY KEY, we just have a list of column names.
	 *
	 * Make sure referenced keys exist.  If we are making a PRIMARY KEY index,
	 * also make sure they are NOT NULL, if possible. (Although we could leave
	 * it to DefineIndex to mark the columns NOT NULL, it's more efficient to
	 * get it right the first time.)
	 */</comment>
	<else>else
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint-&gt;keys</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>

			<comment type="block">/* Make sure referenced column exist. */</comment>
			<macro><name>foreach</name><argument_list>(<argument>columns</argument>, <argument>cxt-&gt;columns</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* found column in the new table; force it to be NOT NULL */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>constraint</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTR_PRIMARY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>column</name><operator>-&gt;</operator><name>is_not_null</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>hasoids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * column will be a system column in the new table, so accept
				 * it. System columns can't ever be null, so no need to worry
				 * about PRIMARY/NOT NULL constraint.
				 */</comment>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try inherited tables */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inher</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>inher</argument>, <argument>cxt-&gt;inhRelations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>inh</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>inher</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>inh</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* check user requested inheritance from valid relkind */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
										<argument><expr><name><name>inh</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>inhattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
																  <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inhname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>inhattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>inhattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>inhname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<comment type="block">/*
							 * We currently have no easy way to force an
							 * inherited column to be NOT NULL at creation, if
							 * its parent wasn't so already. We leave it to
							 * DefineIndex to fix things up in this case.
							 */</comment>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * In the ALTER TABLE case, don't complain about index keys not
			 * created in the command; they may well exist already.
			 * DefineIndex will complain about them if not, and will also take
			 * care of marking them NOT NULL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cxt</name><operator>-&gt;</operator><name>isalter</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in key does not exist"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Check for PRIMARY KEY(foo, foo) */</comment>
			<macro><name>foreach</name><argument_list>(<argument>columns</argument>, <argument>index-&gt;indexParams</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>iparam</name> <operator>=</operator> <operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>primary</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" appears twice in primary key constraint"</literal></expr></argument>,
										<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" appears twice in unique constraint"</literal></expr></argument>,
										<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* OK, add it to the index definition */</comment>
			<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>ordering</name></name> <operator>=</operator> <name>SORTBY_DEFAULT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>nulls_ordering</name></name> <operator>=</operator> <name>SORTBY_NULLS_DEFAULT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Add included columns to index definition */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>constraint-&gt;including</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>column</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>iparam</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>columns</argument>, <argument>cxt-&gt;columns</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>column</name> <operator>=</operator> <call><name>lfirst_node</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>column</name><operator>-&gt;</operator><name>colname</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>SystemAttributeByName</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>hasoids</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * column will be a system column in the new table, so accept
				 * it. System columns can't ever be null, so no need to worry
				 * about PRIMARY/NOT NULL constraint.
				 */</comment>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>inhRelations</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try inherited tables */</comment>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>inher</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>inher</argument>, <argument>cxt-&gt;inhRelations</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>inh</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RangeVar</name></expr></argument>, <argument><expr><name>inher</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name>inh</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* check user requested inheritance from valid relkind */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
						<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"inherited relation \"%s\" is not a table or foreign table"</literal></expr></argument>,
										<argument><expr><name><name>inh</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<for>for <control>(<init><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>count</name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>count</name><operator>++</operator></expr></incr>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>inhattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>,
																  <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>inhname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>inhattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>inhattr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>inhname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

							<comment type="block">/*
							 * We currently have no easy way to force an
							 * inherited column to be NOT NULL at creation, if
							 * its parent wasn't so already. We leave it to
							 * DefineIndex to fix things up in this case.
							 */</comment>
							<break>break;</break>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
					<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * In the ALTER TABLE case, don't complain about index keys not
		 * created in the command; they may well exist already. DefineIndex
		 * will complain about them if not, and will also take care of marking
		 * them NOT NULL.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>cxt</name><operator>-&gt;</operator><name>isalter</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" named in key does not exist"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>constraint</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK, add it to the index definition */</comment>
		<expr_stmt><expr><name>iparam</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexElem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>iparam</name><operator>-&gt;</operator><name>opclass</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexIncludingParams</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>index</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformExtendedStatistics
 *     Handle extended statistic objects
 *
 * Right now, there's nothing to do here, so we just append the list to
 * the existing "after" list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformExtendedStatistics</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>extstats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformCheckConstraints
 *		handle CHECK constraints
 *
 * Right now, there's nothing to do here when called from ALTER TABLE,
 * but the other constraint-transformation functions are called in both
 * the CREATE TABLE and ALTER TABLE paths, so do the same here, and just
 * don't do anything if we're not authorized to skip validation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformCheckConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ckclist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>ckconstraints</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If creating a new table (but not a foreign table), we can safely skip
	 * validation of check constraints, and nonetheless mark them valid. (This
	 * will override any user-supplied NOT VALID flag.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>skipValidation</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>ckclist</argument>, <argument>cxt-&gt;ckconstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ckclist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformFKConstraints
 *		handle FOREIGN KEY constraints
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformFKConstraints</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>skipValidation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isAddConstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>fkclist</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>fkconstraints</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If CREATE TABLE or adding a column with NULL default, we can safely
	 * skip validation of FK constraints, and nonetheless mark them valid.
	 * (This will override any user-supplied NOT VALID flag.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>skipValidation</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>fkclist</argument>, <argument>cxt-&gt;fkconstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fkclist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>constraint</name><operator>-&gt;</operator><name>initially_valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For CREATE TABLE or ALTER TABLE ADD COLUMN, gin up an ALTER TABLE ADD
	 * CONSTRAINT command to execute after the basic command is complete. (If
	 * called from ADD CONSTRAINT, that routine will add the FK constraints to
	 * its own subcommand list.)
	 *
	 * Note: the ADD CONSTRAINT command must also execute after any index
	 * creation commands.  Thus, this should run after
	 * transformIndexConstraints, so that the CREATE INDEX commands are
	 * already in cxt-&gt;alist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isAddConstraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>alterstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name><name>cxt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>OBJECT_TABLE</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>fkclist</argument>, <argument>cxt-&gt;fkconstraints</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>constraint</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>fkclist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>altercmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>altercmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_ProcessedConstraint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>altercmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>altercmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>constraint</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>alterstmt</name><operator>-&gt;</operator><name>cmds</name></name></expr></argument>, <argument><expr><name>altercmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>alist</name></name></expr></argument>, <argument><expr><name>alterstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformIndexStmt - parse analysis for CREATE INDEX and ALTER TABLE
 *
 * Note: this is a no-op for an index not using either index expressions or
 * a predicate expression.  There are several code paths that create indexes
 * without bothering to call this, because they know they don't have any
 * such expressions to deal with.
 *
 * To avoid race conditions, it's important that this function rely only on
 * the passed-in relid (and not on stmt-&gt;relation) to determine the target
 * relation.
 */</comment>
<function><type><name>IndexStmt</name> <modifier>*</modifier></type>
<name>transformIndexStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if statement already transformed. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>stmt</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must not scribble on the passed-in IndexStmt, so copy it.  (This is
	 * overkill, but easy.)
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Put the parent table into the rtable so that the expressions can refer
	 * to its fields without qualification.  Caller is responsible for locking
	 * relation, but we still need to open it.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no to join list, yes to namespaces */</comment>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* take care of the where clause */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>,
												 <argument><expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr></argument>,
												 <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we have to fix its collations too */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* take care of any index expressions */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;indexParams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexElem</name>  <modifier>*</modifier></type><name>ielem</name> <init>= <expr><operator>(</operator><name>IndexElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Extract preliminary index col name before transforming expr */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>indexcolname</name></name> <operator>=</operator> <call><name>FigureIndexColname</name><argument_list>(<argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Now do parse transformation of the expression */</comment>
			<expr_stmt><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
										<argument><expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We have to fix its collations too */</comment>
			<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ielem</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * transformExpr() should have already rejected subqueries,
			 * aggregates, window functions, and SRFs, based on the EXPR_KIND_
			 * for an index expression.
			 *
			 * DefineIndex() will make more checks.
			 */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check that only the base rel is mentioned.  (This should be dead code
	 * now that add_missing_from is history.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index expressions and predicates can refer only to the table being indexed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close relation */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark statement as successfully transformed */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>transformed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>stmt</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * transformRuleStmt -
 *	  transform a CREATE RULE Statement. The action is a list of parse
 *	  trees which is transformed into a list of query trees, and we also
 *	  transform the WHERE clause if any.
 *
 * actions and whereClause are output parameters that receive the
 * transformed results.
 *
 * Note that we must not scribble on the passed-in RuleStmt, so we do
 * copyObject() on the actions and WHERE clause.
 */</comment>
<function><type><name>void</name></type>
<name>transformRuleStmt</name><parameter_list>(<parameter><decl><type><name>RuleStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>actions</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>whereClause</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>oldrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newrte</name></decl>;</decl_stmt>

	<comment type="block">/* POLAR: mark I am creating rule which is used for filting unsafe functions */</comment>
	<expr_stmt><expr><name>polar_creating_rule</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<comment type="block">/*
	 * To avoid deadlock, make sure the first thing we do is grab
	 * AccessExclusiveLock on the target relation.  This will be needed by
	 * DefineQueryRewrite(), and we don't want to grab a lesser lock
	 * beforehand.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rules on materialized views are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * NOTE: 'OLD' must always have a varno equal to 1 and 'NEW' equal to 2.
	 * Set up their RTEs in the main pstate for use in parsing the rule
	 * qualification.
	 */</comment>
	<expr_stmt><expr><name>oldrte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newrte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
										   <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Must override addRangeTableEntry's default access-check flags */</comment>
	<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * They must be in the namespace too for lookup purposes, but only add the
	 * one(s) that are relevant for the current kind of rule.  In an UPDATE
	 * rule, quals must refer to OLD.field or NEW.field to be unambiguous, but
	 * there's no need to be so picky for INSERT &amp; DELETE.  We do not add them
	 * to the joinlist.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_SELECT</name></expr>:</case>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>oldrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>oldrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>oldrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized event type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* take care of the where clause */</comment>
	<expr_stmt><expr><operator>*</operator><name>whereClause</name> <operator>=</operator> <call><name>transformWhereClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>whereClause</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>EXPR_KIND_WHERE</name></expr></argument>,
										<argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we have to fix its collations too */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>*</operator><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this is probably dead code without add_missing_from: */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* naughty, naughty... */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rule WHERE condition cannot contain references to other relations"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * 'instead nothing' rules with a qualification need a query rangetable so
	 * the rewrite handler can add the negated rule qualification to the
	 * original query. We create a query with the new command type CMD_NOTHING
	 * here that is treated specially by the rewrite system.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>actions</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>nothing_qry</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nothing_qry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>=</operator> <name>CMD_NOTHING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nothing_qry</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nothing_qry</name><operator>-&gt;</operator><name>jointree</name></name> <operator>=</operator> <call><name>makeFromExpr</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* no join wanted */</comment>

		<expr_stmt><expr><operator>*</operator><name>actions</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>nothing_qry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newactions</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * transform each statement, like parse_sub_analyze()
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>stmt-&gt;actions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>action</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>sub_pstate</name> <init>= <expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>sub_qry</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>top_subqry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>has_old</name></decl>,
						<decl><type ref="prev"/><name>has_new</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Since outer ParseState isn't parent of inner, have to pass down
			 * the query text by hand.
			 */</comment>
			<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set up OLD/NEW in the rtable for this statement.  The entries
			 * are added only to relnamespace, not varnamespace, because we
			 * don't want them to be referred to by unqualified field names
			 * nor "*" in the rule actions.  We decide later whether to put
			 * them in the joinlist.
			 */</comment>
			<expr_stmt><expr><name>oldrte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
												   <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newrte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>,
												   <argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oldrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>oldrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Transform the rule action statement */</comment>
			<expr_stmt><expr><name>top_subqry</name> <operator>=</operator> <call><name>transformStmt</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We cannot support utility-statement actions (eg NOTIFY) with
			 * nonempty rule WHERE conditions, because there's no way to make
			 * the utility action execute conditionally.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>top_subqry</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UTILITY</name> <operator>&amp;&amp;</operator>
				<operator>*</operator><name>whereClause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"rules with WHERE conditions can only have SELECT, INSERT, UPDATE, or DELETE actions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If the action is INSERT...SELECT, OLD/NEW have been pushed down
			 * into the SELECT, and that's what we need to look at. (Ugly
			 * kluge ... try to fix this when we redesign querytrees.)
			 */</comment>
			<expr_stmt><expr><name>sub_qry</name> <operator>=</operator> <call><name>getInsertSelectQuery</name><argument_list>(<argument><expr><name>top_subqry</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the sub_qry is a setop, we cannot attach any qualifications
			 * to it, because the planner won't notice them.  This could
			 * perhaps be relaxed someday, but for now, we may as well reject
			 * such a rule immediately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sub_qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>whereClause</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional UNION/INTERSECT/EXCEPT statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Validate action's use of OLD/NEW, qual too
			 */</comment>
			<expr_stmt><expr><name>has_old</name> <operator>=</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_qry</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>*</operator><name>whereClause</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>has_new</name> <operator>=</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_qry</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>*</operator><name>whereClause</name></expr></argument>, <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_SELECT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>has_old</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON SELECT rule cannot use OLD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>has_new</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON SELECT rule cannot use NEW"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<comment type="block">/* both are OK */</comment>
					<break>break;</break>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>has_old</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON INSERT rule cannot use OLD"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>has_new</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ON DELETE rule cannot use NEW"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized event type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>

			<comment type="block">/*
			 * OLD/NEW are not allowed in WITH queries, because they would
			 * amount to outer references for the WITH, which we disallow.
			 * However, they were already in the outer rangetable when we
			 * analyzed the query, so we have to check.
			 *
			 * Note that in the INSERT...SELECT case, we need to examine the
			 * CTE lists of both top_subqry and sub_qry.
			 *
			 * Note that we aren't digging into the body of the query looking
			 * for WITHs in nested sub-SELECTs.  A WITH down there can
			 * legitimately refer to OLD/NEW, because it'd be an
			 * indirect-correlated outer reference.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>top_subqry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sub_qry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to OLD within WITH query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>top_subqry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sub_qry</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
									 <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot refer to NEW within WITH query"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * For efficiency's sake, add OLD to the rule action's jointree
			 * only if it was actually referenced in the statement or qual.
			 *
			 * For INSERT, NEW is not really a relation (only a reference to
			 * the to-be-inserted tuple) and should never be added to the
			 * jointree.
			 *
			 * For UPDATE, we treat NEW as being another kind of reference to
			 * OLD, because it represents references to *transformed* tuples
			 * of the existing relation.  It would be wrong to enter NEW
			 * separately in the jointree, since that would cause a double
			 * join of the updated relation.  It's also wrong to fail to make
			 * a jointree entry if only NEW and not OLD is mentioned.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>has_old</name> <operator>||</operator> <operator>(</operator><name>has_new</name> <operator>&amp;&amp;</operator> <name><name>stmt</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If sub_qry is a setop, manipulating its jointree will do no
				 * good at all, because the jointree is dummy. (This should be
				 * a can't-happen case because of prior tests.)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>sub_qry</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional UNION/INTERSECT/EXCEPT statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* hack so we can use addRTEtoQuery() */</comment>
				<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_rtable</name></name> <operator>=</operator> <name><name>sub_qry</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub_pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name> <operator>=</operator> <name><name>sub_qry</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>, <argument><expr><name>oldrte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>sub_qry</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator> <name><name>sub_pstate</name><operator>-&gt;</operator><name>p_joinlist</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>newactions</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newactions</name></expr></argument>, <argument><expr><name>top_subqry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>sub_pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><operator>*</operator><name>actions</name> <operator>=</operator> <name>newactions</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close relation, but keep the exclusive lock */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR: clear polar_creating_rule flag */</comment>
	<expr_stmt><expr><name>polar_creating_rule</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * transformAlterTableStmt -
 *		parse analysis for ALTER TABLE
 *
 * Returns a List of utility commands to be done in sequence.  One of these
 * will be the transformed AlterTableStmt, but there may be additional actions
 * to be done before and after the actual AlterTable() call.
 *
 * To avoid race conditions, it's important that this function rely only on
 * the passed-in relid (and not on stmt-&gt;relation) to determine the target
 * relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformAlterTableStmt</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AlterTableStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CreateStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>save_alist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lcmd</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcmds</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipValidation</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>newcmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must not scribble on the passed-in AlterTableStmt, so copy it. (This
	 * is overkill, but easy.)
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Caller is responsible for locking the relation */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up pstate */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>rel</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up CreateStmtContext */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pstate</name></name> <operator>=</operator> <name>pstate</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>OBJECT_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"ALTER FOREIGN TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"ALTER TABLE"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isforeign</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>relation</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>rel</name></name> <operator>=</operator> <name>rel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inhRelations</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>isalter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>hasoids</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* need not be right */</comment>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ckconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>fkconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ixconstraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>inh_indexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>extstats</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>pkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ispartitioned</name></name> <operator>=</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>partbound</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>ofType</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The only subtypes that currently require parse transformation handling
	 * are ADD COLUMN, ADD CONSTRAINT and SET DATA TYPE.  These largely re-use
	 * code from CREATE TABLE.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcmd</argument>, <argument>stmt-&gt;cmds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><operator>(</operator><name>AlterTableCmd</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AT_AddColumn</name></expr>:</case>
			<case>case <expr><name>AT_AddColumnToView</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>transformColumnDefinition</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the column has a non-null default, we can't skip
					 * validation of foreign keys.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>skipValidation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * All constraints are processed in other ways. Remove the
					 * original list
					 */</comment>
					<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>constraints</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_AddConstraint</name></expr>:</case>

				<comment type="block">/*
				 * The original AddConstraint cmd node doesn't go to newcmds
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>transformTableConstraint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name><operator>)</operator><operator>-&gt;</operator><name>contype</name> <operator>==</operator> <name>CONSTR_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>skipValidation</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_ProcessedConstraint</name></expr>:</case>

				<comment type="block">/*
				 * Already-transformed ADD CONSTRAINT, so just make it look
				 * like the standard case.
				 */</comment>
				<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>AT_AlterColumnType</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>def</name> <init>= <expr><operator>(</operator><name>ColumnDef</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * For ALTER COLUMN TYPE, transform the USING clause if
					 * one was specified.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>def</name><operator>-&gt;</operator><name>cooked_default</name></name> <operator>=</operator>
							<call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>,
										  <argument><expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * For identity column, create ALTER SEQUENCE command to
					 * change the data type of the sequence.
					 */</comment>
					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if attribute not found, something will error about it
					 * later
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name> <operator>&amp;&amp;</operator> <call><name>get_attidentity</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name> <init>= <expr><call><name>getOwnedSequence</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>typeOid</name> <init>= <expr><call><name>typenameTypeId</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>def</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>altseqstmt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>,
															<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeDefElem</name><argument_list>(<argument><expr><literal type="string">"as"</literal></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeTypeNameFromOid</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>altseqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>altseqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_AddIdentity</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Constraint</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ColumnDef</name>  <modifier>*</modifier></type><name>newdef</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnDef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

					<expr_stmt><expr><name><name>newdef</name><operator>-&gt;</operator><name>colname</name></name> <operator>=</operator> <name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newdef</name><operator>-&gt;</operator><name>identity</name></name> <operator>=</operator> <name><name>def</name><operator>-&gt;</operator><name>generated_when</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newdef</name></expr>;</expr_stmt>

					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * if attribute not found, something will error about it
					 * later
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>generateSerialExtraStmts</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>newdef</name></expr></argument>,
												 <argument><expr><call><name>get_atttype</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><name><name>def</name><operator>-&gt;</operator><name>options</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_SetIdentity</name></expr>:</case>
				<block>{<block_content>
					<comment type="block">/*
					 * Create an ALTER SEQUENCE statement for the internal
					 * sequence of the identity column.
					 */</comment>
					<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newseqopts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newdef</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>seqlist</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * Split options into those handled by ALTER SEQUENCE and
					 * those for ALTER TABLE proper.
					 */</comment>
					<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>castNode(List, cmd-&gt;def)</argument>)</argument_list></macro>
					<block>{<block_content>
						<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>def</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>DefElem</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>def</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"generated"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>newdef</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newdef</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>newseqopts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newseqopts</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block>

					<expr_stmt><expr><name>attnum</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>attnum</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>seqlist</name> <operator>=</operator> <call><name>getOwnedSequences</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>seqlist</name></expr>)</condition>
						<block>{<block_content>
							<decl_stmt><decl><type><name>AlterSeqStmt</name> <modifier>*</modifier></type><name>seqstmt</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>Oid</name></type>			<name>seq_relid</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>seqstmt</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterSeqStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>seq_relid</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>seqlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>sequence</name></name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>seq_relid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>newseqopts</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>for_identity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>seqstmt</name><operator>-&gt;</operator><name>missing_ok</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

							<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>, <argument><expr><name>seqstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * If column was not found or was not an identity column,
					 * we just let the ALTER TABLE command error out later.
					 */</comment>

					<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newdef</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>

			<case>case <expr><name>AT_AttachPartition</name></expr>:</case>
			<case>case <expr><name>AT_DetachPartition</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>partcmd</name> <init>= <expr><operator>(</operator><name>PartitionCmd</name> <operator>*</operator><operator>)</operator> <name><name>cmd</name><operator>-&gt;</operator><name>def</name></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>transformPartitionCmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>partcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* assign transformed value of the partition bound */</comment>
					<expr_stmt><expr><name><name>partcmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>partbound</name></name></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/*
	 * transformIndexConstraints wants cxt.alist to contain only index
	 * statements, so transfer anything we already have into save_alist
	 * immediately.
	 */</comment>
	<expr_stmt><expr><name>save_alist</name> <operator>=</operator> <name><name>cxt</name><operator>.</operator><name>alist</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Postprocess constraints */</comment>
	<expr_stmt><expr><call><name>transformIndexConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>transformFKConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>skipValidation</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>transformCheckConstraints</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push any index-creation commands into the ALTER, so that they can be
	 * scheduled nicely by tablecmds.c.  Note that tablecmds.c assumes that
	 * the IndexStmt attached to an AT_AddIndex or AT_AddIndexConstraint
	 * subcommand has already been through transformIndexStmt.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cxt.alist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>idxstmt</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexStmt</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>idxstmt</name> <operator>=</operator> <call><name>transformIndexStmt</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>idxstmt</name></expr></argument>, <argument><expr><name>queryString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>idxstmt</name><operator>-&gt;</operator><name>indexOid</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>AT_AddIndexConstraint</name></expr> </then><else>: <expr><name>AT_AddIndex</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>idxstmt</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* Append any CHECK or FK constraints to the commands list */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cxt.ckconstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>cxt.fkconstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>newcmd</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_AddConstraint</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcmd</name><operator>-&gt;</operator><name>def</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcmds</name></expr></argument>, <argument><expr><name>newcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Append extended statistic objects */</comment>
	<expr_stmt><expr><call><name>transformExtendedStatistics</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close rel */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Output results.
	 */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>cmds</name></name> <operator>=</operator> <name>newcmds</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>blist</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>alist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>save_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Preprocess a list of column constraint clauses
 * to attach constraint attributes to their primary constraint nodes
 * and detect inconsistent/misplaced constraint attributes.
 *
 * NOTE: currently, attributes are only supported for FOREIGN KEY, UNIQUE,
 * EXCLUSION, and PRIMARY KEY constraints, but someday they ought to be
 * supported for other constraint types.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformConstraintAttrs</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>constraintList</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>lastprimarycon</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_deferrability</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>saw_initially</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>clist</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUPPORTS_ATTRS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>)</parameter_list></cpp:macro>				\
	<cpp:value>((node) != NULL &amp;&amp;						\
	 ((node)-&gt;contype == CONSTR_PRIMARY ||	\
	  (node)-&gt;contype == CONSTR_UNIQUE ||	\
	  (node)-&gt;contype == CONSTR_EXCLUSION || \
	  (node)-&gt;contype == CONSTR_FOREIGN))</cpp:value></cpp:define>

	<macro><name>foreach</name><argument_list>(<argument>clist</argument>, <argument>constraintList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>clist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>Constraint</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced DEFERRABLE clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_deferrability</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple DEFERRABLE/NOT DEFERRABLE clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_deferrability</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced NOT DEFERRABLE clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_deferrability</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple DEFERRABLE/NOT DEFERRABLE clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_deferrability</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_initially</name> <operator>&amp;&amp;</operator>
					<name><name>lastprimarycon</name><operator>-&gt;</operator><name>initdeferred</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint declared INITIALLY DEFERRED must be DEFERRABLE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced INITIALLY DEFERRED clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_initially</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple INITIALLY IMMEDIATE/DEFERRED clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_initially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * If only INITIALLY DEFERRED appears, assume DEFERRABLE
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saw_deferrability</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>lastprimarycon</name><operator>-&gt;</operator><name>deferrable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint declared INITIALLY DEFERRED must be DEFERRABLE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SUPPORTS_ATTRS</name><argument_list>(<argument><expr><name>lastprimarycon</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"misplaced INITIALLY IMMEDIATE clause"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>saw_initially</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple INITIALLY IMMEDIATE/DEFERRED clauses not allowed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>saw_initially</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lastprimarycon</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<comment type="block">/* Otherwise it's not an attribute */</comment>
				<expr_stmt><expr><name>lastprimarycon</name> <operator>=</operator> <name>con</name></expr>;</expr_stmt>
				<comment type="block">/* reset flags for new primary node */</comment>
				<expr_stmt><expr><name>saw_deferrability</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>saw_initially</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Special handling of type definition for a column
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformColumnType</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>ColumnDef</name> <modifier>*</modifier></type><name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * All we really need to do here is verify that the type is valid,
	 * including any collation spec that might be present.
	 */</comment>
	<decl_stmt><decl><type><name>Type</name></type>		<name>ctype</name> <init>= <expr><call><name>typenameType</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name><name>column</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LookupCollation</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
						<argument><expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>,
						<argument><expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Complain if COLLATE is applied to an uncollatable type */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typcollation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>,
										<argument><expr><name><name>column</name><operator>-&gt;</operator><name>collClause</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>ctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * transformCreateSchemaStmt -
 *	  analyzes the CREATE SCHEMA statement
 *
 * Split the schema element list into individual commands and place
 * them in the result list in an order such that there are no forward
 * references (e.g. GRANT to a table created later in the list). Note
 * that the logic we use for determining forward references is
 * presently quite incomplete.
 *
 * SQL also allows constraints to make forward references, so thumb through
 * the table columns and move forward references to a posterior alter-table
 * command.
 *
 * The result is a list of parse nodes that still need to be analyzed ---
 * but we can't analyze the later commands until we've executed the earlier
 * ones, because of possible inter-object references.
 *
 * Note: this breaks the rules a little bit by modifying schema-name fields
 * within passed-in structs.  However, the transformation would be the same
 * if done over, so it should be all right to scribble on the input to this
 * extent.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>transformCreateSchemaStmt</name><parameter_list>(<parameter><decl><type><name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CreateSchemaStmtContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>stmtType</name></name> <operator>=</operator> <literal type="string">"CREATE SCHEMA"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name> <operator>=</operator> <name><name>stmt</name><operator>-&gt;</operator><name>schemaname</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>authrole</name></name> <operator>=</operator> <operator>(</operator><name>RoleSpec</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>authrole</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>views</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run through each schema element in the schema element list. Separate
	 * statements by type, and do preliminary analysis.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>elements</argument>, <argument>stmt-&gt;schemaElts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>element</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateSeqStmt</name> <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>CreateSeqStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>sequence</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateStmt</name> <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * XXX todo: deal with constraints
					 */</comment>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_ViewStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ViewStmt</name>   <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>ViewStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>view</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * XXX todo: deal with references between views
					 */</comment>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>views</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>views</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>IndexStmt</name>  <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>IndexStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>elp</name> <init>= <expr><operator>(</operator><name>CreateTrigStmt</name> <operator>*</operator><operator>)</operator> <name>element</name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>setSchemaName</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>schemaname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>elp</name><operator>-&gt;</operator><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>T_GrantStmt</name></expr>:</case>
				<expr_stmt><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name></expr></argument>, <argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>sequences</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>tables</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>views</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>indexes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>triggers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>cxt</name><operator>.</operator><name>grants</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setSchemaName
 *		Set or check schema name in an element of a CREATE SCHEMA command
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setSchemaName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>context_schema</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>stmt_schema_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>stmt_schema_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>stmt_schema_name</name> <operator>=</operator> <name>context_schema</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>context_schema</name></expr></argument>, <argument><expr><operator>*</operator><name>stmt_schema_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_SCHEMA_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"CREATE specifies a schema (%s) "</literal>
						<literal type="string">"different from the one being created (%s)"</literal></expr></argument>,
						<argument><expr><operator>*</operator><name>stmt_schema_name</name></expr></argument>, <argument><expr><name>context_schema</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * transformPartitionCmd
 *		Analyze the ATTACH/DETACH PARTITION command
 *
 * In case of the ATTACH PARTITION command, cxt-&gt;partbound is set to the
 * transformed value of cmd-&gt;bound.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>transformPartitionCmd</name><parameter_list>(<parameter><decl><type><name>CreateStmtContext</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>PartitionCmd</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>parentRel</name> <init>= <expr><name><name>cxt</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>parentRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<comment type="block">/* transform the partition bound, if any */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>partbound</name></name> <operator>=</operator> <call><name>transformPartitionBound</name><argument_list>(<argument><expr><name><name>cxt</name><operator>-&gt;</operator><name>pstate</name></name></expr></argument>, <argument><expr><name>parentRel</name></expr></argument>,
														 <argument><expr><name><name>cmd</name><operator>-&gt;</operator><name>bound</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
			<comment type="block">/* nothing to check */</comment>
			<break>break;</break>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
			<comment type="block">/* the table must be partitioned */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table \"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<comment type="block">/* the index must be partitioned */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not partitioned"</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* parser shouldn't let this case through */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" is not a partitioned table or index"</literal></expr></argument>,
				 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parentRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * transformPartitionBound
 *
 * Transform a partition bound specification
 */</comment>
<function><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type>
<name>transformPartitionBound</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>,
						<parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>result_spec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionKey</name></type> <name>key</name> <init>= <expr><call><name>RelationGetPartitionKey</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>strategy</name> <init>= <expr><call><name>get_partition_strategy</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partnatts</name> <init>= <expr><call><name>get_partition_natts</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>partexprs</name> <init>= <expr><call><name>get_partition_exprs</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Avoid scribbling on input */</comment>
	<expr_stmt><expr><name>result_spec</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"a hash-partitioned table may not have a default partition"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In case of the default partition, parser had no way to identify the
		 * partition strategy. Assign the parent's strategy to the default
		 * partition bound spec.
		 */</comment>
		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>strategy</name></expr>;</expr_stmt>

		<return>return <expr><name>result_spec</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_HASH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bound specification for a hash partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"modulus for hash partition must be a positive integer"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>remainder</name></name> <operator>&gt;=</operator> <name><name>spec</name><operator>-&gt;</operator><name>modulus</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"remainder for hash partition must be less than modulus"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_LIST</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bound specification for a list partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Get the only column's name in case we need to output an error */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
															 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* Need its type data too */</comment>
		<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>spec-&gt;listdatums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>duplicate</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>con</name></expr></argument>,
												 <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Don't add to the result if the value is a duplicate */</comment>
			<expr_stmt><expr><name>duplicate</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>cell2</argument>, <argument>result_spec-&gt;listdatums</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value2</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>value2</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>duplicate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>duplicate</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>listdatums</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result_spec</name><operator>-&gt;</operator><name>listdatums</name></name></expr></argument>,
											  <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>strategy</name> <operator>==</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell1</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>spec</name><operator>-&gt;</operator><name>strategy</name></name> <operator>!=</operator> <name>PARTITION_STRATEGY_RANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid bound specification for a range partition"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>partnatts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FROM must specify exactly one value per partitioning column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>partnatts</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TO must specify exactly one value per partitioning column"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Once we see MINVALUE or MAXVALUE for one column, the remaining
		 * columns must be the same.
		 */</comment>
		<expr_stmt><expr><call><name>validateInfiniteBounds</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>validateInfiniteBounds</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Transform all the constants */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <name><name>result_spec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>forboth</name><argument_list>(<argument>cell1</argument>, <argument>spec-&gt;lowerdatums</argument>, <argument>cell2</argument>, <argument>spec-&gt;upperdatums</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>ldatum</name> <init>= <expr><operator>(</operator><name>PartitionRangeDatum</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>rdatum</name> <init>= <expr><operator>(</operator><name>PartitionRangeDatum</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>coltype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>coltypmod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

			<comment type="block">/* Get the column's name in case we need to output an error */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>key</name><operator>-&gt;</operator><name>partattrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>deparse_expression</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>deparse_context_for</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
																 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name>j</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* Need its type data too */</comment>
			<expr_stmt><expr><name>coltype</name> <operator>=</operator> <call><name>get_partition_col_typid</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>coltypmod</name> <operator>=</operator> <call><name>get_partition_col_typmod</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ldatum</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>, <argument><expr><name><name>ldatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>con</name></expr></argument>,
													 <argument><expr><name>colname</name></expr></argument>,
													 <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify NULL in range bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>ldatum</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>ldatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* don't scribble on input */</comment>
				<expr_stmt><expr><name><name>ldatum</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>value</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rdatum</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>, <argument><expr><name><name>rdatum</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>transformPartitionBoundValue</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>con</name></expr></argument>,
													 <argument><expr><name>colname</name></expr></argument>,
													 <argument><expr><name>coltype</name></expr></argument>, <argument><expr><name>coltypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify NULL in range bound"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>rdatum</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* don't scribble on input */</comment>
				<expr_stmt><expr><name><name>rdatum</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>value</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>lowerdatums</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result_spec</name><operator>-&gt;</operator><name>lowerdatums</name></name></expr></argument>,
											   <argument><expr><name>ldatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result_spec</name><operator>-&gt;</operator><name>upperdatums</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>result_spec</name><operator>-&gt;</operator><name>upperdatums</name></name></expr></argument>,
											   <argument><expr><name>rdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected partition strategy: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>result_spec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * validateInfiniteBounds
 *
 * Check that a MAXVALUE or MINVALUE specification in a partition bound is
 * followed only by more of the same.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validateInfiniteBounds</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>blist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PartitionRangeDatumKind</name></type> <name>kind</name> <init>= <expr><name>PARTITION_RANGE_DATUM_VALUE</name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>blist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>prd</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>PartitionRangeDatum</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name><name>prd</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PARTITION_RANGE_DATUM_VALUE</name></expr>:</case>
				<expr_stmt><expr><name>kind</name> <operator>=</operator> <name><name>prd</name><operator>-&gt;</operator><name>kind</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PARTITION_RANGE_DATUM_MAXVALUE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every bound following MAXVALUE must also be MAXVALUE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PARTITION_RANGE_DATUM_MINVALUE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"every bound following MINVALUE must also be MINVALUE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>prd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Transform one constant in a partition bound spec
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>transformPartitionBoundValue</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Const</name> <modifier>*</modifier></type><name>con</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>colType</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>colTypmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

	<comment type="block">/* Make it into a Const */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_const</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Coerce to correct type */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								  <argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>colType</name></expr></argument>,
								  <argument><expr><name>colTypmod</name></expr></argument>,
								  <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
								  <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified value cannot be cast to type %s for column \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Simplify the expression, in case we had a coercion */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fail if we don't have a constant (i.e., non-immutable coercion) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"specified value cannot be cast to type %s for column \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>colType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>colName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The cast requires a non-immutable conversion."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try putting the literal value in single quotes."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>value</name></expr>;</return>
</block_content>}</block></function>
</unit>
