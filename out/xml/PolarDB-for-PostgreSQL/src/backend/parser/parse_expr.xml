<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/parser/parse_expr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * parse_expr.c
 *	  handle expressions in parser
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/parser/parse_expr.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/tlist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_oper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_target.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_agg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>


<comment type="block">/* GUC parameters */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>operator_precedence_warning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Transform_null_equals</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Node-type groups for operator precedence warnings
 * We use zero for everything not otherwise classified
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_POSTFIX_IS</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>	<comment type="block">/* postfix IS tests (NullTest, etc) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_INFIX_IS</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>	<comment type="block">/* infix IS (IS DISTINCT FROM, etc) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_LESS</name></cpp:macro>			<cpp:value>3</cpp:value></cpp:define>	<comment type="block">/* &lt; &gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_EQUAL</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>	<comment type="block">/* = */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_LESS_EQUAL</name></cpp:macro>	<cpp:value>5</cpp:value></cpp:define>	<comment type="block">/* &lt;= &gt;= &lt;&gt; */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_LIKE</name></cpp:macro>			<cpp:value>6</cpp:value></cpp:define>	<comment type="block">/* LIKE ILIKE SIMILAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_BETWEEN</name></cpp:macro>		<cpp:value>7</cpp:value></cpp:define>	<comment type="block">/* BETWEEN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_IN</name></cpp:macro>			<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* IN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_NOT_LIKE</name></cpp:macro>		<cpp:value>9</cpp:value></cpp:define>	<comment type="block">/* NOT LIKE/ILIKE/SIMILAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_NOT_BETWEEN</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>	<comment type="block">/* NOT BETWEEN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_NOT_IN</name></cpp:macro>		<cpp:value>11</cpp:value></cpp:define>	<comment type="block">/* NOT IN */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_POSTFIX_OP</name></cpp:macro>	<cpp:value>12</cpp:value></cpp:define>	<comment type="block">/* generic postfix operators */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_INFIX_OP</name></cpp:macro>		<cpp:value>13</cpp:value></cpp:define>	<comment type="block">/* generic infix operators */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREC_GROUP_PREFIX_OP</name></cpp:macro>	<cpp:value>14</cpp:value></cpp:define>	<comment type="block">/* generic prefix operators */</comment>

<comment type="block">/*
 * Map precedence groupings to old precedence ordering
 *
 * Old precedence order:
 * 1. NOT
 * 2. =
 * 3. &lt; &gt;
 * 4. LIKE ILIKE SIMILAR
 * 5. BETWEEN
 * 6. IN
 * 7. generic postfix Op
 * 8. generic Op, including &lt;= =&gt; &lt;&gt;
 * 9. generic prefix Op
 * 10. IS tests (NullTest, BooleanTest, etc)
 *
 * NOT BETWEEN etc map to BETWEEN etc when considered as being on the left,
 * but to NOT when considered as being on the right, because of the buggy
 * precedence handling of those productions in the old grammar.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>oldprecedence_l</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>oldprecedence_r</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><literal type="number">6</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">7</literal></expr>, <expr><literal type="number">8</literal></expr>, <expr><literal type="number">9</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformExprRecurse</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformParamRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprOp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprOpAny</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprOpAll</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprDistinct</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprNullIf</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprOf</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprIn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformAExprBetween</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformBoolExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformFuncCall</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformMultiAssignRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>MultiAssignRef</name> <modifier>*</modifier></type><name>maref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCaseExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformSubLink</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformArrayExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>array_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformRowExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowDefault</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformMinMaxExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						  <parameter><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformXmlExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>XmlExpr</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformXmlSerialize</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>XmlSerialize</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformBooleanTest</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformColumnRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformWholeRowRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformIndirection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformTypeCast</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>transformCollateClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CollateClause</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_row_comparison_op</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>largs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rargs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_row_distinct_op</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
					 <parameter><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>lrow</name></decl></parameter>, <parameter><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>rrow</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type><name>make_distinct_op</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>ltree</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rtree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_nulltest_from_distinct</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							<parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>distincta</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>operator_precedence_group</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodename</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>emit_precedence_warnings</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>opgroup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
						 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>lchild</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rchild</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * transformExpr -
 *	  Analyze and transform expressions. Type checking and type casting is
 *	  done here.  This processing converts the raw grammar output into
 *	  expression trees with fully determined semantics.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>transformExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseExprKind</name></type> <name>sv_expr_kind</name></decl>;</decl_stmt>

	<comment type="block">/* Save and restore identity of expression type we're parsing */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>exprKind</name> <operator>!=</operator> <name>EXPR_KIND_NONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sv_expr_kind</name> <operator>=</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>exprKind</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>=</operator> <name>sv_expr_kind</name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformExprRecurse</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformColumnRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ColumnRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_ParamRef</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformParamRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>ParamRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_A_Const</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Value</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_const</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_A_Indirection</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformIndirection</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>A_Indirection</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformArrayExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>A_ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>,
										<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_TypeCast</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformTypeCast</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CollateClause</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCollateClause</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CollateClause</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_A_Expr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>AEXPR_OP</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprOp</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_OP_ANY</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprOpAny</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_OP_ALL</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprOpAll</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_DISTINCT</name></expr>:</case>
					<case>case <expr><name>AEXPR_NOT_DISTINCT</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprDistinct</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_NULLIF</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprNullIf</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_OF</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprOf</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_IN</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprIn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_LIKE</name></expr>:</case>
					<case>case <expr><name>AEXPR_ILIKE</name></expr>:</case>
					<case>case <expr><name>AEXPR_SIMILAR</name></expr>:</case>
						<comment type="block">/* we can transform these just like AEXPR_OP */</comment>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprOp</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_BETWEEN</name></expr>:</case>
					<case>case <expr><name>AEXPR_NOT_BETWEEN</name></expr>:</case>
					<case>case <expr><name>AEXPR_BETWEEN_SYM</name></expr>:</case>
					<case>case <expr><name>AEXPR_NOT_BETWEEN_SYM</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformAExprBetween</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>AEXPR_PAREN</name></expr>:</case>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized A_Expr kind: %d"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
						<break>break;</break>
				</block_content>}</block></switch>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformBoolExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_FuncCall</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformFuncCall</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>FuncCall</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformMultiAssignRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>MultiAssignRef</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformGroupingFunc</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>GroupingFunc</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NamedArgExpr</name> <modifier>*</modifier></type><name>na</name> <init>= <expr><operator>(</operator><name>NamedArgExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name><name>na</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>na</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformSubLink</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCaseExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CaseExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformRowExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCoalesceExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CoalesceExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformMinMaxExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>MinMaxExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformSQLValueFunction</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>SQLValueFunction</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformXmlExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformXmlSerialize</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>XmlSerialize</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_IS</name></expr></argument>, <argument><expr><literal type="string">"IS"</literal></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* the argument can be any type, so don't coerce it */</comment>
				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformBooleanTest</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>BooleanTest</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformCurrentOfExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>CurrentOfExpr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * In all places where DEFAULT is legal, the caller should have
			 * processed it rather than passing it to transformExpr().
			 */</comment>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DEFAULT is not allowed in this context"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><operator>(</operator><operator>(</operator><name>SetToDefault</name> <operator>*</operator><operator>)</operator> <name>expr</name><operator>)</operator><operator>-&gt;</operator><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * CaseTestExpr doesn't require any processing; it is only
			 * injected into parse trees in a fully-formed state.
			 *
			 * Ordinarily we should not see a Var here, but it is convenient
			 * for transformJoinUsingClause() to create untransformed operator
			 * trees containing already-transformed Vars.  The best
			 * alternative would be to deconstruct and reconstruct column
			 * references, which seems expensively pointless.  So allow it.
			 */</comment>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>

		<default>default:</default>
			<comment type="block">/* should not reach here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * helper routine for delivering "column does not exist" error message
 *
 * (Usually we don't have to work this hard, but the general case of field
 * selection from an arbitrary node needs it.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unknown_attribute</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>relref</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>relref</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>relref</name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reference the RTE by alias not by actual table name */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>GetRTEByRangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									 <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>relref</name><operator>)</operator><operator>-&gt;</operator><name>varno</name></expr></argument>,
									 <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>relref</name><operator>)</operator><operator>-&gt;</operator><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column %s.%s does not exist"</literal></expr></argument>,
						<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Have to do it by reference to the type of the expression */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relTypeId</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>relref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ISCOMPLEX</name><argument_list>(<argument><expr><name>relTypeId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" not found in data type %s"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>relTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>relTypeId</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not identify column \"%s\" in record data type"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column notation .%s applied to type %s, "</literal>
							<literal type="string">"which is not a composite type"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>relTypeId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformIndirection</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Indirection</name> <modifier>*</modifier></type><name>ind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>ind</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subscripts</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>location</name> <init>= <expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have to split any field-selection operations apart from
	 * subscripting.  Adjacent A_Indices nodes have to be treated as a single
	 * multidimensional subscript operation.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>i</argument>, <argument>ind-&gt;indirection</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>A_Indices</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>subscripts</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>subscripts</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row expansion via \"*\" is not supported here"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newresult</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* process subscripts before this field selection */</comment>
			<if_stmt><if>if <condition>(<expr><name>subscripts</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>transformArraySubscripts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
														   <argument><expr><name>result</name></expr></argument>,
														   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><name>InvalidOid</name></expr></argument>,
														   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
														   <argument><expr><name>subscripts</name></expr></argument>,
														   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>subscripts</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>newresult</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>last_srf</name></expr></argument>,
										  <argument><expr><name>NULL</name></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>,
										  <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newresult</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>unknown_attribute</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>newresult</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<comment type="block">/* process trailing subscripts, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>subscripts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>transformArraySubscripts</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><name>result</name></expr></argument>,
												   <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>InvalidOid</name></expr></argument>,
												   <argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
												   <argument><expr><name>subscripts</name></expr></argument>,
												   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a ColumnRef.
 *
 * If you find yourself changing this code, see also ExpandColumnRefStar.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformColumnRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>levels_up</name></decl>;</decl_stmt>
	<enum>enum
	<block>{
		<decl><name>CRERR_NO_COLUMN</name></decl>,
		<decl><name>CRERR_NO_RTE</name></decl>,
		<decl><name>CRERR_WRONG_DB</name></decl>,
		<decl><name>CRERR_TOO_MANY</name></decl>
	}</block>			<decl><name>crerr</name> <init>= <expr><name>CRERR_NO_COLUMN</name></expr></init></decl>;</enum>

	<comment type="block">/*
	 * Give the PreParseColumnRefHook, if any, first shot.  If it returns
	 * non-null then that's all, folks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * The allowed syntaxes are:
	 *
	 * A		First try to resolve as unqualified column name;
	 *			if no luck, try to resolve as unqualified table name (A.*).
	 * A.B		A is an unqualified table name; B is either a
	 *			column or function name (trying column name first).
	 * A.B.C	schema A, table B, col or func name C.
	 * A.B.C.D	catalog A, schema B, table C, col or func D.
	 * A.*		A is an unqualified table name; means whole-row value.
	 * A.B.*	whole-row value of table B in schema A.
	 * A.B.C.*	whole-row value of table C in schema B in catalog A.
	 *
	 * We do not need to cope with bare "*"; that will only be accepted by
	 * the grammar at the top level of a SELECT list, and transformTargetList
	 * will take care of it before it ever gets here.  Also, "A.*" etc will
	 * be expanded by transformTargetList if they appear at SELECT top level,
	 * so here we are only going to see them as function or operator inputs.
	 *
	 * Currently, if a catalog name is given then it must equal the current
	 * database name; we check it here and then discard it.
	 *----------
	 */</comment>
	<switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Try to identify as an unqualified column */</comment>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>colNameToVar</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Not known as a column of any range-table entry.
					 *
					 * Try to find the name as a relation.  Note that only
					 * relations already entered into the rangetable will be
					 * recognized.
					 *
					 * This is a hack for backwards compatibility with
					 * PostQUEL-inspired syntax.  The preferred form now is
					 * "rel.*".
					 */</comment>
					<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>,
											   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>rte</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>,
													<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Locate the referenced RTE */</comment>
				<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
										   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>crerr</name> <operator>=</operator> <name>CRERR_NO_RTE</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Whole-row reference? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Try to identify as a column of the RTE */</comment>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Try it as a function call on the whole row */</comment>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field3</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Locate the referenced RTE */</comment>
				<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
										   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>crerr</name> <operator>=</operator> <name>CRERR_NO_RTE</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Whole-row reference? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field3</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field3</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Try to identify as a column of the RTE */</comment>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Try it as a function call on the whole row */</comment>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field3</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field4</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfourth</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catname</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>catname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field3</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>relname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * We check the catalog name and then ignore it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>catname</name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>crerr</name> <operator>=</operator> <name>CRERR_WRONG_DB</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Locate the referenced RTE */</comment>
				<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>refnameRangeTblEntry</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
										   <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rte</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>crerr</name> <operator>=</operator> <name>CRERR_NO_RTE</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Whole-row reference? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field4</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field4</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Try to identify as a column of the RTE */</comment>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>scanRTEForColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Try it as a function call on the whole row */</comment>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>transformWholeRowRef</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument>,
											 <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><name>crerr</name> <operator>=</operator> <name>CRERR_TOO_MANY</name></expr>;</expr_stmt> <comment type="block">/* too many dotted names */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Now give the PostParseColumnRefHook, if any, a chance.  We pass the
	 * translation-so-far so that it can throw an error if it wishes in the
	 * case that it has a conflicting interpretation of the ColumnRef. (If it
	 * just translates anyway, we'll throw an error, because we can't undo
	 * whatever effects the preceding steps may have had on the pstate.) If it
	 * returns NULL, use the standard translation, or throw a suitable error
	 * if there is none.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>hookresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hookresult</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <name>hookresult</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>hookresult</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column reference \"%s\" is ambiguous"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Throw error if no translation found.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>crerr</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CRERR_NO_COLUMN</name></expr>:</case>
				<expr_stmt><expr><call><name>errorMissingColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>colname</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CRERR_NO_RTE</name></expr>:</case>
				<expr_stmt><expr><call><name>errorMissingRTE</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>,
													 <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CRERR_WRONG_DB</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: %s"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CRERR_TOO_MANY</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper qualified name (too many dotted names): %s"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformParamRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The core parser knows nothing about Params.  If a hook is supplied,
	 * call it.  If not, or if the hook returns NULL, throw a generic error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_PARAMETER</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"there is no parameter $%d"</literal></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Test whether an a_expr is a plain NULL constant or not */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>exprIsNullConstant</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>T_Null</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprOp</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>opgroup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opgroup</name> <operator>=</operator> <call><name>operator_precedence_group</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>opgroup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>opgroup</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>,
									 <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>,
									 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Look through AEXPR_PAREN nodes so they don't affect tests below */</comment>
		<while>while <condition>(<expr><name>lexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>AEXPR_PAREN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>lexpr</name></expr>;</expr_stmt></block_content></block></while>
		<while>while <condition>(<expr><name>rexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>AEXPR_PAREN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>lexpr</name></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Special-case "foo = NULL" and "NULL = foo" for compatibility with
	 * standards-broken products (like Microsoft's).  Turn these into IS NULL
	 * exprs. (If either side is a CaseTestExpr, then the expression was
	 * generated internally from a CASE-WHEN expression, and
	 * transform_null_equals does not apply.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Transform_null_equals</name> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>exprIsNullConstant</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>exprIsNullConstant</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>exprIsNullConstant</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rexpr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>lexpr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>lexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <name>rexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>(</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Convert "row op subselect" into a ROWCOMPARE sublink. Formerly the
		 * grammar did this, but now that a row construct is allowed anywhere
		 * in expressions, it's easier to do it here.
		 */</comment>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>rexpr</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>ROWCOMPARE_SUBLINK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>lexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>lexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <name>rexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ROW() op ROW() is handled specially */</comment>
		<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_row_comparison_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
										<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>,
										<argument><expr><call><name>castNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>args</name></expr></argument>,
										<argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Ordinary scalar operator */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								  <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
								  <argument><expr><name>lexpr</name></expr></argument>,
								  <argument><expr><name>rexpr</name></expr></argument>,
								  <argument><expr><name>last_srf</name></expr></argument>,
								  <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprOpAny</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_OP</name></expr></argument>,
								 <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_scalar_array_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>lexpr</name></expr></argument>,
										 <argument><expr><name>rexpr</name></expr></argument>,
										 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprOpAll</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_OP</name></expr></argument>,
								 <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_scalar_array_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>,
										 <argument><expr><name>lexpr</name></expr></argument>,
										 <argument><expr><name>rexpr</name></expr></argument>,
										 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprDistinct</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_INFIX_IS</name></expr></argument>, <argument><expr><literal type="string">"IS"</literal></expr></argument>,
								 <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If either input is an undecorated NULL literal, transform to a NullTest
	 * on the other input. That's simpler to process than a full DistinctExpr,
	 * and it avoids needing to require that the datatype have an = operator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>exprIsNullConstant</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>make_nulltest_from_distinct</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>exprIsNullConstant</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>make_nulltest_from_distinct</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>rexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* ROW() op ROW() is handled specially */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_row_distinct_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									  <argument><expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>lexpr</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>rexpr</name></expr></argument>,
									  <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Ordinary scalar operator */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_distinct_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
										   <argument><expr><name>lexpr</name></expr></argument>,
										   <argument><expr><name>rexpr</name></expr></argument>,
										   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If it's NOT DISTINCT, we first build a DistinctExpr and then stick a
	 * NOT on top.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_NOT_DISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>NOT_EXPR</name></expr></argument>,
									   <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>,
									   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprNullIf</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
								<argument><expr><name>lexpr</name></expr></argument>,
								<argument><expr><name>rexpr</name></expr></argument>,
								<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
								<argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The comparison operator itself should yield boolean ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"NULLIF requires = operator to yield boolean"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>-&gt;</operator><name>opretset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg NULLIF */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s must not return a set"</literal></expr></argument>, <argument><expr><literal type="string">"NULLIF"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ... but the NullIfExpr will yield the first operand's type.
	 */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We rely on NullIfExpr and OpExpr being the same struct
	 */</comment>
	<expr_stmt><expr><call><name>NodeSetTag</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>T_NullIfExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Checking an expression for match to a list of type names. Will result
 * in a boolean constant node.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprOf</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>telem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ltype</name></decl>,
				<decl><type ref="prev"/><name>rtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>matched</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_IS</name></expr></argument>, <argument><expr><literal type="string">"IS"</literal></expr></argument>,
								 <argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ltype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>telem</argument>, <argument>(List *) a-&gt;rexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>rtype</name> <operator>=</operator> <call><name>typenameTypeId</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>telem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>matched</name> <operator>=</operator> <operator>(</operator><name>rtype</name> <operator>==</operator> <name>ltype</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>matched</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * We have two forms: equals or not equals. Flip the sense of the result
	 * for not equals.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>matched</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name>matched</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>matched</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the result have the original input's parse location */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprIn</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rnonvars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useOr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the operator is &lt;&gt;, combine with AND not OR.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>useOr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>useOr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								 <argument><expr><ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><name>PREC_GROUP_IN</name></expr> </then><else>: <expr><name>PREC_GROUP_NOT_IN</name></expr></else></ternary></expr></argument>,
								 <argument><expr><literal type="string">"IN"</literal></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We try to generate a ScalarArrayOpExpr from IN/NOT IN, but this is only
	 * possible if there is a suitable array type available.  If not, we fall
	 * back to a boolean condition tree with multiple copies of the lefthand
	 * expression.  Also, any IN-list items that contain Vars are handled as
	 * separate boolean conditions, because that gives the planner more scope
	 * for optimization on such clauses.
	 *
	 * First step: transform all the inputs, and detect whether any contain
	 * Vars.
	 */</comment>
	<expr_stmt><expr><name>lexpr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rexprs</name> <operator>=</operator> <name>rvars</name> <operator>=</operator> <name>rnonvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>(List *) a-&gt;rexpr</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rexprs</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>contain_vars_of_level</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rvars</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rnonvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rnonvars</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * ScalarArrayOpExpr is only going to be useful if there's more than one
	 * non-Var righthand item.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>rnonvars</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>allexprs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>scalar_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>array_type</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Try to select a common type for the array elements.  Note that
		 * since the LHS' type is first in the list, it will be preferred when
		 * there is doubt (eg, when all the RHS items are unknown literals).
		 *
		 * Note: use list_concat here not lcons, to avoid damaging rnonvars.
		 */</comment>
		<expr_stmt><expr><name>allexprs</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rnonvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>scalar_type</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>allexprs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do we have an array type to use?  Aside from the case where there
		 * isn't one, we don't risk using ScalarArrayOpExpr when the common
		 * type is RECORD, because the RowExpr comparison logic below can cope
		 * with some cases of non-identical row types.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>scalar_type</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>scalar_type</name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>array_type</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>scalar_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>array_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>array_type</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * OK: coerce all the right-hand non-Var inputs to the common type
			 * and build an ArrayExpr for them.
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>aexprs</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>newa</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rnonvars</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>,
											  <argument><expr><name>scalar_type</name></expr></argument>,
											  <argument><expr><literal type="string">"IN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>aexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>aexprs</name></expr></argument>, <argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><name>newa</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <name>array_type</name></expr>;</expr_stmt>
			<comment type="block">/* array_collid will be set by parse_collate.c */</comment>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>scalar_type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>aexprs</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_scalar_array_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
												   <argument><expr><name>useOr</name></expr></argument>,
												   <argument><expr><name>lexpr</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newa</name></expr></argument>,
												   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Consider only the Vars (if any) in the loop below */</comment>
			<expr_stmt><expr><name>rexprs</name> <operator>=</operator> <name>rvars</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Must do it the hard way, ie, with a boolean expression tree.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>rexprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cmp</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>IsA</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* ROW() op ROW() is handled specially */</comment>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>make_row_comparison_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
										 <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>lexpr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>rexpr</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr></argument>,
										 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Ordinary scalar operator */</comment>
			<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
								   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>rexpr</name></expr></argument>,
								   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>,
								   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>, <argument><expr><literal type="string">"IN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>cmp</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><name>OR_EXPR</name></expr> </then><else>: <expr><name>AND_EXPR</name></expr></else></ternary></expr></argument>,
										   <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformAExprBetween</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>aexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>bexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sub1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>sub2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

	<comment type="block">/* Deconstruct A_Expr into three subexprs */</comment>
	<expr_stmt><expr><name>aexpr</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>lexpr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>List</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>rexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>bexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>opgroup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>opgroup</name> <operator>=</operator> <call><name>operator_precedence_group</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>opgroup</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>,
								 <argument><expr><name>aexpr</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>,
								 <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We can ignore bexpr thanks to syntactic restrictions */</comment>
		<comment type="block">/* Wrap subexpressions to prevent extra warnings */</comment>
		<expr_stmt><expr><name>aexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeA_Expr</name><argument_list>(<argument><expr><name>AEXPR_PAREN</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>aexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeA_Expr</name><argument_list>(<argument><expr><name>AEXPR_PAREN</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>bexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeA_Expr</name><argument_list>(<argument><expr><name>AEXPR_PAREN</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Build the equivalent comparison expression.  Make copies of
	 * multiply-referenced subexpressions for safety.  (XXX this is really
	 * wrong since it results in multiple runtime evaluations of what may be
	 * volatile expressions ...)
	 *
	 * Ideally we would not use hard-wired operators here but instead use
	 * opclasses.  However, mixed data types and other issues make this
	 * difficult:
	 * http://archives.postgresql.org/pgsql-hackers/2008-08/msg01142.php
	 */</comment>
	<switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AEXPR_BETWEEN</name></expr>:</case>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>,
											   <argument><expr><name>aexpr</name></expr></argument>, <argument><expr><name>bexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&lt;="</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN</name></expr>:</case>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>,
											   <argument><expr><name>aexpr</name></expr></argument>, <argument><expr><name>bexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN_SYM</name></expr>:</case>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>,
											   <argument><expr><name>aexpr</name></expr></argument>, <argument><expr><name>bexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&lt;="</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sub1</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&lt;="</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>bexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sub2</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>sub1</name></expr></argument>, <argument><expr><name>sub2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN_SYM</name></expr>:</case>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>,
											   <argument><expr><name>aexpr</name></expr></argument>, <argument><expr><name>bexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cexpr</name></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sub1</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>cexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>,
											   <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>aexpr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name>bexpr</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sub2</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>sub1</name></expr></argument>, <argument><expr><name>sub2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized A_Expr kind: %d"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformBoolExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>BoolExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OR_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"OR"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOT_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <literal type="string">"NOT"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized boolop: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>a-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>boolop</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformFuncCall</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>FuncCall</name> <modifier>*</modifier></type><name>fn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>targs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

	<comment type="block">/* Transform the list of arguments ... */</comment>
	<expr_stmt><expr><name>targs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>fn-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>targs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targs</name></expr></argument>, <argument><expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * When WITHIN GROUP is used, we treat its ORDER BY expressions as
	 * additional arguments to the function, for purposes of function lookup
	 * and argument type coercion.  So, transform each such expression and add
	 * them to the targs list.  We don't explicitly mark where each argument
	 * came from, but ParseFuncOrColumn can tell what's what by reference to
	 * list_length(fn-&gt;agg_order).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fn</name><operator>-&gt;</operator><name>agg_within_group</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fn</name><operator>-&gt;</operator><name>agg_order</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>fn-&gt;agg_order</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SortBy</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>SortBy</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>targs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>targs</name></expr></argument>, <argument><expr><call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>arg</name><operator>-&gt;</operator><name>node</name></name></expr></argument>,
												 <argument><expr><name>EXPR_KIND_ORDER_BY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ... and hand off to ParseFuncOrColumn */</comment>
	<return>return <expr><call><name>ParseFuncOrColumn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
							 <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
							 <argument><expr><name>targs</name></expr></argument>,
							 <argument><expr><name>last_srf</name></expr></argument>,
							 <argument><expr><name>fn</name></expr></argument>,
							 <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><name><name>fn</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformMultiAssignRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>MultiAssignRef</name> <modifier>*</modifier></type><name>maref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sublink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>rexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qtree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

	<comment type="block">/* We should only see this in first-stage processing of UPDATE tlists */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name> <operator>==</operator> <name>EXPR_KIND_UPDATE_SOURCE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We only need to transform the source if this is the first column */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>maref</name><operator>-&gt;</operator><name>colno</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For now, we only allow EXPR SubLinks and RowExprs as the source of
		 * an UPDATE multiassignment.  This is sufficient to cover interesting
		 * cases; at worst, someone would have to write (SELECT * FROM expr)
		 * to expand a composite-returning expression of another form.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>maref</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name><name>maref</name><operator>-&gt;</operator><name>source</name></name><operator>)</operator><operator>-&gt;</operator><name>subLinkType</name> <operator>==</operator> <name>EXPR_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Relabel it as a MULTIEXPR_SUBLINK */</comment>
			<expr_stmt><expr><name>sublink</name> <operator>=</operator> <operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name><name>maref</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>=</operator> <name>MULTIEXPR_SUBLINK</name></expr>;</expr_stmt>
			<comment type="block">/* And transform it */</comment>
			<expr_stmt><expr><name>sublink</name> <operator>=</operator> <operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													   <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>qtree</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check subquery returns required number of columns */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>count_nonjunk_tlist_entries</name><argument_list>(<argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>maref</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of columns does not match number of values"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Build a resjunk tlist item containing the MULTIEXPR SubLink,
			 * and add it to pstate-&gt;p_multiassign_exprs, whence it will later
			 * get appended to the completed targetlist.  We needn't worry
			 * about selecting a resno for it; transformUpdateStmt will do
			 * that.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>sublink</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr></argument>,
												  <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Assign a unique-within-this-targetlist ID to the MULTIEXPR
			 * SubLink.  We can just use its position in the
			 * p_multiassign_exprs list.
			 */</comment>
			<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>maref</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Transform the RowExpr, allowing SetToDefault items */</comment>
			<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <call><name>transformRowExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												 <argument><expr><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name><name>maref</name><operator>-&gt;</operator><name>source</name></name></expr></argument>,
												 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check it returns required number of columns */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>maref</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of columns does not match number of values"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Temporarily append it to p_multiassign_exprs, so we can get it
			 * back when we come back here for additional columns.
			 */</comment>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>rexpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr></argument>,
												  <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source for a multiple-column UPDATE item must be a sub-SELECT or ROW() expression"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>maref</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Second or later column in a multiassignment.  Re-fetch the
		 * transformed SubLink or RowExpr, which we assume is still the last
		 * entry in p_multiassign_exprs.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Emit the appropriate output expression for the current column
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sublink</name> <operator>=</operator> <operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qtree</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Build a Param representing the current subquery output column */</comment>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>maref</name><operator>-&gt;</operator><name>colno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_MULTIEXPR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <operator>(</operator><name><name>sublink</name><operator>-&gt;</operator><name>subLinkId</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name><name>maref</name><operator>-&gt;</operator><name>colno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <call><name>exprLocation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rexpr</name> <operator>=</operator> <operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

		<comment type="block">/* Just extract and return the next element of the RowExpr */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>rexpr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>maref</name><operator>-&gt;</operator><name>colno</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're at the last column, delete the RowExpr from
		 * p_multiassign_exprs; we don't need it anymore, and don't want it in
		 * the finished UPDATE tlist.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>maref</name><operator>-&gt;</operator><name>colno</name></name> <operator>==</operator> <name><name>maref</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name> <operator>=</operator>
				<call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_multiassign_exprs</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected expr type in multiassign list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCaseExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CaseExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CaseExpr</name>   <modifier>*</modifier></type><name>newc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>placeholder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>resultexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>defresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ptype</name></decl>;</decl_stmt>

	<comment type="block">/* transform the test expression, if any */</comment>
	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* generate placeholder for test expression */</comment>
	<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If test expression is an untyped literal, force it to text. We have
		 * to do something now because we won't be able to do this coercion on
		 * the placeholder.  This is not as flexible as what was done in 7.4
		 * and before, but it's good enough to handle the sort of silly coding
		 * commonly seen.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Run collation assignment on the test expression so that we know
		 * what collation to mark the placeholder with.  In principle we could
		 * leave it to parse_collate.c to do that later, but propagating the
		 * result to the CaseTestExpr would be unnecessarily complicated.
		 */</comment>
		<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>placeholder</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>placeholder</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>placeholder</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

	<comment type="block">/* transform the list of arguments */</comment>
	<expr_stmt><expr><name>newargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>c-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>w</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>neww</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CaseWhen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>warg</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>warg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>placeholder</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* shorthand form was specified, so expand... */</comment>
			<expr_stmt><expr><name>warg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeSimpleA_Expr</name><argument_list>(<argument><expr><name>AEXPR_OP</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>,
											 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>placeholder</name></expr></argument>,
											 <argument><expr><name>warg</name></expr></argument>,
											 <argument><expr><name><name>w</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>warg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>neww</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
												<argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>warg</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>warg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>neww</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>neww</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>resultexprs</name></expr></argument>, <argument><expr><name><name>neww</name><operator>-&gt;</operator><name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newargs</name></expr>;</expr_stmt>

	<comment type="block">/* transform the default clause */</comment>
	<expr_stmt><expr><name>defresult</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>c</name><operator>-&gt;</operator><name>defresult</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>defresult</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>T_Null</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>defresult</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>defresult</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: default result is considered the most significant type in
	 * determining preferred type. This is how the code worked before, but it
	 * seems a little bogus to me --- tgl
	 */</comment>
	<expr_stmt><expr><name>resultexprs</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name><name>newc</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>, <argument><expr><name>resultexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ptype</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>resultexprs</name></expr></argument>, <argument><expr><literal type="string">"CASE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>casetype</name></name> <operator>=</operator> <name>ptype</name></expr>;</expr_stmt>
	<comment type="block">/* casecollid will be set by parse_collate.c */</comment>

	<comment type="block">/* Convert default result clause, if necessary */</comment>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>defresult</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
		<call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
							  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>newc</name><operator>-&gt;</operator><name>defresult</name></name></expr></argument>,
							  <argument><expr><name>ptype</name></expr></argument>,
							  <argument><expr><literal type="string">"CASE/ELSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert when-clause results, if necessary */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>newc-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CaseWhen</name>   <modifier>*</modifier></type><name>w</name> <init>= <expr><operator>(</operator><name>CaseWhen</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator>
			<call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>w</name><operator>-&gt;</operator><name>result</name></name></expr></argument>,
								  <argument><expr><name>ptype</name></expr></argument>,
								  <argument><expr><literal type="string">"CASE/WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* if any subexpression contained a SRF, complain */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in %s"</literal></expr></argument>,
						<argument><expr><literal type="string">"CASE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might be able to move the set-returning function into a LATERAL FROM item."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformSubLink</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SubLink</name> <modifier>*</modifier></type><name>sublink</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sublink</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qtree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check to see if the sublink is in an invalid place within the query. We
	 * allow sublinks everywhere in SELECT/INSERT/UPDATE/DELETE, but generally
	 * not in utility statements.
	 */</comment>
	<expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPR_KIND_NONE</name></expr>:</case>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* can't happen */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_OTHER</name></expr>:</case>
			<comment type="block">/* Accept sublink here; caller must throw error if wanted */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_JOIN_ON</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_JOIN_USING</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FROM_SUBSELECT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FROM_FUNCTION</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WHERE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_POLICY</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_HAVING</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FILTER</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_PARTITION</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_ORDER</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_RANGE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_ROWS</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_GROUPS</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_SELECT_TARGET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_INSERT_TARGET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_TARGET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_GROUP_BY</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_ORDER_BY</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_DISTINCT_ON</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_LIMIT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_OFFSET</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_RETURNING</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_VALUES</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_VALUES_SINGLE</name></expr>:</case>
			<comment type="block">/* okay */</comment>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CHECK_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_DOMAIN_CHECK</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in check constraint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FUNCTION_DEFAULT</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in DEFAULT expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in index expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in index predicate"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in transform expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_EXECUTE_PARAMETER</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in EXECUTE parameter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_TRIGGER_WHEN</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in trigger WHEN condition"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in partition key expression"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>EXPR_KIND_CALL_ARGUMENT</name></expr>:</case>
			<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot use subquery in CALL argument"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * There is intentionally no default: case here, so that the
			 * compiler will warn if we add a new ParseExprKind without
			 * extending this switch.  If we do see an unrecognized value at
			 * runtime, the behavior will be the same as for EXPR_KIND_OTHER,
			 * which is sane anyway.
			 */</comment>
	</block_content>}</block></switch>
	<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_hasSubLinks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, let's transform the sub-SELECT.
	 */</comment>
	<expr_stmt><expr><name>qtree</name> <operator>=</operator> <call><name>parse_sub_analyze</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check that we got a SELECT.  Anything else should be impossible given
	 * restrictions of the grammar, but check anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>qtree</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>qtree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-SELECT command in SubLink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>subselect</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>qtree</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXISTS_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * EXISTS needs no test expression or combining operator. These fields
		 * should be null already, but make sure.
		 */</comment>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>EXPR_SUBLINK</name> <operator>||</operator>
			 <name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ARRAY_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make sure the subselect delivers a single column (ignoring resjunk
		 * targets).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>count_nonjunk_tlist_entries</name><argument_list>(<argument><expr><name><name>qtree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subquery must return only one column"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * EXPR and ARRAY need no test expression or combining operator. These
		 * fields should be null already, but make sure.
		 */</comment>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>MULTIEXPR_SUBLINK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Same as EXPR case, except no restriction on number of columns */</comment>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ALL, ANY, or ROWCOMPARE: generate row-comparing expression */</comment>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>lefthand</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>left_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>right_list</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_IN</name></expr></argument>, <argument><expr><literal type="string">"IN"</literal></expr></argument>,
										 <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_OP</name></expr></argument>,
										 <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the source was "x IN (select)", convert to "x = ANY (select)".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Transform lefthand expression, and convert to a list
		 */</comment>
		<expr_stmt><expr><name>lefthand</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>lefthand</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>lefthand</name></expr></argument>, <argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>left_list</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RowExpr</name> <operator>*</operator><operator>)</operator> <name>lefthand</name><operator>)</operator><operator>-&gt;</operator><name>args</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>left_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Build a list of PARAM_SUBLINK nodes representing the output columns
		 * of the subquery.
		 */</comment>
		<expr_stmt><expr><name>right_list</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>qtree-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tent</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tent</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_SUBLINK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name><name>tent</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tent</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name>right_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>right_list</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * We could rely on make_row_comparison_op to complain if the list
		 * lengths differ, but we prefer to generate a more specific error
		 * message.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>left_list</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>right_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subquery has too many columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>left_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>right_list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"subquery has too few columns"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Identify the combining operator(s) and generate a suitable
		 * row-comparison expression.
		 */</comment>
		<expr_stmt><expr><name><name>sublink</name><operator>-&gt;</operator><name>testexpr</name></name> <operator>=</operator> <call><name>make_row_comparison_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
												   <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>operName</name></name></expr></argument>,
												   <argument><expr><name>left_list</name></expr></argument>,
												   <argument><expr><name>right_list</name></expr></argument>,
												   <argument><expr><name><name>sublink</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * transformArrayExpr
 *
 * If the caller specifies the target type, the resulting array will
 * be of exactly that type.  Otherwise we try to infer a common type
 * for the elements using select_common_type().
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformArrayExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_ArrayExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>array_type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>element_type</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>newa</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newelems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcoercedelems</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>element</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>coerce_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>coerce_hard</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Transform the element expressions
	 *
	 * Assume that the array is one-dimensional unless we find an array-type
	 * element expression.
	 */</comment>
	<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>element</argument>, <argument>a-&gt;elements</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<comment type="block">/* Look through AEXPR_PAREN nodes so they don't affect test below */</comment>
		<while>while <condition>(<expr><name>e</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			   <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>e</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>AEXPR_PAREN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>e</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>e</name><operator>)</operator><operator>-&gt;</operator><name>lexpr</name></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/*
		 * If an element is itself an A_ArrayExpr, recurse directly so that we
		 * can pass down any target type we were given.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transformArrayExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>A_ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>e</name></expr></argument>,
									  <argument><expr><name>array_type</name></expr></argument>,
									  <argument><expr><name>element_type</name></expr></argument>,
									  <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* we certainly have an array here */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>array_type</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <name>array_type</name> <operator>==</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check for sub-array expressions, if we haven't already found
			 * one.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>&amp;&amp;</operator> <call><name>type_is_array</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>newelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newelems</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Select a target type for the elements.
	 *
	 * If we haven't been given a target array type, we must try to deduce a
	 * common type based on the types of the individual elements present.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Caller must ensure array_type matches element_type */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coerce_type</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name></expr> ?</condition><then> <expr><name>array_type</name></expr> </then><else>: <expr><name>element_type</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>coerce_hard</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Can't handle an empty array without a target type */</comment>
		<if_stmt><if>if <condition>(<expr><name>newelems</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_DATATYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot determine type of empty array"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Explicitly cast to the desired type, "</literal>
							 <literal type="string">"for example ARRAY[]::integer[]."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Select a common type for the elements */</comment>
		<expr_stmt><expr><name>coerce_type</name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newelems</name></expr></argument>, <argument><expr><literal type="string">"ARRAY"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>newa</name><operator>-&gt;</operator><name>multidims</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>array_type</name> <operator>=</operator> <name>coerce_type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>element_type</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find element type for data type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>element_type</name> <operator>=</operator> <name>coerce_type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>array_type</name> <operator>=</operator> <call><name>get_array_type</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find array type for data type %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>coerce_hard</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Coerce elements to target type
	 *
	 * If the array has been explicitly cast, then the elements are in turn
	 * explicitly coerced.
	 *
	 * If the array's type was merely derived from the common type of its
	 * elements, then the elements are implicitly coerced to the common type.
	 * This is consistent with other uses of select_common_type().
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>element</argument>, <argument>newelems</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>coerce_hard</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>,
										 <argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>coerce_type</name></expr></argument>,
										 <argument><expr><name>typmod</name></expr></argument>,
										 <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
										 <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>newe</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>coerce_type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name>e</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>,
										 <argument><expr><name>coerce_type</name></expr></argument>,
										 <argument><expr><literal type="string">"ARRAY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>newcoercedelems</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcoercedelems</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>array_typeid</name></name> <operator>=</operator> <name>array_type</name></expr>;</expr_stmt>
	<comment type="block">/* array_collid will be set by parse_collate.c */</comment>
	<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>element_typeid</name></name> <operator>=</operator> <name>element_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>elements</name></name> <operator>=</operator> <name>newcoercedelems</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newa</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newa</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformRowExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allowDefault</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowExpr</name>    <modifier>*</modifier></type><name>newr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transform the field expressions */</comment>
	<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>transformExpressionList</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
										 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_expr_kind</name></name></expr></argument>, <argument><expr><name>allowDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Barring later casting, we consider the type RECORD */</comment>
	<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>row_typeid</name></name> <operator>=</operator> <name>RECORDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>row_format</name></name> <operator>=</operator> <name>COERCE_IMPLICIT_CAST</name></expr>;</expr_stmt>

	<comment type="block">/* ROW() has anonymous columns, so invent some field names */</comment>
	<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>newr-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"f%d"</literal></expr></argument>, <argument><expr><name>fnum</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>colnames</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newr</name><operator>-&gt;</operator><name>colnames</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>newr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CoalesceExpr</name> <modifier>*</modifier></type><name>newc</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoalesceExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>last_srf</name> <init>= <expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcoercedargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>c-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>coalescetype</name></name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* coalescecollid will be set by parse_collate.c */</comment>

	<comment type="block">/* Convert arguments if necessary */</comment>
	<macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>newargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>,
									 <argument><expr><name><name>newc</name><operator>-&gt;</operator><name>coalescetype</name></name></expr></argument>,
									 <argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcoercedargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcoercedargs</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* if any subexpression contained a SRF, complain */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name> <operator>!=</operator> <name>last_srf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg GROUP BY */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-returning functions are not allowed in %s"</literal></expr></argument>,
						<argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You might be able to move the set-returning function into a LATERAL FROM item."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									<argument><expr><call><name>exprLocation</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newcoercedargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformMinMaxExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>m</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinMaxExpr</name> <modifier>*</modifier></type><name>newm</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>MinMaxExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newcoercedargs</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_GREATEST</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"GREATEST"</literal></expr> </then><else>: <expr><literal type="string">"LEAST"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>newm</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>m-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>newm</name><operator>-&gt;</operator><name>minmaxtype</name></name> <operator>=</operator> <call><name>select_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* minmaxcollid and inputcollid will be set by parse_collate.c */</comment>

	<comment type="block">/* Convert arguments if necessary */</comment>
	<macro><name>foreach</name><argument_list>(<argument>args</argument>, <argument>newargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_common_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>,
									 <argument><expr><name><name>newm</name><operator>-&gt;</operator><name>minmaxtype</name></name></expr></argument>,
									 <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newcoercedargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newcoercedargs</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>newm</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>newcoercedargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newm</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newm</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>SQLValueFunction</name> <modifier>*</modifier></type><name>svf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * All we need to do is insert the correct result type and (where needed)
	 * validate the typmod, so we just modify the node in-place.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>svf</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>SVFOP_CURRENT_DATE</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>DATEOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_TIME</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMETZOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_TIME_N</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMETZOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <call><name>anytime_typmod_check</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMESTAMPTZOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_TIMESTAMP_N</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMESTAMPTZOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <call><name>anytimestamp_typmod_check</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_LOCALTIME</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMEOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_LOCALTIME_N</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMEOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <call><name>anytime_typmod_check</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_LOCALTIMESTAMP</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMESTAMPOID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_LOCALTIMESTAMP_N</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>TIMESTAMPOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <call><name>anytimestamp_typmod_check</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>svf</name><operator>-&gt;</operator><name>typmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SVFOP_CURRENT_ROLE</name></expr>:</case>
		<case>case <expr><name>SVFOP_CURRENT_USER</name></expr>:</case>
		<case>case <expr><name>SVFOP_USER</name></expr>:</case>
		<case>case <expr><name>SVFOP_SESSION_USER</name></expr>:</case>
		<case>case <expr><name>SVFOP_CURRENT_CATALOG</name></expr>:</case>
		<case>case <expr><name>SVFOP_CURRENT_SCHEMA</name></expr>:</case>
			<expr_stmt><expr><name><name>svf</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NAMEOID</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>svf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformXmlExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>XmlExpr</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>newx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name> <operator>&amp;&amp;</operator> <name><name>x</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_DOCUMENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_IS</name></expr></argument>, <argument><expr><literal type="string">"IS"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>x</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newx</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>op</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name><name>x</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>xmloption</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>xmloption</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>XMLOID</name></expr>;</expr_stmt>		<comment type="block">/* this just marks the node as transformed */</comment>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>x</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * gram.y built the named args as a list of ResTarget.  Transform each,
	 * and break the names out as a separate list.
	 */</comment>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>named_args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>arg_names</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>x-&gt;named_args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResTarget</name>  <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>ResTarget</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argname</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>argname</name> <operator>=</operator> <call><name>map_sql_identifier_to_xml_name</name><argument_list>(<argument><expr><call><name>FigureColname</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <ternary><condition><expr><name><name>x</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLELEMENT</name></expr>
					 ?</condition><then> <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed XML attribute value must be a column reference"</literal></expr></argument>)</argument_list></call></expr>
					 </then><else>: <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unnamed XML element value must be a column reference"</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>argname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* reject duplicate argnames in XMLELEMENT only */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_XMLELEMENT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>newx-&gt;arg_names</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>argname</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"XML attribute name \"%s\" appears more than once"</literal></expr></argument>,
									<argument><expr><name>argname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>r</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>named_args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newx</name><operator>-&gt;</operator><name>named_args</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>arg_names</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newx</name><operator>-&gt;</operator><name>arg_names</name></name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>argname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* The other arguments are of varying types depending on the function */</comment>
	<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>x-&gt;args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>e</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newe</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>op</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>IS_XMLCONCAT</name></expr>:</case>
				<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>XMLOID</name></expr></argument>,
											   <argument><expr><literal type="string">"XMLCONCAT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_XMLELEMENT</name></expr>:</case>
				<comment type="block">/* no coercion necessary */</comment>
				<break>break;</break>
			<case>case <expr><name>IS_XMLFOREST</name></expr>:</case>
				<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>XMLOID</name></expr></argument>,
											   <argument><expr><literal type="string">"XMLFOREST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_XMLPARSE</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
												   <argument><expr><literal type="string">"XMLPARSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><literal type="string">"XMLPARSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_XMLPI</name></expr>:</case>
				<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
											   <argument><expr><literal type="string">"XMLPI"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_XMLROOT</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>XMLOID</name></expr></argument>,
												   <argument><expr><literal type="string">"XMLROOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>,
												   <argument><expr><literal type="string">"XMLROOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>,
												   <argument><expr><literal type="string">"XMLROOT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_XMLSERIALIZE</name></expr>:</case>
				<comment type="block">/* not handled here */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_DOCUMENT</name></expr>:</case>
				<expr_stmt><expr><name>newe</name> <operator>=</operator> <call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>newe</name></expr></argument>, <argument><expr><name>XMLOID</name></expr></argument>,
											   <argument><expr><literal type="string">"IS DOCUMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><name><name>newx</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>newx</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>newe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newx</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformXmlSerialize</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>XmlSerialize</name> <modifier>*</modifier></type><name>xs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>xexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targetType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>targetTypmod</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xexpr</name><operator>-&gt;</operator><name>op</name></name> <operator>=</operator> <name>IS_XMLSERIALIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>coerce_to_specific_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
													 <argument><expr><call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><name>XMLOID</name></expr></argument>,
													 <argument><expr><literal type="string">"XMLSERIALIZE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>xs</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>xexpr</name><operator>-&gt;</operator><name>xmloption</name></name> <operator>=</operator> <name><name>xs</name><operator>-&gt;</operator><name>xmloption</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>xs</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<comment type="block">/* We actually only need these to be able to parse back the expression. */</comment>
	<expr_stmt><expr><name><name>xexpr</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>targetType</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>xexpr</name><operator>-&gt;</operator><name>typmod</name></name> <operator>=</operator> <name>targetTypmod</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The actual target type is determined this way.  SQL allows char and
	 * varchar as target types.  We allow anything that can be cast implicitly
	 * from text.  This way, user-defined text-like data types automatically
	 * fit in.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>xexpr</name></expr></argument>,
								   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>targetTypmod</name></expr></argument>,
								   <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
								   <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast XMLSERIALIZE result to %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>xexpr</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformBooleanTest</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>BooleanTest</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>clausename</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_precedence_warning</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>emit_precedence_warnings</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>PREC_GROUP_POSTFIX_IS</name></expr></argument>, <argument><expr><literal type="string">"IS"</literal></expr></argument>,
								 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
								 <argument><expr><name><name>b</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>booltesttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>IS_TRUE</name></expr>:</case>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <literal type="string">"IS TRUE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <literal type="string">"IS NOT TRUE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IS_FALSE</name></expr>:</case>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <literal type="string">"IS FALSE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <literal type="string">"IS NOT FALSE"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <literal type="string">"IS UNKNOWN"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <literal type="string">"IS NOT UNKNOWN"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>booltesttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>clausename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>b</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,
										<argument><expr><name>clausename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>b</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CurrentOfExpr</name> <modifier>*</modifier></type><name>cexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>

	<comment type="block">/* CURRENT OF can only appear at top level of UPDATE/DELETE */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cvarno</name></name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_target_rangetblentry</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sublevels_up</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to see if the cursor name matches a parameter of type REFCURSOR.
	 * If so, replace the raw name reference with a parameter reference. (This
	 * is a hack for the convenience of plpgsql.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <comment type="block">/* in case already transformed */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ColumnRef</name>  <modifier>*</modifier></type><name>cref</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>ColumnRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Build an unqualified ColumnRef with the given name */</comment>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/* See if there is a translation available from a parser hook */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * XXX Should we throw an error if we get a translation that isn't a
		 * refcursor Param?  For now it seems best to silently ignore false
		 * matches.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXTERN</name> <operator>&amp;&amp;</operator>
				<name><name>p</name><operator>-&gt;</operator><name>paramtype</name></name> <operator>==</operator> <name>REFCURSOROID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Matches, so convert CURRENT OF to a param reference */</comment>
				<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cexpr</name><operator>-&gt;</operator><name>cursor_param</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>paramid</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a whole-row reference to represent the notation "relation.*".
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformWholeRowRef</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>vnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sublevels_up</name></decl>;</decl_stmt>

	<comment type="block">/* Find the RTE's rangetable location */</comment>
	<expr_stmt><expr><name>vnum</name> <operator>=</operator> <call><name>RTERangeTablePosn</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sublevels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build the appropriate referencing node.  Note that if the RTE is a
	 * function returning scalar, we create just a plain reference to the
	 * function value, not a composite containing a single column.  This is
	 * pretty inconsistent at first sight, but it's what we've done
	 * historically.  One argument for it is that "rel" and "rel.*" mean the
	 * same thing for composite relations, so why not for scalar functions...
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>vnum</name></expr></argument>, <argument><expr><name>sublevels_up</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* location is not filled in by makeWholeRowVar */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<comment type="block">/* mark relation as requiring whole-row SELECT access */</comment>
	<expr_stmt><expr><call><name>markVarForSelectPriv</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle an explicit CAST construct.
 *
 * Transform the argument, look up the type name, and apply any necessary
 * coercion function(s).
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformTypeCast</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>TypeCast</name> <modifier>*</modifier></type><name>tc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>targetType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>targetTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>location</name></decl>;</decl_stmt>

	<comment type="block">/* Look up the type name first */</comment>
	<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>tc</name><operator>-&gt;</operator><name>typeName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look through any AEXPR_PAREN nodes that may have been inserted thanks
	 * to operator_precedence_warning.  Otherwise, ARRAY[]::foo[] behaves
	 * differently from (ARRAY[])::foo[].
	 */</comment>
	<while>while <condition>(<expr><name>arg</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>kind</name> <operator>==</operator> <name>AEXPR_PAREN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>arg</name><operator>)</operator><operator>-&gt;</operator><name>lexpr</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * If the subject of the typecast is an ARRAY[] construct and the target
	 * type is an array type, we invoke transformArrayExpr() directly so that
	 * we can pass down the type information.  This avoids some cases where
	 * transformArrayExpr() might not infer the correct type.  Otherwise, just
	 * transform the argument normally.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>A_ArrayExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>targetBaseType</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>targetBaseTypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>elementType</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If target is a domain over array, work with the base array type
		 * here.  Below, we'll cast the array type to the domain.  In the
		 * usual case that the target is not a domain, the remaining steps
		 * will be a no-op.
		 */</comment>
		<expr_stmt><expr><name>targetBaseTypmod</name> <operator>=</operator> <name>targetTypmod</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>targetBaseType</name> <operator>=</operator> <call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>targetBaseTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elementType</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>targetBaseType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>elementType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformArrayExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>A_ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>,
									  <argument><expr><name>targetBaseType</name></expr></argument>,
									  <argument><expr><name>elementType</name></expr></argument>,
									  <argument><expr><name>targetBaseTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>inputType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>inputType</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>expr</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* do nothing if NULL input */</comment>

	<comment type="block">/*
	 * Location of the coercion is preferentially the location of the :: or
	 * CAST symbol, but if there is none then use the location of the type
	 * name (this can happen in TypeName 'string' syntax, for instance).
	 */</comment>
	<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>location</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>typeName</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>inputType</name></expr></argument>,
								   <argument><expr><name>targetType</name></expr></argument>, <argument><expr><name>targetTypmod</name></expr></argument>,
								   <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
								   <argument><expr><name>COERCE_EXPLICIT_CAST</name></expr></argument>,
								   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANNOT_COERCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot cast type %s to %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>inputType</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>targetType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_coercion_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Handle an explicit COLLATE clause.
 *
 * Transform the argument, and look up the collation name.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>transformCollateClause</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>CollateClause</name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CollateExpr</name> <modifier>*</modifier></type><name>newc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CollateExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>argtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>newc</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The unknown type is not collatable, but coerce_type() takes care of it
	 * separately, so we'll let it go here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>type_is_collatable</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>argtype</name> <operator>!=</operator> <name>UNKNOWNOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collations are not supported by type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>collOid</name></name> <operator>=</operator> <call><name>LookupCollation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newc</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a "row compare-op row" construct
 *
 * The inputs are lists of already-transformed expressions.
 * As with coerce_type, pstate may be NULL if no special unknown-Param
 * processing is wanted.
 *
 * The output may be a single OpExpr, an AND or OR combination of OpExprs,
 * or a RowCompareExpr.  In all cases it is guaranteed to return boolean.
 * The AND, OR, and RowCompareExpr cases further imply things about the
 * behavior of the operators (ie, they behave as =, &lt;&gt;, or &lt; &lt;= &gt; &gt;=).
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_row_comparison_op</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
					   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>largs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rargs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rcexpr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowCompareType</name></type> <name>rctype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfamilies</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>opinfo_lists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>strats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nopers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nopers</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nopers</name> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unequal number of entries in row expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't compare zero-length rows because there is no principled basis
	 * for figuring out what the operator is.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nopers</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot compare rows of zero length"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Identify all the pairwise operators, using make_op so that behavior is
	 * the same as in the simple scalar case.
	 */</comment>
	<expr_stmt><expr><name>opexprs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>largs</argument>, <argument>r</argument>, <argument>rargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>larg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>cmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>, <argument><expr><call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>larg</name></expr></argument>, <argument><expr><name>rarg</name></expr></argument>,
									   <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We don't use coerce_to_boolean here because we insist on the
		 * operator yielding boolean directly, not via coercion.  If it
		 * doesn't yield bool it won't be in any index opfamilies...
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cmp</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row comparison operator must yield type boolean, "</literal>
							<literal type="string">"not type %s"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>cmp</name><operator>-&gt;</operator><name>opresulttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>expression_returns_set</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>cmp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"row comparison operator must not return a set"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>opexprs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>opexprs</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If rows are length 1, just return the single operator.  In this case we
	 * don't insist on identifying btree semantics for the operator (but we
	 * still require it to return boolean).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nopers</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>opexprs</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now we must determine which row comparison semantics (= &lt;&gt; &lt; &lt;= &gt; &gt;=)
	 * apply to this set of operators.  We look for btree opfamilies
	 * containing the operators, and see which interpretations (strategy
	 * numbers) exist for each operator.
	 */</comment>
	<expr_stmt><expr><name>opinfo_lists</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nopers</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>strats</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>opexprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name> <init>= <expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>this_strats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>opinfo_lists</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_op_btree_interpretation</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * convert strategy numbers into a Bitmapset to make the intersection
		 * calculation easy.
		 */</comment>
		<expr_stmt><expr><name>this_strats</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>opinfo_lists[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>opinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>this_strats</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>this_strats</name></expr></argument>, <argument><expr><name><name>opinfo</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>strats</name> <operator>=</operator> <name>this_strats</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>strats</name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name>strats</name></expr></argument>, <argument><expr><name>this_strats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If there are multiple common interpretations, we may use any one of
	 * them ... this coding arbitrarily picks the lowest btree strategy
	 * number.
	 */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>bms_first_member</name><argument_list>(<argument><expr><name>strats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No common interpretation, so fail */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine interpretation of row comparison operator %s"</literal></expr></argument>,
						<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Row comparison operators must be associated with btree operator families."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rctype</name> <operator>=</operator> <operator>(</operator><name>RowCompareType</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For = and &lt;&gt; cases, we just combine the pairwise operators with AND or
	 * OR respectively.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rctype</name> <operator>==</operator> <name>ROWCOMPARE_EQ</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>AND_EXPR</name></expr></argument>, <argument><expr><name>opexprs</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rctype</name> <operator>==</operator> <name>ROWCOMPARE_NE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>, <argument><expr><name>opexprs</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise we need to choose exactly which opfamily to associate with
	 * each operator.
	 */</comment>
	<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nopers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>j</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>j</argument>, <argument>opinfo_lists[i]</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>opinfo</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>opinfo</name><operator>-&gt;</operator><name>strategy</name></name> <operator>==</operator> <name>rctype</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>opinfo</name><operator>-&gt;</operator><name>opfamily_id</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>opfamilies</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine interpretation of row comparison operator %s"</literal></expr></argument>,
							<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name>opname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are multiple equally-plausible candidates."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now deconstruct the OpExprs and create a RowCompareExpr.
	 *
	 * Note: can't just reuse the passed largs/rargs lists, because of
	 * possibility that make_op inserted coercion operations.
	 */</comment>
	<expr_stmt><expr><name>opnos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>largs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rargs</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>opexprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>cmp</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>opnos</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opnos</name></expr></argument>, <argument><expr><name><name>cmp</name><operator>-&gt;</operator><name>opno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>largs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>largs</name></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>cmp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rargs</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>, <argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>cmp</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>rcexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rctype</name></name> <operator>=</operator> <name>rctype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opnos</name></name> <operator>=</operator> <name>opnos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>opfamilies</name></name> <operator>=</operator> <name>opfamilies</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>inputcollids</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt> <comment type="block">/* assign_expr_collations will fix this */</comment>
	<expr_stmt><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>largs</name></name> <operator>=</operator> <name>largs</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rcexpr</name><operator>-&gt;</operator><name>rargs</name></name> <operator>=</operator> <name>rargs</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>rcexpr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Transform a "row IS DISTINCT FROM row" construct
 *
 * The input RowExprs are already transformed
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_row_distinct_op</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
					 <parameter><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>lrow</name></decl></parameter>, <parameter><decl><type><name>RowExpr</name> <modifier>*</modifier></type><name>rrow</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>largs</name> <init>= <expr><name><name>lrow</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rargs</name> <init>= <expr><name><name>rrow</name><operator>-&gt;</operator><name>args</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unequal number of entries in row expressions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>forboth</name><argument_list>(<argument>l</argument>, <argument>largs</argument>, <argument>r</argument>, <argument>rargs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>larg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rarg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>cmp</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>make_distinct_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>larg</name></expr></argument>, <argument><expr><name>rarg</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>cmp</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBoolExpr</name><argument_list>(<argument><expr><name>OR_EXPR</name></expr></argument>,
										   <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cmp</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* zero-length rows?  Generate constant FALSE */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeBoolConst</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * make the node for an IS DISTINCT FROM operator
 */</comment>
<function><type><specifier>static</specifier> <name>Expr</name> <modifier>*</modifier></type>
<name>make_distinct_op</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>ltree</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rtree</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>make_op</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>opname</name></expr></argument>, <argument><expr><name>ltree</name></expr></argument>, <argument><expr><name>rtree</name></expr></argument>,
					 <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_last_srf</name></name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>result</name><operator>)</operator><operator>-&gt;</operator><name>opresulttype</name> <operator>!=</operator> <name>BOOLOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"IS DISTINCT FROM requires = operator to yield boolean"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>result</name><operator>)</operator><operator>-&gt;</operator><name>opretset</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is name of a SQL construct, eg NULLIF */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s must not return a set"</literal></expr></argument>, <argument><expr><literal type="string">"IS DISTINCT FROM"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We rely on DistinctExpr and OpExpr being same struct
	 */</comment>
	<expr_stmt><expr><call><name>NodeSetTag</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>T_DistinctExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Produce a NullTest node from an IS [NOT] DISTINCT FROM NULL construct
 *
 * "arg" is the untransformed other argument
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_nulltest_from_distinct</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>A_Expr</name> <modifier>*</modifier></type><name>distincta</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>transformExprRecurse</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* the argument can be any type, so don't coerce it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>distincta</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_NOT_DISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>=</operator> <name>IS_NOT_NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/* argisrow = false is correct whether or not arg is composite */</comment>
	<expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>argisrow</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nt</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>distincta</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Identify node's group for operator precedence warnings
 *
 * For items in nonzero groups, also return a suitable node name into *nodename
 *
 * Note: group zero is used for nodes that are higher or lower precedence
 * than everything that changed precedence; we need never issue warnings
 * related to such nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>operator_precedence_group</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>group</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>A_Expr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>A_Expr</name>	   <modifier>*</modifier></type><name>aexpr</name> <init>= <expr><operator>(</operator><name>A_Expr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OP</name> <operator>&amp;&amp;</operator>
			<name><name>aexpr</name><operator>-&gt;</operator><name>lexpr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>aexpr</name><operator>-&gt;</operator><name>rexpr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* binary operator */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Ignore if op was always higher priority than IS-tests */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"%"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"&lt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_LESS</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_EQUAL</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"&lt;="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"&gt;="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
						 <call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_LESS_EQUAL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_INFIX_OP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* schema-qualified operator syntax */</comment>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"OPERATOR()"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_INFIX_OP</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OP</name> <operator>&amp;&amp;</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>lexpr</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>rexpr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* prefix operator */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Ignore if op was always higher priority than IS-tests */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
					<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name>nodename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_PREFIX_OP</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* schema-qualified operator syntax */</comment>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"OPERATOR()"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_PREFIX_OP</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OP</name> <operator>&amp;&amp;</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>lexpr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>rexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* postfix operator */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_OP</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* schema-qualified operator syntax */</comment>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"OPERATOR()"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_OP</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OP_ANY</name> <operator>||</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OP_ALL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_OP</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_DISTINCT</name> <operator>||</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_NOT_DISTINCT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_INFIX_IS</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_OF</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_IS</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_IN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IN"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_IN</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_NOT_IN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_LIKE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"LIKE"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"~~"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_LIKE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_NOT_LIKE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_ILIKE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"ILIKE"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"~~*"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_LIKE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_NOT_LIKE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_SIMILAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"SIMILAR"</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"~"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_LIKE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_NOT_LIKE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_BETWEEN</name> <operator>||</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_BETWEEN_SYM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_BETWEEN</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_NOT_BETWEEN</name> <operator>||</operator>
				 <name><name>aexpr</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>AEXPR_NOT_BETWEEN_SYM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>aexpr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_NOT_BETWEEN</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BooleanTest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_IS</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>x</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_DOCUMENT</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_IS</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name> <operator>||</operator>
			<name><name>s</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ALL_SUBLINK</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>operName</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IN"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_IN</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>llast</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>operName</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_OP</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BoolExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Must dig into NOTs to see if it's IS NOT DOCUMENT or NOT IN.  This
		 * opens us to possibly misrecognizing, eg, NOT (x IS DOCUMENT) as a
		 * problematic construct.  We can tell the difference by checking
		 * whether the parse locations of the two nodes are identical.
		 *
		 * Note that when we are comparing the child node to its own children,
		 * we will not know that it was a NOT.  Fortunately, that doesn't
		 * matter for these cases.
		 */</comment>
		<decl_stmt><decl><type><name>BoolExpr</name>   <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>BoolExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>boolop</name></name> <operator>==</operator> <name>NOT_EXPR</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>child</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>XmlExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>XmlExpr</name>    <modifier>*</modifier></type><name>x</name> <init>= <expr><operator>(</operator><name>XmlExpr</name> <operator>*</operator><operator>)</operator> <name>child</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>x</name><operator>-&gt;</operator><name>op</name></name> <operator>==</operator> <name>IS_DOCUMENT</name> <operator>&amp;&amp;</operator>
					<name><name>x</name><operator>-&gt;</operator><name>location</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>location</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IS"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_POSTFIX_IS</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>child</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>subLinkType</name></name> <operator>==</operator> <name>ANY_SUBLINK</name> <operator>&amp;&amp;</operator> <name><name>s</name><operator>-&gt;</operator><name>operName</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
					<name><name>s</name><operator>-&gt;</operator><name>location</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>location</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>nodename</name> <operator>=</operator> <literal type="string">"IN"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>group</name> <operator>=</operator> <name>PREC_GROUP_NOT_IN</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>group</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * helper routine for delivering 9.4-to-9.5 operator precedence warnings
 *
 * opgroup/opname/location represent some parent node
 * lchild, rchild are its left and right children (either could be NULL)
 *
 * This should be called before transforming the child nodes, since if a
 * precedence-driven parsing change has occurred in a query that used to work,
 * it's quite possible that we'll get a semantic failure while analyzing the
 * child expression.  We want to produce the warning before that happens.
 * In any case, operator_precedence_group() expects untransformed input.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>emit_precedence_warnings</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>opgroup</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opname</name></decl></parameter>,
						 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>lchild</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rchild</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>cgroup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>copname</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>opgroup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Complain if left child, which should be same or higher precedence
	 * according to current rules, used to be lower precedence.
	 *
	 * Exception to precedence rules: if left child is IN or NOT IN or a
	 * postfix operator, the grouping is syntactically forced regardless of
	 * precedence.
	 */</comment>
	<expr_stmt><expr><name>cgroup</name> <operator>=</operator> <call><name>operator_precedence_group</name><argument_list>(<argument><expr><name>lchild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cgroup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>oldprecedence_l</name><index>[<expr><name>cgroup</name></expr>]</index></name> <operator>&lt;</operator> <name><name>oldprecedence_r</name><index>[<expr><name>opgroup</name></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name>cgroup</name> <operator>!=</operator> <name>PREC_GROUP_IN</name> <operator>&amp;&amp;</operator>
			<name>cgroup</name> <operator>!=</operator> <name>PREC_GROUP_NOT_IN</name> <operator>&amp;&amp;</operator>
			<name>cgroup</name> <operator>!=</operator> <name>PREC_GROUP_POSTFIX_OP</name> <operator>&amp;&amp;</operator>
			<name>cgroup</name> <operator>!=</operator> <name>PREC_GROUP_POSTFIX_IS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator precedence change: %s is now lower precedence than %s"</literal></expr></argument>,
							<argument><expr><name>opname</name></expr></argument>, <argument><expr><name>copname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Complain if right child, which should be higher precedence according to
	 * current rules, used to be same or lower precedence.
	 *
	 * Exception to precedence rules: if right child is a prefix operator, the
	 * grouping is syntactically forced regardless of precedence.
	 */</comment>
	<expr_stmt><expr><name>cgroup</name> <operator>=</operator> <call><name>operator_precedence_group</name><argument_list>(<argument><expr><name>rchild</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cgroup</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>oldprecedence_r</name><index>[<expr><name>cgroup</name></expr>]</index></name> <operator>&lt;=</operator> <name><name>oldprecedence_l</name><index>[<expr><name>opgroup</name></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name>cgroup</name> <operator>!=</operator> <name>PREC_GROUP_PREFIX_OP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"operator precedence change: %s is now lower precedence than %s"</literal></expr></argument>,
							<argument><expr><name>opname</name></expr></argument>, <argument><expr><name>copname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Produce a string identifying an expression by kind.
 *
 * Note: when practical, use a simple SQL keyword for the result.  If that
 * doesn't work well, check call sites to see whether custom error message
 * strings are required.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>ParseExprKindName</name><parameter_list>(<parameter><decl><type><name>ParseExprKind</name></type> <name>exprKind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>exprKind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EXPR_KIND_NONE</name></expr>:</case>
			<return>return <expr><literal type="string">"invalid expression context"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_OTHER</name></expr>:</case>
			<return>return <expr><literal type="string">"extension expression"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_JOIN_ON</name></expr>:</case>
			<return>return <expr><literal type="string">"JOIN/ON"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_JOIN_USING</name></expr>:</case>
			<return>return <expr><literal type="string">"JOIN/USING"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_FROM_SUBSELECT</name></expr>:</case>
			<return>return <expr><literal type="string">"sub-SELECT in FROM"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_FROM_FUNCTION</name></expr>:</case>
			<return>return <expr><literal type="string">"function in FROM"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_WHERE</name></expr>:</case>
			<return>return <expr><literal type="string">"WHERE"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_POLICY</name></expr>:</case>
			<return>return <expr><literal type="string">"POLICY"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_HAVING</name></expr>:</case>
			<return>return <expr><literal type="string">"HAVING"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_FILTER</name></expr>:</case>
			<return>return <expr><literal type="string">"FILTER"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_WINDOW_PARTITION</name></expr>:</case>
			<return>return <expr><literal type="string">"window PARTITION BY"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_WINDOW_ORDER</name></expr>:</case>
			<return>return <expr><literal type="string">"window ORDER BY"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_RANGE</name></expr>:</case>
			<return>return <expr><literal type="string">"window RANGE"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_ROWS</name></expr>:</case>
			<return>return <expr><literal type="string">"window ROWS"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_WINDOW_FRAME_GROUPS</name></expr>:</case>
			<return>return <expr><literal type="string">"window GROUPS"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_SELECT_TARGET</name></expr>:</case>
			<return>return <expr><literal type="string">"SELECT"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_INSERT_TARGET</name></expr>:</case>
			<return>return <expr><literal type="string">"INSERT"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_UPDATE_SOURCE</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_UPDATE_TARGET</name></expr>:</case>
			<return>return <expr><literal type="string">"UPDATE"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_GROUP_BY</name></expr>:</case>
			<return>return <expr><literal type="string">"GROUP BY"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_ORDER_BY</name></expr>:</case>
			<return>return <expr><literal type="string">"ORDER BY"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_DISTINCT_ON</name></expr>:</case>
			<return>return <expr><literal type="string">"DISTINCT ON"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_LIMIT</name></expr>:</case>
			<return>return <expr><literal type="string">"LIMIT"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_OFFSET</name></expr>:</case>
			<return>return <expr><literal type="string">"OFFSET"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_RETURNING</name></expr>:</case>
			<return>return <expr><literal type="string">"RETURNING"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_VALUES</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_VALUES_SINGLE</name></expr>:</case>
			<return>return <expr><literal type="string">"VALUES"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_CHECK_CONSTRAINT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_DOMAIN_CHECK</name></expr>:</case>
			<return>return <expr><literal type="string">"CHECK"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr>:</case>
		<case>case <expr><name>EXPR_KIND_FUNCTION_DEFAULT</name></expr>:</case>
			<return>return <expr><literal type="string">"DEFAULT"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_INDEX_EXPRESSION</name></expr>:</case>
			<return>return <expr><literal type="string">"index expression"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_INDEX_PREDICATE</name></expr>:</case>
			<return>return <expr><literal type="string">"index predicate"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_ALTER_COL_TRANSFORM</name></expr>:</case>
			<return>return <expr><literal type="string">"USING"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_EXECUTE_PARAMETER</name></expr>:</case>
			<return>return <expr><literal type="string">"EXECUTE"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_TRIGGER_WHEN</name></expr>:</case>
			<return>return <expr><literal type="string">"WHEN"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_PARTITION_EXPRESSION</name></expr>:</case>
			<return>return <expr><literal type="string">"PARTITION BY"</literal></expr>;</return>
		<case>case <expr><name>EXPR_KIND_CALL_ARGUMENT</name></expr>:</case>
			<return>return <expr><literal type="string">"CALL"</literal></expr>;</return>

			<comment type="block">/*
			 * There is intentionally no default: case here, so that the
			 * compiler will warn if we add a new ParseExprKind without
			 * extending this switch.  If we do see an unrecognized value at
			 * runtime, we'll fall through to the "unrecognized" return.
			 */</comment>
	</block_content>}</block></switch>
	<return>return <expr><literal type="string">"unrecognized expression kind"</literal></expr>;</return>
</block_content>}</block></function>
</unit>
