<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/px_mutate.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_mutate.c
 *	  Parallelize a PostgreSQL sequential plan tree.
 *
 * Portions Copyright (c) 2004-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	    src/backend/px/px_mutate.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/px_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/var.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>	<comment type="block">/* for rt_fetch() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>		<comment type="block">/* RelationGetPartitioningKey() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_llize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_mutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_plan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>

<comment type="block">/*
 * ApplyMotionState holds state for the recursive apply_motion_mutator().
 */</comment>
<typedef>typedef <type><struct>struct <name>ApplyMotionSubPlanState</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceDepth</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>parentFlow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>outerQueryFlow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_initplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useHashTable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>processed</name></decl>;</decl_stmt>

}</block></struct></type> <name>ApplyMotionSubPlanState</name>;</typedef>

<typedef>typedef <type><struct>struct <name>ApplyMotionState</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextMotionID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceDepth</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ApplyMotionSubPlanState</name> <modifier>*</modifier></type><name>subplans</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subplan_workingQueue</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>currentPlanFlow</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>outer_query_flow</name></decl>;</decl_stmt>
}</block></struct></type> <name>ApplyMotionState</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for
								 * plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>single_row_insert</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cursorPositions</name></decl>;</decl_stmt>
}</block></struct></type> <name>pre_dispatch_function_evaluation_context</name>;</typedef>

<comment type="block">/*
 * Forward Declarations
 */</comment>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>pre_dispatch_function_evaluation_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>replace_shareinput_targetlists_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<function_decl><type><name>Node</name><modifier>*</modifier></type> (<modifier>*</modifier><name>test_pre_dispatch_function_evaluation_mutator</name>)<parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
					<parameter><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list> <init>= <expr><name>pre_dispatch_function_evaluation_mutator</name></expr></init>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* --------------------------------------------------------------------
 *
 *	Static Helper routines
 * --------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Code that mutate the tree for share input
 *
 * After the planner, the plan is really a DAG.  SISCs will have valid
 * pointer to the underlying share.  However, other code (setrefs etc)
 * depends on the fact that the plan is a tree.  We first mutate the DAG
 * to a tree.
 *
 * Next, we will need to decide if the share is cross slices.  If the share
 * is not cross slice, we do not need the syncrhonization, and it is possible to
 * keep the Material/Sort in memory to save a sort.
 *
 * It is essential that we walk the tree in the same order as the ExecProcNode start
 * execution, otherwise, deadlock may rise.
 */</comment>

<comment type="block">/* Walk the tree for shareinput.
 * Shareinput fix shared_as_id and underlying_share_id of nodes in place.  We do not want to use
 * the ordinary tree walker as it is unnecessary to make copies etc.
 */</comment>
<typedef>typedef <function_decl><type><name>bool</name></type> (<modifier>*</modifier><name>SHAREINPUT_MUTATOR</name>) <parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>;</function_decl></typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_walker</name><parameter_list>(<parameter><decl><type><name>SHAREINPUT_MUTATOR</name></type> <name>f</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>recursive_down</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>l</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursive_down</name> <operator>=</operator> <call>(<modifier>*</modifier><name>f</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>recursive_down</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Append</name>	   <modifier>*</modifier></type><name>app</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>app-&gt;appendplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mt-&gt;plans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SubqueryScan</name>  <modifier>*</modifier></type><name>subqscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PlannerInfo</name>   <modifier>*</modifier></type><name>subroot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	      <modifier>*</modifier></type><name>save_rtable</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RelOptInfo</name>    <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If glob-&gt;finalrtable is not NULL, rtables have been flatten,
			 * thus we should use glob-&gt;finalrtable instead.
			 */</comment>
			<expr_stmt><expr><name>save_rtable</name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>subqscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/*
				 * The Assert() on RelOptInfo's subplan being same as the
				 * subqueryscan's subplan, is valid in Upstream but for not
				 * for PX, since we create a new copy of the subplan if two
				 */</comment>
				<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>subroot</name><operator>-&gt;</operator><name>parse</name><operator>-&gt;</operator><name>rtable</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>subroot</name> <operator>=</operator> <name>root</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>subqscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name>save_rtable</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>ba</name> <init>= <expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>ba-&gt;bitmapplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>bo</name> <init>= <expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>bo-&gt;bitmapplans</argument>)</argument_list></macro>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Nest loop join is strange.  Exec order depends on
			 * prefetch_inner
			 */</comment>
			<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>nl</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nl</name><operator>-&gt;</operator><name>join</name><operator>.</operator><name>prefetch_inner</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Hash join the hash table is at inner */</comment>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>mj</name> <init>= <expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>mj</name><operator>-&gt;</operator><name>unique_outer</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Sequence</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Sequence</name>   <modifier>*</modifier></type><name>sequence</name> <init>= <expr><operator>(</operator><name>Sequence</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>sequence-&gt;subplans</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>plan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call>(<modifier>*</modifier><name>f</name>) <argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a fake CTE range table entry that reflects the target list of a
 * shared input.
 */</comment>
<function><type><specifier>static</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type>
<name>create_shareinput_producer_rte</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>share_id</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>refno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>attno</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colnames</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>coltypmods</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>colcollations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>&gt;</operator> <name>share_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>subplan</name> <operator>=</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>subplan-&gt;targetlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>vartype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>vartypmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>varcollid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resname</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>vartype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>vartypmod</name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varcollid</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We should've filled in tle-&gt;resname in shareinput_save_producer().
		 * Note that it's too late to call get_tle_name() here, because this
		 * runs after all the varnos in Vars have already been changed to
		 * INNER_VAR/OUTER_VAR.
		 */</comment>
		<expr_stmt><expr><name>resname</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>resname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"unnamed_attr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>colnames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>, <argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>coltypmods</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>, <argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colcollations</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>, <argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a new RTE. Note that we use a different RTE for each reference,
	 * because we want to give each reference a different name.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"share%d_ref%d"</literal></expr></argument>, <argument><expr><name>share_id</name></expr></argument>, <argument><expr><name>refno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_CTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>alias</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name></name> <operator>=</operator> <call><name>makeAlias</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypes</name></name> <operator>=</operator> <name>coltypes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>coltypmods</name></name> <operator>=</operator> <name>coltypmods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>colcollations</name></name> <operator>=</operator> <name>colcollations</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inFromCl</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<return>return <expr><name>rte</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px begin */</comment>

<comment type="block">/*
 * Memorize the shared plan of a shared input in an array, one per share_id.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_save_producer</name><parameter_list>(<parameter><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>share_id</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>share_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_shared_input_count</name> <init>= <expr><operator>(</operator><name>share_id</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>share_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>new_shared_input_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>=</operator> <name>new_shared_input_count</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>&lt;</operator> <name>new_shared_input_count</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name></name></expr></argument>, <argument><expr><name>new_shared_input_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>new_shared_input_count</name> <operator>-</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>=</operator> <name>new_shared_input_count</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_plans</name><index>[<expr><name>share_id</name></expr>]</index></name> <operator>=</operator> <name><name>plan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Collect all the producer ShareInput nodes into an array, for later use by
 * replace_shareinput_targetlists().
 *
 * This is a stripped-down version of apply_shareinput_dag_to_tree(), for use
 * on PXOPT-produced plans. PXOPT assigns share_ids to all ShareInputScan nodes,
 * and only producer nodes have a subtree, so we don't need to do the DAG to
 * tree conversion or assign share_ids here.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>collect_shareinput_producers_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>siscan</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><name><name>siscan</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>siscan</name><operator>-&gt;</operator><name>share_id</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>subplan</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shareinput_save_producer</name><argument_list>(<argument><expr><name>siscan</name></expr></argument>, <argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>collect_shareinput_producers</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>share</name><operator>.</operator><name>curr_rtable</name></name> <operator>=</operator> <name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>collect_shareinput_producers_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Some helper: implements a stack using List. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_pushmot</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>motid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name> <operator>=</operator> <call><name>lcons_int</name><argument_list>(<argument><expr><name>motid</name></expr></argument>, <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shareinput_popmot</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>list_delete_first</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>shareinput_peekmot</name><parameter_list>(<parameter><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>linitial_int</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* POLAR px end */</comment>

<comment type="block">/*
 * Replace the target list of ShareInputScan nodes, with references
 * to CTEs that we build on the fly.
 *
 * Only one of the ShareInputScan nodes in a plan tree contains the real
 * child plan, while others contain just a "share id" that binds all the
 * ShareInputScan nodes sharing the same input together. The missing
 * child plan is a problem for EXPLAIN, as any OUTER Vars in the
 * ShareInputScan's target list cannot be resolved without the child
 * plan.
 *
 * To work around that issue, create a CTE for each shared input node, with
 * columns that match the target list of the SharedInputScan's subplan,
 * and replace the target list entries of the SharedInputScan with
 * Vars that point to the CTE instead of the child plan.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>replace_shareinput_targetlists</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>replace_shareinput_targetlists_walker</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>replace_shareinput_targetlists_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>share_id</name> <init>= <expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newtargetlist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Note that even though the planner assigns sequential share_ids for
		 * each shared node, so that share_id is always below
		 * list_length(ctxt-&gt;sharedNodes), PXOPT has a different assignment
		 * scheme. So we have to be prepared for any share_id, at least when
		 * PXOPT is in use.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>new_sz</name> <init>= <expr><name>share_id</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>new_sz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name> <operator>=</operator> <name>new_sz</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>share_id</name> <operator>&gt;=</operator> <name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>old_sz</name> <init>= <expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>new_sz</name> <init>= <expr><name>share_id</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name></name></expr></argument>, <argument><expr><name>new_sz</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name><index>[<expr><name>old_sz</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>new_sz</name> <operator>-</operator> <name>old_sz</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts_sz</name></name> <operator>=</operator> <name>new_sz</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name><index>[<expr><name>share_id</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Create a new RTE. Note that we use a different RTE for each
		 * reference, because we want to give each reference a different name.
		 */</comment>
		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>create_shareinput_producer_rte</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>share_id</name></expr></argument>,
											 <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>share_refcounts</name><index>[<expr><name>share_id</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>, <argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>glob</name><operator>-&gt;</operator><name>finalrtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Replace all the target list entries.
		 *
		 * SharedInputScan nodes are not projection-capable, so the target
		 * list of the SharedInputScan matches the subplan's target list.
		 */</comment>
		<expr_stmt><expr><name>newtargetlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sisc-&gt;scan.plan.targetlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>newtle</name> <init>= <expr><call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newtle</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>scanrelid</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>,
											<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprTypmod</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>exprCollation</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newtargetlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newtargetlist</name></expr></argument>, <argument><expr><name>newtle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>attno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>scan</name><operator>.</operator><name>plan</name><operator>.</operator><name>targetlist</name></name> <operator>=</operator> <name>newtargetlist</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px begin */</comment>

<comment type="block">/*
 * First walk on shareinput xslice. Collect information about the producer
 * and consumer slice IDs for each share. It also builds a list of shares
 * that should run in the QD.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shareinput_mutator_xslice_1</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>motId</name> <init>= <expr><call><name>shareinput_peekmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>shared</name> <init>= <expr><name><name>plan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>currentSlice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ApplyShareInputContextPerShare</name> <modifier>*</modifier></type><name>share_info</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>share_info</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name><index>[<expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>currentSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>motId</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name> <operator>||</operator>
			<name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name></expr></argument>, <argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Remember information about the slice that this instance appears in. */</comment>
		<if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name><index>[<expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr>]</index></name><operator>.</operator><name>producer_slice_id</name> <operator>=</operator> <name>motId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>share_info</name><operator>-&gt;</operator><name>participant_slices</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>share_info</name><operator>-&gt;</operator><name>participant_slices</name></name></expr></argument>, <argument><expr><name>motId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>this_slice_id</name></name> <operator>=</operator> <name>motId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Second pass:
 * 1. Mark shareinput scans with multiple consumer slices as cross-slice.
 * 2. Fill 'share_type' and 'share_id' fields in the shared Material/Sort nodes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shareinput_mutator_xslice_2</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>fPop</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>plan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>fPop</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>motionID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>plan</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sisc</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>motId</name> <init>= <expr><call><name>shareinput_peekmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ApplyShareInputContextPerShare</name> <modifier>*</modifier></type><name>pershare</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pershare</name> <operator>=</operator> <operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name><index>[<expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>pershare</name><operator>-&gt;</operator><name>participant_slices</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>cross_slice</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>producer_slice_id</name></name> <operator>=</operator> <name><name>pershare</name><operator>-&gt;</operator><name>producer_slice_id</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sisc</name><operator>-&gt;</operator><name>nconsumers</name></name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name><name>pershare</name><operator>-&gt;</operator><name>participant_slices</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this share needs to run in the QD, mark the slice accordingly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name><name>sisc</name><operator>-&gt;</operator><name>share_id</name></name></expr></argument>, <argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PlanSlice</name>  <modifier>*</modifier></type><name>currentSlice</name> <init>= <expr><operator>&amp;</operator><name><name>ctxt</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>motId</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>currentSlice</name><operator>-&gt;</operator><name>gangType</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
				<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
					<break>break;</break>
				<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
					currentSlice-&gt;gangType = GANGTYPE_ENTRYDB_READER;
					break;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
				<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot share ShareInputScan between QD and primary reader/write gang"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Scan through the plan tree and make note of which Share Input Scans
 * are cross-slice.
 */</comment>
<function><type><name>Plan</name> <modifier>*</modifier></type>
<name>apply_shareinput_xslice</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name></decl></parameter>, <parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerGlobal</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>glob</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ApplyShareInputContext</name> <modifier>*</modifier></type><name>ctxt</name> <init>= <expr><operator>&amp;</operator><name><name>glob</name><operator>-&gt;</operator><name>share</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>subplan_id</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the plan tree has only one slice, there cannot be any cross-slice
	 * Share Input Scans. They were all marked as cross_slice=false when they
	 * were created. Note that we won't set slice_ids on them correctly;
	 * the executor knows not to expect that when numSlices == 1.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>plan</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>motStack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>qdShares</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>slices</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>glob</name><operator>-&gt;</operator><name>slices</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_inputs</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>ctxt</name><operator>-&gt;</operator><name>shared_input_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ApplyShareInputContextPerShare</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Walk the tree.  See comment for each pass for what each pass will do.
	 * The context is used to carry information from one pass to another, as
	 * well as within a pass.
	 */</comment>

	<comment type="block">/*
	 * A subplan might have a SharedScan consumer while the SharedScan
	 * producer is in the main plan, or vice versa. So in the first pass, we
	 * walk through all plans and collect all producer subplans into the
	 * context, before processing the consumers.
	 */</comment>
	<expr_stmt><expr><name>subplan_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>=  <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slice_id</name> <init>= <expr><name><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>subplan_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_1</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subplan_id</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_1</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now walk the tree again, and process all the consumers. */</comment>
	<expr_stmt><expr><name>subplan_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>forboth</name><argument_list>(<argument>lp</argument>, <argument>glob-&gt;subplans</argument>, <argument>lr</argument>, <argument>glob-&gt;subroots</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>subroot</name> <init>=  <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slice_id</name> <init>= <expr><name><name>glob</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>subplan_id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>shareinput_pushmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_2</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>subplan</name></expr></argument>, <argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>shareinput_popmot</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>subplan_id</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>shareinput_walker</name><argument_list>(<argument><expr><name>shareinput_mutator_xslice_2</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>plan</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* POLAR px end */</comment>

<comment type="block">/*
 * Hash a list of const values with GPDB's hash function
 */</comment>
<function><type><name>int32</name></type>
<name>pxhash_const_list</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>plConsts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iSegments</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>hashfuncs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxHash</name>    <modifier>*</modifier></type><name>ppxhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>plConsts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ppxhash</name> <operator>=</operator> <call><name>makePxHash</name><argument_list>(<argument><expr><name>iSegments</name></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>plConsts</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hashfuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pxhashinit</name><argument_list>(<argument><expr><name>ppxhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>plConsts</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>plConsts</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>pconst</name> <init>= <expr><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pxhash</name><argument_list>(<argument><expr><name>ppxhash</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pconst</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>pconst</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><call><name>pxhashreduce</name><argument_list>(<argument><expr><name>ppxhash</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct an expression that checks whether the current worker is
 * 'workerid'.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>makePXWorkerIndexFilterExpr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>workerid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* 
	 * get px_workerid_funcid if it is InvalidOid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_workerid_funcid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_px_workerid_funcid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build an expression: polar_px_workerid() = &lt;workerid&gt; */</comment>
	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
		<call><name>make_opclause</name><argument_list>(<argument><expr><name>Int4EqualOperator</name></expr></argument>,
					  <argument><expr><name>BOOLOID</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* opretset */</comment>
					  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeFuncExpr</name><argument_list>(<argument><expr><name>px_workerid_funcid</name></expr></argument>,
											<argument><expr><name>INT4OID</name></expr></argument>,
											<argument><expr><name>NIL</name></expr></argument>,	<comment type="block">/* args */</comment>
											<argument><expr><name>InvalidOid</name></expr></argument>,
											<argument><expr><name>InvalidOid</name></expr></argument>,
											<argument><expr><name>COERCE_EXPLICIT_CALL</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
										 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,		<comment type="block">/* consttypmod */</comment>
										 <argument><expr><name>InvalidOid</name></expr></argument>, <comment type="block">/* constcollid */</comment>
										 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>,
										 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>workerid</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* constisnull */</comment>
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>,		<comment type="block">/* constbyval */</comment>
					  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* opcollid */</comment>
					  <argument><expr><name>InvalidOid</name></expr></argument>	<comment type="block">/* inputcollid */</comment>
			)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Evaluate functions to constants.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>exec_make_plan_constant</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannedStmt</name></name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_SRI</name></decl></parameter>,
						<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>cursorPositions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pre_dispatch_function_evaluation_context</name></type> <name>pcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>exec_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pcontext</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcontext</name><operator>.</operator><name>single_row_insert</name></name> <operator>=</operator> <name>is_SRI</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcontext</name><operator>.</operator><name>cursorPositions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pcontext</name><operator>.</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pre_dispatch_function_evaluation_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>cursorPositions</name> <operator>=</operator> <name><name>pcontext</name><operator>.</operator><name>cursorPositions</name></name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove subquery field in RTE's with subquery kind.
 */</comment>
<function><type><name>void</name></type>
<name>remove_subquery_in_RTEs</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>RTE_SUBQUERY</name> <operator>==</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>&amp;&amp;</operator> <name>NULL</name> <operator>!=</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Replace subquery with a dummy subquery.
			 *
			 * XXX: We could save a lot more memory by deep-freeing the many
			 * fields in the Query too. But I'm not sure which of them might
			 * be shared by other objects in the tree.
			 */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>list</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><call><name>remove_subquery_in_RTEs</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Let's evaluate all STABLE functions that have constant args before
 * dispatch, so we get a consistent view across PXs
 *
 * Also, if this is a single_row insert, let's evaluate nextval() and
 * currval() before dispatching
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>pre_dispatch_function_evaluation_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
										 <parameter><decl><type><name>pre_dispatch_function_evaluation_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_node</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Not replaceable, so just copy the Param (no need to recurse) */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>simple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_nonconst_input</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>funcform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprstate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>const_val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>const_is_null</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>resultTypLen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>resultTypByVal</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>func_tuple</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reduce constants in the FuncExpr's arguments. We know args is
		 * either NIL or a List node, so we can call expression_tree_mutator
		 * directly rather than recursing to self.
		 */</comment>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												<argument><expr><name>pre_dispatch_function_evaluation_mutator</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>FuncExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcvariadic</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcvariadic</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funcformat</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funcformat</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>funccollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>isGlobalFunc</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>isGlobalFunc</name></name></expr>;</expr_stmt>

		<comment type="block">/* newexpr-&gt;is_tablefunc = expr-&gt;is_tablefunc; */</comment>

		<comment type="block">/*
		 * Check for constant inputs
		 */</comment>
		<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>arg</argument>, <argument>args</argument>)</argument_list></macro>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>has_nonconst_input</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_nonconst_input</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>is_seq_func</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>tup_or_set</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>func_tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>funcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* can't handle set returning or row returning functions */</comment>
			<expr_stmt><expr><name>tup_or_set</name> <operator>=</operator> <operator>(</operator><name><name>funcform</name><operator>-&gt;</operator><name>proretset</name></name> <operator>||</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>funcform</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>func_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* can't handle it */</comment>
			<if_stmt><if>if <condition>(<expr><name>tup_or_set</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We haven't mutated this node, but we still return the
				 * mutated arguments.
				 *
				 * If we don't do this, we'll miss out on transforming
				 * function arguments which are themselves functions we need
				 * to mutated. For example, select foo(now()).
				 */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Here we want to mark any statement that is going to use a
			 * sequence as dirty.  Doing this means that the QC will flush the
			 * xlog which will also flush any xlog writes that the sequence
			 * server might do.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <name>F_NEXTVAL_OID</name> <operator>||</operator> <name>funcid</name> <operator>==</operator> <name>F_CURRVAL_OID</name> <operator>||</operator>
				<name>funcid</name> <operator>==</operator> <name>F_SETVAL_OID</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ExecutorMarkTransactionUsesSequences(); */</comment>
				<expr_stmt><expr><name>is_seq_func</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_IMMUTABLE</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>funcform</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>==</operator> <name>PROVOLATILE_STABLE</name></expr>)</condition><block type="pseudo"><block_content>
				 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>single_row_insert</name></name> <operator>&amp;&amp;</operator> <name>is_seq_func</name></expr>)</condition><block type="pseudo"><block_content>
				<empty_stmt>;</empty_stmt></block_content></block></if>				<comment type="block">/* Volatile, but special sequence function */</comment>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Ok, we have a function that is STABLE (or IMMUTABLE), with
			 * constant args. Let's try to evaluate it.
			 */</comment>

			<comment type="block">/*
			 * To use the executor, we need an EState.
			 */</comment>
			<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We can use the estate's working context to avoid memory leaks. */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_query_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Prepare expr for execution.
			 */</comment>
			<expr_stmt><expr><name>exprstate</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * And evaluate it.
			 *
			 * It is OK to use a default econtext because none of the
			 * ExecEvalExpr() code used in this situation will use econtext.
			 * That might seem fortuitous, but it's not so unreasonable --- a
			 * constant expression does not depend on context, by definition,
			 * n'est-ce pas?
			 */</comment>
			<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><name>exprstate</name></expr></argument>,
												  <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>const_is_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get info needed about result datatype */</comment>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Get back to outer memory context */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Must copy result out of sub-context used by expression eval */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>const_is_null</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>const_val</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>resultTypByVal</name></expr></argument>, <argument><expr><name>resultTypLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Release all the junk we just created */</comment>
			<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Make the constant result node.
			 */</comment>
			<expr_stmt><expr><name>simple</name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funcresulttype</name></name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>funccollid</name></name></expr></argument>,
										<argument><expr><name>resultTypLen</name></expr></argument>,
										<argument><expr><name>const_val</name></expr></argument>, <argument><expr><name>const_is_null</name></expr></argument>,
										<argument><expr><name>resultTypByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* successfully simplified it */</comment>
			<if_stmt><if>if <condition>(<expr><name>simple</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>simple</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The expression cannot be simplified any further, so build and
		 * return a replacement FuncExpr node using the possibly-simplified
		 * arguments.
		 */</comment>
		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Reduce constants in the OpExpr's arguments.  We know args is either
		 * NIL or a List node, so we can call expression_tree_mutator directly
		 * rather than recursing to self.
		 */</comment>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>expression_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>expr</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
												<argument><expr><name>pre_dispatch_function_evaluation_mutator</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Need to get OID of underlying function.	Okay to scribble on input
		 * to this extent.
		 */</comment>
		<expr_stmt><expr><call><name>set_opfuncid</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opno</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opfuncid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opresulttype</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opresulttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opretset</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opretset</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>opcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>opcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>inputcollid</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>args</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newexpr</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>location</name></name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>CurrentOfExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * updatable cursors
		 *
		 * During constant folding, we collect the current position of each
		 * cursor mentioned in the plan into a list, and dispatch them to the
		 * PXs.
		 *
		 * We should not get here if called from planner_make_plan_constant().
		 * That is only used for simple Result plans, which should not contain
		 * CURRENT OF expressions.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>estate</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CursorPosInfo</name> <modifier>*</modifier></type><name>cpos</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>cpos</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CursorPosInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* TODO */</comment>
			<comment type="block">/* getCurrentOf(expr, */</comment>
			<comment type="block">/* GetPerTupleExprContext(context-&gt;estate), */</comment>
			<comment type="block">/* expr-&gt;target_relid, */</comment>
			<comment type="block">/* &amp;cpos-&gt;ctid, */</comment>
			<comment type="block">/* &amp;cpos-&gt;_px_worker_id, */</comment>
			<comment type="block">/* &amp;cpos-&gt;table_oid, */</comment>
			<comment type="block">/* &amp;cpos-&gt;cursor_name); */</comment>

			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>cursorPositions</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>cursorPositions</name></name></expr></argument>, <argument><expr><name>cpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For any node type not handled above, we recurse using
	 * plan_tree_mutator, which will copy the node unchanged but try to
	 * simplify its arguments (if any) using this routine.
	 */</comment>
	<expr_stmt><expr><name>new_node</name> <operator>=</operator> <call><name>plan_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>,
								 <argument><expr><name>pre_dispatch_function_evaluation_mutator</name></expr></argument>,
								 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>new_node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Does the given expression contain Params that are passed down from
 * outer query?
 */</comment>
<function><type><name>bool</name></type>
<name>contains_outer_params</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name> <init>= <expr><operator>(</operator><name>Param</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>==</operator> <name>PARAM_EXEC</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Does this Param refer to a value that an outer query provides? */</comment>
			<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>parent_root</name></name></expr></init></decl>;</decl_stmt>

			<while>while <condition>(<expr><name>parent</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parent-&gt;plan_params</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PlannerParamItem</name> <modifier>*</modifier></type><name>ppi</name> <init>= <expr><operator>(</operator><name>PlannerParamItem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>ppi</name><operator>-&gt;</operator><name>paramId</name></name> <operator>==</operator> <name><name>param</name><operator>-&gt;</operator><name>paramid</name></name></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* abort the tree traversal and return
										 * true */</comment>
				</block_content>}</block>

				<expr_stmt><expr><name>parent</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>parent_root</name></name></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contains_outer_params</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
