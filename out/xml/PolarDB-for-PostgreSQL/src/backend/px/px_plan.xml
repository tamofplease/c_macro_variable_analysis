<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/px_plan.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_plan.c
 *	  Provides routines supporting plan tree manipulation.
 *
 * Portions Copyright (c) 2004-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	    src/backend/px/px_plan.c
 *
 * NOTES
 *	See src/backend/optimizer/util/clauses.c for background information
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/parsenodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/primnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_plan.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mutate_plan_fields</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>newplan</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>oldplan</name></decl></parameter>, <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mutate_join_fields</name><parameter_list>(<parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>newplan</name></decl></parameter>, <parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>oldplan</name></decl></parameter>, <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------------- *
 * Plan Tree Mutator Framework
 * ----------------------------------------------------------------------- *
 */</comment>

<comment type="block">/*--------------------
 * expression_tree_mutator() is designed to support routines that make a
 * modified copy of an expression tree, with some nodes being added,
 * removed, or replaced by new subtrees.  The original tree is (normally)
 * not changed.  Each recursion level is responsible for returning a copy of
 * (or appropriately modified substitute for) the subtree it is handed.
 * A mutator routine should look like this:
 *
 * Node * my_mutator (Node *node, my_struct *context)
 * {
 *		if (node == NULL)
 *			return NULL;
 *		// check for nodes that special work is required for, eg:
 *		if (IsA(node, Var))
 *		{
 *			... create and return modified copy of Var node
 *		}
 *		else if (IsA(node, ...))
 *		{
 *			... do special transformations of other node types
 *		}
 *		// for any node type not specially processed, do:
 *		return expression_tree_mutator(node, my_mutator, (void *) context);
 * }
 *
 * The "context" argument points to a struct that holds whatever context
 * information the mutator routine needs --- it can be used to return extra
 * data gathered by the mutator, too.  This argument is not touched by
 * expression_tree_mutator, but it is passed down to recursive sub-invocations
 * of my_mutator.  The tree walk is started from a setup routine that
 * fills in the appropriate context struct, calls my_mutator with the
 * top-level node of the tree, and does any required post-processing.
 *
 * Each level of recursion must return an appropriately modified Node.
 * If expression_tree_mutator() is called, it will make an exact copy
 * of the given Node, but invoke my_mutator() to copy the sub-node(s)
 * of that Node.  In this way, my_mutator() has full control over the
 * copying process but need not directly deal with expression trees
 * that it has no interest in.
 *
 * Just as for expression_tree_walker, the node types handled by
 * expression_tree_mutator include all those normally found in target lists
 * and qualifier clauses during the planning stage.
 *
 * expression_tree_mutator will handle SubLink nodes by recursing normally
 * into the "lefthand" arguments (which are expressions belonging to the outer
 * plan).  It will also call the mutator on the sub-Query node; however, when
 * expression_tree_mutator itself is called on a Query node, it does nothing
 * and returns the unmodified Query node.  The net effect is that unless the
 * mutator does something special at a Query node, sub-selects will not be
 * visited or modified; the original sub-select will be linked to by the new
 * SubLink node.  Mutators that want to descend into sub-selects will usually
 * do so by recognizing Query nodes and calling query_tree_mutator (below).
 *
 * expression_tree_mutator will handle a SubPlan node by recursing into
 * the "exprs" and "args" lists (which belong to the outer plan), but it
 * will simply copy the link to the inner plan, since that's typically what
 * expression tree mutators want.  A mutator that wants to modify the subplan
 * can force appropriate behavior by recognizing SubPlan expression nodes
 * and doing the right thing.
 *--------------------
 */</comment>

<function><type><name>Node</name> <modifier>*</modifier></type>
<name>plan_tree_mutator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
				  <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>recurse_into_subplans</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The mutator has already decided not to modify the current node, but we
	 * must call the mutator for any sub-nodes.
	 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLATCOPY</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>( (newnode) = makeNode(nodetype), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKFLATCOPY</name><parameter_list>(<parameter><type><name>newnode</name></type></parameter>, <parameter><type><name>node</name></type></parameter>, <parameter><type><name>nodetype</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>( AssertMacro(IsA((node), nodetype)), \
	  (newnode) = makeNode(nodetype), \
	  memcpy((newnode), (node), sizeof(nodetype)) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTATE</name><parameter_list>(<parameter><type><name>newfield</name></type></parameter>, <parameter><type><name>oldfield</name></type></parameter>, <parameter><type><name>fieldtype</name></type></parameter>)</parameter_list></cpp:macro>  \
		<cpp:value>( (newfield) = (fieldtype) mutator((Node *) (oldfield), context) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLANMUTATE</name><parameter_list>(<parameter><type><name>newplan</name></type></parameter>, <parameter><type><name>oldplan</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>mutate_plan_fields((Plan*)(newplan), (Plan*)(oldplan), mutator, context)</cpp:value></cpp:define>

<comment type="block">/* This is just like  PLANMUTATE because Scan adds only scalar fields. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCANMUTATE</name><parameter_list>(<parameter><type><name>newplan</name></type></parameter>, <parameter><type><name>oldplan</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>mutate_plan_fields((Plan*)(newplan), (Plan*)(oldplan), mutator, context)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JOINMUTATE</name><parameter_list>(<parameter><type><name>newplan</name></type></parameter>, <parameter><type><name>oldplan</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>mutate_join_fields((Join*)(newplan), (Join*)(oldplan), mutator, context)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYARRAY</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>,<parameter><type><name>src</name></type></parameter>,<parameter><type><name>lenfld</name></type></parameter>,<parameter><type><name>datfld</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		(dest)-&gt;lenfld = (src)-&gt;lenfld; \
		if ( (src)-&gt;lenfld &gt; 0  &amp;&amp; \
             (src)-&gt;datfld != NULL) \
		{ \
			Size _size = ((src)-&gt;lenfld*sizeof(*((src)-&gt;datfld))); \
			(dest)-&gt;datfld = palloc(_size); \
			memcpy((dest)-&gt;datfld, (src)-&gt;datfld, _size); \
		} \
		else \
		{ \
			(dest)-&gt;datfld = NULL; \
		} \
	} while (0)</cpp:value></cpp:define>



	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Plan nodes aren't handled by expression_tree_walker, so we need
			 * to do them here.
			 */</comment>
		<case>case <expr><name>T_Plan</name></expr>:</case>
			<comment type="block">/* Abstract: Should see only subclasses. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"abstract node type not allowed: T_Plan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Result</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Result</name>	   <modifier>*</modifier></type><name>newresult</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newresult</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>Result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newresult</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newresult</name><operator>-&gt;</operator><name>resconstantqual</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>resconstantqual</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newresult</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ProjectSet</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><operator>(</operator><name>ProjectSet</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ProjectSet</name> <modifier>*</modifier></type><name>newps</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newps</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>, <argument><expr><name>ProjectSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newps</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newps</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ModifyTable</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>mt</name> <init>= <expr><operator>(</operator><name>ModifyTable</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ModifyTable</name> <modifier>*</modifier></type><name>newmt</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newmt</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>, <argument><expr><name>ModifyTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newmt</name></expr></argument>, <argument><expr><name>mt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmt</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>plans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmt</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmt</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>onConflictWhere</name></name></expr></argument> , <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmt</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>withCheckOptionLists</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmt</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>, <argument><expr><name><name>mt</name><operator>-&gt;</operator><name>returningLists</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newmt</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_LockRows</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>lockrows</name> <init>= <expr><operator>(</operator><name>LockRows</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>LockRows</name>   <modifier>*</modifier></type><name>newlockrows</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newlockrows</name></expr></argument>, <argument><expr><name>lockrows</name></expr></argument>, <argument><expr><name>LockRows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newlockrows</name></expr></argument>, <argument><expr><name>lockrows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newlockrows</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Repeat</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Repeat</name>	   <modifier>*</modifier></type><name>repeat</name> <init>= <expr><operator>(</operator><name>Repeat</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Repeat</name>	   <modifier>*</modifier></type><name>newrepeat</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newrepeat</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>, <argument><expr><name>Repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newrepeat</name></expr></argument>, <argument><expr><name>repeat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newrepeat</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Append</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Append</name>	   <modifier>*</modifier></type><name>append</name> <init>= <expr><operator>(</operator><name>Append</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Append</name>	   <modifier>*</modifier></type><name>newappend</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newappend</name></expr></argument>, <argument><expr><name>append</name></expr></argument>, <argument><expr><name>Append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newappend</name></expr></argument>, <argument><expr><name>append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newappend</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>, <argument><expr><name><name>append</name><operator>-&gt;</operator><name>appendplans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newappend</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_MergeAppend</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>merge</name> <init>= <expr><operator>(</operator><name>MergeAppend</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MergeAppend</name> <modifier>*</modifier></type><name>newmerge</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newmerge</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name>MergeAppend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newmerge</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmerge</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>, <argument><expr><name><name>merge</name><operator>-&gt;</operator><name>mergeplans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newmerge</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>ru</name> <init>= <expr><operator>(</operator><name>RecursiveUnion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RecursiveUnion</name> <modifier>*</modifier></type><name>newru</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newru</name></expr></argument>, <argument><expr><name>ru</name></expr></argument>, <argument><expr><name>RecursiveUnion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newru</name></expr></argument>, <argument><expr><name>ru</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newru</name></expr>;</return>
			</block_content>}</block>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_Sequence</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Sequence</name>   <modifier>*</modifier></type><name>sequence</name> <init>= <expr><operator>(</operator><name>Sequence</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Sequence</name>   <modifier>*</modifier></type><name>newSequence</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newSequence</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>, <argument><expr><name>Sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newSequence</name></expr></argument>, <argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newSequence</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name><name>sequence</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newSequence</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PartitionSelector</name> <modifier>*</modifier></type><name>partsel</name> <init>= <expr><operator>(</operator><name>PartitionSelector</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PartitionSelector</name> <modifier>*</modifier></type><name>newPartsel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newPartsel</name></expr></argument>, <argument><expr><name>partsel</name></expr></argument>, <argument><expr><name>PartitionSelector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newPartsel</name></expr></argument>, <argument><expr><name>partsel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newPartsel</name></expr>;</return>
			</block_content>}</block>
			
		<case>case <expr><name>T_AssertOp</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>AssertOp</name>   <modifier>*</modifier></type><name>assert</name> <init>= <expr><operator>(</operator><name>AssertOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>AssertOp</name>   <modifier>*</modifier></type><name>newAssert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newAssert</name></expr></argument>, <argument><expr><name>assert</name></expr></argument>, <argument><expr><name>AssertOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newAssert</name></expr></argument>, <argument><expr><name>assert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newAssert</name></expr>;</return>
			</block_content>}</block>
		<comment type="block">/* POLAR end */</comment>

		<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>old</name> <init>= <expr><operator>(</operator><name>BitmapAnd</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BitmapAnd</name>  <modifier>*</modifier></type><name>mut</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>mut</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>BitmapAnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>mut</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>mut</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>mut</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapOr</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>old</name> <init>= <expr><operator>(</operator><name>BitmapOr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BitmapOr</name>   <modifier>*</modifier></type><name>mut</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>mut</name></expr></argument>, <argument><expr><name>old</name></expr></argument>, <argument><expr><name>BitmapOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>mut</name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>mut</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>bitmapplans</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>mut</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Scan</name></expr>:</case>
			<comment type="block">/* Abstract: Should see only subclasses. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"abstract node type not allowed: T_Scan"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_SampleScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>samplescan</name> <init>= <expr><operator>(</operator><name>SampleScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SampleScan</name> <modifier>*</modifier></type><name>newsamplescan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newsamplescan</name></expr></argument>, <argument><expr><name>samplescan</name></expr></argument>, <argument><expr><name>SampleScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newsamplescan</name></expr></argument>, <argument><expr><name>samplescan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newsamplescan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_CustomScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>cscan</name> <init>= <expr><operator>(</operator><name>CustomScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>CustomScan</name> <modifier>*</modifier></type><name>newcscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newcscan</name></expr></argument>, <argument><expr><name>cscan</name></expr></argument>, <argument><expr><name>CustomScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newcscan</name></expr></argument>, <argument><expr><name>cscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SeqScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SeqScan</name>    <modifier>*</modifier></type><name>seqscan</name> <init>= <expr><operator>(</operator><name>SeqScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SeqScan</name>    <modifier>*</modifier></type><name>newseqscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newseqscan</name></expr></argument>, <argument><expr><name>seqscan</name></expr></argument>, <argument><expr><name>SeqScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newseqscan</name></expr></argument>, <argument><expr><name>seqscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* A SeqScan is really just a Scan, so we're done. */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newseqscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>idxscan</name> <init>= <expr><operator>(</operator><name>IndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexScan</name>  <modifier>*</modifier></type><name>newidxscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newidxscan</name></expr></argument>, <argument><expr><name>idxscan</name></expr></argument>, <argument><expr><name>IndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newidxscan</name></expr></argument>, <argument><expr><name>idxscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newidxscan</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name><name>idxscan</name><operator>-&gt;</operator><name>indexid</name></name></expr>;</expr_stmt>
				<comment type="block">/* MUTATE(newidxscan-&gt;indexid, idxscan-&gt;indexid, List *); */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newidxscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name><name>idxscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newidxscan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name><name>idxscan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* indxorderdir  is  scalar */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newidxscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>idxonlyscan</name> <init>= <expr><operator>(</operator><name>IndexOnlyScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>IndexOnlyScan</name> <modifier>*</modifier></type><name>newidxonlyscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newidxonlyscan</name></expr></argument>, <argument><expr><name>idxonlyscan</name></expr></argument>, <argument><expr><name>IndexOnlyScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newidxonlyscan</name></expr></argument>, <argument><expr><name>idxonlyscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newidxonlyscan</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name><name>idxonlyscan</name><operator>-&gt;</operator><name>indexid</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * MUTATE(newidxonlyscan-&gt;indexid, idxonlyscan-&gt;indexid, List
				 * *);
				 */</comment>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newidxonlyscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name><name>idxonlyscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newidxonlyscan</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>, <argument><expr><name><name>idxonlyscan</name><operator>-&gt;</operator><name>indextlist</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* indxorderdir  is  scalar */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newidxonlyscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>idxscan</name> <init>= <expr><operator>(</operator><name>BitmapIndexScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BitmapIndexScan</name> <modifier>*</modifier></type><name>newidxscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newidxscan</name></expr></argument>, <argument><expr><name>idxscan</name></expr></argument>, <argument><expr><name>BitmapIndexScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newidxscan</name></expr></argument>, <argument><expr><name>idxscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newidxscan</name><operator>-&gt;</operator><name>indexid</name></name> <operator>=</operator> <name><name>idxscan</name><operator>-&gt;</operator><name>indexid</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newidxscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name><name>idxscan</name><operator>-&gt;</operator><name>indexqual</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newidxscan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name><name>idxscan</name><operator>-&gt;</operator><name>indexqualorig</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newidxscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>bmheapscan</name> <init>= <expr><operator>(</operator><name>BitmapHeapScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>BitmapHeapScan</name> <modifier>*</modifier></type><name>newbmheapscan</name></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newbmheapscan</name></expr></argument>, <argument><expr><name>bmheapscan</name></expr></argument>, <argument><expr><name>BitmapHeapScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newbmheapscan</name></expr></argument>, <argument><expr><name>bmheapscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newbmheapscan</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>, <argument><expr><name><name>bmheapscan</name><operator>-&gt;</operator><name>bitmapqualorig</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newbmheapscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TidScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>tidscan</name> <init>= <expr><operator>(</operator><name>TidScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TidScan</name>    <modifier>*</modifier></type><name>newtidscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newtidscan</name></expr></argument>, <argument><expr><name>tidscan</name></expr></argument>, <argument><expr><name>TidScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newtidscan</name></expr></argument>, <argument><expr><name>tidscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newtidscan</name><operator>-&gt;</operator><name>tidquals</name></name></expr></argument>, <argument><expr><name><name>tidscan</name><operator>-&gt;</operator><name>tidquals</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* isTarget is scalar. */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newtidscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>sqscan</name> <init>= <expr><operator>(</operator><name>SubqueryScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubqueryScan</name> <modifier>*</modifier></type><name>newsqscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newsqscan</name></expr></argument>, <argument><expr><name>sqscan</name></expr></argument>, <argument><expr><name>SubqueryScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newsqscan</name></expr></argument>, <argument><expr><name>sqscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newsqscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name><name>sqscan</name><operator>-&gt;</operator><name>subplan</name></name></expr></argument>, <argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newsqscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>fnscan</name> <init>= <expr><operator>(</operator><name>FunctionScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FunctionScan</name> <modifier>*</modifier></type><name>newfnscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newfnscan</name></expr></argument>, <argument><expr><name>fnscan</name></expr></argument>, <argument><expr><name>FunctionScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newfnscan</name></expr></argument>, <argument><expr><name>fnscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* A FunctionScan is really just a Scan, so we're done. */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newfnscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ValuesScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>scan</name> <init>= <expr><operator>(</operator><name>ValuesScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ValuesScan</name> <modifier>*</modifier></type><name>newscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newscan</name></expr></argument>, <argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ValuesScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newscan</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newscan</name></expr></argument>, <argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>wts</name> <init>= <expr><operator>(</operator><name>WorkTableScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WorkTableScan</name> <modifier>*</modifier></type><name>newwts</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newwts</name></expr></argument>, <argument><expr><name>wts</name></expr></argument>, <argument><expr><name>WorkTableScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newwts</name></expr></argument>, <argument><expr><name>wts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newwts</name></expr>;</return>
			</block_content>}</block>

		<case>case <expr><name>T_Join</name></expr>:</case>
			<comment type="block">/* Abstract: Should see only subclasses. */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"abstract node type not allowed: T_Join"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_NestLoop</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>loopscan</name> <init>= <expr><operator>(</operator><name>NestLoop</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>NestLoop</name>   <modifier>*</modifier></type><name>newloopscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newloopscan</name></expr></argument>, <argument><expr><name>loopscan</name></expr></argument>, <argument><expr><name>NestLoop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JOINMUTATE</name><argument_list>(<argument><expr><name>newloopscan</name></expr></argument>, <argument><expr><name>loopscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* A NestLoop is really just a Join. */</comment>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newloopscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_MergeJoin</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>merge</name> <init>= <expr><operator>(</operator><name>MergeJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>MergeJoin</name>  <modifier>*</modifier></type><name>newmerge</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newmerge</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>, <argument><expr><name>MergeJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JOINMUTATE</name><argument_list>(<argument><expr><name>newmerge</name></expr></argument>, <argument><expr><name>merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmerge</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>, <argument><expr><name><name>merge</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newmerge</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_HashJoin</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>hjoin</name> <init>= <expr><operator>(</operator><name>HashJoin</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>HashJoin</name>   <modifier>*</modifier></type><name>newhjoin</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newhjoin</name></expr></argument>, <argument><expr><name>hjoin</name></expr></argument>, <argument><expr><name>HashJoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>JOINMUTATE</name><argument_list>(<argument><expr><name>newhjoin</name></expr></argument>, <argument><expr><name>hjoin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newhjoin</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>, <argument><expr><name><name>hjoin</name><operator>-&gt;</operator><name>hashclauses</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newhjoin</name><operator>-&gt;</operator><name>hashqualclauses</name></name></expr></argument>, <argument><expr><name><name>hjoin</name><operator>-&gt;</operator><name>hashqualclauses</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newhjoin</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<comment type="block">/* POLAR px */</comment>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>sis</name> <init>= <expr><operator>(</operator><name>ShareInputScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ShareInputScan</name> <modifier>*</modifier></type><name>newsis</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newsis</name></expr></argument>, <argument><expr><name>sis</name></expr></argument>, <argument><expr><name>ShareInputScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newsis</name></expr></argument>, <argument><expr><name>sis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newsis</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Material</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>material</name> <init>= <expr><operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Material</name>   <modifier>*</modifier></type><name>newmaterial</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newmaterial</name></expr></argument>, <argument><expr><name>material</name></expr></argument>, <argument><expr><name>Material</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newmaterial</name></expr></argument>, <argument><expr><name>material</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newmaterial</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Sort</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>sort</name> <init>= <expr><operator>(</operator><name>Sort</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Sort</name>	   <modifier>*</modifier></type><name>newsort</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newsort</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>Sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newsort</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newsort</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>sortColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newsort</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newsort</name></expr></argument>, <argument><expr><name>sort</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newsort</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Agg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Agg</name>		   <modifier>*</modifier></type><name>newagg</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newagg</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>, <argument><expr><name>Agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newagg</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newagg</name></expr></argument>, <argument><expr><name>agg</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>grpColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newagg</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>tabfunc</name> <init>= <expr><operator>(</operator><name>TableFuncScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TableFuncScan</name> <modifier>*</modifier></type><name>newtabfunc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newtabfunc</name></expr></argument>, <argument><expr><name>tabfunc</name></expr></argument>, <argument><expr><name>TableFuncScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newtabfunc</name></expr></argument>, <argument><expr><name>tabfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newtabfunc</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>window</name> <init>= <expr><operator>(</operator><name>WindowAgg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>WindowAgg</name>  <modifier>*</modifier></type><name>newwindow</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newwindow</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>WindowAgg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newwindow</name></expr></argument>, <argument><expr><name>window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newwindow</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>partNumCols</name></expr></argument>, <argument><expr><name>partColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newwindow</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>partNumCols</name></expr></argument>, <argument><expr><name>partOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newwindow</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>ordNumCols</name></expr></argument>, <argument><expr><name>ordColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newwindow</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>ordNumCols</name></expr></argument>, <argument><expr><name>ordOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newwindow</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name><name>window</name><operator>-&gt;</operator><name>startOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newwindow</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name><name>window</name><operator>-&gt;</operator><name>endOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newwindow</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Unique</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Unique</name>	   <modifier>*</modifier></type><name>uniq</name> <init>= <expr><operator>(</operator><name>Unique</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Unique</name>	   <modifier>*</modifier></type><name>newuniq</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newuniq</name></expr></argument>, <argument><expr><name>uniq</name></expr></argument>, <argument><expr><name>Unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newuniq</name></expr></argument>, <argument><expr><name>uniq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newuniq</name></expr></argument>, <argument><expr><name>uniq</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>uniqColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newuniq</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Gather</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Gather</name>	   <modifier>*</modifier></type><name>gather</name> <init>= <expr><operator>(</operator><name>Gather</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Gather</name>	   <modifier>*</modifier></type><name>newgather</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newgather</name></expr></argument>, <argument><expr><name>gather</name></expr></argument>, <argument><expr><name>Gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newgather</name></expr></argument>, <argument><expr><name>gather</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newgather</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Hash</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>hash</name> <init>= <expr><operator>(</operator><name>Hash</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Hash</name>	   <modifier>*</modifier></type><name>newhash</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>, <argument><expr><name>Hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newhash</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newhash</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SetOp</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>setop</name> <init>= <expr><operator>(</operator><name>SetOp</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SetOp</name>	   <modifier>*</modifier></type><name>newsetop</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newsetop</name></expr></argument>, <argument><expr><name>setop</name></expr></argument>, <argument><expr><name>SetOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newsetop</name></expr></argument>, <argument><expr><name>setop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newsetop</name></expr></argument>, <argument><expr><name>setop</name></expr></argument>, <argument><expr><name>numCols</name></expr></argument>, <argument><expr><name>dupColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newsetop</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Limit</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Limit</name>	   <modifier>*</modifier></type><name>limit</name> <init>= <expr><operator>(</operator><name>Limit</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Limit</name>	   <modifier>*</modifier></type><name>newlimit</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newlimit</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>Limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newlimit</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newlimit</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name><name>limit</name><operator>-&gt;</operator><name>limitOffset</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newlimit</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name><name>limit</name><operator>-&gt;</operator><name>limitCount</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newlimit</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_Motion</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>motion</name> <init>= <expr><operator>(</operator><name>Motion</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Motion</name>	   <modifier>*</modifier></type><name>newmotion</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newmotion</name></expr></argument>, <argument><expr><name>motion</name></expr></argument>, <argument><expr><name>Motion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newmotion</name></expr></argument>, <argument><expr><name>motion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newmotion</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>, <argument><expr><name><name>motion</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newmotion</name></expr></argument>, <argument><expr><name>motion</name></expr></argument>, <argument><expr><name>numSortCols</name></expr></argument>, <argument><expr><name>sortColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newmotion</name></expr></argument>, <argument><expr><name>motion</name></expr></argument>, <argument><expr><name>numSortCols</name></expr></argument>, <argument><expr><name>sortOperators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>COPYARRAY</name><argument_list>(<argument><expr><name>newmotion</name></expr></argument>, <argument><expr><name>motion</name></expr></argument>, <argument><expr><name>numSortCols</name></expr></argument>, <argument><expr><name>nullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newmotion</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>


		<case>case <expr><name>T_Flow</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>flow</name> <init>= <expr><operator>(</operator><name>Flow</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Flow</name>	   <modifier>*</modifier></type><name>newflow</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newflow</name></expr></argument>, <argument><expr><name>flow</name></expr></argument>, <argument><expr><name>Flow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newflow</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_IntList</name></expr>:</case>
		<case>case <expr><name>T_OidList</name></expr>:</case>

			<comment type="block">/*
			 * Note that expression_tree_mutator handles T_List but not these.
			 * A shallow copy will do.
			 */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</return>

			<break>break;</break>

		<case>case <expr><name>T_Query</name></expr>:</case>

			<comment type="block">/*
			 * Since expression_tree_mutator doesn't descend into Query nodes,
			 * we use ...
			 */</comment>
			<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>query_tree_mutator</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>, <argument><expr><name>mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>

		<case>case <expr><name>T_SubPlan</name></expr>:</case>

			<comment type="block">/*
			 * Since expression_tree_mutator doesn't descend into the plan in
			 * a SubPlan node, we handle the case directly.
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>subplan</name> <init>= <expr><operator>(</operator><name>SubPlan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SubPlan</name>    <modifier>*</modifier></type><name>newnode</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>, <argument><expr><name>SubPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>testexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newnode</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>recurse_into_subplans</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>subplan_plan</name> <init>= <expr><call><name>plan_tree_base_subplan_get_plan</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Plan</name>	   <modifier>*</modifier></type><name>newsubplan_plan</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name>newsubplan_plan</name></expr></argument>, <argument><expr><name>subplan_plan</name></expr></argument>, <argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>newsubplan_plan</name> <operator>!=</operator> <name>subplan_plan</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>plan_tree_base_subplan_put_plan</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>newnode</name></expr></argument>, <argument><expr><name>newsubplan_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* An IntList isn't interesting to mutate; just copy. */</comment>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>paramIds</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>paramIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>setParam</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>setParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>parParam</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>parParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newnode</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>subplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newnode</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>

			<comment type="block">/*
			 * Also expression_tree_mutator doesn't recognize range table
			 * entries.
			 *
			 * TODO Figure out what's to do and handle this case. ***************************************************
			 *
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newrte</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newrte</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>RTE_RELATION</name></expr>:</case>	<comment type="block">/* ordinary relation reference */</comment>
					<case>case <expr><name>RTE_VOID</name></expr>:</case>	<comment type="block">/* deleted entry */</comment>
						<comment type="block">/* No extras. */</comment>
						<break>break;</break>

					<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>	<comment type="block">/* subquery in FROM */</comment>
						<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RTE_CTE</name></expr>:</case>
						<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>ctename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>ctelevelsup</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>ctelevelsup</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>self_reference</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>self_reference</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>ctecoltypes</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctecoltypes</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>ctecoltypmods</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>ctecoltypmods</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RTE_JOIN</name></expr>:</case>	<comment type="block">/* join */</comment>
						<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>	<comment type="block">/* functions in FROM */</comment>
						<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
						<expr_stmt><expr><name><name>newrte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>RTE_VALUES</name></expr>:</case>
						<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case> <comment type="block">/* FIXME */</comment>
					<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newrte</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>rtfunc</name> <init>= <expr><operator>(</operator><name>RangeTblFunction</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblFunction</name> <modifier>*</modifier></type><name>newrtfunc</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newrtfunc</name></expr></argument>, <argument><expr><name>rtfunc</name></expr></argument>, <argument><expr><name>RangeTblFunction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newrtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name><name>rtfunc</name><operator>-&gt;</operator><name>funcexpr</name></name></expr></argument>, <argument><expr><name>Node</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * TODO is this right? //newrte-&gt;coldeflist = (List *)
				 * copyObject(rte-&gt;coldeflist);
				 */</comment>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_ForeignScan</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>fdwscan</name> <init>= <expr><operator>(</operator><name>ForeignScan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>ForeignScan</name> <modifier>*</modifier></type><name>newfdwscan</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newfdwscan</name></expr></argument>, <argument><expr><name>fdwscan</name></expr></argument>, <argument><expr><name>ForeignScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SCANMUTATE</name><argument_list>(<argument><expr><name>newfdwscan</name></expr></argument>, <argument><expr><name>fdwscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newfdwscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>, <argument><expr><name><name>fdwscan</name><operator>-&gt;</operator><name>fdw_exprs</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Don't mutate fdw_private, it's private to the FDW. Must
				 * make a copy of it, though.
				 */</comment>
				<expr_stmt><expr><name><name>newfdwscan</name><operator>-&gt;</operator><name>fdw_private</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>fdwscan</name><operator>-&gt;</operator><name>fdw_private</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>newfdwscan</name><operator>-&gt;</operator><name>fsSystemCol</name></name> <operator>=</operator> <name><name>fdwscan</name><operator>-&gt;</operator><name>fsSystemCol</name></name></expr>;</expr_stmt>

				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newfdwscan</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>SplitUpdate</name> <modifier>*</modifier></type><name>splitUpdate</name> <init>= <expr><operator>(</operator><name>SplitUpdate</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>SplitUpdate</name> <modifier>*</modifier></type><name>newSplitUpdate</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>FLATCOPY</name><argument_list>(<argument><expr><name>newSplitUpdate</name></expr></argument>, <argument><expr><name>splitUpdate</name></expr></argument>, <argument><expr><name>SplitUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PLANMUTATE</name><argument_list>(<argument><expr><name>newSplitUpdate</name></expr></argument>, <argument><expr><name>splitUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newSplitUpdate</name></expr>;</return>
			</block_content>}</block>
			<break>break;</break>
			<comment type="block">/*
			 * The following cases are handled by expression_tree_mutator.	In
			 * addition, we let expression_tree_mutator handle unrecognized
			 * nodes.
			 *
			 * TODO: Identify node types that should never appear in plan
			 * trees and disallow them here by issuing an error or asserting
			 * false.
			 */</comment>
		<case>case <expr><name>T_Var</name></expr>:</case>
		<case>case <expr><name>T_Const</name></expr>:</case>
		<case>case <expr><name>T_Param</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
		<case>case <expr><name>T_CaseWhen</name></expr>:</case>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
		<case>case <expr><name>T_List</name></expr>:</case>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
		<case>case <expr><name>T_SpecialJoinInfo</name></expr>:</case>

		<default>default:</default>

			<comment type="block">/*
			 * Let expression_tree_mutator handle remaining cases or complain
			 * of unrecognized node type.
			 */</comment>
			<return>return <expr><call><name>expression_tree_mutator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
			<break>break;</break>
	</block_content>}</block></switch>
	<comment type="block">/* can't get here, but keep compiler happy */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Function mutate_plan_fields() is a subroutine for plan_tree_mutator().
 * It "hijacks" the macro MUTATE defined for use in that function, so don't
 * change the argument names "mutator" and "context" use in the macro
 * definition.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
			<name>mutate_plan_fields</name><parameter_list>(<parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>newplan</name></decl></parameter>, <parameter><decl><type><name>Plan</name> <modifier>*</modifier></type><name>oldplan</name></decl></parameter>, <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Scalar fields startup_cost total_cost plan_rows plan_width nParamExec
	 * need no mutation.
	 */</comment>

	<comment type="block">/* Node fields need mutation. */</comment>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>lefttree</name></name></expr></argument>, <argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>righttree</name></name></expr></argument>, <argument><expr><name>Plan</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newplan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>initPlan</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bitmapsets aren't nodes but need to be copied to palloc'd space. */</comment>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>extParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>extParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newplan</name><operator>-&gt;</operator><name>allParam</name></name> <operator>=</operator> <call><name>bms_copy</name><argument_list>(<argument><expr><name><name>oldplan</name><operator>-&gt;</operator><name>allParam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Function mutate_plan_fields() is a subroutine for plan_tree_mutator().
 * It "hijacks" the macro MUTATE defined for use in that function, so don't
 * change the argument names "mutator" and "context" use in the macro
 * definition.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
			<name>mutate_join_fields</name><parameter_list>(<parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>newjoin</name></decl></parameter>, <parameter><decl><type><name>Join</name> <modifier>*</modifier></type><name>oldjoin</name></decl></parameter>, <parameter><function_decl><type><name>Node</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>mutator</name>) <parameter_list>()</parameter_list></function_decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* A Join node is a Plan node. */</comment>
	<expr_stmt><expr><call><name>mutate_plan_fields</name><argument_list>(<argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>newjoin</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>oldjoin</name></expr></argument>, <argument><expr><name>mutator</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scalar field jointype needs no mutation. */</comment>

	<comment type="block">/* Node fields need mutation. */</comment>
	<expr_stmt><expr><call><name>MUTATE</name><argument_list>(<argument><expr><name><name>newjoin</name><operator>-&gt;</operator><name>joinqual</name></name></expr></argument>, <argument><expr><name><name>oldjoin</name><operator>-&gt;</operator><name>joinqual</name></name></expr></argument>, <argument><expr><name>List</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function></unit>
