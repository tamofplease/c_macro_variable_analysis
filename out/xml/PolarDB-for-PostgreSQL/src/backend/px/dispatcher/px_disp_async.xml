<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_disp_async.c">
<comment type="block">/*-------------------------------------------------------------------------
 *
 * px_disp_async.c
 *	  Functions for asynchronous implementation of dispatching
 *	  commands to PXxecutors.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * IDENTIFICATION
 *	  src/backend/px/dispatcher/px_disp_async.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/sequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>		<comment type="block">/* For proc_exit_inprogress  */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_pq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_TIMEOUT_MSEC</name></cpp:macro> <cpp:value>2000</cpp:value></cpp:define>

<comment type="block">/*
 * Ideally, we should set timeout to zero to cancel PXs as soon as possible,
 * but considering the cost of sending cancel signal is high, we want to process
 * as many finishing PXs as possible before cancelling
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_CANCEL_TIMEOUT_MSEC</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>pxdisp_makeDispatchParams_async</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxSlices</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>largestGangSize</name></decl></parameter>,
								 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxdisp_checkDispatchResult_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
								  <parameter><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxdisp_dispatchToGang_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							 <parameter><decl><type><name><name>struct</name> <name>Gang</name></name> <modifier>*</modifier></type><name>gp</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxdisp_waitDispatchFinish_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>pxdisp_checkForCancel_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pxdisp_getWaitSocketFd_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><name>DispatcherInternalFuncs</name></type> <name>DispatcherAsyncFuncs</name> <init>=
<expr><block>{
	<expr><name>pxdisp_checkForCancel_async</name></expr>,
	<expr><name>pxdisp_getWaitSocketFd_async</name></expr>,
	<expr><name>pxdisp_makeDispatchParams_async</name></expr>,
	<expr><name>pxdisp_checkDispatchResult_async</name></expr>,
	<expr><name>pxdisp_dispatchToGang_async</name></expr>,
	<expr><name>pxdisp_waitDispatchFinish_async</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dispatchCommand</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query_text</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>query_text_len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkDispatchResult</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>processResults</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>signalPXs</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>checkSegmentAlive</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>handlePollError</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>handlePollSuccess</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>fds</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type>
			<name>checkDispatchResult_thread</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Check dispatch result.
 * Don't wait all dispatch commands to complete.
 *
 * Return true if any connection received error.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pxdisp_checkForCancel_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxdisp_isDsThreadRuning</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_adps_dispatch_wait</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>pxdisp_checkResultsErrcode</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a FD to wait for, after dispatching.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pxdisp_getWaitSocketFd_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PGINVALID_SOCKET</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If libpq-thread, should not wait for socket any more */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pxdisp_isDsThreadRuning</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PGINVALID_SOCKET</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This should match the logic in pxdisp_checkForCancel_async(). In
	 * particular, when pxdisp_checkForCancel_async() is called, it must
	 * process any incoming data from the socket we return here, or we will
	 * busy wait.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Already finished with this PX?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></for>

	<return>return <expr><name>PGINVALID_SOCKET</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Block until all data are dispatched.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxdisp_waitDispatchFinish_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <specifier>static</specifier> <name>int</name></type> <name>DISPATCH_POLL_TIMEOUT</name> <init>= <expr><literal type="number">500</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>fds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nfds</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dispatchCount</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>fds</name> <operator>=</operator> <operator>(</operator>struct <name>pollfd</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>dispatchCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>pollRet</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>nfds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>fds</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dispatchCount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>dispatchCount</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>pxResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>pxResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_flush_nonblock"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>FAULT_INJECTOR_FLUSH_NONBLOCK_LABEL</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* skip already completed connections */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<label><name>FAULT_INJECTOR_FLUSH_NONBLOCK_LABEL</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * call send for this connection regardless of its POLLOUT status,
			 * because it may be writable NOW
			 */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqFlushNonBlocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_nonblock_zero"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_nonblock_over_zero"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_nonblock_less_zero"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>sock</name> <init>= <expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLOUT</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nfds</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>pxResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Command could not be dispatch to segment %s: %s"</literal></expr></argument>, <argument><expr><name><name>pxResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_poll_fd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>FAULT_INJECTOR_POLL_FD</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>nfds</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<label><name>FAULT_INJECTOR_POLL_FD</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* guarantee poll() is interruptible */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pollRet</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name>fds</name></expr></argument>, <argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>DISPATCH_POLL_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pollRet</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"pxdisp_waitDispatchFinish_async(): Dispatch poll timeout after %d ms"</literal></expr></argument>, <argument><expr><name>DISPATCH_POLL_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>pollRet</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pollRet</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>SOCK_ERRNO</name> <operator>==</operator> <name>EINTR</name> <operator>||</operator> <name>SOCK_ERRNO</name> <operator>==</operator> <name>EAGAIN</name><operator>)</operator><operator>)</operator></expr>)</condition>;</do>

		<if_stmt><if>if <condition>(<expr><name>pollRet</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Poll failed during dispatch"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dispatch command to gang.
 *
 * Throw out error to upper try-catch block if anything goes wrong. This function only kicks off dispatching,
 * call pxdisp_waitDispatchFinish_async to ensure the completion
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxdisp_dispatchToGang_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							 <parameter><decl><type><name><name>struct</name> <name>Gang</name></name> <modifier>*</modifier></type><name>gp</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>pParms</name> <operator>=</operator> <operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start the dispatching
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gp</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>pxResult</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>gp</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pxWorkerDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Initialize the PX's PxDispatchResult object.
		 */</comment>
		<expr_stmt><expr><name>pxResult</name> <operator>=</operator> <call><name>pxdisp_makeResult</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></argument>, <argument><expr><name>pxWorkerDesc</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pxResult</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not allocate resources for segworker communication"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>pxResult</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dispatchCommand</name><argument_list>(<argument><expr><name>pxResult</name></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text</name></name></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check dispatch result.
 *
 * Wait all dispatch work to complete, either success or fail.
 * (Set stillRunning to true when one dispatch work is completed)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxdisp_checkDispatchResult_async</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
								  <parameter><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ds</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pParms</name> <operator>=</operator> <operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr>;</expr_stmt>

	<comment type="block">/* pxdisp_destroyDispatcherState is called */</comment>
	<if_stmt><if>if <condition>(<expr><name>pParms</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't overwrite DISPATCH_WAIT_CANCEL or DISPATCH_WAIT_FINISH with
	 * DISPATCH_WAIT_NONE
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>waitMode</name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>waitMode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It looks like everything went fine, make sure we don't miss a user
	 * cancellation?
	 *
	 * The waitMode argument is NONE when we are doing "normal work".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>waitMode</name> <operator>==</operator> <name>DISPATCH_WAIT_NONE</name> <operator>||</operator> <name>waitMode</name> <operator>==</operator> <name>DISPATCH_WAIT_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocates memory for a PxDispatchCmdAsync structure and do the initialization.
 *
 * Memory will be freed in function pxdisp_destroyDispatcherState by deleting the
 * memory context.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>pxdisp_makeDispatchParams_async</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>maxSlices</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>largestGangSize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxResults</name> <init>= <expr><name>maxSlices</name> <operator>*</operator> <name>largestGangSize</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxDispatchCmdAsync</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <name>maxResults</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxDispatchResult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name></name> <operator>=</operator> <operator>(</operator><name>PxDispatchResult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>DISPATCH_WAIT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text</name></name> <operator>=</operator> <name>queryText</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>query_text_len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pParms</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive and process results from all running PXs.
 *
 * wait: true, wait until all dispatch works are completed.
 *       false, return immediate when there's no more data.
 *
 * Don't throw out error, instead, append the error message to
 * PxDispatchResult.error_message.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDispatchResult</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>meleeResults</name> <init>= <expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>db_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>sentSignal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>fds</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxdisp_isDsThreadRuning</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>checkDispatchResult_thread</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>wait</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>db_count</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fds</name> <operator>=</operator> <operator>(</operator>struct <name>pollfd</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>db_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * OK, we are finished submitting the command to the segdbs. Now, we have
	 * to wait for them to finish.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nfds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * bail-out if we are dying. Once QC dies, PX will recognize it
		 * shortly anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * escalate waitMode to cancel if: - user interrupt has occurred, - or
		 * an error has been reported by any PX, - in case the caller wants
		 * cancelOnError
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_PX_NEED_CANCELED</name><argument_list>()</argument_list></call> <operator>||</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>cancelOnError</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>DISPATCH_WAIT_CANCEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Which PXs are still running and could send results to us?
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>db_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Already finished with this PX?
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Flush out buffer in case some commands are not fully dispatched
			 * to PXs, this can prevent QC from polling on such PXs forever.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Don't error out here, let following poll() routine to
				 * handle it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Failed flushing outbound data to %s:%s"</literal></expr></argument>,
						 <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Add socket to fd_set if still connected.
			 */</comment>
			<expr_stmt><expr><name>sock</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nfds</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Break out when no PXs still running.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nfds</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Wait for results from PXs
		 *
		 * Don't wait if: - this is called from interconnect to check if
		 * there's any error.
		 *
		 * Lower the timeout if: - we need send signal to PXs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_NONE</name> <operator>||</operator> <name>sentSignal</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>DISPATCH_WAIT_TIMEOUT_MSEC</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>DISPATCH_WAIT_CANCEL_TIMEOUT_MSEC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name>fds</name></expr></argument>, <argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * poll returns with an error, including one due to an interrupted
		 * call
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_check_dispatch_no_result"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>sock_errno</name> <init>= <expr><name>SOCK_ERRNO</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>sock_errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"handlePollError poll() failed; errno=%d"</literal></expr></argument>, <argument><expr><name>sock_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>handlePollError</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Since an error was detected for the segment, request FTS to
			 * perform a probe before checking the segment state.
			 */</comment>
			<expr_stmt><expr><call><name>checkSegmentAlive</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>signalPXs</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sentSignal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* If the time limit expires, poll() returns 0 */</comment>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>signalPXs</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>sentSignal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* We have data waiting on one or more of the connections. */</comment>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>handlePollSuccess</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>, <argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function that actually kicks off the command on the libpq connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dispatchCommand</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
				<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>query_text</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>query_text_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>beforeSend</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>beforeSend</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Submit the command asynchronously.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQsendPxQuery_shared</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>query_text</name></expr></argument>,
						<argument><expr><name>query_text_len</name></expr></argument>,
						<argument><expr><name>px_enable_dispatch_async</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_dispatch_command_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Command could not be dispatch to segment %s: %s"</literal></expr></argument>,
						<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>beforeSend</name></expr></argument>, <argument><expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>secs</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>usecs</name> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* Time &gt; 1ms? */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"time for PQsendPxQuery_shared %ld.%06d"</literal></expr></argument>, <argument><expr><name>secs</name></expr></argument>, <argument><expr><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We'll keep monitoring this PX -- whether or not the command was
	 * dispatched -- in order to check for a lost connection or any other
	 * errors that libpq might have in store for us.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>hasDispatched</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"Command dispatched to PX (%s)"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function to checkDispatchResult that handles errors that occur
 * during the poll() call.
 *
 * NOTE: The cleanup of the connections will be performed by handlePollTimeout().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handlePollError</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>

		<comment type="block">/* Skip if already finished or didn't dispatch. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We're done with this PX, sadly. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"handle_poll_bad"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Dispatcher encountered connection error on %s: %s"</literal></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Dispatcher noticed bad connection in handlePollError()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save error info for later. */</comment>
			<expr_stmt><expr><call><name>pxdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
										   <argument><expr><literal type="string">"Error after dispatch from %s: %s"</literal></expr></argument>,
										   <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive and process results from PXs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handlePollSuccess</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>,
				  <parameter><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>fds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentFdNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We have data waiting on one or more of the connections.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>finished</name></decl>;</decl_stmt>
		<function_decl><type><name>int</name>			<name>sock</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list>;</function_decl>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip if already finished or didn't dispatch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"looking for results from %d of %d (%s)"</literal></expr></argument>,
							  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sock</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>==</operator> <name><name>fds</name><index>[<expr><name>currentFdNumber</name></expr>]</index></name><operator>.</operator><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Skip this connection if it has no input available.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fds</name><index>[<expr><name>currentFdNumber</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"PQsocket says there are results from %d of %d (%s)"</literal></expr></argument>,
							  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Receive and process results from this PX.
		 */</comment>
		<expr_stmt><expr><name>finished</name> <operator>=</operator> <call><name>processResults</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Are we through with this PX now?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>finished</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"processResults says we are finished with %d of %d (%s)"</literal></expr></argument>,
								  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

				<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="number">1</literal></expr>:</case>
					<case>case <expr><literal type="number">2</literal></expr>:</case>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"duration to dispatch result received from %d (seg %d): %s ms"</literal></expr></argument>,
							 <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>logicalWorkerInfo</name><operator>.</operator><name>idx</name></name></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"We thought we were done, because finished==true, but libpq says we are still busy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"processResults says we have more to do with %d of %d (%s)"</literal></expr></argument>,
								  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Send finish or cancel signal to PXs if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>signalPXs</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dispatchResult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't send the signal if - PX is finished or canceled - the signal
		 * was already sent - connection is dead
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>||</operator>
			<name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>||</operator>
			<call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>pxconn_signalPX</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>waitMode</name> <operator>==</operator> <name>DISPATCH_WAIT_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>=</operator> <name>waitMode</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Unable to cancel: %s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"cannot allocate PGCancel"</literal></expr> </then><else>: <expr><name>errbuf</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Check if any segment DB down is detected by FTS.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkSegmentAlive</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * check the connection still valid
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Skip if already finished or didn't dispatch.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Skip the entry db.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>logicalWorkerInfo</name><operator>.</operator><name>idx</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"FTS testing connection %d of %d (%s)"</literal></expr></argument>,
							  <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>send_sequence_response</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>last</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>cached</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>increment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overflow</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pqPutMsgStart</name><argument_list>(<argument><expr><name>SEQ_NEXTVAL_QUERY_RESPONSE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>last</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>last</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>cached</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>cached</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>increment</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutInt</name><argument_list>(<argument><expr><name>increment</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutc</name><argument_list>(<argument><expr><ternary><condition><expr><name>overflow</name></expr> ?</condition><then> <expr><name>SEQ_NEXTVAL_TRUE</name></expr> </then><else>: <expr><name>SEQ_NEXTVAL_FALSE</name></expr></else></ternary></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutc</name><argument_list>(<argument><expr><ternary><condition><expr><name>error</name></expr> ?</condition><then> <expr><name>SEQ_NEXTVAL_TRUE</name></expr> </then><else>: <expr><name>SEQ_NEXTVAL_FALSE</name></expr></else></ternary></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqPutMsgEnd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<call><name>pqFlush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Receive and process input from one PX.
 *
 * Return true if all input are consumed or the connection went wrong.
 * Return false if there'er still more data expected.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>processResults</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGnotify</name>   <modifier>*</modifier></type><name>nextval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Receive input from PX.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_process_results_input"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
									   <argument><expr><literal type="string">"Error on receive from %s: %s"</literal></expr></argument>,
									   <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have received one or more complete messages, process them.
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* loop to call PQgetResult; won't block */</comment>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pRes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>resultIndex</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * PQisBusy() does some error handling, which can cause the connection
		 * to die -- we can't just continue on as if the connection is happy
		 * without checking first.
		 *
		 * For example, pxdisp_numPGresult() will return a completely bogus
		 * value!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_process_bad_connection"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pxdisp_appendMessageNonThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
										   <argument><expr><literal type="string">"Connection lost when receiving from %s: %s"</literal></expr></argument>,
										   <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get one message.
		 */</comment>
		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"PQgetResult"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pRes</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Command is complete when PGgetResult() returns NULL. It is critical
		 * that for any connection that had an asynchronous command sent thru
		 * it, we call PQgetResult until it returns NULL. Otherwise, the next
		 * time a command is sent to that connection, it will return an error
		 * that there's a command pending.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pRes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; idle"</literal></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* this is normal end of command */</comment>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Attach the PGresult object to the PxDispatchResult object.
		 */</comment>
		<expr_stmt><expr><name>resultIndex</name> <operator>=</operator> <call><name>pxdisp_numPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_appendResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Did a command complete successfully?
		 */</comment>
		<expr_stmt><expr><name>resultStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; ok %s"</literal></expr></argument>,
								  <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
								  <argument><expr><ternary><condition><expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>PQcmdStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">"(no cmdStatus)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"PX received empty query."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Save the index of the last successful PGresult. Can be given to
			 * pxdisp_getPGresult() to get tuple count, etc.
			 */</comment>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>=</operator> <name>resultIndex</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * SREH - get number of rows rejected from PX if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pRes</name><operator>-&gt;</operator><name>numRejected</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name> <operator>+=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>numRejected</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * COPY FROM ON SEGMENT - get the number of rows completed by PX
			 * if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pRes</name><operator>-&gt;</operator><name>numCompleted</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowscompleted</name></name> <operator>+=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>numCompleted</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
				<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * Note PX error. Cancel the whole statement if requested.
		 */</comment>
		<else>else
		<block>{<block_content>
			<comment type="block">/* PX reported an error */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>errcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"%s -&gt; %s %s  %s"</literal></expr></argument>,
								  <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
								  <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><name>resultStatus</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><ternary><condition><expr><name>sqlstate</name></expr> ?</condition><then> <expr><name>sqlstate</name></expr> </then><else>: <expr><literal type="string">"(no SQLSTATE)"</literal></expr></else></ternary></expr></argument>,
								  <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Convert SQLSTATE to an error code (ERRCODE_xxx). Use a generic
			 * nonzero error code if no SQLSTATE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>px_sqlstate_to_errcode</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Save first error code and the index of its PGresult buffer
			 * entry.
			 */</comment>
			<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>resultIndex</name></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If there was nextval request then respond back on this libpq connection
	 * with the next value. Check and process nextval message only if QC has
	 * not already hit the error. Since QC could have hit the error while
	 * processing the previous nextval_qc() request itself and since full
	 * error handling is not complete yet like releasing all the locks, etc..,
	 * shouldn't attempt to call nextval_qc() again.
	 */</comment>
	<expr_stmt><expr><name>nextval</name> <operator>=</operator> <call><name>PQnotifies</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><call><name>px_elog_geterrcode</name><argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>nextval</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>nextval</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><literal type="string">"nextval"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"nextval_inject"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>last</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>cached</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>increment</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>overflow</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>dbid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>seq_oid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name><name>nextval</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>, <argument><expr><literal type="string">"%d:%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dbid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seq_oid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid nextval message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dbid</name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"nextval message database id:%d doesn't match my database id:%d"</literal></expr></argument>,
				 <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>nextval_qc</name><argument_list>(<argument><expr><name>seq_oid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cached</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>increment</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>overflow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>send_sequence_response</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>seq_oid</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>cached</name></expr></argument>, <argument><expr><name>increment</name></expr></argument>, <argument><expr><name>overflow</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* error */</comment> )</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * respond back on this libpq connection with the next value
		 */</comment>
		<expr_stmt><expr><call><name>send_sequence_response</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>seq_oid</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>cached</name></expr></argument>, <argument><expr><name>increment</name></expr></argument>, <argument><expr><name>overflow</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* error */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nextval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreemem</name><argument_list>(<argument><expr><name>nextval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* we must keep on monitoring this socket */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDispatchResult_thread</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wait</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pq_thread: begin check dispatch result from libpq thread."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_all_finish</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<comment type="block">/*
			 * Already finished with this PX
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"px check dispatch result error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>is_all_finish</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wait</name> <operator>||</operator> <name>is_all_finish</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pq_thread: finish check dispatch result from libpq thread."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
