<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_disp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_disp.c
 *	  Functions to dispatch commands to PX executors.
 *
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	  src/backend/px/dispatcher/px_disp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils_px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>		<comment type="block">/* For proc_exit_inprogress */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_sreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>numNonExtendedDispatcherState</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>open_dispatcher_handles</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>find_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>allocate_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroy_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>segmentsListToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>DispatcherInternalFuncs</name> <modifier>*</modifier></type><name>pDispatchFuncs</name> <init>= <expr><operator>&amp;</operator><name>DispatcherAsyncFuncs</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * pxdisp_dispatchToGang:
 * Send the strCommand SQL statement to the subset of all segdbs in the cluster
 * specified by the gang parameter. cancelOnError indicates whether an error
 * occurring on one of the qExec segdbs should cause all still-executing commands to cancel
 * on other qExecs. Normally this would be true. The commands are sent over the libpq
 * connections that were established during pxlink_setup.
 *
 * The caller must provide a PxDispatchResults object having available
 * resultArray slots sufficient for the number of PXs to be dispatched:
 * i.e., resultCapacity - resultCount &gt;= gp-&gt;size.	This function will
 * assign one resultArray slot per PX of the Gang, paralleling the Gang's
 * db_descriptors array. Success or failure of each PX will be noted in
 * the PX's PxDispatchResult entry; but before examining the results, the
 * caller must wait for execution to end by calling pxdisp_checkDispatchResult().
 *
 * The PxDispatchResults object owns some malloc'ed storage, so the caller
 * must make certain to free it by calling pxdisp_destroyDispatcherState().
 *
 * When dispatchResults-&gt;cancelOnError is false, strCommand is to be
 * dispatched to every connected gang member if possible, despite any
 * cancellation requests, PX errors, connection failures, etc.
 *
 * NB: This function should return normally even if there is an error.
 * It should not longjmp out via elog(ERROR, ...), ereport(ERROR, ...),
 * PG_THROW, CHECK_FOR_INTERRUPTS, etc.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_dispatchToGang</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>Gang</name></name> <modifier>*</modifier></type><name>gp</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gp</name> <operator>&amp;&amp;</operator> <name><name>gp</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name> <operator>&amp;&amp;</operator> <name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>resultArray</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>dispatchToGang</name></name><operator>)</operator> <operator>(</operator><name>ds</name><operator>,</operator> <name>gp</name><operator>,</operator> <name>sliceIndex</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * For asynchronous dispatcher, we have to wait all dispatch to finish before we move on to query execution,
 * otherwise we may get into a deadlock situation, e.g, gather motion node waiting for data,
 * while segments waiting for plan.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_waitDispatchFinish</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>waitDispatchFinish</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>waitDispatchFinish</name></name><operator>)</operator> <operator>(</operator><name>ds</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pxdisp_checkDispatchResult:
 *
 * Waits for completion of threads launched by pxdisp_dispatchToGang().
 *
 * PXs that were dispatched with 'cancelOnError' true and are not yet idle
 * will be canceled/finished according to waitMode.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_checkDispatchResult</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							<parameter><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>checkResults</name></name><operator>)</operator> <operator>(</operator><name>ds</name><operator>,</operator> <name>waitMode</name><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_log_dispatch_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowUsage</name><argument_list>(<argument><expr><literal type="string">"DISPATCH STATISTICS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to dispatch result received from all PXs: %s ms"</literal></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pxdisp_getDispatchResults:
 *
 * Block until all PXs return results or report errors.
 *
 * Return Values:
 *   Return NULL If one or more PXs got Error. In that case, *pxErrors contains
 *   a list of ErrorDatas.
 */</comment>
<function><type><name><name>struct</name> <name>PxDispatchResults</name></name> <modifier>*</modifier></type>
<name>pxdisp_getDispatchResults</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pxError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errorcode</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ds</name> <operator>||</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Fallback in case we have no dispatcher state.  Since the caller is
		 * likely to output the errors on NULL return, add an error message to
		 * aid debugging.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>errstart</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>, <argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>pxError</name> <operator>=</operator> <call><name>px_errfinish_and_return</name><argument_list>(<argument><expr><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no dispatcher state"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check if any error reported */</comment>
	<expr_stmt><expr><name>errorcode</name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>errorcode</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pxdisp_dumpDispatchResults</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></argument>, <argument><expr><name>pxError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PxDispatchHandleError
 *
 * When caller catches an error, the PG_CATCH handler can use this
 * function instead of pxdisp_finishCommand to wait for all PXs
 * to finish, and report PX errors if appropriate.
 * This function should be called only from PG_CATCH handlers.
 *
 * This function doesn't cleanup dispatcher state, dispatcher state
 * will be destroyed as part of the resource owner cleanup.
 *
 * On return, the caller is expected to finish its own cleanup and
 * exit via PG_RE_THROW().
 */</comment>
<function><type><name>void</name></type>
<name>PxDispatchHandleError</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatcherState</name></name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>qderrcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useQeError</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>error</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If pxdisp_dispatchToGang() wasn't called, don't wait.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ds</name> <operator>||</operator> <operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Request any remaining commands executing on qExecs to stop. We need to
	 * wait for the threads to finish. This allows for proper cleanup of the
	 * results from the async command executions. Cancel any PXs still
	 * running.
	 */</comment>
	<expr_stmt><expr><call><name>pxdisp_cancelDispatch</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * When a PX stops executing a command due to an error, as a consequence
	 * there can be a cascade of interconnect errors (usually "sender closed
	 * connection prematurely") thrown in downstream processes (PXs and QC).
	 * So if we are handling an interconnect error, and a PX hit a more
	 * interesting error, we'll let the PX's error report take precedence.
	 */</comment>
	<expr_stmt><expr><name>qderrcode</name> <operator>=</operator> <call><name>px_elog_geterrcode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>qderrcode</name> <operator>==</operator> <name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>qd_lost_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>qderrtext</name> <init>= <expr><call><name>elog_message</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>qderrtext</name>
			<operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>qderrtext</name></expr></argument>, <argument><expr><name>PX_MOTION_LOST_CONTACT_STRING</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>qd_lost_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name> <operator>&amp;&amp;</operator> <name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>qd_lost_flag</name>
				<operator>&amp;&amp;</operator> <name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>==</operator> <name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>useQeError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>!=</operator> <name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>useQeError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>useQeError</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Throw the PX's error, catch it, and fall thru to return normally so
		 * caller can finish cleaning up. Afterwards caller must exit via
		 * PG_RE_THROW().
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * During abort processing, we are running in ErrorContext. Avoid
		 * doing these heavy things in ErrorContext. (There's one particular
		 * issue: these calls use CopyErrorData(), which asserts that we are
		 * not in ErrorContext.)
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>CurTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pxdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
		</block_content>}</block>						<comment type="block">/* nop; fall thru */</comment>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Allocate memory and initialize PxDispatcherState.
 *
 * Call pxdisp_destroyDispatcherState to free it.
 */</comment>
<function><type><name>PxDispatcherState</name> <modifier>*</modifier></type>
<name>pxdisp_makeDispatcherState</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isExtendedQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>handle</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isExtendedQuery</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numNonExtendedDispatcherState</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query plan with multiple segworker groups is not supported"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"likely caused by a function that reads or modifies data in a distributed table"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>numNonExtendedDispatcherState</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>handle</name> <operator>=</operator> <call><name>allocate_dispatcher_handle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>forceDestroyGang</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>isExtendedQuery</name></name> <operator>=</operator> <name>isExtendedQuery</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>isGangDestroying</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>allocatedGangs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>handle</name><operator>-&gt;</operator><name>dispatcherState</name><operator>-&gt;</operator><name>largestGangSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name><name>handle</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pxdisp_makeDispatchParams</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>maxSlices</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>queryText</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>queryTextLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>dispatchParams</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dispatchParams</name> <operator>=</operator> <operator>(</operator><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>makeDispatchParams</name></name><operator>)</operator> <operator>(</operator><name>maxSlices</name><operator>,</operator> <name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name><operator>,</operator> <name>queryText</name><operator>,</operator> <name>queryTextLen</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name> <operator>=</operator> <name>dispatchParams</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free memory in PxDispatcherState
 *
 * Free dispatcher memory context.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_destroyDispatcherState</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ds</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<comment type="block">/* Disallow reentrance. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>isGangDestroying</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>isGangDestroying</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ds</name><operator>-&gt;</operator><name>isExtendedQuery</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numNonExtendedDispatcherState</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numNonExtendedDispatcherState</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>results</name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>find_dispatcher_handle</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>results</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>results</name><operator>-&gt;</operator><name>resultArray</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pxdisp_termResult</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultArray</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Recycle or destroy gang accordingly.
	 *
	 * We must recycle them in the reverse order of AllocateGang() to restore
	 * the original order of the idle gangs.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ds-&gt;allocatedGangs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>gp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>RecycleGang</name><argument_list>(<argument><expr><name>gp</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>forceDestroyGang</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>h</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroy_dispatcher_handle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pxdisp_cancelDispatch</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pxdisp_checkDispatchResult</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>DISPATCH_WAIT_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>pxdisp_checkForCancel</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pDispatchFuncs</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>checkForCancel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>checkForCancel</name></name><operator>)</operator> <operator>(</operator><name>ds</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a file descriptor to wait for events from the PXs after dispatching
 * a query.
 *
 * This is intended for use with pxdisp_checkForCancel(). First call
 * pxdisp_getWaitSocketFd(), and wait on that socket to become readable
 * e.g. with select() or poll(). When it becomes readable, call
 * pxdisp_checkForCancel() to process the incoming data, and repeat.
 *
 * XXX: This returns only one fd, but we might be waiting for results from
 * multiple PXs. In that case, this returns arbitrarily one of them. You
 * should still have a timeout, and call pxdisp_checkForCancel()
 * periodically, to process results from the other PXs.
 */</comment>
<function><type><name>int</name></type>
<name>pxdisp_getWaitSocketFd</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>pDispatchFuncs</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>getWaitSocketFd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name><name>pDispatchFuncs</name><operator>-&gt;</operator><name>getWaitSocketFd</name></name><operator>)</operator> <operator>(</operator><name>ds</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type>
<name>allocate_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_DispatcherContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_DispatcherContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												  <argument><expr><literal type="string">"Dispatch Context"</literal></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
												  <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dispatcher_handle_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PxDispatcherState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>open_dispatcher_handles</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>open_dispatcher_handles</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>open_dispatcher_handles</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>open_dispatcher_handles</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>

	<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroy_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* unlink from linked list first */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>open_dispatcher_handles</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>open_dispatcher_handles</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>dispatcher_handle_t</name> <modifier>*</modifier></type>
<name>find_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name>open_dispatcher_handles</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>==</operator> <name>ds</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>head</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_dispatcher_handle</name><parameter_list>(<parameter><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>destroy_dispatcher_handle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pxdisp_cancelDispatch</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxdisp_destroyDispatcherState</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pxdisp_cleanupDispatcherHandle</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>ResourceOwnerData</name></name> <modifier>*</modifier></type><name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dispatcher_handle_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>next</name> <operator>=</operator> <name>open_dispatcher_handles</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>next</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>curr</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>owner</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cleanup_dispatcher_handle</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * segmentsListToString
 *		Utility routine to convert a segment list into a string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>segmentsListToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>segments</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>segID</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><name>segID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>string</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>segmentsToContentStr</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>segments</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"ALL contents"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"SINGLE content"</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>size</name> <operator>&lt;</operator> <call><name>getPxWorkerCount</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>segmentsListToString</name><argument_list>(<argument><expr><literal type="string">"PARTIAL contents"</literal></expr></argument>, <argument><expr><name>segments</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>segmentsListToString</name><argument_list>(<argument><expr><literal type="string">"ALL contents"</literal></expr></argument>, <argument><expr><name>segments</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup all dispatcher state that belong to
 * current resource owner and its childrens
 */</comment>
<function><type><name>void</name></type>
<name>AtAbort_DispatcherState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>!=</operator> <name>PX_ROLE_QC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>CurrentGangCreating</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecycleGang</name><argument_list>(<argument><expr><name>CurrentGangCreating</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentGangCreating</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Cleanup all outbound dispatcher states belong to
	 * current resource owner and its children
	 */</comment>
	<expr_stmt><expr><call><name>PxResourceOwnerWalker</name><argument_list>(<argument><expr><name>CurrentResourceOwner</name></expr></argument>, <argument><expr><name>pxdisp_cleanupDispatcherHandle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>open_dispatcher_handles</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
