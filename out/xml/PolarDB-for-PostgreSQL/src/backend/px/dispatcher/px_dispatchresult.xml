<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_dispatchresult.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_dispatchresult.c
 *	  Functions for handling dispatch results.
 *
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 * IDENTIFICATION
 *	  src/backend/px/dispatcher/px_dispatchresult.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>			<comment type="block">/* prerequisite for libpq-int.h */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>			<comment type="block">/* PQExpBufferData */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>			<comment type="block">/* log_min_messages */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>			<comment type="block">/* PxWorkerDescriptor */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_sreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>noTrailingNewlinePQ</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>oneTrailingNewlinePQ</name><parameter_list>(<parameter><decl><type><name>PQExpBuffer</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>noTrailingNewlinePQ</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendPQExpBufferChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a PxDispatchResult object, appending it to the
 * resultArray of a given PxDispatchResults object.
 */</comment>
<function><type><name>PxDispatchResult</name> <modifier>*</modifier></type>
<name>pxdisp_makeResult</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatchResults</name></name> <modifier>*</modifier></type><name>meleeResults</name></decl></parameter>,
				   <parameter><decl><type><name><name>struct</name> <name>PxWorkerDescriptor</name></name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>meleeIndex</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>meleeResults</name> <operator>&amp;&amp;</operator>
		   <name><name>meleeResults</name><operator>-&gt;</operator><name>resultArray</name></name> <operator>&amp;&amp;</operator>
		   <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCount</name></name> <operator>&lt;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCapacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate a slot for the new PxDispatchResult object.
	 */</comment>
	<expr_stmt><expr><name>meleeIndex</name> <operator>=</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <operator>&amp;</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name>meleeIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize PxDispatchResult.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeResults</name></name> <operator>=</operator> <name>meleeResults</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeIndex</name></name> <operator>=</operator> <name>meleeIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name> <operator>=</operator> <name>pxWorkerDesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <call><name>createPQExpBuffer</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowscompleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<call><name>PQExpBufferBroken</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_makeresult_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * caller is responsible for cleanup -- can't elog(ERROR, ...) from
		 * here.
		 */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reset summary indicators.
	 */</comment>
	<expr_stmt><expr><call><name>pxdisp_resetResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update slice map entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sliceIndex</name> <operator>&lt;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>sliceCapacity</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResults_SliceInfo</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><operator>&amp;</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>==</operator> <name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>=</operator> <name>meleeIndex</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>=</operator> <name>meleeIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>&gt;</operator> <name>meleeIndex</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>=</operator> <name>meleeIndex</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>&lt;=</operator> <name>meleeIndex</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>=</operator> <name>meleeIndex</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dispatchResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Destroy a PxDispatchResult object.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_termResult</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>trash</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the PGresult objects.
	 */</comment>
	<expr_stmt><expr><call><name>pxdisp_resetResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Free the error message buffer and result buffer.
	 */</comment>
	<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyPQExpBuffer</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset a PxDispatchResult object for possible reuse.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_resetResult</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>begp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>endp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Free the PGresult objects.
	 */</comment>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>begp</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Reset summary indicators.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset progress indicators.
	 */</comment>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>hasDispatched</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>=</operator> <name>DISPATCH_WAIT_NONE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Empty (but don't free) the error message buffer and result buffer.
	 */</comment>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resetPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Take note of an error.
 * 'errcode' is the ERRCODE_xxx value for setting the client's SQLSTATE.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_seterrcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <comment type="block">/* ERRCODE_xxx or 0 */</comment>
				   <parameter><decl><type><name>int</name></type> <name>resultIndex</name></decl></parameter>, <comment type="block">/* -1 if no PGresult */</comment>
				   <parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>meleeResults</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeResults</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must ensure a nonzero errcode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>errcode</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>errcode</name> <operator>=</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Was the command canceled?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>==</operator> <name>ERRCODE_PX_OPERATION_CANCELED</name> <operator>||</operator>
		<name>errcode</name> <operator>==</operator> <name>ERRCODE_QUERY_CANCELED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If this is the first error from this PX, save the error code and the
	 * index of the PGresult buffer entry. We assume the caller has not yet
	 * added the item to the PGresult buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>meleeResults</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Remember which PX reported an error first among the gangs, but keep
	 * quiet about cancellation done at our request.
	 *
	 * Interconnection errors are given lower precedence because often they
	 * are secondary to an earlier and more interesting error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>errcode</name> <operator>==</operator> <name>ERRCODE_PX_OPERATION_CANCELED</name> <operator>&amp;&amp;</operator>
		<name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>==</operator> <name>DISPATCH_WAIT_CANCEL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nop */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
			 <operator>(</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>==</operator> <name>ERRCODE_PX_INTERCONNECTION_ERROR</name> <operator>&amp;&amp;</operator>
			  <name>errcode</name> <operator>!=</operator> <name>ERRCODE_PX_INTERCONNECTION_ERROR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <name>errcode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeIndex</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * NonThread version of pxdisp_appendMessage.
 *
 * It's safe to use palloc/pfree or elog/ereport if not in thread.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_appendMessageNonThread</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgoff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remember first error.
	 */</comment>
	<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate buffer if first message. Insert newline between previous
	 * message and new one.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>oneTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>msgoff</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Format the message and append it to the buffer.
	 */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferVA</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Display the message on stderr for debugging, if requested. This helps
	 * to clarify the actual timing of threaded events.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>oneTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>msgoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In case the caller wants to hand the buffer to ereport(), follow the
	 * ereport() convention of not ending with a newline.
	 */</comment>
	<expr_stmt><expr><call><name>noTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Thread version of pxdisp_appendMessage.
 *
 * It's unsafe to use palloc/pfree or elog/ereport if in thread.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_appendMessageThread</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>msgoff</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remember first error.
	 */</comment>
	<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate buffer if first message. Insert newline between previous
	 * message and new one.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>oneTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>msgoff</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Format the message and append it to the buffer.
	 */</comment>
	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendPQExpBufferVA</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Display the message on stderr for debugging, if requested. This helps
	 * to clarify the actual timing of threaded events.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>oneTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"LOG: %s"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>msgoff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In case the caller wants to hand the buffer to ereport(), follow the
	 * ereport() convention of not ending with a newline.
	 */</comment>
	<expr_stmt><expr><call><name>noTrailingNewlinePQ</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store a PGresult object ptr in the result buffer.
 * NB: Caller must not PQclear() the PGresult object.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_appendResult</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dispatchResult</name> <operator>&amp;&amp;</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Attach the PX identification string to the PGresult
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name> <operator>&amp;&amp;</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pqSaveMessageField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_PX_PROCESS_TAG</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendBinaryPQExpBuffer</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the i'th PGresult object ptr (if i &gt;= 0), or
 * the n+i'th one (if i &lt; 0), or NULL (if i out of bounds).
 * NB: Caller must not PQclear() the PGresult object.
 */</comment>
<function><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type>
<name>pxdisp_getPGresult</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dispatchResult</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PQExpBuffer</name></type> <name>buf</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>begp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>endp</name> <init>= <expr><operator>(</operator><name>PGresult</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>  <modifier>*</modifier><modifier>*</modifier></type><name>p</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>begp</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>endp</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name>begp</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>*</operator><name>p</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the number of PGresult objects in the result buffer.
 */</comment>
<function><type><name>int</name></type>
<name>pxdisp_numPGresult</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name>dispatchResult</name></expr> ?</condition><then> <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>resultbuf</name><operator>-&gt;</operator><name>len</name></name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PGresult</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct an ErrorData from the dispatch results.
 */</comment>
<function><type><name>ErrorData</name> <modifier>*</modifier></type>
<name>pxdisp_dumpDispatchResult</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ires</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nres</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>errdata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dispatchResult</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Format PGresult messages
	 */</comment>
	<expr_stmt><expr><name>nres</name> <operator>=</operator> <call><name>pxdisp_numPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>ires</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ires</name> <operator>&lt;</operator> <name>nres</name></expr>;</condition> <incr><expr><operator>++</operator><name>ires</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name> <init>= <expr><call><name>pxdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>ires</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>errdata</name> <operator>=</operator> <call><name>pxdisp_get_PXerror</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>errdata</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>errdata</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Error found on our side of the libpq interface?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name></name> <operator>&amp;&amp;</operator>
		<name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>errstart</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>PG_FUNCNAME_MACRO</name></expr></argument>, <argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errdata</name> <operator>=</operator> <call><name>px_errfinish_and_return</name><argument_list>(<argument><expr><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call></expr></argument>,
										   <argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>error_message</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<return>return <expr><name>errdata</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The returned error object is allocated in TopTransactionContext.
 *
 * Caution: do not use the returned object across transaction boundary.
 * Current usages of this API are such that the returned object is either
 * logged using elog() or rethrown, both within a transaction context, at the
 * time of finishing a dispatched command.  The caution applies to future uses
 * of this function.
 */</comment>
<function><type><name>ErrorData</name> <modifier>*</modifier></type>
<name>pxdisp_get_PXerror</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>pgresult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name> <init>= <expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * These will be overwritten below with the values from PX, if the PX sent
	 * them.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>__FILE__</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lineno</name> <init>= <expr><name>__LINE__</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><name>PG_FUNCNAME_MACRO</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>px_errcode</name> <init>= <expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>whoami</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fld</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * PX success
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
		<name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * errstart need a const filename and funcname, make sure they are at
	 * least const in this transaction.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lineno</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should only get errors with ERROR level or above, if the command
	 * failed. And if a PX disconnected with FATAL, or PANICed, we don't want
	 * to do the same in the QC. So, always an ERROR.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>errstart</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* unexpected path. */</comment>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_errcode</name> <operator>=</operator> <call><name>px_sqlstate_to_errcode</name><argument_list>(<argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>errcode</name><argument_list>(<argument><expr><name>px_errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>whoami</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_PX_PROCESS_TAG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fld</name> <operator>=</operator> <literal type="string">"no primary message received"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>whoami</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s  (%s)"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>, <argument><expr><name>whoami</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fld</name> <operator>=</operator> <call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fld</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>fld</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>px_errfinish_and_return</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>edata</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format a PxDispatchResults object.
 * Returns an ErrorData object in *pxError if some error was found, or NIL if no errors.
 * Before calling this function, you must call PxCheckDispatchResult().
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_dumpDispatchResults</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatchResults</name></name> <modifier>*</modifier></type><name>meleeResults</name></decl></parameter>,
							<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier><modifier>*</modifier></type><name>pxError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Quick exit if no error (not counting ERRCODE_PX_OPERATION_CANCELED).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>meleeResults</name> <operator>||</operator> <operator>!</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>pxError</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the PxDispatchResult of the first PX that got an error.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>&lt;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>resultCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <operator>&amp;</operator><name><name>meleeResults</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>meleeResults</name><operator>-&gt;</operator><name>iFirstError</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>meleeResults</name></name> <operator>==</operator> <name>meleeResults</name> <operator>&amp;&amp;</operator>
		   <name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Format one PX's result.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>pxError</name> <operator>=</operator> <call><name>pxdisp_dumpDispatchResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return sum of the cmdTuples values from PxDispatchResult
 * entries that have a successful PGresult. If sliceIndex &gt;= 0,
 * uses only the results belonging to the specified slice.
 */</comment>
<function><type><name>int64</name></type>
<name>pxdisp_sumCmdTuples</name><parameter_list>(<parameter><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>resultEnd</name> <init>= <expr><call><name>pxdisp_resultEnd</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dispatchResult</name> <operator>=</operator> <call><name>pxdisp_resultBegin</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>dispatchResult</name> <operator>&lt;</operator> <name>resultEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>dispatchResult</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>pxdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgresult</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmdTuples</name> <init>= <expr><call><name>PQcmdTuples</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>cmdTuples</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sum</name> <operator>+=</operator> <call><name>atoll</name><argument_list>(<argument><expr><name>cmdTuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If several tuples were eliminated/rejected from the result because of
 * bad data formatting (this is currenly only possible in external tables
 * with single row error handling) - sum up the total rows rejected from
 * all PX's and notify the client.
 */</comment>
<comment type="block">/*
 * ReportSrehResults
 *
 * When necessary emit a NOTICE that describes the end result of the
 * SREH operations. Information includes the total number of rejected
 * rows, and whether rows were ignored or logged into an error log file.
 */</comment>
<function><type><name>void</name></type>
<name>ReportSrehResults</name><parameter_list>(<parameter><decl><type><name>PxSreh</name> <modifier>*</modifier></type><name>pxsreh</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>total_rejected</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>total_rejected</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"found "</literal> <name>INT64_FORMAT</name> <literal type="string">" data formatting errors ("</literal> <name>INT64_FORMAT</name> <literal type="string">" or more input rows), rejected related input data"</literal></expr></argument>,
						<argument><expr><name>total_rejected</name></expr></argument>, <argument><expr><name>total_rejected</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pxdisp_sumRejectedRows</name><parameter_list>(<parameter><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>resultEnd</name> <init>= <expr><call><name>pxdisp_resultEnd</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>totalRejected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dispatchResult</name> <operator>=</operator> <call><name>pxdisp_resultBegin</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>dispatchResult</name> <operator>&lt;</operator> <name>resultEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>dispatchResult</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>pxdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgresult</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * add num rows rejected from this PX to the total
			 */</comment>
			<expr_stmt><expr><name>totalRejected</name> <operator>+=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>totalRejected</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReportSrehResults</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>totalRejected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>


<comment type="block">/*
 * Find the max of the lastOid values returned from the QEs
 */</comment>
<function><type><name>Oid</name></type>
<name>pxdisp_maxLastOid</name><parameter_list>(<parameter><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>resultEnd</name> <init>= <expr><call><name>pxdisp_resultEnd</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pgresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>dispatchResult</name> <operator>=</operator> <call><name>pxdisp_resultBegin</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>dispatchResult</name> <operator>&lt;</operator> <name>resultEnd</name></expr>;</condition> <incr><expr><operator>++</operator><name>dispatchResult</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>pgresult</name> <operator>=</operator> <call><name>pxdisp_getPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pgresult</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>tmpoid</name> <init>= <expr><call><name>PQoidValue</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tmpoid</name> <operator>&gt;</operator> <name>oid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>oid</name> <operator>=</operator> <name>tmpoid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return ptr to first resultArray entry for a given sliceIndex.
 */</comment>
<function><type><name>PxDispatchResult</name> <modifier>*</modifier></type>
<name>pxdisp_resultBegin</name><parameter_list>(<parameter><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResults_SliceInfo</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>results</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceIndex</name> <operator>&lt;</operator> <name><name>results</name><operator>-&gt;</operator><name>sliceCapacity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>si</name> <operator>=</operator> <operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name> <operator>&lt;=</operator> <name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>&amp;&amp;</operator>
		   <name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name> <operator>&lt;=</operator> <name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>si</name><operator>-&gt;</operator><name>resultBegin</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return ptr to last+1 resultArray entry for a given sliceIndex.
 */</comment>
<function><type><name>PxDispatchResult</name> <modifier>*</modifier></type>
<name>pxdisp_resultEnd</name><parameter_list>(<parameter><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResults_SliceInfo</name> <modifier>*</modifier></type><name>si</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>results</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>sliceIndex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>si</name> <operator>=</operator> <operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><name>sliceIndex</name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><name><name>si</name><operator>-&gt;</operator><name>resultEnd</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * used in the interconnect on the dispatcher to avoid error-cleanup deadlocks.
 */</comment>
<function><type><name>bool</name></type>
<name>pxdisp_checkResultsErrcode</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PxDispatchResults</name></name> <modifier>*</modifier></type><name>meleeResults</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>meleeResults</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pxdisp_makeDispatchResults:
 * Allocates a PxDispatchResults object in the current memory context.
 * Will be freed in function pxdisp_destroyDispatcherState by deleting the
 * memory context.
 */</comment>
<function><type><name>void</name></type>
<name>pxdisp_makeDispatchResults</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>sliceCapacity</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>resultCapacity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>resultCapacity</name> <operator>=</operator> <name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name> <operator>*</operator> <name>sliceCapacity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>resultCapacity</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>results</name><operator>-&gt;</operator><name>resultArray</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>results</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultArray</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultCapacity</name></name> <operator>=</operator> <name>resultCapacity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>resultCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>iFirstError</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>errcode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>cancelOnError</name></name> <operator>=</operator> <name>cancelOnError</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>sliceCapacity</name></name> <operator>=</operator> <name>sliceCapacity</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sliceCapacity</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name>sliceCapacity</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>results</name><operator>-&gt;</operator><name>sliceMap</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name> <operator>=</operator> <name>results</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
