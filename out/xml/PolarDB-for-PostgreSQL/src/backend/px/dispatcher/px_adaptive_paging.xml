<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_adaptive_paging.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_adaptive_paging.c
 *	  Dynamic paging between PX and QC.
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *	  src/backend/px/dispatcher/px_adaptive_paging.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sdir.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_adaptive_paging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/* generator random error */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_libpq_fault_injection.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* POLAR px */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HEAPDEBUGALL</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PX_HEAPDEBUG_1</name></cpp:macro> \
	<cpp:value>elog(DEBUG5, "px_paging: worker_id: %d, request page. current_page: %u/%u, dir: %d, task_id: %d, round: %ld", \
		 seqReq-&gt;worker_id, seqReq-&gt;current_page, seqReq-&gt;page_count, \
		 seqReq-&gt;direction, seqReq-&gt;task_id, seqReq-&gt;scan_round)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PX_HEAPDEBUG_2</name></cpp:macro> \
	<cpp:value>elog(DEBUG5, "px_paging: worker_id: %d, get a page. %u:[%u-%u], task_id: %d, round: %ld", \
			seqReq-&gt;worker_id, seqReq-&gt;table_oid, seqRes.page_start, seqRes.page_end, \
			seqReq-&gt;task_id, seqReq-&gt;scan_round)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PX_HEAPDEBUG_3</name></cpp:macro> \
	<cpp:value>elog(DEBUG5, "px_paging: worker_id: %d, paging finish, task_id: %d, round: %ld", \
			seqReq-&gt;worker_id, seqReq-&gt;task_id, seqReq-&gt;scan_round)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PX_HEAPDEBUG_1</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PX_HEAPDEBUG_2</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PX_HEAPDEBUG_3</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* !defined(HEAPDEBUGALL) */</comment>

<comment type="block">/* struct for ip-binding paging */</comment>
<typedef>typedef <type><struct>struct <name>_NodePagingState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>     <name>finish</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type>  <name>batch_size</name></decl>;</decl_stmt>	<comment type="block">/* The count of unit number which px worker to read */</comment>
	<comment type="block">/* header or tail may less than batch_size, so remember it */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>  <name>header_unit_begin</name></decl>;</decl_stmt> <comment type="block">/* first slice begin */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>  <name>header_unit_end</name></decl>;</decl_stmt>
	<comment type="block">/* first slice end, abs(header_unit_end - header_unit_begin) = one unit size */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>  <name>tail_unit_begin</name></decl>;</decl_stmt> <comment type="block">/* last slice begin */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>  <name>tail_unit_end</name></decl>;</decl_stmt> <comment type="block">/* last slice end */</comment>
	<comment type="block">/* last slice end, abs(tail_unit_end - tail_unit_begin) = one unit size */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>  <name>current_page</name></decl>;</decl_stmt>
}</block></struct></type> <name>NodePagingState</name>;</typedef>

<comment type="block">/* struct for dynamic paging state */</comment>
<typedef>typedef <type><struct>struct <name>_SeqscanPagingState</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>				 <name>task_id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				 <name>direction</name></decl>;</decl_stmt>   <comment type="block">/* 1 or -1 */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>			 <name>current_num</name></decl>;</decl_stmt> <comment type="block">/* current progress */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>			 <name>scan_start</name></decl>;</decl_stmt>  <comment type="block">/* job`s start count */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>			 <name>scan_count</name></decl>;</decl_stmt>  <comment type="block">/* job`s scan count */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type>			 <name>page_count</name></decl>;</decl_stmt>  <comment type="block">/* page count of relation */</comment>
	<comment type="block">/* internal var */</comment>
	<decl_stmt><decl><type><name>int</name></type>				 <name>node_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type>			 <name>scan_round</name></decl>;</decl_stmt>  <comment type="block">/* may be more than 1 time */</comment>
	<comment type="block">/* used for analyze */</comment>
	<decl_stmt><decl><type><name>int</name></type>				 <name>worker_count</name></decl>;</decl_stmt> <comment type="block">/* max worker_id + 1 */</comment>
	<decl_stmt><decl><type><name>BlockNumber</name>		 <modifier>*</modifier></type><name>pages_per_worker</name></decl>;</decl_stmt> <comment type="block">/* [page_count]*/</comment>
	<decl_stmt><decl><type><name>NodePagingState</name>	 <modifier>*</modifier></type><name>node_states</name></decl>;</decl_stmt>
}</block></struct></type> <name>SeqscanPagingState</name>;</typedef>

<comment type="block">/* struct for paging state container */</comment>
<typedef>typedef <type><struct>struct <name>_PagingArray</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>					 <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqscanPagingState</name>	 <modifier>*</modifier><modifier>*</modifier></type><name>pStates</name></decl>;</decl_stmt>
}</block></struct></type> <name>PagingArray</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>PagingArray</name></type> <name>seq_paging_array</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>px_init_adps_state_per_worker</name><parameter_list>(<parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Add the state into PagingArray */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_adps_array_append</name><parameter_list>(<parameter><decl><type><name>PagingArray</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>pStates</name></name> <operator>=</operator> <operator>(</operator><name>SeqscanPagingState</name> <operator>*</operator><operator>*</operator><operator>)</operator><call><name>realloc</name><argument_list>(<argument><expr><name><name>array</name><operator>-&gt;</operator><name>pStates</name></name></expr></argument>,
					 <argument><expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SeqscanPagingState</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>array</name><operator>-&gt;</operator><name>pStates</name><index>[<expr><name><name>array</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>px_adps_array_free</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seq_paging_array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>node_states</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>node_states</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Used for explain analyze */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pages_per_worker</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>pages_per_worker</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seq_paging_array</name><operator>.</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Init the adaptive scan state from px's request.
 */</comment>
<function><type><specifier>static</specifier> <name>SeqscanPagingState</name> <modifier>*</modifier></type>
<name>make_adps_state</name><parameter_list>(<parameter><decl><type><name>SeqscanPageRequest</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>paging_state</name> <init>= <expr><operator>(</operator><name>SeqscanPagingState</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SeqscanPagingState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>paging_state</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>task_id</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>task_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>direction</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>direction</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>ForwardScanDirection</name></expr>)</condition> <comment type="block">/* forward */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>current_num</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* part */</comment>
			<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>current_num</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>scan_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>current_num</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>page_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>!=</operator> <name>InvalidBlockNumber</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* part */</comment>
			<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>current_num</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>scan_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>scan_start</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>scan_start</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>scan_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>page_count</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>page_count</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>scan_round</name></name> <operator>=</operator> <name><name>req</name><operator>-&gt;</operator><name>scan_round</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>node_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>node_states</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* analyze */</comment>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>worker_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paging_state</name><operator>-&gt;</operator><name>pages_per_worker</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>paging_state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Given a seqReq, return the dynamic task which belongs to the request.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>px_check_match_and_update_state</name><parameter_list>(<parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name></decl></parameter>, <parameter><decl><type><name>SeqscanPageRequest</name> <modifier>*</modifier></type><name>seqReq</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>has_finished</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>task_id</name></name> <operator>!=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>task_id</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* this round has finished */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>scan_round</name></name> <operator>&gt;</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>scan_round</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>has_finished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>has_finished</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<comment type="block">/* upgrade to next round */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>scan_round</name></name> <operator>&lt;</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>scan_round</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p_state</name><operator>-&gt;</operator><name>node_states</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>finish</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* maybe error occur in paging */</comment>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px_paging: error: round %ld has unfinished page"</literal></expr></argument>, <argument><expr><name><name>p_state</name><operator>-&gt;</operator><name>scan_round</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>scan_round</name></name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* must be one round ahead */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>p_state</name><operator>-&gt;</operator><name>scan_round</name></name> <operator>==</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>scan_round</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* reinit the paging state */</comment>
		<expr_stmt><expr><call><name>px_init_adps_state_per_worker</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the current worker_id is less than worker_count, means this worker has been recorded in p_state,
 * we just need to update the page_count belongs to this worker.
 * Else, this is a new worker, we should realloc the pages_per_worker and init the newer ones.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_adps_add_page_count</name><parameter_list>(<parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>worker_id</name></decl></parameter>, <parameter><decl><type><name>BlockNumber</name></type> <name>page_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* This worker is a new worker. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>worker_count</name></name> <operator>&lt;=</operator> <name>worker_id</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>old_count</name> <init>= <expr><name><name>p_state</name><operator>-&gt;</operator><name>worker_count</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>worker_count</name></name> <operator>=</operator> <name>worker_id</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>pages_per_worker</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>p_state</name><operator>-&gt;</operator><name>pages_per_worker</name></name></expr></argument>, <argument><expr><name><name>p_state</name><operator>-&gt;</operator><name>worker_count</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>BlockNumber</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Init the newer worker */</comment>
		<while>while <condition>(<expr><name>old_count</name> <operator>&lt;</operator> <name><name>p_state</name><operator>-&gt;</operator><name>worker_count</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>pages_per_worker</name><index>[<expr><name>old_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>pages_per_worker</name><index>[<expr><name>worker_id</name></expr>]</index></name> <operator>+=</operator> <name>page_count</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Init the adaptive scan state for each px workers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_init_adps_state_per_worker</name><parameter_list>(<parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64_t</name></type> <name>cached_unit_pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>NodePagingState</name> <modifier>*</modifier></type><name>n_state</name> <init>= <expr><operator>&amp;</operator><name><name>p_state</name><operator>-&gt;</operator><name>node_states</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>=</operator> <name>px_scan_unit_size</name></expr>;</expr_stmt>

		<comment type="block">/* How many units to get from all the workers once */</comment>
		<expr_stmt><expr><name>cached_unit_pages</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>*</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr>;</expr_stmt>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int64_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64_t</name></type> <name>header_unit_page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int64_t</name></type> <name>tail_unit_page</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>==</operator> <name>InvalidBlockNumber</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Scan all the blocks */</comment>
				<expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>page_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Forward scan part of blocks */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>ForwardScanDirection</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>scan_start</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>scan_start</name></name> <operator>+</operator> <name><name>p_state</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&gt;=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>page_count</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>page_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<comment type="block">/* Backward scan blocks */</comment>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>scan_start</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>p_state</name><operator>-&gt;</operator><name>scan_start</name></name> <operator>-</operator> <name><name>p_state</name><operator>-&gt;</operator><name>scan_count</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>start</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>start</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>header_unit_page</name> <operator>=</operator> <name>cached_unit_pages</name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>start</name> <operator>/</operator> <name>cached_unit_pages</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>tail_unit_page</name> <operator>=</operator> <name>cached_unit_pages</name> <operator>*</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><operator>(</operator><name>end</name> <operator>/</operator> <name>cached_unit_pages</name><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name> <operator>=</operator> <name>tail_unit_page</name> <operator>+</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name> <operator>=</operator> <name>tail_unit_page</name> <operator>+</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name> <operator>&gt;</operator> <name>end</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name> <operator>-=</operator> <name>cached_unit_pages</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name> <operator>-=</operator> <name>cached_unit_pages</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name> <operator>&lt;</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name> <operator>&lt;</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name> <operator>=</operator> <name>header_unit_page</name> <operator>+</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>*</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name> <operator>=</operator> <name>header_unit_page</name> <operator>+</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>*</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name> <operator>&lt;</operator> <name>start</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name> <operator>+=</operator> <name>cached_unit_pages</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name> <operator>+=</operator> <name>cached_unit_pages</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name> <operator>&lt;</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name> <operator>=</operator> <name>start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name> <operator>&gt;</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name> <operator>=</operator> <name>end</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>ForwardScanDirection</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Change batch size when this is the last only slice */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>px_adps_can_get_next_unit</name><parameter_list>(<parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>int64_t</name> <modifier>*</modifier></type><name>end</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>current_is_last</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodePagingState</name> <modifier>*</modifier></type><name>n_state</name> <init>= <expr><operator>&amp;</operator><name><name>p_state</name><operator>-&gt;</operator><name>node_states</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>cached_unit_pages</name> <init>= <expr><name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>*</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* This px worker has run out all the slices, return */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Forward scan */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>p_state</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>ForwardScanDirection</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>==</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name> <operator>+</operator> <name>cached_unit_pages</name> <operator>-</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>&gt;=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>current_is_last</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* When this is the last only slice, make batch_size small */</comment>
				<decl_stmt><decl><type><name>int</name></type> <name>small_batch</name> <init>= <expr><name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>/</operator> <literal type="number">16</literal></expr></init></decl>;</decl_stmt>
				<comment type="block">/* But at least one page */</comment>
				<if_stmt><if>if <condition>(<expr><name>small_batch</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>small_batch</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>+</operator> <name>small_batch</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<comment type="block">/* And not large than tail */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>&gt;</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>+=</operator> <name>small_batch</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>+</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>+=</operator> <name>cached_unit_pages</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>&gt;</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Backward scan */</comment>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>==</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_end</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>==</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_end</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>tail_unit_begin</name></name> <operator>-</operator> <name>cached_unit_pages</name> <operator>+</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>start</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>-</operator> <name><name>n_state</name><operator>-&gt;</operator><name>batch_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>-=</operator> <name>cached_unit_pages</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>n_state</name><operator>-&gt;</operator><name>current_page</name></name> <operator>&lt;</operator> <name><name>n_state</name><operator>-&gt;</operator><name>header_unit_begin</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>n_state</name><operator>-&gt;</operator><name>finish</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the last only px workers, if it exists, a smaller batch scan will be happened.
 * Get the next unit in current px workers, if it gets one unit, use it. Else, scan
 * all the other px workers to find an avaiable unit.
 * Save the result of next unit into pRes.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>px_adps_get_next_scan_unit</name><parameter_list>(<parameter><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node_idx</name></decl></parameter>, <parameter><decl><type><name>SeqscanPageResponse</name> <modifier>*</modifier></type><name>pRes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found_next_unit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>last_only_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>unfinished</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>page_start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>page_end</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Find the last unfinished px worker, and mark the last only index */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p_state</name><operator>-&gt;</operator><name>node_states</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>finish</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>unfinished</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>last_only_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>last_only_idx</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>unfinished</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>i</name></expr> </then><else>: <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>found_next_unit</name> <operator>=</operator> <call><name>px_adps_can_get_next_unit</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name>node_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page_end</name></expr></argument>,
												<argument><expr><name>last_only_idx</name> <operator>==</operator> <name>node_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_next_unit</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * May be first task is empty, scan the other tasks.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Skip the worker in the first task */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>node_idx</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Scan other tasks on each px workers */</comment>
			<expr_stmt><expr><name>found_next_unit</name> <operator>=</operator> <call><name>px_adps_can_get_next_unit</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page_start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page_end</name></expr></argument>, <argument><expr><name>last_only_idx</name> <operator>==</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found_next_unit</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the scan unit, update the result's page_start and page_end */</comment>
	<expr_stmt><expr><name><name>pRes</name><operator>-&gt;</operator><name>page_start</name></name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator><name>page_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pRes</name><operator>-&gt;</operator><name>page_end</name></name> <operator>=</operator> <operator>(</operator><name>BlockNumber</name><operator>)</operator><name>page_end</name></expr>;</expr_stmt>
	<return>return <expr><name>found_next_unit</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the scan response from px's scan request. PX worker have run out
 * it's scan blocks from the last task, get response from qc to find a new
 * task.
 * Ip binding per px workers and cached friendly.
 */</comment>
<function><type><name>SeqscanPageResponse</name></type>
<name>px_adps_get_response_block</name><parameter_list>(<parameter><decl><type><name>SeqscanPageRequest</name> <modifier>*</modifier></type><name>seqReq</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node_idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>node_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SeqscanPageResponse</name></type> <name>seqRes</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>page_start</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>page_end</name></name> <operator>=</operator> <name>InvalidBlockNumber</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>success</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>node_idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>node_count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px_paging: error node args when px_adps_get_response_block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>seqRes</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/*
		 * Init seq_paging_array is 0, so at the beginning of searching,
		 * it will miss.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seq_paging_array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>has_finished</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name> <init>= <expr><name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>px_check_match_and_update_state</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name>seqReq</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>has_finished</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* This round has consumed by other workers */</comment>
				<if_stmt><if>if <condition>(<expr><name>has_finished</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>seqRes</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* Search all the nodes to find the next unit(or page) to read */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>px_adps_get_next_scan_unit</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name>node_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqRes</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>BlockNumber</name></type> <name>page_count</name></decl>;</decl_stmt>
					<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>success</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>page_count</name> <operator>=</operator> <call><name>Abs</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>seqRes</name><operator>.</operator><name>page_end</name></name> <operator>-</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>seqRes</name><operator>.</operator><name>page_start</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>px_adps_add_page_count</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name><name>seqReq</name><operator>-&gt;</operator><name>worker_id</name></name></expr></argument>, <argument><expr><name>page_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<comment type="block">/* Can not find a task matches the request task, init a new task and record it */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>p_state</name> <init>= <expr><call><name>make_adps_state</name><argument_list>(<argument><expr><name>seqReq</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_state</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px_paging: memory not enough when px_adps_get_response_block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>seqRes</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* init node state */</comment>
			<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name> <operator>=</operator> <name>node_count</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>p_state</name><operator>-&gt;</operator><name>node_states</name></name> <operator>=</operator> <operator>(</operator><name>NodePagingState</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NodePagingState</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>p_state</name><operator>-&gt;</operator><name>node_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p_state</name><operator>-&gt;</operator><name>node_states</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px_paging: memory not enough when px_adps_get_response_block"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>seqRes</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>px_adps_array_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq_paging_array</name></expr></argument>, <argument><expr><name>p_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>px_init_adps_state_per_worker</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>px_adps_get_next_scan_unit</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name>node_idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqRes</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>BlockNumber</name></type> <name>page_count</name></decl>;</decl_stmt>
				<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>success</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>page_count</name> <operator>=</operator> <call><name>Abs</name><argument_list>(<argument><expr><operator>(</operator><name>int64_t</name><operator>)</operator><name><name>seqRes</name><operator>.</operator><name>page_end</name></name> <operator>-</operator> <operator>(</operator><name>int64_t</name><operator>)</operator><name><name>seqRes</name><operator>.</operator><name>page_start</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>px_adps_add_page_count</name><argument_list>(<argument><expr><name>p_state</name></expr></argument>, <argument><expr><name><name>seqReq</name><operator>-&gt;</operator><name>worker_id</name></name></expr></argument>, <argument><expr><name>page_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* Fix the result, rs_nblocks may be different between px workers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>seqRes</name><operator>.</operator><name>success</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>ForwardScanDirection</name> <operator>==</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>direction</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>seqRes</name><operator>.</operator><name>page_start</name></name> <operator>&gt;=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>page_count</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>success</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>seqRes</name><operator>.</operator><name>page_end</name></name> <operator>&gt;=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>page_count</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>page_end</name></name> <operator>=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>page_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Move to the tail page */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>seqRes</name><operator>.</operator><name>page_start</name></name> <operator>&gt;=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>page_count</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>page_start</name></name> <operator>=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>page_count</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Move to the head page */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>seqRes</name><operator>.</operator><name>page_end</name></name> <operator>&gt;=</operator> <name><name>seqReq</name><operator>-&gt;</operator><name>page_count</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>seqReq</name><operator>-&gt;</operator><name>current_page</name></name> <operator>=</operator> <name><name>seqRes</name><operator>.</operator><name>page_end</name></name></expr>;</expr_stmt>
				<return>return <expr><call><name>px_adps_get_response_block</name><argument_list>(<argument><expr><name>seqReq</name></expr></argument>, <argument><expr><name>node_idx</name></expr></argument>, <argument><expr><name>node_count</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>seqRes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Init px adaptive scan array */</comment>
<function><type><name>bool</name></type>
<name>px_adps_check_valid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check the seq_paging_array's size is reset to zero */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>seq_paging_array</name><operator>.</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px_paging: check dynamic paging error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get dynamic seqscan result for explain analyze, called in qc */</comment>
<function><type><name>void</name></type>
<name>px_adps_analyze_result</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>scan_id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p_msg_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqscanPagingState</name> <modifier>*</modifier></type><name>found_pStates</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_msg_buf</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>p_msg_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>seq_paging_array</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>scan_id</name> <operator>==</operator> <name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>task_id</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found_pStates</name> <operator>=</operator> <name><name>seq_paging_array</name><operator>.</operator><name>pStates</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>found_pStates</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>found_pStates</name><operator>-&gt;</operator><name>worker_count</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>max_size</name> <init>= <expr><name>count</name> <operator>*</operator> <literal type="number">15</literal> <operator>+</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Use palloc when in main thread */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_msg_buf</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>max_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_msg_buf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="char">'['</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>found_pStates</name><operator>-&gt;</operator><name>pages_per_worker</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pos</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>tmp_msg_buf</name> <operator>+</operator> <name>pos</name></expr></argument>, <argument><expr><name>max_size</name> <operator>-</operator> <name>pos</name></expr></argument>, <argument><expr><literal type="string">"%u,"</literal></expr></argument>, <argument><expr><name><name>found_pStates</name><operator>-&gt;</operator><name>pages_per_worker</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>tmp_msg_buf</name><index>[<expr><name>pos</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">']'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tmp_msg_buf</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>p_msg_buf</name> <operator>=</operator> <name>tmp_msg_buf</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PX worker has run out of it's scan unit, request qc to get a new scan unit.
 * Called in px workers.
 */</comment>
<function><type><name>SeqscanPageResponse</name></type>
<name>px_adps_request_scan_unit</name><parameter_list>(<parameter><decl><type><name>SeqscanPageRequest</name> <modifier>*</modifier></type><name>seqReq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SeqscanPageResponse</name></type> <name>seqRes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>request_size</name></decl>, <decl><type ref="prev"/><name>response_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>encoded_msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg_buffer</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>seqRes</name><operator>.</operator><name>success</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_heap_scan_flow</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>PX_HEAPDEBUG_1</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>request_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SeqscanPageRequest</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>encoded_msg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>request_size</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hex_encode</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>seqReq</name></expr></argument>, <argument><expr><name>request_size</name></expr></argument>, <argument><expr><name>encoded_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>encoded_msg</name><index>[<expr><name>request_size</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>MSG_ADAPTIVE_PAGING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>encoded_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>encoded_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage_reuse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Must flush this message */</comment>
	<if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <call><name>pq_flush</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"px_paging: can`t send paging response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finish</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>response_size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SeqscanPageResponse</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_startmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>pq_getbyte</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"px_paging: can`t get paging response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finish</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>PACKET_TYPE_PAGING</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"px_paging: get an error paging response, code:%d"</literal></expr></argument>, <argument><expr><name>code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finish</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>EOF</name> <operator>==</operator> <call><name>pq_getmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>response_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"px_paging: can`t get paging response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finish</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>msg_buffer</name> <operator>=</operator> <call><name>pq_getmsgbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>response_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqRes</name></expr></argument>, <argument><expr><name>msg_buffer</name></expr></argument>, <argument><expr><name>response_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>seqRes</name><operator>.</operator><name>success</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_heap_scan_flow</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>PX_HEAPDEBUG_2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlikely</name><argument_list>(<argument><expr><name>polar_trace_heap_scan_flow</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>PX_HEAPDEBUG_3</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

<label><name>finish</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>pq_is_reading_msg</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_endmsgread</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>seqReq</name><operator>-&gt;</operator><name>worker_id</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"px_paging: px_worker %d, inject a scan delay fault"</literal></expr></argument>, <argument><expr><name><name>seqReq</name><operator>-&gt;</operator><name>worker_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_adaptive_scan_round_delay"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>seqRes</name></expr>;</return>
</block_content>}</block></function>
</unit>
