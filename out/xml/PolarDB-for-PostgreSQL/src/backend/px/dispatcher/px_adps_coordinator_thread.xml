<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_adps_coordinator_thread.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_adps_coordinator_thread.c
 *	  Create a background thread for libpq realtime interactive.
 *
 * Copyright (c) 2020, Alibaba Group Holding Limited
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * IDENTIFICATION
 *	  src/backend/px/dispatcher/px_adps_coordinator_thread.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<comment type="block">/* libpq */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pqexpbuffer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>

<comment type="block">/* px interactive */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>

<comment type="block">/* dynamic paging */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_adaptive_paging.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>  <comment type="block">/* for write_log */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include> <comment type="block">/* for from_hex */</comment>

<comment type="block">/* break poll loop */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/* system header */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/prctl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* generator random error */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_libpq_fault_injection.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Dispatch result timeout from px_disp_async.c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_TIMEOUT_MSEC</name></cpp:macro> <cpp:value>2000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DISPATCH_WAIT_CANCEL_TIMEOUT_MSEC</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>PxDispatcherState</name> <modifier>*</modifier></type><name>pxds_backgroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>bool</name></type> <name>px_task_finished</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type> <name>px_pq_mutex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_cond_t</name></type>  <name>pq_wait_cv</name> <init>= <expr><name>PTHREAD_COND_INITIALIZER</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>px_adps_dispatch_wait</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>px_adps_eno</name></decl>;</decl_stmt>

<comment type="block">/* If or not the px worker' query has already finished */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>pq_is_px_finish</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If or not the px adaptive scan thread is running.
 * Run this function in main thread 
 */</comment>
<function><type><name>bool</name></type>
<name>pxdisp_isDsThreadRuning</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>px_adaptive_paging</name> <operator>&amp;&amp;</operator> <name>pxds_backgroup</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether there was error in the background thread in main thread.
 * If error found, report it.
 */</comment>
<function><type><name>void</name></type>
<name>px_check_adps_thread_error</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>eno</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>eno</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_adps_eno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>eno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>eno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Px adaptive scan thread encountered an error"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the Px adaptive scan error no in background thread.
 * Record the error in background thread. Main thread checks the errors periodically.
 * If main thread will find it, main thread will handle it.
 */</comment>
<function><type><name>void</name></type>
<name>px_set_adps_thread_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type> <name>expected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Always let main thread know the error that occurred first. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_adps_eno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expected</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>eno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Px adaptive scan thread starts failed in background, set eno to %d"</literal></expr></argument>, <argument><expr><name>expected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset the error no.
 */</comment>
<function><type><name>void</name></type>
<name>px_reset_adps_thread_error</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_adps_eno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Px adaptive scan has finished, set the status to false */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>px_result_finish</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset parameter-status in adaptive scan libpq connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clearParameterStatus</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>paramName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgParameterStatus</name> <modifier>*</modifier></type><name>pstatus</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>conn</name> <operator>||</operator> <operator>!</operator><name>paramName</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>pstatus</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pstatus</name></name></expr>;</init> <condition><expr><name>pstatus</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>pstatus</name> <operator>=</operator> <name><name>pstatus</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>pstatus</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>paramName</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>pstatus</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Get a valid adaptive scan response and send it to px worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_handle_adaptive_scan</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>msg_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SeqscanPageRequest</name></type> <name>seqReq</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SeqscanPageResponse</name></type> <name>seqRes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>response_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SeqscanPageResponse</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>msg_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hex_decode</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><name>msg_len</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>seqReq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_adaptive_paging</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/* If more than one px workers have the same ip, result always be 0 */</comment>
			<decl_stmt><decl><type><name>int</name></type> <name>node_idx</name> <init>= <expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>pxNodeInfo</name><operator>-&gt;</operator><name>cm_node_idx</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>node_count</name> <init>= <expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>pxNodeInfo</name><operator>-&gt;</operator><name>cm_node_size</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>seqRes</name> <operator>=</operator> <call><name>px_adps_get_response_block</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seqReq</name></expr></argument>, <argument><expr><name>node_idx</name></expr></argument>, <argument><expr><name>node_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>STATUS_OK</name> <operator>!=</operator> <call><name>pqPacketSend</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>PACKET_TYPE_PAGING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>seqRes</name></expr></argument>, <argument><expr><name>response_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Can`t write log in thread */</comment>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px_paging: message send to px failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Do the real work of px adaptive scan */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_do_real_message</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGconn</name>  <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>MSG_ADAPTIVE_PAGING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>px_handle_adaptive_scan</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Clear after use */</comment>
		<expr_stmt><expr><call><name>clearParameterStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>MSG_ADAPTIVE_PAGING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Px adaptive scan thread is woken. Parse the message from px worker and
 * response the scan task to px worker.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_adps_message_handle</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>  <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no cover begin */</comment>
		<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pxdisp_appendMessageThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
									<argument><expr><literal type="string">"Error on receive from %s: %s"</literal></expr></argument>,
									<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
		<comment type="block">/* no cover end */</comment>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Parse one message and update status */</comment>
	<expr_stmt><expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no cover begin */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: Dispatcher encountered connection error on %s: %s"</literal></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: Dispatcher noticed bad connection in handlePollError()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save error info for later. */</comment>
		<expr_stmt><expr><call><name>pxdisp_appendMessageThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
									<argument><expr><literal type="string">"Error after dispatch from %s: %s"</literal></expr></argument>,
									<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
		<comment type="block">/* no cover end */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * In query-process message, the px query is not completed.
	 * We get the msg from px to get the request slice.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>asyncStatus</name></name> <operator>==</operator> <name>PGASYNC_BUSY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>px_do_real_message</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The same as 'processResults' to deal with one or more complete
	 * messages.
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>pRes</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>resultIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecStatusType</name></type> <name>resultStatus</name></decl>;</decl_stmt>
		<comment type="block">/* pqResult */</comment>
		<expr_stmt><expr><name>pRes</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pRes</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* normal finish way */</comment>
			<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* pRes will free at pxdisp_resetResult */</comment>
		<expr_stmt><expr><name>resultIndex</name> <operator>=</operator> <call><name>pxdisp_numPGresult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_appendResult</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultStatus</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COMMAND_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_TUPLES_OK</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name> <operator>||</operator>
			<name>resultStatus</name> <operator>==</operator> <name>PGRES_EMPTY_QUERY</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Save the index of the last successful PGresult. Can be given to
			 * pxdisp_getPGresult() to get tuple count, etc.
			 */</comment>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>okindex</name></name> <operator>=</operator> <name>resultIndex</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * SREH - get number of rows rejected from PX if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pRes</name><operator>-&gt;</operator><name>numRejected</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowsrejected</name></name> <operator>+=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>numRejected</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * COPY FROM ON SEGMENT - get the number of rows completed by PX
			 * if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pRes</name><operator>-&gt;</operator><name>numCompleted</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>numrowscompleted</name></name> <operator>+=</operator> <name><name>pRes</name><operator>-&gt;</operator><name>numCompleted</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_IN</name> <operator>||</operator>
				<name>resultStatus</name> <operator>==</operator> <name>PGRES_COPY_OUT</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* normal finish way */</comment>
				<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* PX reported an error */</comment>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sqlstate</name> <init>= <expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>errcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>pRes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: %s -&gt; %s %s  %s"</literal></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
					  <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><name>resultStatus</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>sqlstate</name></expr> ?</condition><then> <expr><name>sqlstate</name></expr> </then><else>: <expr><literal type="string">"(no SQLSTATE)"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Convert SQLSTATE to an error code (ERRCODE_xxx). Use a generic
			 * nonzero error code if no SQLSTATE.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>sqlstate</name> <operator>&amp;&amp;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errcode</name> <operator>=</operator> <call><name>px_sqlstate_to_errcode</name><argument_list>(<argument><expr><name>sqlstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Save first error code and the index of its PGresult buffer
			 * entry.
			 */</comment>
			<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>, <argument><expr><name>resultIndex</name></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Deal with poll events error. Clean the px dynamic states.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pq_thread_handle_error</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<comment type="block">/* no cover begin */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>

		<comment type="block">/* Skip if already finished or didn't dispatch. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We're done with this PX, sadly. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_BAD</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>msg</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: Dispatcher encountered connection error on %s: %s"</literal></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: Dispatcher noticed bad connection in handlePollError()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Save error info for later. */</comment>
			<expr_stmt><expr><call><name>pxdisp_appendMessageThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>,
										<argument><expr><literal type="string">"Error after dispatch from %s: %s"</literal></expr></argument>,
										<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
										<argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* no cover end */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pq_thread_signalPXs</name><parameter_list>(<parameter><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchWaitMode</name></type> <name>waitMode</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>sent</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dispatchResult</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Don't send the signal if - PX is finished or canceled - the signal
		 * was already sent - connection is dead
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dispatchResult</name><operator>-&gt;</operator><name>stillRunning</name></name> <operator>||</operator>
				<name><name>dispatchResult</name><operator>-&gt;</operator><name>wasCanceled</name></name> <operator>||</operator>
				<call><name>pxconn_isBadConnection</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sent</name> <operator>=</operator> <call><name>pxconn_signalPX</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>waitMode</name> <operator>==</operator> <name>DISPATCH_WAIT_CANCEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sent</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>dispatchResult</name><operator>-&gt;</operator><name>sentSignal</name></name> <operator>=</operator> <name>waitMode</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: Unable to cancel: %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"cannot allocate PGCancel"</literal></expr> </then><else>: <expr><name>errbuf</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>pq_flush_buffer</name><parameter_list>(<parameter><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGconn</name>	<modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>
	<comment type="block">/* skip already completed connections */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>outCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/*
	* call send for this connection regardless of its POLLOUT status,
	* because it may be writable NOW
	*/</comment>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: flush libpq buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pqFlushNonBlocking</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>pqHandleSendFailure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>msg</name> <operator>=</operator> <call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>px_result_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pxdisp_appendMessageThread</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><literal type="string">"Command could not flush to segment %s: %s"</literal></expr></argument>,
									<argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>whoami</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>msg</name></expr> ?</condition><then> <expr><name>msg</name></expr> </then><else>: <expr><literal type="string">"unknown error"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pxdisp_seterrcode</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Function in thread. can not use palloc/pfree.
 * The main thread for adaptive scan in QC. Poll from px workers and response
 * if it is necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_consumer_ds</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Receive from px */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>fds</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchCmdAsync</name> <modifier>*</modifier></type><name>pParms</name> <init>= <expr><operator>(</operator><name>PxDispatchCmdAsync</name> <operator>*</operator><operator>)</operator> <name><name>ds</name><operator>-&gt;</operator><name>dispatchParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatchResults</name> <modifier>*</modifier></type><name>meleeResults</name> <init>= <expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>px_workers_count</name> <init>= <expr><name><name>pParms</name><operator>-&gt;</operator><name>dispatchCount</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>nfds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>sentSignal</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>px_finished_tasks_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	* Escalate waitMode to cancel if: - user interrupt has occurred, - or
	* an error has been reported by any PX, - in case the caller wants
	* cancelOnError
	*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>InterruptPending</name> <operator>||</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>errcode</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>meleeResults</name><operator>-&gt;</operator><name>cancelOnError</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>=</operator> <name>DISPATCH_WAIT_CANCEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fds</name> <operator>=</operator> <operator>(</operator>struct <name>pollfd</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>px_workers_count</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fds</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>finish</name>;</goto></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>px_workers_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>sock</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pxWorkerDesc</name> <operator>=</operator> <name><name>dispatchResult</name><operator>-&gt;</operator><name>pxWorkerDesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pq_is_px_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>px_finished_tasks_count</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>px_task_finished</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Flush outBuff */</comment>
		<expr_stmt><expr><call><name>pq_flush_buffer</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		* Add socket to fd_set if still connected.
		*/</comment>
		<expr_stmt><expr><name>sock</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nfds</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>nfds</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 
		 * If the px finished tasks number equal to px workers
		 * number, means one px task has finished.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_finished_tasks_count</name> <operator>==</operator> <name>px_workers_count</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>px_task_finished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Prevent deal loop */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>finish</name>;</goto>
	</block_content>}</block></if></if_stmt>
<label><name>poll</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_adps_dispatch_wait</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>px_adps_dispatch_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>==</operator> <name>DISPATCH_WAIT_NONE</name> <operator>||</operator> <name>sentSignal</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>DISPATCH_WAIT_TIMEOUT_MSEC</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>DISPATCH_WAIT_CANCEL_TIMEOUT_MSEC</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name>fds</name></expr></argument>, <argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	* Poll returns with an error, including one due to an interrupted
	* call
	*/</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>sock_errno</name> <init>= <expr><name>SOCK_ERRNO</name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>sock_errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>poll</name>;</goto></block_content></block></if></if_stmt>
		<comment type="block">/* no cover begin */</comment>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: handlePollError poll() failed; errno=%d"</literal></expr></argument>, <argument><expr><name>sock_errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pq_thread_handle_error</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: signal to cancel all px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_thread_signalPXs</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sentSignal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* no cover end */</comment>
	</block_content>}</block></if>
	<comment type="block">/* If the time limit expires, poll() returns 0 */</comment>
	<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pParms</name><operator>-&gt;</operator><name>waitMode</name></name> <operator>!=</operator> <name>DISPATCH_WAIT_NONE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: signal to cancel all px"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_thread_signalPXs</name><argument_list>(<argument><expr><name>pParms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>sentSignal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* We have data waiting on one or more of the connections. */</comment>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>currentFdNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>px_workers_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PxDispatchResult</name> <modifier>*</modifier></type><name>dispatchResult</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>dispatchResult</name> <operator>=</operator> <name><name>pParms</name><operator>-&gt;</operator><name>dispatchResultPtrArray</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>pq_is_px_finish</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fds</name><index>[<expr><name>currentFdNumber</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>px_adps_message_handle</name><argument_list>(<argument><expr><name>dispatchResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

<label><name>finish</name>:</label>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PX adaptive scan background thread. It will start in the QC node when
 * px query is running.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>px_adps_coordinator_thread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>px_adps_thread_name</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>px_adps_thread_name</name></expr></argument>, <argument><expr><literal type="string">"pxadps%d"</literal></expr></argument>, <argument><expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>prctl</name><argument_list>(<argument><expr><name>PR_SET_NAME</name></expr></argument>, <argument><expr><name>px_adps_thread_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>proc_exit_inprogress</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"pq_thread: break up px_pq thread when exit process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pxds_backgroup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Prevent spurious wake up */</comment>
			<while>while <condition>(<expr><name>pxds_backgroup</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Wait will unlock automatic */</comment>
				<expr_stmt><expr><call><name>pthread_cond_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pq_wait_cv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Leave wait will lock automatic */</comment>
			</block_content>}</block></while>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Check dynamic state when px query begin */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>px_adps_check_valid</name><argument_list>()</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* In debug mode we want to get a panic result */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"px adaptive scan state is invalid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>px_set_adps_thread_error</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>px_consumer_ds</name><argument_list>(<argument><expr><name>pxds_backgroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Create pq thread when PX_SETUP, no matter px_adaptive_paging */</comment>
<function><type><name>void</name></type>
<name>pxdisp_createPqThread</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>pthread_err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_t</name></type> <name>t_handle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>t_atts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>m_atts</name></decl>;</decl_stmt>

	<comment type="block">/* If guc flag is closed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_adaptive_paging</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>px_adaptive_scan_setup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* init pthread */</comment>
	<expr_stmt><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* init mutex */</comment>
	<expr_stmt><expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutexattr_settype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m_atts</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_ERRORCHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_adps_eno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pq_thread: creating the background libpq thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_attr_setstacksize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>PTHREAD_STACK_MIN</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">128</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pthread_err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_handle</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>, <argument><expr><name>px_adps_coordinator_thread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_attr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pthread_err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pxds_backgroup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_cond_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pq_wait_cv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to create libpq thread"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"pthread_create() failed with err %d"</literal></expr></argument>, <argument><expr><name>pthread_err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Run this function in main thread */</comment>
<function><type><name>void</name></type>
<name>pxdisp_startPqThread</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If guc flag is closed */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_adaptive_paging</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pxds_backgroup</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>px_task_finished</name> <operator>==</operator> <name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pq_thread: starting the background libpq thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* update the ds */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pxds_backgroup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>px_adps_array_free</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pxds_backgroup</name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_cond_signal</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pq_wait_cv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Run this function in main thread */</comment>
<function><type><name>void</name></type>
<name>pxdisp_finishPqThread</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_adaptive_paging</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pxds_backgroup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_task_finished</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>px_adps_array_free</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>px_pq_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"pq_thread: stopping the background libpq thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function></unit>
