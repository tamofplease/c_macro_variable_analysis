<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_gang.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_gang.c
 *	  Query Executor Factory for gangs of PXs.
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	  src/backend/px/dispatcher/px_gang.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>			<comment type="block">/* MyProcPid */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>	<comment type="block">/* PxProcess, Slice, SliceTable */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>				<comment type="block">/* pgstat_report_sessionid() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>			<comment type="block">/* PxWorkerDescriptor */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>			<comment type="block">/* me */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang_async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>			<comment type="block">/* PxNodeInfo */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>			<comment type="block">/* px_role, etc. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>

<comment type="block">/*
 * All PXs are managed by px_workers in QC, QC assigned
 * a unique identifier for each PX, when a PX is created, this
 * identifier is passed along with pxid params, see
 * pxgang_parse_pxid_params()
 *
 * px_identifier is use to go through slice table and find which slice
 * this PX should execute.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>px_identifier</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * size of hash table of interconnect connections
 * equals to 2 * (the number of total segments)
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>ic_htab_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>px_logical_worker_idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>px_logical_total_workers</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* version for compat future, different with remote means not compat*/</comment>
<decl_stmt><decl><type><name>uint64</name></type>		<name>px_compat_version</name> 		<init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>	
<comment type="block">/* incluse version and self, used for decode member */</comment>
<decl_stmt><decl><type><name>uint64</name></type> 		<name>px_serialize_member_count</name>	<init>= <expr><literal type="number">11</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* version for wal sync */</comment>
<decl_stmt><decl><type><name>uint64</name></type>		<name>px_sql_wal_lsn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* value of systemid for authorization */</comment>
<decl_stmt><decl><type><name>uint64</name></type>		<name>px_auth_systemid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>CurrentGangCreating</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CreateGangFunc</name></type> <name>pCreateGangFunc</name> <init>= <expr><name>pxgang_createGang_async</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * pxgang_createGang:
 *
 * Creates a new gang by logging on a session to each segDB involved.
 *
 * call this function in GangContext memory context.
 * elog ERROR or return a non-NULL gang.
 */</comment>
<function><type><name>Gang</name> <modifier>*</modifier></type>
<name>pxgang_createGang</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>, <parameter><decl><type><name>SegmentType</name></type> <name>segmentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pCreateGangFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>pCreateGangFunc</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>segmentType</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Creates a new gang by logging on a session to each segDB involved.
 *
 * elog ERROR or return a non-NULL gang.
 */</comment>
<function><type><name>Gang</name> <modifier>*</modifier></type>
<name>AllocateGang</name><parameter_list>(<parameter><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl></parameter>, <parameter><decl><type><name>GangType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SegmentType</name></type> <name>segmentType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>newGang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"AllocateGang begin."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>!=</operator> <name>PX_ROLE_QC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"dispatch process called with role %d"</literal></expr></argument>, <argument><expr><name>px_role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>segments</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>segmentType</name> <operator>=</operator> <name>SEGMENTTYPE_EXPLICT_WRITER</name></expr>;</expr_stmt></block_content></block></if>
	<comment type="block">/* for extended query like cursor, must specify a reader */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>isExtendedQuery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>segmentType</name> <operator>=</operator> <name>SEGMENTTYPE_EXPLICT_READER</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>segmentType</name> <operator>=</operator> <name>SEGMENTTYPE_ANY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>newGang</name> <operator>=</operator> <call><name>pxgang_createGang</name><argument_list>(<argument><expr><name>segments</name></expr></argument>, <argument><expr><name>segmentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGang</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGang</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Push to the head of the allocated list, later in
	 * pxdisp_destroyDispatcherState() we should recycle them from the head
	 * to restore the original order of the idle gangs.
	 */</comment>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>newGang</name></expr></argument>, <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>allocatedGangs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>ds</name><operator>-&gt;</operator><name>largestGangSize</name></name></expr></argument>, <argument><expr><name><name>newGang</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"AllocateGang end."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * set "whoami" for utility statement. non-utility statement will
		 * overwrite it in function getPxProcessList.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>newGang</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pxconn_setPXIdentifier</name><argument_list>(<argument><expr><name><name>newGang</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newGang</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the segment failure reason by comparing connection error message.
 */</comment>
<function><type><name>bool</name></type>
<name>segment_failure_due_to_recovery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fatal</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fatal_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>error_message</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fatal</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fatal_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * it would be nice if we could check errcode for
	 * ERRCODE_CANNOT_CONNECT_NOW, instead we wind up looking for at the
	 * strings.
	 *
	 * And because if LC_MESSAGES gets set to something which changes the
	 * strings a lot we have to take extreme care with looking at the string.
	 */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><name>fatal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><name>fatal_len</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_STARTUP_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>error_message</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>POSTMASTER_IN_RECOVERY_MSG</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* We could do retries for "sorry, too many clients already" here too */</comment>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reads the GP catalog tables and build a PxNodes structure.
 * It then converts this to a Gang structure and initializes all the non-connection related fields.
 *
 * Call this function in GangContext.
 * Returns a not-null pointer.
 */</comment>
<function><type><name>Gang</name> <modifier>*</modifier></type>
<name>buildGangDefinition</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>segments</name></decl></parameter>, <parameter><decl><type><name>SegmentType</name></type> <name>segmentType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>newGangDefinition</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalPxNodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>workerId</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>totalPxNodes</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"buildGangDefinition:Starting %d qExec processes for gang"</literal></expr></argument>, <argument><expr><name>totalPxNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>getPxWorkerCount</name><argument_list>()</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate a gang */</comment>
	<expr_stmt><expr><name>newGangDefinition</name> <operator>=</operator> <operator>(</operator><name>Gang</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Gang</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>GANGTYPE_UNALLOCATED</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>totalPxNodes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>db_descriptors</name></name> <operator>=</operator>
		<operator>(</operator><name>PxWorkerDescriptor</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>totalPxNodes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PxWorkerDescriptor</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_build_gang_definition_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"px buildGangDefinition inject error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<comment type="block">/* initialize db_descriptors */</comment>
		<macro><name>foreach_with_count</name><argument_list>(<argument>lc</argument>, <argument>segments</argument>, <argument>i</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>workerId</name> <operator>=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>newGangDefinition</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
						<call><name>pxnode_allocateIdlePX</name><argument_list>(<argument><expr><name>workerId</name></expr></argument>, <argument><expr><name>totalPxNodes</name></expr></argument>, <argument><expr><name>segmentType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RecycleGang</name><argument_list>(<argument><expr><name>newGangDefinition</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* destroy */</comment> )</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"buildGangDefinition done"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>newGangDefinition</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add one GUC to the option string.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addOneOption</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>string</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>guc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>guc</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>guc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_PX_NEED_SYNC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>guc</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>bguc</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c %s=%s"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><operator>(</operator><name><name>bguc</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>iguc</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c %s=%d"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>iguc</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>rguc</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c %s=%f"</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name><name>rguc</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>sguc</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><operator>*</operator><name><name>sguc</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c %s="</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * All whitespace characters must be escaped. See
				 * pg_split_opts() in the backend.
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>eguc</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>guc</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>value</name> <init>= <expr><operator>*</operator><name><name>eguc</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>eguc</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c %s="</literal></expr></argument>, <argument><expr><name><name>guc</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * All whitespace characters must be escaped. See
				 * pg_split_opts() in the backend. (Not sure if an enum value
				 * can have whitespace, but let's be prepared.)
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>Insist</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Add GUCs to option string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>makeOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>gucs</name> <init>= <expr><call><name>get_guc_variables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ngucs</name> <init>= <expr><call><name>px_get_num_guc_variables</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxNodeInfo</name> <modifier>*</modifier></type><name>qdinfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qdinfo</name> <operator>=</operator> <call><name>pxnode_getPxNodeInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c polar_px_qc_hostname=%s"</literal></expr></argument>, <argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="string">" -c polar_px_qc_port=%d"</literal></expr></argument>, <argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ngucs</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>guc</name> <init>= <expr><name><name>gucs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>guc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_PX_NEED_SYNC</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>guc</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_USERSET</name> <operator>||</operator>
			 <name><name>guc</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_BACKEND</name> <operator>||</operator>
			 <call><name>px_authenticated_user_is_superuser</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>addOneOption</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><name>guc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>string</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * build_pxid_param
 *
 * Called from the qDisp process to create the "pxid" parameter string
 * to be passed to a qExec that is being started.  NB: Can be called in a
 * thread, so mustn't use palloc/elog/ereport/etc.
 */</comment>
<function><type><name>bool</name></type>
<name>build_pxid_param</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>identifier</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>icHtabSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT64_TIMESTAMP</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_FORMAT</name></cpp:macro> <cpp:value>INT64_FORMAT</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_FORMAT</name></cpp:macro> <cpp:value>"%.14a"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMESTAMP_FORMAT</name></cpp:macro> <cpp:value>"%g"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>systemid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type> <name>random_data</name></decl>;</decl_stmt>

	<comment type="block">/* add a random data for confusing */</comment>
	<expr_stmt><expr><call><name>srandom</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <operator>(</operator><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>random_data</name> <operator>=</operator> <call><name>random</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>systemid</name> <operator>=</operator> <call><name>GetSystemIdentifier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, 
					<argument><expr><name>UINT64_FORMAT</name> <literal type="string">";"</literal> <name>UINT64_FORMAT</name> <literal type="string">";"</literal>
					<name>UINT64_FORMAT</name> <literal type="string">";%d;"</literal> <name>TIMESTAMP_FORMAT</name> <literal type="string">";"</literal>
					<literal type="string">"%d;"</literal> <name>UINT64_FORMAT</name> <literal type="string">";"</literal>
					<literal type="string">"%d;%d;%u;%u"</literal></expr></argument>,
					<argument><expr><name>px_compat_version</name></expr></argument>, <argument><expr><name>px_serialize_member_count</name></expr></argument>,
					<argument><expr><name>systemid</name></expr></argument>, <argument><expr><name>px_session_id</name></expr></argument>, <argument><expr><name>PgStartTime</name></expr></argument>,
					<argument><expr><name>px_enable_replay_wait</name></expr></argument>, <argument><expr><name>px_sql_wal_lsn</name></expr></argument>,
					<argument><expr><name>identifier</name></expr></argument>, <argument><expr><name>icHtabSize</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator><name>px_adaptive_paging</name></expr></argument>, <argument><expr><name>random_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <name>bufsz</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>pxid_next_param</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>cpp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>npp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>cpp</name> <operator>=</operator> <operator>*</operator><name>npp</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>cpp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>npp</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><operator>*</operator><name>npp</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>npp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>*</operator><name>npp</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><operator>*</operator><name>npp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pxgang_parse_pxid_params
 *
 * Called very early in backend initialization, to interpret the "pxid"
 * parameter value that a qExec receives from its qDisp.
 *
 * At this point, client authentication has not been done; the backend
 * command line options have not been processed; GUCs have the settings
 * inherited from the postmaster; etc; so don't try to do too much in here.
 */</comment>
<decl_stmt><decl><type><name>void</name></type>
<name>pxgang_parse_pxid_params</name><argument_list>(<argument><expr>struct <name>Port</name> <operator>*</operator><name>port</name> <call><name>pg_attribute_unused</name><argument_list>()</argument_list></call></expr></argument>,
						 <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>pxid_value</name></expr></argument>)</argument_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pxid</name> <init>= <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>pxid_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>np</name> <init>= <expr><name>pxid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 		<name>recv_compat_version</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> 		<name>recv_serialize_member_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* always set cache px var to true on px */</comment>
	<expr_stmt><expr><name>px_is_executing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_is_planning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_role</name> <operator>=</operator> <name>PX_ROLE_PX</name></expr>;</expr_stmt>

	<comment type="block">/* before global csn supported, we use csn2xid_snapshot to support local csn*/</comment>
	<expr_stmt><expr><name>polar_csn_xid_snapshot</name> <operator>=</operator> <name>polar_csn_enable</name></expr>;</expr_stmt>

	<comment type="block">/* px_compat_version */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recv_compat_version</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>recv_compat_version</name> <operator>!=</operator> <name>px_compat_version</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"px compat version not match, local-remote:%lu-%lu"</literal></expr></argument>, <argument><expr><name>px_compat_version</name></expr></argument>, <argument><expr><name>recv_compat_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>bad</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* px_serialize_member_count*/</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recv_serialize_member_count</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_auth_systemid</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* px_session_id */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"polar_px_session_id"</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* PgStartTime */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_INT64_TIMESTAMP</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>scanint8</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>PgStartTime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>PgStartTime</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>cached_px_enable_replay_wait</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_sql_wal_lsn</name> <operator>=</operator> <call><name>pg_strtouint64</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_identifier</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ic_htab_size</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_adaptive_paging</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* do noting, just param the random data */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Too few items */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cp</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>np</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>recv_serialize_member_count</name> <operator>&gt;</operator> <name>px_serialize_member_count</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
				<condition><expr><name>i</name> <operator>&lt;</operator> <name>recv_serialize_member_count</name> <operator>-</operator> <name>px_serialize_member_count</name></expr>;</condition> 
				<incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pxid_next_param</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"extra pxid param %s"</literal></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else 
		<block>{<block_content>
			<comment type="block">/* error version or member count */</comment>
			<goto>goto <name>bad</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_session_id</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>PgStartTime</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>px_identifier</name> <operator>&lt;</operator> <literal type="number">0</literal>
		<operator>||</operator> <name>ic_htab_size</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>px_sql_wal_lsn</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>

<label><name>bad</name>:</label>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Segment dispatched with invalid option: 'pxid=%s'"</literal></expr></argument>, <argument><expr><name>pxid_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>PxProcess</name> <modifier>*</modifier></type>
<name>makePxProcess</name><parameter_list>(<parameter><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>process</name> <init>= <expr><operator>(</operator><name>PxProcess</name> <operator>*</operator><operator>)</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PxProcess</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxNodeInfo</name> <modifier>*</modifier></type><name>pxinfo</name> <init>= <expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>pxNodeInfo</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>pxinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"required segment is unavailable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>pxinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"required segment IP is unavailable"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>listenerAddr</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>pxinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>remotePort</name></name> <operator>=</operator> <name><name>pxinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>port</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>motionListener</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>motionListener</name></name> <operator>&amp;</operator> <literal type="number">0x0ffff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>backendPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>contentid</name></name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>logicalWorkerInfo</name><operator>.</operator><name>idx</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>contentCount</name></name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>logicalWorkerInfo</name><operator>.</operator><name>total_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>process</name><operator>-&gt;</operator><name>identifier</name></name> <operator>=</operator> <name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>identifier</name></name></expr>;</expr_stmt>
	<return>return <expr><name>process</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create a list of PxProcess and initialize with Gang information.
 *
 * 1) For primary reader gang and primary writer gang, the elements
 * in this list is order by segment index.
 * 2) For entry DB gang and singleton gang, the list length is 1.
 *
 * @directDispatch: might be null
 */</comment>
<function><type><name>void</name></type>
<name>setupPxProcessList</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>gang</name> <init>= <expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"getPxProcessList slice%d gangtype=%d gangsize=%d"</literal></expr></argument>,
						  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name><name>gang</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>gang</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_WRITER</name> <operator>||</operator>
		   <name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_READER</name> <operator>||</operator>
		   <operator>(</operator><name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name> <operator>&amp;&amp;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><name><name>gang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_SINGLETON_READER</name> <operator>&amp;&amp;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gang</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>gang</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>process</name> <init>= <expr><call><name>makePxProcess</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pxconn_setPXIdentifier</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>, <argument><expr><name>process</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slice</name><operator>-&gt;</operator><name>processesMap</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>processesMap</name></name></expr></argument>, <argument><expr><name><name>pxWorkerDesc</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ELOG_DISPATCHER_DEBUG</name><argument_list>(<argument><expr><literal type="string">"Gang assignment: slice%d seg%d count%d identifier%d %s:%d pid=%d"</literal></expr></argument>,
							  <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name><name>process</name><operator>-&gt;</operator><name>contentid</name></name></expr></argument>, 
							  <argument><expr><name><name>process</name><operator>-&gt;</operator><name>contentCount</name></name></expr></argument>, <argument><expr><name><name>process</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>,
							  <argument><expr><name><name>process</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>process</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>,
							  <argument><expr><name><name>process</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * getPxProcessForQC:	Manufacture a PxProcess representing the QC,
 * as if it were a worker from the executor factory.
 *
 * NOTE: Does not support multiple (mirrored) QCs.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>getPxProcessesForQC</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>isPrimary</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<function_decl><type><name>PxNodeInfo</name> <modifier>*</modifier><name>qdinfo</name></type> <name>pg_attribute_unused</name><parameter_list>()</parameter_list>;</function_decl>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isPrimary</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"getPxProcessesForQC: unsupported request for master mirror process"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>qdinfo</name> <operator>=</operator> <call><name>pxnode_getPxNodeInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>node_idx</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qdinfo</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>hostip</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>PxProcess</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set QC listener address to NULL. This will be filled during starting up
	 * outgoing interconnect connection.
	 */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>listenerAddr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name>px_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>=</operator> <operator>(</operator><name>px_listener_port</name> <operator>&amp;</operator> <literal type="number">0x0ffff</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>contentid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper functions
 */</comment>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>gangTypeToString</name><parameter_list>(<parameter><decl><type><name>GangType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GANGTYPE_PRIMARY_WRITER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"primary writer"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_PRIMARY_READER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"primary reader"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_SINGLETON_READER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"singleton reader"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_ENTRYDB_READER</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"entry DB reader"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GANGTYPE_UNALLOCATED</name></expr>:</case>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"unallocated"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>RecycleGang</name><parameter_list>(<parameter><decl><type><name>Gang</name> <modifier>*</modifier></type><name>gp</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forceDestroy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop through the px_worker_descriptors array and, for each
	 * PxWorkerDescriptor: 1) discard the query results (if any), 2)
	 * disconnect the session, and 3) discard any connection error message.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gp</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxWorkerDescriptor</name> <modifier>*</modifier></type><name>pxWorkerDesc</name> <init>= <expr><name><name>gp</name><operator>-&gt;</operator><name>db_descriptors</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pxWorkerDesc</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pxnode_recycleIdlePX</name><argument_list>(<argument><expr><name>pxWorkerDesc</name></expr></argument>, <argument><expr><name>forceDestroy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>PXScanDesc</name></type>
<name>CreatePXScanDesc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PXScanDesc</name></type>	<name>px_scan</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>px_scan</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PXScanDescData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_total_workers</name></name> <operator>=</operator> <name>px_logical_total_workers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_worker_id</name></name> <operator>=</operator> <name>px_logical_worker_idx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_scan_round</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_adaptive_scan</name></name> <operator>=</operator> <name>px_adaptive_paging</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_prefetch_inner_scan</name></name> <operator>=</operator> <name>px_prefetch_inner_executing</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"create px scandesc, worker_id: %d, total_workers: %d"</literal></expr></argument>,
		<argument><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_worker_id</name></name></expr></argument>, <argument><expr><name><name>px_scan</name><operator>-&gt;</operator><name>pxs_total_workers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>px_scan</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> 
<name>get_worker_info_by_identifier</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>slice</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slice</name> <operator>&amp;&amp;</operator> 
		<name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name></name> <operator>&amp;&amp;</operator>
		<name><name>slice</name><operator>-&gt;</operator><name>primaryProcesses</name><operator>-&gt;</operator><name>length</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>idx</name> <operator>&amp;&amp;</operator>
		<name>total_count</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>	<modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PxProcess</name>	<modifier>*</modifier></type><name>px_process</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type> 		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<comment type="block">/* Just reading, so don't check INS/DEL/UPD permissions. */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>slice-&gt;primaryProcesses</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>px_process</name> <operator>=</operator> <operator>(</operator><name>PxProcess</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>px_process</name> <operator>&amp;&amp;</operator> <name><name>px_process</name><operator>-&gt;</operator><name>identifier</name></name> <operator>==</operator> <name>px_identifier</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find PX identifier in db_descriptors"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>idx</name> <operator>=</operator> <name><name>px_process</name><operator>-&gt;</operator><name>contentid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>total_count</name> <operator>=</operator> <name><name>px_process</name><operator>-&gt;</operator><name>contentCount</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>idx</name> <operator>&gt;=</operator> <name>MASTER_CONTENT_ID</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>total_count</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
