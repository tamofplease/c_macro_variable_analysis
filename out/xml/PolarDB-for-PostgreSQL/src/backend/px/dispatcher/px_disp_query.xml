<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/dispatcher/px_disp_query.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * px_disp_query.c
 *	  Functions to dispatch command string or plan to PX executors.
 *
 *
 * Portions Copyright (c) 2005-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	    src/backend/px/dispatcher/px_disp_query.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execUtils_px.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-int.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_conn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_mutate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_srlz.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/tupleremap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_snapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUERY_STRING_TRUNCATE_SIZE</name></cpp:macro> <cpp:value>(1024)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>px_test_print_direct_dispatch_info</name></decl>;</decl_stmt>

<comment type="block">/*
 * We need an array describing the relationship between a slice and
 * the number of "child" slices which depend on it.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>sliceIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>children</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
}</block></struct></type> <name>SliceVec</name>;</typedef>

<comment type="block">/*
 * Parameter structure for Greenplum Database Queries
 */</comment>
<typedef>typedef <type><struct>struct <name>DispatchCommandQueryParms</name>
<block>{
	<comment type="block">/*
	 * The SQL command
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strCommand</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>strCommandlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedQuerytree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedQuerytreelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedPlantree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedPlantreelen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedQueryDispatchDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedQueryDispatchDesclen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedParamslen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Additional information.
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedOidAssignments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedOidAssignmentslen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * serialized Snapshot string
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>serializedSnapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>serializedSnapshotlen</name></decl>;</decl_stmt>
}</block></struct></type> <name>DispatchCommandQueryParms</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fillSliceVector</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type> <name>sliceTable</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>,
				<parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVector</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>buildPXQueryString</name><parameter_list>(<parameter><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>finalLen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pxdisp_buildPlanQueryParms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pxdisp_dispatchX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>serializeParamListInfo</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len_p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Compose and dispatch the POLARPX commands corresponding to a plan tree
 * within a complete parallel plan. (A plan tree will correspond either
 * to an initPlan or to the main plan.)
 *
 * If cancelOnError is true, then any dispatching error, a cancellation
 * request from the client, or an error from any of the associated PXs,
 * may cause the unfinished portion of the plan to be abandoned or canceled;
 * and in the event this occurs before all gangs have been dispatched, this
 * function does not return, but waits for all PXs to stop and exits to
 * the caller's error catcher via ereport(ERROR,...). Otherwise this
 * function returns normally and errors are not reported until later.
 *
 * If cancelOnError is false, the plan is to be dispatched as fully as
 * possible and the PXs allowed to proceed regardless of cancellation
 * requests, errors or connection failures from other PXs, etc.
 *
 * The PxDispatchResults objects allocated for the plan are returned
 * in *pPrimaryResults. The caller, after calling
 * PxCheckDispatchResult(), can examine the PxDispatchResults
 * objects, can keep them as long as needed, and ultimately must free
 * them with pxdisp_destroyDispatcherState() prior to deallocation of
 * the caller's memory context. Callers should use PG_TRY/PG_CATCH to
 * ensure proper cleanup.
 *
 * To wait for completion, check for errors, and clean up, it is
 * suggested that the caller use pxdisp_finishCommand().
 *
 * Note that the slice tree dispatched is the one specified in the EState
 * of the argument QueryDesc as es_cur__slice.
 *
 * Note that the QueryDesc params must include PARAM_EXEC_REMOTE parameters
 * containing the values of any initplans required by the slice to be run.
 * (This is handled by calls to addRemoteExecParamsToParamList() from the
 * functions preprocess_initplans() and ExecutorRun().)
 *
 * Each PX receives its assignment as a message of type 'M' in PostgresMain().
 * The message is deserialized and processed by exec_px_query() in postgres.c.
 */</comment>
<function><type><name>void</name></type>
<name>PxDispatchPlan</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_SRI</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cursors</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryDesc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This function is called only for planned statements.
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need to be careful not to modify the original PlannedStmt, because
	 * it might be a cached plan. So make a copy. A shallow copy of the
	 * fields we don't modify should be enough.
	 */</comment>
	<expr_stmt><expr><name>stmt</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PlannedStmt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>subplans</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name> <operator>=</operator> <operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <call><name>exec_make_plan_constant</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>, <argument><expr><name>is_SRI</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name><operator>-&gt;</operator><name>cursorPositions</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>cursors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pxdisp_dispatchX</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>planRequiresTxn</name></expr></argument>, <argument><expr><name>cancelOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DispatchCommandQueryParms</name> <modifier>*</modifier></type>
<name>pxdisp_buildPlanQueryParms</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>QueryDesc</name></name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>splan</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>sddesc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>sparams</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>splan_len</name></decl>,
				<decl><type ref="prev"/><name>splan_len_uncompressed</name></decl>,
				<decl><type ref="prev"/><name>sddesc_len</name></decl>,
				<decl><type ref="prev"/><name>sparams_len</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>plan_size_in_kb</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <operator>(</operator><name>DispatchCommandQueryParms</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pQueryParms</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * serialized plan tree. Note that we're called for a single slice tree
	 * (corresponding to an initPlan or the main plan), so the parameters are
	 * fixed and we can include them in the prefix.
	 */</comment>
	<expr_stmt><expr><name>splan</name> <operator>=</operator> <call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>splan_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>splan_len_uncompressed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan_size_in_kb</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>splan_len_uncompressed</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">1024</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>px_log_gang</name> <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_TERSE</name><operator>)</operator></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary><operator>)</operator></expr></argument>,
		 <argument><expr><literal type="string">"Query plan size to dispatch: "</literal> <name>UINT64_FORMAT</name> <literal type="string">"KB"</literal></expr></argument>, <argument><expr><name>plan_size_in_kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;</operator> <name>px_max_plan_size</name> <operator>&amp;&amp;</operator> <name>plan_size_in_kb</name> <operator>&gt;</operator> <name>px_max_plan_size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_STATEMENT_TOO_COMPLEX</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Query plan size limit exceeded, current size: "</literal>
						 <name>UINT64_FORMAT</name> <literal type="string">"KB, max allowed size: %dKB"</literal></expr></argument>,
						 <argument><expr><name>plan_size_in_kb</name></expr></argument>, <argument><expr><name>px_max_plan_size</name></expr></argument>)</argument_list></call><operator>,</operator>
				  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Size controlled by px_max_plan_size"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>splan</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>splan_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>splan_len_uncompressed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>params</name><operator>-&gt;</operator><name>numParams</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sparams</name> <operator>=</operator> <call><name>serializeParamListInfo</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>params</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sparams_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>sparams</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sparams_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>sddesc</name> <operator>=</operator> <call><name>serializeNode</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sddesc_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* uncompressed_size */</comment> )</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>strCommand</name></name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>sourceText</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQuerytree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQuerytreelen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantree</name></name> <operator>=</operator> <name>splan</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantreelen</name></name> <operator>=</operator> <name>splan_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedParams</name></name> <operator>=</operator> <name>sparams</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedParamslen</name></name> <operator>=</operator> <name>sparams_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesc</name></name> <operator>=</operator> <name>sddesc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesclen</name></name> <operator>=</operator> <name>sddesc_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedSnapshot</name></name> <operator>=</operator> <call><name>pxsn_get_serialized_snapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedSnapshotlen</name></name> <operator>=</operator> <call><name>pxsn_get_serialized_snapshot_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pQueryParms</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Three Helper functions for pxdisp_dispatchX:
 *
 * Used to figure out the dispatch order for the sliceTable by
 * counting the number of dependent child slices for each slice; and
 * then sorting based on the count (all indepenedent slices get
 * dispatched first, then the slice above them and so on).
 *
 * fillSliceVector: figure out the number of slices we're dispatching,
 * and order them.
 *
 * count_dependent_children(): walk tree counting up children.
 *
 * compare_slice_order(): comparison function for qsort(): order the
 * slices by the number of dependent children. Empty slices are
 * sorted last (to make this work with initPlans).
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_slice_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceVec</name>   <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>SliceVec</name> <operator>*</operator><operator>)</operator> <name>aa</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceVec</name>   <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>SliceVec</name> <operator>*</operator><operator>)</operator> <name>bb</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>slice</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Put the slice not going to dispatch in the last
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * sort slice with larger size first because it has a bigger chance to
	 * contain writers
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>slice</name><operator>-&gt;</operator><name>primaryGang</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>children</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>children</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>children</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>children</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Quick and dirty bit mask operations
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mark_bit</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nthbyte</name> <init>= <expr><name>nth</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>nthbit</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>nth</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>bits</name><index>[<expr><name>nthbyte</name></expr>]</index></name> <operator>|=</operator> <name>nthbit</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>or_bits</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name> <operator>|=</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_bits</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nbyte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name><name>bitcount</name><index>[]</index></name> <init>=
	<expr><block>{
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nbyte</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>nbit</name> <operator>+=</operator> <name><name>bitcount</name><index>[<expr><name><name>bits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nbit</name> <operator>+=</operator> <name><name>bitcount</name><index>[<expr><operator>(</operator><name><name>bits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>nbit</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We use a bitmask to count the dep. childrens.
 * Because of input sharing, the slices now are DAG. We cannot simply go down the
 * tree and add up number of children, which will return too big number.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>markbit_dep_children</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type> <name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIdx</name></decl></parameter>,
					 <parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVec</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bitmasklen</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>bits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>sublist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name> <init>= <expr><operator>&amp;</operator><name><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>sliceIdx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>sublist</argument>, <argument>slice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>childIndex</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newbits</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>markbit_dep_children</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>,
							 <argument><expr><name>sliceVec</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>, <argument><expr><name>newbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>or_bits</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>newbits</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mark_bit</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>childIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newbits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name> <operator>=</operator> <name>sliceIdx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>children</name> <operator>=</operator> <call><name>count_bits</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>slice</name> <operator>=</operator> <name>slice</name></expr>;</expr_stmt>

	<return>return <expr><name><name>sliceVec</name><index>[<expr><name>sliceIdx</name></expr>]</index></name><operator>.</operator><name>children</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Count how many dependent childrens and fill in the sliceVector of dependent childrens.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_dependent_children</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type> <name>sliceTable</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sliceIndex</name></decl></parameter>,
						 <parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bitmasklen</name> <init>= <expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bitmask</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><name>bitmasklen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>markbit_dep_children</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>, <argument><expr><name>sliceIndex</name></expr></argument>, <argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>bitmasklen</name></expr></argument>, <argument><expr><name>bitmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>bitmask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>fillSliceVector</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type> <name>sliceTbl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rootIdx</name></decl></parameter>,
				<parameter><decl><type><name>SliceVec</name> <modifier>*</modifier></type><name>sliceVector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nTotalSlices</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>top_count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * count doesn't include top slice add 1, note that sliceVector would be
	 * modified in place by count_dependent_children.
	 */</comment>
	<expr_stmt><expr><name>top_count</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <call><name>count_dependent_children</name><argument_list>(<argument><expr><name>sliceTbl</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SliceVec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>compare_slice_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>top_count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a query string to be dispatched to PX.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>buildPXQueryString</name><parameter_list>(<parameter><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>finalLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT32_ENCODE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>u32 = htonl(value);\
	memcpy(pos, &amp;u32, sizeof(value));\
	pos += sizeof(value);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT64_ENCODE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>u32 = (uint32) (value &gt;&gt; 32);\
	u32 = htonl(u32);\
	memcpy(pos, &amp;u32, sizeof(u32));\
	pos += sizeof(u32);\
	\
	u32 = (uint32) value;\
	u32 = htonl(u32);\
	memcpy(pos, &amp;u32, sizeof(u32));\
	pos += sizeof(u32);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRN_ENCODE</name><parameter_list>(<parameter><type><name>len</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>u32 = htonl(len);\
	memcpy(pos, &amp;u32, sizeof(len));\
	pos += sizeof(len);\
	if (len &gt; 0)\
	{\
		memcpy(pos, str, len);\
		pos[len - 1] = '\0';\
		pos += len;\
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_ENCODE</name><parameter_list>(<parameter><type><name>len</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro>\
	<cpp:value>u32 = htonl(len);\
	memcpy(pos, &amp;u32, sizeof(len));\
	pos += sizeof(len);\
	if (len &gt; 0)\
	{\
		memcpy(pos, str, len);\
		pos += len;\
	}</cpp:value></cpp:define>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>strCommand</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>command_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querytree</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQuerytree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>querytree_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQuerytreelen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plantree</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantree</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>plantree_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedPlantreelen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>params</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedParams</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>params_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedParamslen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sddesc</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sddesc_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedQueryDispatchDesclen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sdsnapshot</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedSnapshot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sdsnapshot_len</name> <init>= <expr><name><name>pQueryParms</name><operator>-&gt;</operator><name>serializedSnapshotlen</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>currentStatementStartTimestamp</name> <init>= <expr><call><name>GetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>sessionUserId</name> <init>= <expr><call><name>GetSessionUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outerUserId</name> <init>= <expr><call><name>GetOuterUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>currentUserId</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>u32</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_query_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_query</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must allocate query text within px_DispatcherContext,
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>px_DispatcherContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If either querytree or plantree is set then the query string is not so
	 * important, dispatch a truncated version to increase the performance.
	 *
	 * Here we only need to determine the truncated size, the actual work is
	 * done later when copying it to the result buffer.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>querytree</name> <operator>||</operator> <name>plantree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>command_len</name> <operator>=</operator> <call><name>strnlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>QUERY_STRING_TRUNCATE_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>command_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>


	<expr_stmt><expr><name>total_query_len</name> <operator>=</operator> <literal type="number">1</literal> <comment type="block">/* 'M' */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* message length */</comment> <operator>+</operator> 
		<sizeof>sizeof<argument_list>(<argument><expr><name>px_serialize_version</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>sessionUserId</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* sessionUserIsSuper */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>outerUserId</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* outerUserIsSuper */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>currentUserId</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>currentStatementStartTimestamp</name></expr></argument>)</argument_list></sizeof> <comment type="block">/* currentStatementStartTimestamp */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>sql_trace_id</name><operator>.</operator><name>uval</name></name></expr></argument>)</argument_list></sizeof> <comment type="block">/* sqlTraceId */</comment> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>command_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>command_len</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>querytree_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>querytree_len</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>plantree_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>plantree_len</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>params_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>params_len</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>sddesc_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>sddesc_len</name> <operator>+</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name>sdsnapshot_len</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>sdsnapshot_len</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>shared_query</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>total_query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>shared_query</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>pos</name><operator>++</operator> <operator>=</operator> <literal type="char">'M'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>total_query_len</name> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INT32_ENCODE</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INT32_ENCODE</name><argument_list>(<argument><expr><name>px_serialize_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INT32_ENCODE</name><argument_list>(<argument><expr><name>sessionUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INT32_ENCODE</name><argument_list>(<argument><expr><name>outerUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INT32_ENCODE</name><argument_list>(<argument><expr><name>currentUserId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UINT64_ENCODE</name><argument_list>(<argument><expr><name>currentStatementStartTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UINT64_ENCODE</name><argument_list>(<argument><expr><name><name>sql_trace_id</name><operator>.</operator><name>uval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STRN_ENCODE</name><argument_list>(<argument><expr><name>command_len</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STR_ENCODE</name><argument_list>(<argument><expr><name>querytree_len</name></expr></argument>, <argument><expr><name>querytree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STR_ENCODE</name><argument_list>(<argument><expr><name>plantree_len</name></expr></argument>, <argument><expr><name>plantree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STR_ENCODE</name><argument_list>(<argument><expr><name>params_len</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STR_ENCODE</name><argument_list>(<argument><expr><name>sddesc_len</name></expr></argument>, <argument><expr><name>sddesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STR_ENCODE</name><argument_list>(<argument><expr><name>sdsnapshot_len</name></expr></argument>, <argument><expr><name>sdsnapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>total_query_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>finalLen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>finalLen</name> <operator>=</operator> <name>total_query_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>shared_query</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>px_log_querydesc</name><parameter_list>(<parameter><decl><type><name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>ddesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceT</name> <init>= <expr><name><name>ddesc</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><name><name>sliceT</name><operator>-&gt;</operator><name>slices</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>px_enable_print</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary><operator>)</operator></expr></argument>, 
		<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"begin exec px query: sessid %d, trace_id %ld, num slices %d, local slice %d, px_sql_wal_lsn %lX"</literal></expr></argument>,
			<argument><expr><name>px_session_id</name></expr></argument>, <argument><expr><name><name>sql_trace_id</name><operator>.</operator><name>uval</name></name></expr></argument>, <argument><expr><name><name>sliceT</name><operator>-&gt;</operator><name>numSlices</name></name></expr></argument>, 
			<argument><expr><name><name>sliceT</name><operator>-&gt;</operator><name>localSlice</name></name></expr></argument>, <argument><expr><name>px_sql_wal_lsn</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_info_debug</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sliceT</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>ps</name> <init>= <expr><name><name>es</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>primaryProcesses</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sliceIndex: %d, rootIndex: %d, parentIndex: %d, numSegs: %d, gangType: %d"</literal></expr></argument>,
						<argument><expr><name><name>es</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>, <argument><expr><name><name>es</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rootIndex</name></expr></argument>, <argument><expr><name><name>es</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>,  <argument><expr><name><name>es</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>planNumSegments</name></expr></argument>, <argument><expr><name><name>es</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>ps</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>PxProcess</name><operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"    remote addr: %s, remote port: %d, local listen port: %d, pid: %d, contentid: %d, contentCount: %d, identifier: %d"</literal></expr></argument>,
							<argument><expr><name><name>p</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>remotePort</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, 
							<argument><expr><name><name>p</name><operator>-&gt;</operator><name>contentid</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>contentCount</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>identifier</name></name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errhidestmt</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function is used for dispatching sliced plans
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pxdisp_dispatchX</name><parameter_list>(<parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>queryDesc</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>planRequiresTxn</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>cancelOnError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SliceVec</name>   <modifier>*</modifier></type><name>sliceVector</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nSlices</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* slices this dispatch cares about */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nTotalSlices</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* total slices in sliceTbl */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>iSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rootIdx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>queryText</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queryTextLength</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>SliceTable</name></name> <modifier>*</modifier></type><name>sliceTbl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>EState</name></name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxDispatcherState</name> <modifier>*</modifier></type><name>ds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>pxError</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DispatchCommandQueryParms</name> <modifier>*</modifier></type><name>pQueryParms</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_log_dispatch_stats</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetUsage</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>queryDesc</name><operator>-&gt;</operator><name>estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceTbl</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceTbl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rootIdx</name> <operator>=</operator> <call><name>RootSliceIndex</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ds</name> <operator>=</operator> <call><name>pxdisp_makeDispatcherState</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>extended_query</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we intend to execute the plan, inventory the slice tree, allocate
	 * gangs, and associate them with slices.
	 *
	 * On return, gangs have been allocated and PXProcess lists have been
	 * filled in in the slice table.)
	 *
	 * Notice: This must be done before pxdisp_buildPlanQueryParms
	 */</comment>
	<expr_stmt><expr><call><name>AssignGangs</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>queryDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Traverse the slice tree in sliceTbl rooted at rootIdx and build a
	 * vector of slice indexes specifying the order of [potential] dispatch.
	 */</comment>
	<expr_stmt><expr><name>nTotalSlices</name> <operator>=</operator> <name><name>sliceTbl</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sliceVector</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>nTotalSlices</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SliceVec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nSlices</name> <operator>=</operator> <call><name>fillSliceVector</name><argument_list>(<argument><expr><name>sliceTbl</name></expr></argument>, <argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>sliceVector</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Each slice table has a unique-id. */</comment>
	<expr_stmt><expr><name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name> <operator>=</operator> <operator>++</operator><name>px_interconnect_id</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pQueryParms</name> <operator>=</operator> <call><name>pxdisp_buildPlanQueryParms</name><argument_list>(<argument><expr><name>queryDesc</name></expr></argument>, <argument><expr><name>planRequiresTxn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>queryText</name> <operator>=</operator> <call><name>buildPXQueryString</name><argument_list>(<argument><expr><name>pQueryParms</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>px_log_querydesc</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>ddesc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate result array with enough slots for PXs of primary gangs.
	 */</comment>
	<expr_stmt><expr><call><name>pxdisp_makeDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>, <argument><expr><name>cancelOnError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pxdisp_makeDispatchParams</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>nTotalSlices</name></expr></argument>, <argument><expr><name>queryText</name></expr></argument>, <argument><expr><name>queryTextLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>px_total_plans</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_total_slices</name> <operator>+=</operator> <name>nSlices</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nSlices</name> <operator>&gt;</operator> <name>px_max_slices</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_max_slices</name> <operator>=</operator> <name>nSlices</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to start of dispatch send (root %d): %s ms"</literal></expr></argument>,
								<argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>iSlice</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>iSlice</name> <operator>&lt;</operator> <name>nSlices</name></expr>;</condition> <incr><expr><name>iSlice</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Gang</name>	   <modifier>*</modifier></type><name>primaryGang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>slice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>si</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceVector</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>slice</name> <operator>=</operator> <name><name>sliceVector</name><index>[<expr><name>iSlice</name></expr>]</index></name><operator>.</operator><name>slice</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>si</name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Is this a slice we should dispatch?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>slice</name> <operator>&amp;&amp;</operator> <name><name>slice</name><operator>-&gt;</operator><name>gangType</name></name> <operator>==</operator> <name>GANGTYPE_UNALLOCATED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Most slices are dispatched, however, in many cases the root
			 * runs only on the QC and is not dispatched to the PXs.
			 */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>primaryGang</name> <operator>=</operator> <name><name>slice</name><operator>-&gt;</operator><name>primaryGang</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>primaryGang</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>queryDesc</name><operator>-&gt;</operator><name>extended_query</name></name></expr></argument>,
					<argument><expr><name><name>primaryGang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_PRIMARY_READER</name> <operator>||</operator>
					<name><name>primaryGang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_SINGLETON_READER</name> <operator>||</operator>
					<name><name>primaryGang</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>GANGTYPE_ENTRYDB_READER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_test_print_direct_dispatch_info</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"(slice %d) Dispatch command to %s"</literal></expr></argument>, <argument><expr><name><name>slice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
				 <argument><expr><call><name>segmentsToContentStr</name><argument_list>(<argument><expr><name><name>slice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Bail out if already got an error or cancellation request.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>cancelOnError</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ds</name><operator>-&gt;</operator><name>primaryResults</name><operator>-&gt;</operator><name>errcode</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_PX_NEED_CANCELED</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pxdisp_dispatchToGang</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><name>primaryGang</name></expr></argument>, <argument><expr><name>si</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>sliceVector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start a background libpq thread */</comment>
	<expr_stmt><expr><call><name>pxdisp_startPqThread</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* If libpq is not run in background*/</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pxdisp_isDsThreadRuning</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pxdisp_waitDispatchFinish</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If bailed before completely dispatched, stop PXs and throw error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>iSlice</name> <operator>&lt;</operator> <name>nSlices</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pxdisp_dispatch_slices"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><name>px_debug_cancel_print</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG2</name></expr></else></ternary></expr></argument>,
			 <argument><expr><literal type="string">"Plan dispatch canceled; dispatched %d of %d slices"</literal></expr></argument>,
			 <argument><expr><name>iSlice</name></expr></argument>, <argument><expr><name>nSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Cancel any PXs still running, and wait for them to terminate.
		 */</comment>
		<expr_stmt><expr><call><name>pxdisp_cancelDispatch</name><argument_list>(<argument><expr><name>ds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check and free the results of all gangs. If any PX had an error,
		 * report it and exit via PG_THROW.
		 */</comment>
		<expr_stmt><expr><call><name>pxdisp_getDispatchResults</name><argument_list>(<argument><expr><name>ds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pxError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* stop libpq thread if run */</comment>
		<expr_stmt><expr><call><name>pxdisp_finishPqThread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>pxError</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReThrowError</name><argument_list>(<argument><expr><name>pxError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wasn't an error, must have been an interrupt.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Strange! Not an interrupt either.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"unable to dispatch plan"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>msec_str</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><call><name>check_log_duration</name><argument_list>(<argument><expr><name>msec_str</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duration to dispatch out (root %d): %s ms"</literal></expr></argument>,
								<argument><expr><name>rootIdx</name></expr></argument>, <argument><expr><name>msec_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name> <operator>=</operator> <name>ds</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Serialization of query parameters (ParamListInfos).
 *
 * When a query is dispatched from QC to PX, we also need to dispatch any
 * query parameters, contained in the ParamListInfo struct. We need to
 * serialize ParamListInfo, but there are a few complications:
 *
 * - ParamListInfo is not a Node type, so we cannot use the usual
 * nodeToStringBinary() function directly. We turn the array of
 * ParamExternDatas into a List of SerializedParamExternData nodes,
 * which we can then pass to nodeToStringBinary().
 *
 * - The paramFetch callback, which could be used in this process to fetch
 * parameter values on-demand, cannot be used in a different process.
 * Therefore, fetch all parameters before serializing them. When
 * deserializing, leave the callbacks NULL.
 *
 * - In order to deserialize correctly, the receiver needs the typlen and
 * typbyval information for each datatype. The receiver has access to the
 * catalogs, so it could look them up, but for the sake of simplicity and
 * robustness in the receiver, we include that information in
 * SerializedParamExternData.
 *
 * - RECORD types. Type information of transient record is kept only in
 * backend private memory, indexed by typmod. The recipient will not know
 * what a record type's typmod means. And record types can also be nested.
 * Because of that, if there are any RECORD, we include a copy of the whole
 * transient record type cache.
 *
 * If there are no record types involved, we dispatch a list of
 * SerializedParamListInfos, i.e.
 *
 * List&lt;SerializedParamListInfo&gt;
 *
 * With record types, we dispatch:
 *
 * List(List&lt;TupleDescNode&gt;, List&lt;SerializedParamListInfo&gt;)
 *
 * XXX: Sending *all* record types can be quite bulky, but ATM there is no
 * easy way to extract just the needed record types.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>serializeParamListInfo</name><parameter_list>(<parameter><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_records</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Construct a list of SerializedParamExternData */</comment>
	<expr_stmt><expr><name>sparams</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SerializedParamExternData</name> <modifier>*</modifier></type><name>sprm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExternData</name></type> <name>prmdata</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prm</name> <operator>=</operator> <call><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name><argument_list>(<argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
										<argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prm</name> <operator>=</operator> <operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * First, use paramFetch to fetch any "lazy" parameters. (The callback
		 * function is of no use in the PX.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call>(<modifier>*</modifier><name><name>paramLI</name><operator>-&gt;</operator><name>paramFetch</name></name>) <argument_list>(<argument><expr><name>paramLI</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>prmdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>sprm</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>SerializedParamExternData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sprm</name><operator>-&gt;</operator><name>plen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sprm</name><operator>-&gt;</operator><name>pbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Note: We don't want to use lookup_rowtype_tupdesc_copy
				 * here, because it copies defaults and constraints too. We
				 * don't want those.
				 */</comment>
				<expr_stmt><expr><name>found_records</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>plen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>sprm</name><operator>-&gt;</operator><name>pbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>sparams</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>, <argument><expr><name>sprm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If there were any record types, include the transient record type
	 * cache.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>found_records</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sparams</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><call><name>build_tuple_node_list</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>nodeToBinaryStringFast</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>, <argument><expr><name>len_p</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>ParamListInfo</name></type>
<name>deserializeParamListInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>slen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sparams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleRemapper</name> <modifier>*</modifier></type><name>remapper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParamListInfo</name></type> <name>paramLI</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numParams</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iparam</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sparams</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>readNodeFromBinaryString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sparams</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not deserialize query parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If a transient record type cache was included, load it into a
	 * TupleRemapper.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>typelist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>sparams</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>remapper</name> <operator>=</operator> <call><name>CreateTupleRemapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TRHandleTypeLists</name><argument_list>(<argument><expr><name>remapper</name></expr></argument>, <argument><expr><name>typelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>remapper</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Build a new ParamListInfo.
	 */</comment>
	<expr_stmt><expr><name>numParams</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>sparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>paramLI</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>numParams</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ParamExternData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* this clears the callback fields, among others */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>paramLI</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>ParamListInfoData</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>paramLI</name><operator>-&gt;</operator><name>numParams</name></name> <operator>=</operator> <name>numParams</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Read the ParamExternDatas
	 */</comment>
	<expr_stmt><expr><name>iparam</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>sparams</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SerializedParamExternData</name> <modifier>*</modifier></type><name>sprm</name> <init>= <expr><operator>(</operator><name>SerializedParamExternData</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ParamExternData</name> <modifier>*</modifier></type><name>prm</name> <init>= <expr><operator>&amp;</operator><name><name>paramLI</name><operator>-&gt;</operator><name>params</name><index>[<expr><name>iparam</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>sprm</name></expr></argument>, <argument><expr><name>SerializedParamExternData</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not deserialize query parameters"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>ptype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>isnull</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>pflags</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>pflags</name></name></expr>;</expr_stmt>

		<comment type="block">/* If remapping record types is needed, do it. */</comment>
		<if_stmt><if>if <condition>(<expr><name>remapper</name> <operator>&amp;&amp;</operator> <name><name>prm</name><operator>-&gt;</operator><name>ptype</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>TRRemapDatum</name><argument_list>(<argument><expr><name>remapper</name></expr></argument>, <argument><expr><name><name>sprm</name><operator>-&gt;</operator><name>ptype</name></name></expr></argument>, <argument><expr><name><name>sprm</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>prm</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>sprm</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>iparam</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>paramLI</name></expr>;</return>
</block_content>}</block></function>

</unit>
