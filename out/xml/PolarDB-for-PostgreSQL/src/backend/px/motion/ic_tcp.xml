<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/motion/ic_tcp.c"><comment type="block">/*-------------------------------------------------------------------------
 * ic_tcp.c
 *	   Interconnect code specific to TCP transport.
 *
 * Portions Copyright (c) 2005-2008, Greenplum, Inc.
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	    src/backend/px/motion/ic_tcp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>	<comment type="block">/* ExecSlice, SliceTable */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_select.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/tupchunklist.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USECS_PER_SECOND</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSECS_PER_SECOND</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * PxMonotonicTime: used to guarantee that the elapsed time is in
 * the monotonic order between two px_get_monotonic_time calls.
 */</comment>
<typedef>typedef <type><struct>struct <name>PxMonotonicTime</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>beginTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>endTime</name></decl>;</decl_stmt>
}</block></struct></type> <name>PxMonotonicTime</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>px_set_monotonic_begin_time</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>px_get_monotonic_time</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type> <name>px_get_elapsed_ms</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type> <name>px_get_elapsed_us</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>timeCmp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * backlog for listen() call: it is important that this be something like a
 * good match for the maximum number of PXs. Slow insert performance will
 * result if it is too low.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECT_RETRY_MS</name></cpp:macro>	<cpp:value>4000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONNECT_AGGRESSIVERETRY_MS</name></cpp:macro>	<cpp:value>500</cpp:value></cpp:define>


<comment type="block">/* our timeout value for select() and other socket operations. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>tval</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>MotionConn</name> <modifier>*</modifier></type>
<name>getMotionConn</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>iConn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>iConn</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>iConn</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>startOutgoingConnections</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>sendSlice</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutgoingCount</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>format_fd_set</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfds</name></decl></parameter>, <parameter><decl><type><name>mpp_fd_set</name> <modifier>*</modifier></type><name>fds</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pfx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sfx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setupOutgoingConnection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updateOutgoingConnection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errnoSave</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendRegisterMessage</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>readRegisterMessage</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MotionConn</name> <modifier>*</modifier></type><name>acceptIncomingConnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>flushInterconnectListenerBacklog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>waitOnOutbound</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TupleChunkListItem</name></type> <name>RecvTupleChunkFromAnyTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
												   <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
												   <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TupleChunkListItem</name></type> <name>RecvTupleChunkFromTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
												<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
												<parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendEosTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SendChunkTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
			 <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>flushBuffer</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
			<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doSendStopMessageTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpEntryConnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>print_connection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * setupTCPListeningSocket
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupTCPListeningSocket</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>backlog</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>listenerSocketFd</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>listenerPort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errnoSave</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fun</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>addrlen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>service</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>myname</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>localname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>listenerSocketFd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>listenerPort</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * we let the system pick the TCP port here so we don't have to manage
	 * port resources ourselves.  So set the port to 0 (any port)
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>service</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>addrinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>	<comment type="block">/* Allow IPv4 or IPv6 */</comment>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>	<comment type="block">/* Two-way, out of band connection */</comment>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_PASSIVE</name></expr>;</expr_stmt>	<comment type="block">/* For wildcard IP address */</comment>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* Any protocol - TCP implied for network use
								 * due to SOCK_STREAM */</comment>

	<comment type="block">/*
	 * We use INADDR_ANY if we don't have a valid address for ourselves (e.g.
	 * QC local connections tend to be AF_UNIX, or on 127.0.0.1 -- so bind
	 * everything)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name> <operator>||</operator> <name>MyProcPort</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<operator>(</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>!=</operator> <name>AF_INET</name> <operator>&amp;&amp;</operator>
		 <name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>!=</operator> <name>AF_INET6</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>localname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>		<comment type="block">/* We will listen on all network adapters */</comment>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Restrict what IP address we will listen on to just the one that was
		 * used to create this PX session.
		 */</comment>
		<expr_stmt><expr><call><name>getnameinfo</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>addr</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>laddr</name><operator>.</operator><name>salen</name></name></expr></argument>,
					<argument><expr><name>myname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>myname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NI_NUMERICHOST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>|=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>localname</name> <operator>=</operator> <name>myname</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"binding to %s only"</literal></expr></argument>, <argument><expr><name>localname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"binding listener %s"</literal></expr></argument>, <argument><expr><name>localname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>localname</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"getaddrinfo says %s"</literal></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * getaddrinfo() returns a list of address structures, one for each valid
	 * address and family we can use.
	 *
	 * Try each address until we successfully bind. If socket (or bind) fails,
	 * we (close the socket and) try the next address.  This can happen if the
	 * system supports IPv6, but IPv6 is disabled from working, or if it
	 * supports IPv6 and IPv4 is disabled.
	 */</comment>


	<comment type="block">/*
	 * If there is both an AF_INET6 and an AF_INET choice, we prefer the
	 * AF_INET6, because on UNIX it can receive either protocol, whereas
	 * AF_INET can only get IPv4.  Otherwise we'd need to bind two sockets,
	 * one for each protocol.
	 *
	 * Why not just use AF_INET6 in the hints?  That works perfect if we know
	 * this machine supports IPv6 and IPv6 is enabled, but we don't know that.
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>&amp;&amp;</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We got both an INET and INET6 possibility, but we want to prefer
		 * the INET6 one if it works. Reverse the order we got from
		 * getaddrinfo so that we try things in our preferred order. If we got
		 * more possibilities (other AFs??), I don't think we care about them,
		 * so don't worry if the list is more that two, we just rearrange the
		 * first two.
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* second node */</comment>

		<expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name><operator>-&gt;</operator><name>ai_next</name></name></expr>;</expr_stmt>	<comment type="block">/* point old first node to
													 * third node if any */</comment>
		<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>=</operator> <name>addrs</name></expr>;</expr_stmt>	<comment type="block">/* point second node to first */</comment>
		<expr_stmt><expr><name>addrs</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>			<comment type="block">/* start the list with the old second node */</comment>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>addrs</name></expr>;</init> <condition><expr><name>rp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>rp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * getaddrinfo gives us all the parameters for the socket() call as
		 * well as the parameters for the bind() call.
		 */</comment>

		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * we let the system pick the TCP port here so we don't have to manage
		 * port resources ourselves.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* Success */</comment>

		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"bind"</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Make socket non-blocking. */</comment>
	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"fcntl(O_NONBLOCK)"</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"listen"</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>listen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>backlog</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Get the listening socket's port number. */</comment>
	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"getsockname"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>addrlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrlen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Give results to caller. */</comment>
	<expr_stmt><expr><operator>*</operator><name>listenerSocketFd</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

	<comment type="block">/* display which port was chosen by the system. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>listenerPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>addr</name><operator>)</operator><operator>-&gt;</operator><name>sin6_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>listenerPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>addr</name><operator>)</operator><operator>-&gt;</operator><name>sin_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><name>errnoSave</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errnoSave</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect Error: Could not set up tcp listener socket"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* setupListeningSocket */</comment>

<comment type="block">/*
 * Initialize TCP specific comms.
 */</comment>
<function><type><name>void</name></type>
<name>InitMotionTCP</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>listenerSocketFd</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>listenerPort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>tval</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tval</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">500000</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>setupTCPListeningSocket</name><argument_list>(<argument><expr><name>px_interconnect_tcp_listener_backlog</name></expr></argument>, <argument><expr><name>listenerSocketFd</name></expr></argument>, <argument><expr><name>listenerPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* cleanup any TCP-specific comms info */</comment>
<function><type><name>void</name></type>
<name>CleanupMotionTCP</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* nothing to do. */</comment>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Function readPacket() is used to read in the next packet from the given
 * MotionConn.
 *
 * This call blocks until the packet is read in, and is part of a
 * global scheme where senders block until the entire message is sent, and
 * receivers block until the entire message is read.  Both use non-blocking
 * socket calls so that we can handle any PG interrupts.
 *
 * Note, that for speed we want to read a message all in one go,
 * header and all. A consequence is that we may read in part of the
 * next message, which we've got to keep track of ... recvBytes holds
 * the byte-count of the unprocessed messages.
 *
 * PARAMETERS
 *	 conn - MotionConn to read the packet from.
 *
 */</comment>
<comment type="block">/* static inline void */</comment>
<function><type><name>void</name></type>
<name>readPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>,
				<decl><type ref="prev"/><name>bytesRead</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>gotHeader</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>gotPacket</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>rset</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"readpacket: (fd %d) (max %d) outstanding bytes %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* do we have a complete message waiting to be processed ? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>&gt;=</operator> <name>PACKET_HEADER_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gotHeader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"readpacket: returning previously read data (%d)"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * partial message waiting in recv buffer! Move to head of buffer:
	 * eliminate the slack (which will always be at the beginning) in the
	 * buffer
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"readpacket: %s on previous call msgSize %d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>gotHeader</name></expr> ?</condition><then> <expr><literal type="string">"got header"</literal></expr> </then><else>: <expr><literal type="string">"no header"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr><operator>!</operator><name>gotPacket</name> <operator>&amp;&amp;</operator> <name>bytesRead</name> <operator>&lt;</operator> <name>px_interconnect_max_packet_size</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* see if user canceled and stuff like that */</comment>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we read at the end of the buffer, we've eliminated any slack above
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name>bytesRead</name></expr></argument>,
					  <argument><expr><name>px_interconnect_max_packet_size</name> <operator>-</operator> <name>bytesRead</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<do>do
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name> <init>= <expr><name>tval</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* check for the QC cancel for every 2 seconds */</comment>
					<if_stmt><if>if <condition>(<expr><name>retry</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<comment type="block">/* check to see if the dispatcher should cancel */</comment>
						<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

					</block_content>}</block></if></if_stmt>

					<comment type="block">/* see if user canceled and stuff like that */</comment>
					<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error reading an incoming packet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"select from seg%d at %s: %m"</literal></expr></argument>,
										   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
										   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				while <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>;</do>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error reading an incoming packet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"read from seg%d at %s: %m"</literal></expr></argument>,
								   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
								   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"readpacket(); breaking in while (fd %d) recvBytes %d msgSize %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>print_connection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><literal type="string">"interconnect error on"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: connection closed prematurely"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"from Remote Connection: contentId=%d at %s"</literal></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>bytesRead</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gotHeader</name> <operator>&amp;&amp;</operator> <name>bytesRead</name> <operator>&gt;=</operator> <name>PACKET_HEADER_SIZE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* got the header */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>gotHeader</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>=</operator> <name>bytesRead</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>gotHeader</name> <operator>&amp;&amp;</operator> <name>bytesRead</name> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>gotPacket</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"readpacket: got %d bytes"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flushIncomingData</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>trash</name><index>[<expr><literal type="number">8192</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we're in TeardownInterconnect, we should only have to call recv() a
	 * couple of times to empty out our socket buffers
	 */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>trash</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* Function startOutgoingConnections() is used to initially kick-off any outgoing
 * connections for mySlice.
 *
 * This should not be called for root slices (i.e. QC ones) since they don't
 * ever have outgoing connections.
 *
 * PARAMETERS
 *
 *  sendSlice - Slice that this process is member of.
 *  pIncIdx - index in the parent slice list of myslice.
 *
 * RETURNS
 *	 Initialized ChunkTransportState for the Sending Motion Node Id.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkTransportStateEntry</name> <modifier>*</modifier></type>
<name>startOutgoingConnections</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>sendSlice</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutgoingCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>recvSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxProc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>pOutgoingCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>recvSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sendSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>adjustMasterRouting</name><argument_list>(<argument><expr><name>recvSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_aggressive_retry</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>children</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>segments</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <name>px_interconnect_tcp_listener_backlog</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>aggressiveRetry</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>aggressiveRetry</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d setting up sending motion node (aggressive retry is %s)"</literal></expr></argument>,
			 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>transportStates</name><operator>-&gt;</operator><name>aggressiveRetry</name></name></expr> ?</condition><then> <expr><literal type="string">"active"</literal></expr> </then><else>: <expr><literal type="string">"inactive"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>createChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>,
									   <argument><expr><name>sendSlice</name></expr></argument>,
									   <argument><expr><name>recvSlice</name></expr></argument>,
									   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup a MotionConn entry for each of our outbound connections. Request
	 * a connection to each receiving backend's listening port.
	 */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>recvSlice-&gt;primaryProcesses</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>pxProc</name> <operator>=</operator> <operator>(</operator><name>PxProcess</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pxProc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>=</operator> <name>pxProc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsSetupOutgoingConnection</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pOutgoingCount</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>conn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>pEntry</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* startOutgoingConnections */</comment>


<comment type="block">/*
 * setupOutgoingConnection
 *
 * Called by SetupInterconnect when conn-&gt;state == mcsSetupOutgoingConnection.
 *
 * On return, state is:
 *      mcsSetupOutgoingConnection if failed and caller should retry.
 *      mcsConnecting if non-blocking connect() is pending.  Caller should
 *          send registration message when socket becomes write-ready.
 *      mcsSendRegMsg or mcsStarted if connect() completed successfully.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupOutgoingConnection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxProc</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>portNumberStr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>service</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hint</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsSetupOutgoingConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name> <operator>=</operator> <name><name>pxProc</name><operator>-&gt;</operator><name>contentid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * record the destination IP addr and port for error messages. Since the
	 * IP addr might be IPv6, it might have ':' embedded, so in that case, put
	 * '[]' around it so we can see that the string is an IP and port
	 * (otherwise it might look just like an IP).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"[%s]:%d"</literal></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%s:%d"</literal></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Might be retrying due to connection failure etc.  Close old socket. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize hint structure */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_STREAM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt> <comment type="block">/* Allow for IPv4 or IPv6  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_NUMERICSERV</name></cpp:ifdef>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name> <operator>|</operator> <name>AI_NUMERICSERV</name></expr>;</expr_stmt>	<comment type="block">/* Never do name
														 * resolution */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt> <comment type="block">/* Never do name resolution */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>service</name> <operator>=</operator> <name>portNumberStr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>addrs</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>addrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not translate host addr \"%s\", port \"%d\" to address: %s"</literal></expr></argument>,
						<argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we aren't using name resolution, getaddrinfo will return only 1
	 * entry
	 */</comment>

	<comment type="block">/*
	 * Create a socket.  getaddrinfo() returns the parameters needed by
	 * socket()
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error setting up outgoing connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><literal type="string">"socket"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* make socket non-blocking BEFORE we connect. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error setting up outgoing connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><literal type="string">"fcntl(O_NONBLOCK)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect connecting to seg%d slice%d %s "</literal>
								<literal type="string">"pid=%d sockfd=%d"</literal></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
								<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Initiate the connection.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>							<comment type="block">/* connect() EINTR retry loop */</comment>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>connect</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Non-blocking socket never connects immediately, but check anyway. */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sendRegisterMessage</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Retry if a signal was received. */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Normal case: select() will tell us when connection is made. */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINPROGRESS</name> <operator>||</operator>
			<name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsConnecting</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* connect() failed.  Log the error.  Caller should retry. */</comment>
		<expr_stmt><expr><call><name>updateOutgoingConnection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></for>							<comment type="block">/* connect() EINTR retry loop */</comment>
</block_content>}</block></function>								<comment type="block">/* setupOutgoingConnection */</comment>


<comment type="block">/*
 * updateOutgoingConnection
 *
 * Called when connect() succeeds or fails.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>updateOutgoingConnection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errnoSave</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>sizeoferrno</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>errnoSave</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get errno value indicating success or failure. */</comment>
	<if_stmt><if>if <condition>(<expr><name>errnoSave</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<call><name>getsockopt</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>SO_ERROR</name></expr></argument>,
				   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>errnoSave</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sizeoferrno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* getsockopt failed */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect could not connect to seg%d %s"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s sockfd=%d: %m"</literal></expr></argument>,
						   <argument><expr><literal type="string">"getsockopt(SO_ERROR)"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>errnoSave</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* Success!  Advance to next state. */</comment>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<expr_stmt><expr><call><name>sendRegisterMessage</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		<default>default:</default>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errnoSave</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect could not connect to seg%d %s pid=%d; will retry; %s: %m"</literal></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><literal type="string">"connect"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Tell caller to close the socket and try again. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsSetupOutgoingConnection</name></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* updateOutgoingConnection */</comment>

<comment type="block">/* Function sendRegisterMessage() used to send a Register message to the
 * remote destination on the other end of the provided conn.
 *
 * PARAMETERS
 *
 *	 pEntry - ChunkTransportState.
 *	 conn	- MotionConn to send message out on.
 *
 * Called by SetupInterconnect when conn-&gt;state == mcsSetupOutgoingConnection.
 *
 * On return, state is:
 *      mcsSendRegMsg if registration message has not been completely sent.
 *          Caller should retry when socket becomes write-ready.
 *      mcsStarted if registration message has been sent.  Caller can start
 *          sending data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendRegisterMessage</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesToSend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesSent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name>      <modifier>*</modifier></type><name>sliceTbl</name> <init>= <expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>mcsSendRegMsg</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RegisterMessage</name> <modifier>*</modifier></type><name>regMsg</name> <init>= <expr><operator>(</operator><name>RegisterMessage</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>localAddr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>socklen_t</name></type>	<name>addrsize</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>&amp;&amp;</operator>
			   <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>&amp;&amp;</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>px_interconnect_max_packet_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Save local host and port for log messages. */</comment>
		<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>localAddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrsize</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error after making connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"getsockname sockfd=%d remote=%s: %m"</literal></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localAddr</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect sending registration message to seg%d slice%d %s pid=%d from seg%d slice%d %s sockfd=%d"</literal></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
							<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
							<argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>,
							<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>msgBytes</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>recvSliceIndex</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>sendSliceIndex</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>srcContentId</name></name> <operator>=</operator> <name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>srcListenerPort</name></name> <operator>=</operator> <name>px_listener_port</name> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>srcPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>srcSessionId</name></name> <operator>=</operator> <name>px_session_id</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>regMsg</name><operator>-&gt;</operator><name>srcCommandCount</name></name> <operator>=</operator> <name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>;</expr_stmt><empty_stmt>;</empty_stmt>


		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsSendRegMsg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send as much as we can. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>bytesToSend</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesSent</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>, <argument><expr><name>bytesToSend</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bytesSent</name> <operator>==</operator> <name>bytesToSend</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>bytesSent</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>+=</operator> <name>bytesSent</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if>				<comment type="block">/* call me again to send the rest */</comment>
		<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error writing registration message to seg%d at %s"</literal></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"write pid=%d sockfd=%d local=%s: %m"</literal></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Sent it all. */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsStarted</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <name>PACKET_HEADER_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* sendRegisterMessage */</comment>


<comment type="block">/* Function readRegisterMessage() reads a "Register" message off of the conn
 * and places it in the right MotionLayerEntry conn slot based on the contents
 * of the register message.
 *
 * PARAMETERS
 *
 *	 conn - MotionConn to read the register messagefrom.
 *
 * Returns true if message has been received; or false if caller must retry
 * when socket becomes read-ready.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>readRegisterMessage</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesToReceive</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesReceived</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iconn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegisterMessage</name> <modifier>*</modifier></type><name>regMsg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegisterMessage</name></type> <name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>newConn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxproc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name>      <modifier>*</modifier></type><name>sliceTbl</name> <init>= <expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get ready to receive the Register message. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>mcsRecvRegMsg</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsRecvRegMsg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>&amp;&amp;</operator>
			   <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>px_interconnect_max_packet_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Receive all that is available, up to the expected message size. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>bytesToReceive</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bytesReceived</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>, <argument><expr><name>bytesToReceive</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bytesReceived</name> <operator>==</operator> <name>bytesToReceive</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>bytesReceived</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>+=</operator> <name>bytesReceived</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>bytesReceived</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect error reading register message from %s: connection closed"</literal></expr></argument>,
				 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* maybe this peer is already retrying ? */</comment>
			<goto>goto <name>old_conn</name>;</goto>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if>		<comment type="block">/* call me again to receive the rest */</comment>
		<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error reading register message from %s"</literal></expr></argument>,
							<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"read sockfd=%d local=%s: %m"</literal></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Got the whole message.  Convert fields to native byte order.
	 */</comment>
	<expr_stmt><expr><name>regMsg</name> <operator>=</operator> <operator>(</operator><name>RegisterMessage</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>msgBytes</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>msgBytes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>recvSliceIndex</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>recvSliceIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>sendSliceIndex</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>srcContentId</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>srcContentId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>srcListenerPort</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>srcListenerPort</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>srcPid</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>srcPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>srcSessionId</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>srcSessionId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>srcCommandCount</name></name> <operator>=</operator> <name><name>regMsg</name><operator>-&gt;</operator><name>srcCommandCount</name></name></expr>;</expr_stmt>

	<comment type="block">/* Check for valid message format. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>msgBytes</name></name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error reading register message from %s: format not recognized"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"msgBytes=%d expected=%d sockfd=%d local=%s"</literal></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>msgBytes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>regMsg</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get rid of old connections first */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>srcSessionId</name></name> <operator>!=</operator> <name>px_session_id</name> <operator>||</operator>
		<name><name>msg</name><operator>.</operator><name>srcCommandCount</name></name> <operator>&lt;</operator> <name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This is an old connection, which can be safely ignored. We get this
		 * kind of stuff for cases in which one gang participating in the
		 * interconnect exited a query before calling SetupInterconnect().
		 * Later queries wind up receiving their registration messages.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Received invalid, old registration message: "</literal>
			 <literal type="string">"will ignore ('expected:received' session %d:%d ic-id %d:%d)"</literal></expr></argument>,
			 <argument><expr><name>px_session_id</name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcSessionId</name></name></expr></argument>,
			 <argument><expr><name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcCommandCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<goto>goto <name>old_conn</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Verify that the message pertains to one of our receiving Motion nodes. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name> <operator>&lt;=</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator>
		<name><name>msg</name><operator>.</operator><name>recvSliceIndex</name></name> <operator>==</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>sliceId</name></name> <operator>&amp;&amp;</operator>
		<name><name>msg</name><operator>.</operator><name>srcContentId</name></name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* this is a good connection */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* something is wrong */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Invalid registration message received from %s"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"sendSlice=%d recvSlice=%d srcContentId=%d srcPid=%d srcListenerPort=%d srcSessionId=%d srcCommandCount=%d motnode=%d"</literal></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>recvSliceIndex</name></name></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcPid</name></name></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>srcListenerPort</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcSessionId</name></name></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>srcCommandCount</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Find state info for the specified Motion node.  The sender's slice
	 * number equals the motion node id.
	 */</comment>
	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach_with_count</name><argument_list>(<argument>lc</argument>, <argument>pEntry-&gt;sendSlice-&gt;primaryProcesses</argument>, <argument>iconn</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>pxproc</name> <operator>=</operator> <operator>(</operator><name>PxProcess</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pxproc</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>msg</name><operator>.</operator><name>srcContentId</name></name> <operator>==</operator> <name><name>pxproc</name><operator>-&gt;</operator><name>contentid</name></name> <operator>&amp;&amp;</operator>
			<name><name>msg</name><operator>.</operator><name>srcListenerPort</name></name> <operator>==</operator> <name><name>pxproc</name><operator>-&gt;</operator><name>listenerPort</name></name> <operator>&amp;&amp;</operator>
			<name><name>msg</name><operator>.</operator><name>srcPid</name></name> <operator>==</operator> <name><name>pxproc</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>iconn</name> <operator>==</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Invalid registration message received from %s"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"sendSlice=%d srcContentId=%d srcPid=%d srcListenerPort=%d"</literal></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcContentId</name></name></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcListenerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate MotionConn slot corresponding to sender's position in the
	 * sending slice's PxProc list.
	 */</comment>
	<expr_stmt><expr><name>newConn</name> <operator>=</operator> <call><name>getMotionConn</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>iconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>newConn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>
		<name><name>newConn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>mcsNull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Duplicate registration message received from %s"</literal></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Already accepted registration from %s for sendSlice=%d srcContentId=%d srcPid=%d srcListenerPort=%d"</literal></expr></argument>,
						   <argument><expr><name><name>newConn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>,
						   <argument><expr><name><name>msg</name><operator>.</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcListenerPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* message looks good */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect seg%d slice%d sockfd=%d accepted registration message from seg%d slice%d %s pid=%d"</literal></expr></argument>,
						<argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>recvSliceIndex</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>,
						<argument><expr><name><name>msg</name><operator>.</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>sendSliceIndex</name></name></expr></argument>,
						<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>srcPid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy caller's temporary MotionConn to its assigned slot. */</comment>
	<expr_stmt><expr><operator>*</operator><name>newConn</name> <operator>=</operator> <operator>*</operator><name>conn</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newConn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>=</operator> <name>pxproc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newConn</name><operator>-&gt;</operator><name>remoteContentId</name></name> <operator>=</operator> <name><name>msg</name><operator>.</operator><name>srcContentId</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The caller's MotionConn object is no longer valid.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>conn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsNull</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare to begin reading tuples.
	 */</comment>
	<expr_stmt><expr><name><name>newConn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsStarted</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newConn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newConn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newConn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>newConn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>readSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>newConn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>highReadSock</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>highReadSock</name></name> <operator>=</operator> <name><name>newConn</name><operator>-&gt;</operator><name>sockfd</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>dumpEntryConnections</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* we've completed registration of this connection */</comment>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>old_conn</name>:</label>
	<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SHUT_RDWR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * this connection is done, but with sockfd == -1 isn't a "success"
	 */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* readRegisterMessage */</comment>


<comment type="block">/*
 * acceptIncomingConnection
 *
 * accept() a connection request that is pending on the listening socket.
 * Returns a newly palloc'ed MotionConn object; or NULL if the listening
 * socket does not have any pending connection requests.
 */</comment>
<function><type><specifier>static</specifier> <name>MotionConn</name> <modifier>*</modifier></type>
<name>acceptIncomingConnection</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newsockfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>addrsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>remoteAddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>localAddr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Accept a connection.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>							<comment type="block">/* loop until success or EWOULDBLOCK */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remoteAddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remoteAddr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>remoteAddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>newsockfd</name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name>TCP_listenerFd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>remoteAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newsockfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name>errno</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>EINTR</name></expr>:</case>
				<comment type="block">/* A signal arrived.  Loop to retry the accept(). */</comment>
				<break>break;</break>

			<case>case <expr><name>EWOULDBLOCK</name></expr>:</case>
				<comment type="block">/* Connection request queue is empty.  Normal return. */</comment>
				<return>return <expr><name>NULL</name></expr>;</return>

			<case>case <expr><name>EBADF</name></expr>:</case>
			<case>case <expr><name>EFAULT</name></expr>:</case>
			<case>case <expr><name>EINVAL</name></expr>:</case>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32</name></cpp:ifndef>
			<case>case <expr><name>ENOTSOCK</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<case>case <expr><name>EOPNOTSUPP</name></expr>:</case>
				<comment type="block">/* Shouldn't get these errors unless there is a bug. */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error on listener port %d"</literal></expr></argument>,
								<argument><expr><name>px_listener_port</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"accept sockfd=%d: %m"</literal></expr></argument>, <argument><expr><name>TCP_listenerFd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* not reached */</comment>
			<case>case <expr><name>ENOMEM</name></expr>:</case>
			<case>case <expr><name>ENFILE</name></expr>:</case>
			<case>case <expr><name>EMFILE</name></expr>:</case>
			<case>case <expr><name>ENOBUFS</name></expr>:</case>
				<comment type="block">/* Out of resources. */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error on listener port %d"</literal></expr></argument>,
								<argument><expr><name>px_listener_port</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"accept sockfd=%d: %m"</literal></expr></argument>, <argument><expr><name>TCP_listenerFd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>			<comment type="block">/* not reached */</comment>
			<default>default:</default>
				<comment type="block">/* Network problem, connection aborted, etc.  Continue. */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect connection request not completed on listener port %d"</literal></expr></argument>,
								<argument><expr><name>px_listener_port</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"accept sockfd=%d: %m"</literal></expr></argument>, <argument><expr><name>TCP_listenerFd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>						<comment type="block">/* switch (errno) */</comment>
	</block_content>}</block></for>							<comment type="block">/* loop until success or EWOULDBLOCK */</comment>

	<comment type="block">/*
	 * Create a MotionConn object to hold the connection state.
	 */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MotionConn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <name>newsockfd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsAccepted</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>

	<comment type="block">/* Save remote and local host:port strings for error messages. */</comment>
	<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remoteAddr</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>localAddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>newsockfd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrsize</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error after accepting connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"getsockname sockfd=%d remote=%s: %m"</literal></expr></argument>,
						   <argument><expr><name>newsockfd</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localAddr</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make socket non-blocking */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name>newsockfd</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error after accepting connection"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"fcntl(O_NONBLOCK) sockfd=%d remote=%s local=%s: %m"</literal></expr></argument>,
						   <argument><expr><name>newsockfd</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
						   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"Interconnect got incoming connection "</literal>
			 <literal type="string">"from remote=%s to local=%s sockfd=%d"</literal></expr></argument>,
			 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>, <argument><expr><name>newsockfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>conn</name></expr>;</return>
</block_content>}</block></function>								<comment type="block">/* acceptIncomingConnection */</comment>

<comment type="block">/* See ml_ipc.h */</comment>
<function><type><name>void</name></type>
<name>SetupTCPInterconnect</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>index</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>mySlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>aSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTable</name> <init>= <expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>incoming_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outgoing_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>expectedTotalIncoming</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>expectedTotalOutgoing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>iteration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxMonotonicTime</name></type> <name>startTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>logbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>elapsed_ms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>last_qd_check_ms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we can have at most one of these. */</comment>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>sendingChunkTransportState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>interconnect_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>interconnect_context</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkTransportState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize state variables */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>CTS_INITIAL_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>CTS_INITIAL_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChunkTransportStateEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>teardownActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>networkTimeoutIsLogged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceId</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>RecvTupleChunkFrom</name></name> <operator>=</operator> <name>RecvTupleChunkFromTCP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>RecvTupleChunkFromAny</name></name> <operator>=</operator> <name>RecvTupleChunkFromAnyTCP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>SendEos</name></name> <operator>=</operator> <name>SendEosTCP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>SendChunk</name></name> <operator>=</operator> <name>SendChunkTCP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>doSendStopMessage</name></name> <operator>=</operator> <name>doSendStopMessageTCP</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>mySlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>sliceTable</name> <operator>&amp;&amp;</operator>
		   <name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>px_set_monotonic_begin_time</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we'll do some setup for each of our Receiving Motion Nodes. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mySlice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>totalNumProcs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childId</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"Setting up RECEIVING motion node %d"</literal></expr></argument>, <argument><expr><name>childId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name>aSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childId</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we're using directed-dispatch we have dummy primary-process
		 * entries, so we count the entries.
		 */</comment>
		<expr_stmt><expr><name>totalNumProcs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>totalNumProcs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxProc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pxProc</name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pxProc</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>expectedTotalIncoming</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>createChunkTransportState</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>aSlice</name></expr></argument>, <argument><expr><name>mySlice</name></expr></argument>, <argument><expr><name>totalNumProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Initiate outgoing connections.
	 *
	 * startOutgoingConnections() and createChunkTransportState() must not be
	 * called during the lifecycle of sendingChunkTransportState, they will
	 * repalloc() interconnect_context-&gt;states so sendingChunkTransportState
	 * points to invalid memory.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sendingChunkTransportState</name> <operator>=</operator> <call><name>startOutgoingConnections</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>mySlice</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expectedTotalOutgoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>expectedTotalIncoming</name> <operator>&gt;</operator> <name>px_interconnect_tcp_listener_backlog</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SetupTCPInterconnect: too many expected incoming connections(%d), Interconnect setup might possibly fail"</literal></expr></argument>, <argument><expr><name>expectedTotalIncoming</name></expr></argument>)</argument_list></call><operator>,</operator>
						  <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Try enlarging the px_interconnect_tcp_listener_backlog GUC value and OS net.core.somaxconn parameter"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SetupInterconnect will activate "</literal>
								<literal type="string">"%d incoming, %d outgoing routes.  "</literal>
								<literal type="string">"Listening on port=%d sockfd=%d."</literal></expr></argument>,
								<argument><expr><name>expectedTotalIncoming</name></expr></argument>, <argument><expr><name>expectedTotalOutgoing</name></expr></argument>,
								<argument><expr><name>px_listener_port</name></expr></argument>, <argument><expr><name>TCP_listenerFd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop until all connections are completed or time limit is exceeded.
	 */</comment>
	<while>while <condition>(<expr><name>outgoing_count</name> <operator>&lt;</operator> <name>expectedTotalOutgoing</name> <operator>||</operator>
		   <name>incoming_count</name> <operator>&lt;</operator> <name>expectedTotalIncoming</name></expr>)</condition>
	<block>{<block_content>							<comment type="block">/* select() loop */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>rset</name></decl>,
					<decl><type ref="prev"/><name>wset</name></decl>,
					<decl><type ref="prev"/><name>eset</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>highsock</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>timeout_ms</name> <init>= <expr><literal type="number">20</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>outgoing_fail_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>select_errno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>iteration</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Expecting any new inbound connections? */</comment>
		<if_stmt><if>if <condition>(<expr><name>incoming_count</name> <operator>&lt;</operator> <name>expectedTotalIncoming</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>TCP_listenerFd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupTCPInterconnect: bad listener"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name>TCP_listenerFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>highsock</name> <operator>=</operator> <name>TCP_listenerFd</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Inbound connections awaiting registration message */</comment>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>interconnect_context-&gt;incompleteConns</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>(</operator><name>MotionConn</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>!=</operator> <name>mcsRecvRegMsg</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupTCPInterconnect: incomplete connection bad state or bad fd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>highsock</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>highsock</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<comment type="block">/* Outgoing connections */</comment>
		<expr_stmt><expr><name>outgoing_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <ternary><condition><expr><name>sendingChunkTransportState</name></expr> ?</condition><then> <expr><name><name>sendingChunkTransportState</name><operator>-&gt;</operator><name>numConns</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>sendingChunkTransportState</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

			<comment type="block">/* Time to cancel incomplete connect() and retry? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsConnecting</name> <operator>&amp;&amp;</operator>
				<name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>&lt;=</operator> <name>elapsed_ms</name> <operator>+</operator> <literal type="number">20</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
							  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect timeout: Connection "</literal>
									 <literal type="string">"to seg%d %s from local port %s was not "</literal>
									 <literal type="string">"complete after "</literal> <name>UINT64_FORMAT</name>
									 <literal type="string">"ms "</literal> <name>UINT64_FORMAT</name> <literal type="string">" elapsed.  Will retry."</literal></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>,
									 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name></expr></argument>, <argument><expr><operator>(</operator><name>elapsed_ms</name> <operator>+</operator> <literal type="number">20</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsSetupOutgoingConnection</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Time to connect? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsSetupOutgoingConnection</name> <operator>&amp;&amp;</operator>
				<name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>&lt;=</operator> <name>elapsed_ms</name> <operator>+</operator> <literal type="number">20</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setupOutgoingConnection</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>sendingChunkTransportState</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>mcsSetupOutgoingConnection</name></expr>:</case>
						<comment type="block">/* Retry failed connection after awhile. */</comment>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <operator>(</operator><name>iteration</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>elapsed_ms</name></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>mcsConnecting</name></expr>:</case>
						<comment type="block">/* Set time limit for connect() to complete. */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>aggressiveRetry</name></name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <name>CONNECT_AGGRESSIVERETRY_MS</name> <operator>+</operator> <name>elapsed_ms</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <name>CONNECT_RETRY_MS</name> <operator>+</operator> <name>elapsed_ms</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* What events are we watching for? */</comment>
			<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>mcsNull</name></expr>:</case>
					<break>break;</break>
				<case>case <expr><name>mcsSetupOutgoingConnection</name></expr>:</case>
					<expr_stmt><expr><name>outgoing_fail_count</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>mcsConnecting</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupTCPInterconnect: bad fd, mcsConnecting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>highsock</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>highsock</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>mcsSendRegMsg</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupTCPInterconnect: bad fd, mcsSendRegMsg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>highsock</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>highsock</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>mcsStarted</name></expr>:</case>
					<expr_stmt><expr><name>outgoing_count</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupTCPInterconnect: bad connection state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>-</operator> <name>elapsed_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>						<comment type="block">/* loop to set up outgoing connections */</comment>

		<comment type="block">/* Break out of select() loop if completed all connections. */</comment>
		<if_stmt><if>if <condition>(<expr><name>outgoing_count</name> <operator>==</operator> <name>expectedTotalOutgoing</name> <operator>&amp;&amp;</operator>
			<name>incoming_count</name> <operator>==</operator> <name>expectedTotalIncoming</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Been here long?  Bail if px_interconnect_setup_timeout exceeded.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>interconnect_setup_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>to</name> <init>= <expr><name>interconnect_setup_timeout</name> <operator>*</operator> <literal type="number">1000</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>to</name> <operator>&lt;=</operator> <name>elapsed_ms</name> <operator>+</operator> <literal type="number">20</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect timeout: Unable to "</literal>
									   <literal type="string">"complete setup of all connections "</literal>
									   <literal type="string">"within time limit."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Completed %d of %d incoming and "</literal>
										  <literal type="string">"%d of %d outgoing connections.  "</literal>
										  <literal type="string">"px_interconnect_setup_timeout = %d "</literal>
										  <literal type="string">"seconds."</literal></expr></argument>,
										  <argument><expr><name>incoming_count</name></expr></argument>, <argument><expr><name>expectedTotalIncoming</name></expr></argument>,
										  <argument><expr><name>outgoing_count</name></expr></argument>, <argument><expr><name>expectedTotalOutgoing</name></expr></argument>,
										  <argument><expr><name>interconnect_setup_timeout</name></expr></argument>)</argument_list></call>
								<operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* don't wait for more than 500ms */</comment>
			<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">500</literal></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><name>to</name> <operator>-</operator> <name>elapsed_ms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check if segments have errors already for every 2 seconds */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name> <operator>&amp;&amp;</operator> <name>elapsed_ms</name> <operator>-</operator> <name>last_qd_check_ms</name> <operator>&gt;</operator> <literal type="number">2000</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_qd_check_ms</name> <operator>=</operator> <name>elapsed_ms</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If no socket events to wait for, loop to retry after a pause.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>highsock</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>timeout_ms</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>iteration</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SetupInterconnect+"</literal> <name>UINT64_FORMAT</name>
									 <literal type="string">"ms:   pause "</literal> <name>UINT64_FORMAT</name> <literal type="string">"ms   "</literal>
									 <literal type="string">"outgoing_fail=%d iteration=%d"</literal></expr></argument>,
									 <argument><expr><name>elapsed_ms</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>,
									 <argument><expr><name>outgoing_fail_count</name></expr></argument>, <argument><expr><name>iteration</name></expr></argument>)</argument_list></call>
							  <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Shouldn't be in this loop unless we have some work to do. */</comment>
			<if_stmt><if>if <condition>(<expr><name>outgoing_fail_count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupInterconnect: invalid outgoing count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Wait until earliest wakeup time or overall timeout. */</comment>
			<if_stmt><if>if <condition>(<expr><name>timeout_ms</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>timeout_ms</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Back to top of loop and look again. */</comment>
			<expr_stmt><expr><name>elapsed_ms</name> <operator>=</operator> <call><name>px_get_elapsed_ms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Wait for socket events.
		 *
		 * In order to handle errors at intervals less than the full timeout
		 * length, we limit our select(2) wait to a maximum of 500ms.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>timeout_ms</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>timeout_ms</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt> <comment type="block">/* 0 */</comment>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name>timeout_ms</name> <operator>-</operator> <operator>(</operator><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>timeout_ms</name> <operator>==</operator> <name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>format_fd_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><literal type="string">"r={"</literal></expr></argument>, <argument><expr><literal type="string">"} "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>format_fd_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>, <argument><expr><literal type="string">"w={"</literal></expr></argument>, <argument><expr><literal type="string">"} "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>format_fd_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>eset</name></expr></argument>, <argument><expr><literal type="string">"e={"</literal></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>elapsed_ms</name> <operator>=</operator> <call><name>px_get_elapsed_ms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SetupInterconnect+"</literal> <name>UINT64_FORMAT</name>
									<literal type="string">"ms:   select()  "</literal>
									<literal type="string">"Interest: %s.  timeout="</literal> <name>UINT64_FORMAT</name> <literal type="string">"ms "</literal>
									<literal type="string">"outgoing_fail=%d iteration=%d"</literal></expr></argument>,
									<argument><expr><name>elapsed_ms</name></expr></argument>, <argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>,
									<argument><expr><name>outgoing_fail_count</name></expr></argument>, <argument><expr><name>iteration</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>wset</name></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>eset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>select_errno</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>elapsed_ms</name> <operator>=</operator> <call><name>px_get_elapsed_ms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Log the select() if requested.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name> <operator>||</operator>
				<name>n</name> <operator>!=</operator> <name>expectedTotalIncoming</name> <operator>+</operator> <name>expectedTotalOutgoing</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>n</name> <operator>==</operator> <name>expectedTotalIncoming</name> <operator>+</operator> <name>expectedTotalOutgoing</name><operator>)</operator></expr>
				?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><literal type="string">"result=%d  Ready: "</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>format_fd_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><literal type="string">"r={"</literal></expr></argument>, <argument><expr><literal type="string">"} "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>format_fd_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>, <argument><expr><literal type="string">"w={"</literal></expr></argument>, <argument><expr><literal type="string">"} "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>format_fd_set</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><name>highsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>eset</name></expr></argument>, <argument><expr><literal type="string">"e={"</literal></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"error"</literal></expr> </then><else>: <expr><literal type="string">"timeout"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SetupInterconnect+"</literal> <name>UINT64_FORMAT</name> <literal type="string">"ms:   select()  %s"</literal></expr></argument>,
										<argument><expr><name>elapsed_ms</name></expr></argument>, <argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>logbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>logbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* An error other than EINTR is not acceptable */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>select_errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error in select: %s"</literal></expr></argument>,
							<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>select_errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/*
		 * check our connections that are accepted'd but no register message.
		 * we don't know which motion node these apply to until we actually
		 * receive the REGISTER message.  this is why they are all in a single
		 * list.
		 *
		 * NOTE: we don't use foreach() here because we want to trim from the
		 * list as we go.
		 *
		 * We used to bail out of the while loop when incoming_count hit
		 * expectedTotalIncoming, but that causes problems if some connections
		 * are left over -- better to just process them here.
		 */</comment>
		<expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cell</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>(</operator><name>MotionConn</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * we'll get the next cell ready now in case we need to delete the
			 * cell that corresponds to our MotionConn
			 */</comment>
			<expr_stmt><expr><name>cell</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>readRegisterMessage</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * We're done with this connection (either it is bogus
					 * (and has been dropped), or we've added it to the
					 * appropriate hash table)
					 */</comment>
					<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* is the connection ready ? */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>incoming_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<comment type="block">/* Free temporary MotionConn storage. */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Someone tickling our listener port?  Accept pending connections.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name>TCP_listenerFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>(</operator><name>conn</name> <operator>=</operator> <call><name>acceptIncomingConnection</name><argument_list>()</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * get the connection read for a subsequent call to
				 * ReadRegisterMessage()
				 */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsRecvRegMsg</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RegisterMessage</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name> <operator>=</operator> <call><name>CreateTupleRemapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Check our outgoing connections.
		 */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <name>outgoing_count</name> <operator>&lt;</operator> <name>expectedTotalOutgoing</name> <operator>&amp;&amp;</operator>
			   <name>i</name> <operator>&lt;</operator> <name><name>sendingChunkTransportState</name><operator>-&gt;</operator><name>numConns</name></name></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* loop to check outgoing connections */</comment>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>sendingChunkTransportState</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
			<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>mcsConnecting</name></expr>:</case>
					<comment type="block">/* Has connect() succeeded or failed? */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call> <operator>||</operator>
						<call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eset</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>updateOutgoingConnection</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>sendingChunkTransportState</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<switch>switch <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
						<block>{<block_content>
							<case>case <expr><name>mcsSetupOutgoingConnection</name></expr>:</case>
								<comment type="block">/* Failed.  Wait awhile before retrying. */</comment>
								<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <operator>(</operator><name>iteration</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>+</operator> <name>elapsed_ms</name></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>mcsSendRegMsg</name></expr>:</case>
								<comment type="block">/* Connected, but reg msg not fully sent. */</comment>
								<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
								<break>break;</break>
							<case>case <expr><name>mcsStarted</name></expr>:</case>
								<comment type="block">/* Connected, sent reg msg, ready to rock. */</comment>
								<expr_stmt><expr><name>outgoing_count</name><operator>++</operator></expr>;</expr_stmt>
								<break>break;</break>
							<default>default:</default>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupInterconnect: bad outgoing state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></switch>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<case>case <expr><name>mcsSendRegMsg</name></expr>:</case>
					<comment type="block">/* Ready to continue sending? */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>sendRegisterMessage</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>sendingChunkTransportState</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsStarted</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>outgoing_count</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>

				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>

		</block_content>}</block></while>						<comment type="block">/* loop to check outgoing connections */</comment>

		<comment type="block">/* By now we have dealt with all the events reported by select(). */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SetupInterconnect: extra select events."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>							<comment type="block">/* select() loop */</comment>

	<comment type="block">/*
	 * if everything really got setup properly then we shouldn't have any
	 * incomplete connections.
	 *
	 * XXX: In some cases (when the previous query got 'fast-track cancelled'
	 * because of an error during setup) we can wind up with connections here
	 * which ought to have been cleaned up. These connections should be closed
	 * out here. It would obviously be better if we could avoid these
	 * connections in the first place!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Incomplete connections after known connections done, cleaning %d"</literal></expr></argument>,
				 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>(</operator><name>MotionConn</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>flushIncomingData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_TERSE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>elapsed_ms</name> <operator>=</operator> <call><name>px_get_elapsed_ms</name><argument_list>(<argument><expr><operator>&amp;</operator><name>startTime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name> <operator>||</operator>
			<name>elapsed_ms</name> <operator>&gt;=</operator> <literal type="number">0.1</literal> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <name>interconnect_setup_timeout</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SetupInterconnect+"</literal> <name>UINT64_FORMAT</name> <literal type="string">"ms: Activated %d incoming, "</literal>
				 <literal type="string">"%d outgoing routes."</literal></expr></argument>,
				 <argument><expr><name>elapsed_ms</name></expr></argument>, <argument><expr><name>incoming_count</name></expr></argument>, <argument><expr><name>outgoing_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name>interconnect_context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>								<comment type="block">/* SetupInterconnect */</comment>

<comment type="block">/* TeardownInterconnect() function is used to cleanup interconnect resources that
 * were allocated during SetupInterconnect().  This function should ALWAYS be
 * called after SetupInterconnect to avoid leaking resources (like sockets)
 * even if SetupInterconnect did not complete correctly.  As a result, this
 * function must complete successfully even if SetupInterconnect didn't.
 *
 * SetupInterconnect() always gets called under the ExecutorState MemoryContext.
 * This context is destroyed at the end of the query and all memory that gets
 * allocated under it is free'd.  We don't have have to worry about pfree() but
 * we definitely have to worry about socket resources.
 */</comment>
<function><type><name>void</name></type>
<name>TeardownTCPInterconnect</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>hasErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>mySlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>transportStates</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"TeardownTCPInterconnect: missing slice table."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we're already trying to clean up after an error -- don't allow
	 * signals to interrupt us
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasErrors</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mySlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceId</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Log the start of TeardownInterconnect. */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_TERSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasErrors</name> <operator>||</operator> <operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG1</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG4</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>elevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect seg%d slice%d cleanup state: "</literal>
									<literal type="string">"%s; setup was %s"</literal></expr></argument>,
									<argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>hasErrors</name></expr> ?</condition><then> <expr><literal type="string">"force"</literal></expr> </then><else>: <expr><literal type="string">"normal"</literal></expr></else></ternary></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr> ?</condition><then> <expr><literal type="string">"completed"</literal></expr> </then><else>: <expr><literal type="string">"exited"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* if setup did not complete, log the slicetable */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name> <operator>&amp;&amp;</operator>
			<name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"local slice table"</literal></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * phase 1 mark all sockets (senders and receivers) with shutdown(2),
	 * start with incomplete connections (if any).
	 */</comment>

	<comment type="block">/*
	 * The incompleteConns list is only used as a staging area for MotionConns
	 * during by SetupInterconnect().  So we only expect to have entries here
	 * if SetupInterconnect() did not finish correctly.
	 *
	 * NOTE: we don't use foreach() here because we want to trim from the list
	 * as we go.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>&amp;&amp;</operator>
		<name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Found incomplete conn. length %d"</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * These are connected inbound peers that we haven't dealt with quite yet
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>cell</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><operator>(</operator><name>MotionConn</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* they're incomplete, so just slam them shut. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>flushIncomingData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* free up the tuple remapper */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>DestroyTupleRemapper</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The list operations are kind of confusing (see list.c), we could
		 * alternatively write the following line as:
		 *
		 * incompleteConns = list_delete_cell(incompleteConns, cell, NULL); or
		 * incompleteConns = list_delete_first(incompleteConns); or
		 * incompleteConns = list_delete_ptr(incompleteConns, conn)
		 */</comment>
		<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <call><name>list_delete</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now "normal" connections which made it through our peer-registration
	 * step. With these we have to worry about "in-flight" data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cleanup a Sending motion node. */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d closing connections to slice%d"</literal></expr></argument>,
				 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* free up the tuple remapper */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>DestroyTupleRemapper</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * cleanup all of our Receiving Motion nodes, these get closed immediately
	 * (the receiver know for real if they want to shut down -- they aren't
	 * going to be processing any more data).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mySlice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>aSlice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childId</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>aSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childId</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Interconnect closing connections from slice%d"</literal></expr></argument>,
				 <argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * receivers know that they no longer care about data from below ...
		 * so we can safely discard data queued in both directions
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>flushIncomingData</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

				<comment type="block">/* free up the tuple remapper */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>DestroyTupleRemapper</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>removeChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * phase 2: wait on all sockets for completion, when complete call close
	 * and free (if required)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cleanup a Sending motion node. */</comment>
		<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * On a normal teardown routine, sender has sent an EOS packet and
		 * disabled further send operations on phase 1. sender can't close the
		 * connection immediately because EOS packet or data packets within
		 * the kernel sending buffer may be lost on some platform if sender
		 * close the connection totally.
		 *
		 * The correct way is sender blocks on the connection until receivers
		 * get the EOS packets and close the peer, then it's safe for sender
		 * to close the connection totally.
		 *
		 * If some errors are happening, senders can skip this step to avoid
		 * hung issues, QC will take care of the error handling.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hasErrors</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>waitOnOutbound</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>removeChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there are clients waiting on our listener; we *must* disconnect
	 * them; otherwise we'll be out of sync with the client (we may accept
	 * them on a subsequent query!)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>TCP_listenerFd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>flushInterconnectListenerBacklog</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hasErrors</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG4</name></expr></argument>, <argument><expr><literal type="string">"TeardownInterconnect successful"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
<function><type><name>void</name></type>
<name>dumpEntryConnections</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
			<name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsNull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"... motNodeId=%d conns[%d]:         not connected"</literal></expr></argument>,
				 <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"... motNodeId=%d conns[%d]:  "</literal>
				 <literal type="string">"%d pid=%d sockfd=%d remote=%s local=%s"</literal></expr></argument>,
				 <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
				 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>,
				 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
				 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>localHostAndPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_connection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in</name></name></type> <name>local</name></decl>,
				<decl><type ref="prev"/><name>remote</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>errlevel</name> <init>= <expr><ternary><condition><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>remote</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getpeername</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>remote</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>errlevel</name></expr></argument>, <argument><expr><literal type="string">"print_connection(%d, %s): can't get peername err: %m"</literal></expr></argument>,
			 <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>local</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>local</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>errlevel</name></expr></argument>, <argument><expr><literal type="string">"print_connection(%d, %s): can't get localname err: %m"</literal></expr></argument>,
			 <argument><expr><name>fd</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"%s: w/ports (%d/%d)"</literal></expr></argument>,
		 <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>local</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ntohs</name><argument_list>(<argument><expr><name><name>remote</name><operator>.</operator><name>sin_port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>format_fd_set</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nfds</name></decl></parameter>, <parameter><decl><type><name>mpp_fd_set</name> <modifier>*</modifier></type><name>fds</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pfx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sfx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nfds</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>fds</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>flushInterconnectListenerBacklog</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pendingConn</name></decl>,
				<decl><type ref="prev"/><name>newfd</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>rset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name>TCP_listenerFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>pendingConn</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>TCP_listenerFd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pendingConn</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pendingConn</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>remoteAddr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>localAddr</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>remoteHostAndPort</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>localHostAndPort</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>socklen_t</name></type>	<name>addrsize</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>remoteAddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
				<expr_stmt><expr><name>newfd</name> <operator>=</operator> <call><name>accept</name><argument_list>(<argument><expr><name>TCP_listenerFd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>remoteAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>newfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect error while clearing incoming connections."</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s sockfd=%d: %m"</literal></expr></argument>, <argument><expr><literal type="string">"accept"</literal></expr></argument>, <argument><expr><name>newfd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Get remote and local host:port strings for message. */</comment>
					<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>remoteAddr</name></expr></argument>, <argument><expr><name>remoteHostAndPort</name></expr></argument>,
									<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remoteHostAndPort</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>addrsize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>localAddr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localAddr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrsize</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error while clearing incoming connections"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"getsockname sockfd=%d remote=%s: %m"</literal></expr></argument>,
										   <argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>remoteHostAndPort</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localAddr</name></expr></argument>, <argument><expr><name>localHostAndPort</name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localHostAndPort</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect clearing incoming connection "</literal>
												<literal type="string">"from remote=%s to local=%s.  sockfd=%d."</literal></expr></argument>,
												<argument><expr><name>remoteHostAndPort</name></expr></argument>, <argument><expr><name>localHostAndPort</name></expr></argument>,
												<argument><expr><name>newfd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* make socket non-blocking */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"During incoming queue flush, could not set non-blocking."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* shutdown this socket */</comment>
					<expr_stmt><expr><call><name>flushIncomingData</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>newfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>pendingConn</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error during listener cleanup"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"select sockfd=%d: %m"</literal></expr></argument>, <argument><expr><name>TCP_listenerFd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * now we either loop through for another check (on EINTR or if we
		 * cleaned one client) or we're done
		 */</comment>
	</block_content>}</block>
	while <condition>(<expr><name>pendingConn</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
 * Wait for our peer to close the socket (at which point our select(2)
 * will tell us that the socket is ready to read, and the socket-read
 * will only return 0.
 *
 * This works without the select, but burns tons of CPU doing nothing
 * useful.
 *
 * ----
 * The way it used to work, is we used CHECK_FOR_INTERRUPTS(), and
 * wrapped it in PG_TRY: We *must* return locally; otherwise
 * TeardownInterconnect() can't exit cleanly. So we wrap our
 * cancel-detection checks for interrupts with a PG_TRY block.
 *
 * By swallowing the non-local return on cancel, we lose the "cancel"
 * state (CHECK_FOR_INTERRUPTS() clears QueryCancelPending()). So we
 * should just check QueryCancelPending here ... and avoid calling
 * CHECK_FOR_INTERRUPTS().
 *
 * ----
 *
 * Now we just check explicitly for interrupts (which is, as far as I
 * can tell, the only interrupt-driven state change we care
 * about). This should give us notification of ProcDiePending and
 * QueryCancelPending
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>waitOnOutbound</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>waitset</name></decl>,
				<decl><type ref="prev"/><name>curset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxfd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>,
				<decl><type ref="prev"/><name>conn_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;</operator> <name>maxfd</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxfd</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>conn_count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>saved_err</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>conn_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_PX_NEED_CANCELED</name><argument_list>()</argument_list></call> <operator>||</operator> <name>QueryFinishPending</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"waitOnOutbound(): interrupt pending fast-track"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">500000</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitset</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mpp_fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>maxfd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>curset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>saved_err</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IS_PX_NEED_CANCELED</name><argument_list>()</argument_list></call> <operator>||</operator> <name>QueryFinishPending</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Something unexpected, but probably not horrible warn and return
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"TeardownTCPInterconnect: waitOnOutbound select errno=%d"</literal></expr></argument>, <argument><expr><name>saved_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>curset</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name>buf</name></decl>;</decl_stmt>

				<comment type="block">/* ready to read. */</comment>
				<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>count</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>	<comment type="block">/* done ! */</comment>
				<block>{<block_content>
					<comment type="block">/* got a stop message */</comment>
					<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>count</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name> <operator>==</operator> <literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>MPP_FD_CLR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* we may have finished */</comment>
					<expr_stmt><expr><name>conn_count</name><operator>--</operator></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Something unexpected, but probably not horrible warn and
				 * return
				 */</comment>
				<expr_stmt><expr><call><name>MPP_FD_CLR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>waitset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* we may have finished */</comment>
				<expr_stmt><expr><name>conn_count</name><operator>--</operator></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"TeardownTCPInterconnect: waitOnOutbound %s: %m"</literal></expr></argument>, <argument><expr><literal type="string">"recv"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>doSendStopMessageTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>m</name> <init>= <expr><literal type="char">'S'</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>written</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Interconnect needs no more input from slice%d; notifying senders to stop."</literal></expr></argument>,
			 <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Note: we're only concerned with receivers here.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>readSet</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* someone is trying to send stuff to us, let's stop 'em */</comment>
			<while>while <condition>(<expr><operator>(</operator><name>written</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<break>break;</break></block_content></block></else></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>written</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * how can this happen ? the kernel buffer should be empty in
				 * the send direction
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"SendStopMessage: failed on write.  %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* CRITICAL TO AVOID DEADLOCK */</comment>
		<expr_stmt><expr><call><name>DeregisterReadInterest</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
							   <argument><expr><literal type="string">"no more input needed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleChunkListItem</name></type>
<name>RecvTupleChunkFromTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
					  <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<comment type="block">/* check em' */</comment>
	<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFrom(motNodID=%d, srcRoute=%d)"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>srcRoute</name></expr>;</expr_stmt>

	<return>return <expr><call><name>RecvTupleChunk</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TupleChunkListItem</name></type>
<name>RecvTupleChunkFromAnyTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>rset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipSelect</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>waitFd</name> <init>= <expr><name>PGINVALID_SOCKET</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAny(motNodeId=%d)"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	   <name>nfds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Every 2 seconds */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name> <operator>&amp;&amp;</operator> <name>retry</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">4</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/* check to see if the dispatcher should cancel */</comment>
			<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>tval</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nfds</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>highReadSock</name></name></expr>;</expr_stmt>

		<comment type="block">/* make sure we check for these. */</comment>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>readSet</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mpp_fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * since we may have data in a local buffer, we may be able to
		 * short-circuit the select() call (and if we don't do this we may
		 * wait when we have data ready, since it has already been read)
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* we have data on this socket, let's short-circuit our select */</comment>
				<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>skipSelect</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>skipSelect</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* 
		 * Also monitor the events on dispatch fds, eg, errors or sequence
		 * request from PXs.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>waitFd</name> <operator>=</operator> <call><name>pxdisp_getWaitSocketFd</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>waitFd</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name>waitFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>waitFd</name> <operator>&gt;</operator> <name>nfds</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nfds</name> <operator>=</operator> <name>waitFd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>nfds</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error receiving an incoming packet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><literal type="string">"select"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>waitFd</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name> <operator>&amp;&amp;</operator> <call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name>waitFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* handle events on dispatch connection */</comment>
			<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAny() select() returned %d ready sockets"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block> while <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>;</do>

	<comment type="block">/*
	 * We scan the file descriptors starting from where we left off in the
	 * last call (don't continually poll the first when others may be ready!).
	 */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>scanStart</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * avoid division ? index = ((scanStart + i) % pEntry-&gt;numConns);
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>index</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAny: trying to read on inactive socket %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAny() (fd %d) %d/%d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name>RecvTupleChunk</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>srcRoute</name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * advance start point (avoid doing division/modulus operation
			 * here)
			 */</comment>
			<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>scanStart</name></name> <operator>=</operator> <name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<return>return <expr><name>tcItem</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* we should never ever get here... */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAnyTCP: didn't receive, and didn't get cancelled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep the compiler happy */</comment>
</block_content>}</block></function>

<comment type="block">/* See ml_ipc.h */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendEosTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>,
		   <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SendEosTCP: missing interconnect context."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SendEosTCP: context and teardown inactive."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check em' */</comment>
	<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d sending end-of-stream to slice%d"</literal></expr></argument>,
			 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * we want to add our tcItem onto each of the outgoing buffers -- this is
	 * guaranteed to leave things in a state where a flush is *required*.
	 */</comment>
	<expr_stmt><expr><call><name>doBroadcast</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>tcItem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now flush all of the buffers. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsStarted</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>flushBuffer</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"SendEosTCP() Leaving"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></for>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>flushBuffer</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
			<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sendptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>,
				<decl><type ref="prev"/><name>sent</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>wset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mpp_fd_set</name></type>	<name>rset</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>snapTime</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snapTime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"----sending chunk @%s.%d time is %d.%d"</literal></expr></argument>,
			 <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>snapTime</name><operator>.</operator><name>tv_sec</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>snapTime</name><operator>.</operator><name>tv_usec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* first set header length */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>

	<comment type="block">/* now send message */</comment>
	<expr_stmt><expr><name>sendptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>

		<comment type="block">/* check for stop message or peer teardown before sending anything  */</comment>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * since timeout = 0, select returns imediately and no time is wasted
		 * waiting trying to send data on the network
		 */</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* handle errors at the write call, below */</comment>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>print_connection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><literal type="string">"stop from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* got a stop message */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>send</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>sendptr</name> <operator>+</operator> <name>sent</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>-</operator> <name>sent</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_flush_buffer"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>	<name>send_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>
			<block>{<block_content>
				<do>do
				<block>{<block_content>
					<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>tval</name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>wset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * if we got an error in teardown, ignore it: treat it
						 * as a stop message
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr>)</condition>
						<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
							<expr_stmt><expr><call><name>print_connection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><literal type="string">"stop from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
							<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
							<return>return <expr><name>false</name></expr>;</return>
						</block_content>}</block></if></if_stmt>

						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error writing an outgoing packet: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Error during select() call (error: %d), for remote connection: contentId=%d at %s"</literal></expr></argument>,
										   <argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
										   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * as a sender... if there is something to read... it must
					 * mean its a StopSendingMessage or receiver has teared down
					 * the interconnect, we don't even bother to read it.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr>)</condition>
					<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
						<expr_stmt><expr><call><name>print_connection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><literal type="string">"stop from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<return>return <expr><name>false</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block> while <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>;</do>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * if we got an error in teardown, ignore it: treat it as a
				 * stop message
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
					<expr_stmt><expr><call><name>print_connection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><literal type="string">"stop from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>


				<comment type="block">/* check whether receiver has teared down the interconnect */</comment>
				<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MPP_FD_SET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>fd_set</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>rset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * as a sender... if there is something to read... it must
				 * mean its a StopSendingMessage or receiver has teared down
				 * the interconnect, we don't even bother to read it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>MPP_FD_ISSET</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rset</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
					<expr_stmt><expr><call><name>print_connection</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><literal type="string">"stop from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<comment type="block">/* got a stop message */</comment>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error writing an outgoing packet"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Error during send() call (error:%d) for remote connection: contentId=%d at %s"</literal></expr></argument>,
								   <argument><expr><name>send_errno</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
								   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sent</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>sent</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>)</condition>;</do>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <name>PACKET_HEADER_SIZE</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The Function sendChunk() is used to send a tcItem to a single
 * destination. Tuples often are *very small* we aggregate in our
 * local buffer before sending into the kernel.
 *
 * PARAMETERS
 *	 conn - MotionConn that the tcItem is to be sent to.
 *	 tcItem - message to be sent.
 *	 motionId - Node Motion Id.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SendChunkTCP</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name> <init>= <expr><call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>TUPLE_CHUNK_ALIGN</name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"sendChunk: msgSize %d this chunk length %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+</operator> <name>length</name> <operator>&gt;</operator> <name>px_interconnect_max_packet_size</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>flushBuffer</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>motionId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_data</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * px_set_monotonic_begin_time: set the beginTime and endTime to the current
 * time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_set_monotonic_begin_time</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>px_get_monotonic_time</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * px_get_monotonic_time
 *    This function returns the time in the monotonic order.
 *
 * The new time is stored in time-&gt;endTime, which has a larger value than
 * the original value. The original endTime is lost.
 *
 * This function is intended for computing elapsed time between two
 * calls. It is not for getting the system time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>px_get_monotonic_time</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>newTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CLOCK_GETTIME</name></cpp:ifdef>
	<comment type="block">/* Use clock_gettime to return monotonic time value. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* gettimeofday always succeeds. */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>timeCmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>time</name><operator>-&gt;</operator><name>endTime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newTime</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>newTime</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>newTime</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator>
			<operator>(</operator><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <name>USECS_PER_SECOND</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>%</operator> <name>USECS_PER_SECOND</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compare two times.
 *
 * If t1 &gt; t2, return 1.
 * If t1 == t2, return 0.
 * If t1 &lt; t2, return -1;
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>timeCmp</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>t1</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>t2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>t2</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&amp;&amp;</operator>
		<name><name>t1</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>==</operator> <name><name>t2</name><operator>-&gt;</operator><name>tv_usec</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&gt;</operator> <name><name>t2</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>||</operator>
		<operator>(</operator><name><name>t1</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>==</operator> <name><name>t2</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&amp;&amp;</operator>
		 <name><name>t1</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>&gt;</operator> <name><name>t2</name><operator>-&gt;</operator><name>tv_usec</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * px_get_elapsed_us -- return the elapsed time in microseconds
 * after the given time-&gt;beginTime.
 *
 * If time-&gt;beginTime is not set (0), then return 0.
 *
 * Note that the beginTime is not changed, but the endTime is set
 * to the current time.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type>
<name>px_get_elapsed_us</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_sec</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_usec</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>px_get_monotonic_time</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SECOND</name> <operator>+</operator>
			<operator>(</operator><name><name>time</name><operator>-&gt;</operator><name>endTime</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>time</name><operator>-&gt;</operator><name>beginTime</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type>
<name>px_get_elapsed_ms</name><parameter_list>(<parameter><decl><type><name>PxMonotonicTime</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>px_get_elapsed_us</name><argument_list>(<argument><expr><name>time</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>USECS_PER_SECOND</name> <operator>/</operator> <name>MSECS_PER_SECOND</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
