<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/motion/ic_common.c"><comment type="block">/*-------------------------------------------------------------------------
 * ic_common.c
 *	   Interconnect code shared between UDP, and TCP IPC Layers.
 *
 * Portions Copyright (c) 2005-2008, Greenplum
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	    src/backend/px/motion/ic_common.c
 *
 * Reviewers: jzhang, tkordas
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<comment type="block">/*
  #define AMS_VERBOSE_LOGGING
*/</comment>

<comment type="block">/*=========================================================================
 * STRUCTS
 */</comment>
<typedef>typedef <type><struct>struct <name>interconnect_handle_t</name>
<block>{
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>interconnect_context</name></decl>;</decl_stmt>	<comment type="block">/* Interconnect state */</comment>

	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>		<comment type="block">/* owner of this handle */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>interconnect_handle_t</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>interconnect_handle_t</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>interconnect_handle_t</name>;</typedef>

<comment type="block">/*=========================================================================
 * GLOBAL STATE VARIABLES
 */</comment>

<comment type="block">/* Socket file descriptor for the listener. */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>TCP_listenerFd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>UDP_listenerFd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>interconnect_handle_t</name> <modifier>*</modifier></type><name>open_interconnect_handles</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>interconnect_resowner_callback_registered</name></decl>;</decl_stmt>

<comment type="block">/*=========================================================================
 * FUNCTIONS PROTOTYPES
 */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>interconnect_abort_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
										<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>interconnect_handle_t</name> <modifier>*</modifier></type><name>allocate_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroy_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>interconnect_handle_t</name> <modifier>*</modifier></type><name>find_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>icContext</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>logChunkParseDetails</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>ic_instance_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>icpkthdr</name></name> <modifier>*</modifier></type><name>pkt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pkt</name> <operator>=</operator> <operator>(</operator>struct <name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect parse details: pkt-&gt;len %d pkt-&gt;seq %d pkt-&gt;flags 0x%x conn-&gt;active %d conn-&gt;stopRequest %d pkt-&gt;icId %d my_icId %d"</literal></expr></argument>,
		 <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name></expr></argument>, 
		 <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name>ic_instance_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect parse details continued: peer: srcpid %d dstpid %d recvslice %d sendslice %d srccontent %d dstcontent %d"</literal></expr></argument>,
		 <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>recvSliceIndex</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>sendSliceIndex</name></name></expr></argument>, 
		 <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstContentId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>TupleChunkListItem</name></type>
<name>RecvTupleChunk</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>firstTcItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>lastTcItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>tcSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytesProcessed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read the packet in from the network. */</comment>
		<expr_stmt><expr><call><name>readPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* go through and form us some TupleChunks. */</comment>
		<expr_stmt><expr><name>bytesProcessed</name> <operator>=</operator> <name>PACKET_HEADER_SIZE</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* go through and form us some TupleChunks. */</comment>
		<expr_stmt><expr><name>bytesProcessed</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"recvtuple chunk recv bytes %d msgsize %d conn-&gt;pBuff %p conn-&gt;msgPos: %p"</literal></expr></argument>,
		 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr><name>bytesProcessed</name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>-</operator> <name>bytesProcessed</name> <operator>&lt;</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>logChunkParseDetails</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error parsing message: insufficient data received"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"conn-&gt;msgSize %d bytesProcessed %d &lt; chunk-header %d"</literal></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name>bytesProcessed</name></expr></argument>, <argument><expr><name>TUPLE_CHUNK_HEADER_SIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tcSize</name> <operator>=</operator> <name>TUPLE_CHUNK_HEADER_SIZE</name> <operator>+</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>+</operator> <name>bytesProcessed</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* sanity check */</comment>
		<if_stmt><if>if <condition>(<expr><name>tcSize</name> <operator>&gt;</operator> <name>px_interconnect_max_packet_size</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * see PX-720: it is possible that our message got messed up by a
			 * cancellation ?
			 */</comment>
			<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * PX-4010: add some extra debugging.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lastTcItem</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect error parsing message: last item length %d inplace %p"</literal></expr></argument>, <argument><expr><name><name>lastTcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>, <argument><expr><name><name>lastTcItem</name><operator>-&gt;</operator><name>inplace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Interconnect error parsing message: no last item"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>logChunkParseDetails</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error parsing message"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"tcSize %d &gt; max %d header %d processed %d/%d from %p"</literal></expr></argument>,
							   <argument><expr><name>tcSize</name></expr></argument>, <argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>,
							   <argument><expr><name>TUPLE_CHUNK_HEADER_SIZE</name></expr></argument>, <argument><expr><name>bytesProcessed</name></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/*
		 * we only check for interrupts here when we don't have a guaranteed
		 * full-message
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>tcSize</name> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * see PX-720: it is possible that our message got messed up
				 * by a cancellation ?
				 */</comment>
				<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>logChunkParseDetails</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error parsing message"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"tcSize %d &gt;= conn-&gt;msgSize %d"</literal></expr></argument>,
								   <argument><expr><name>tcSize</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tcSize</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We store the data inplace, and handle any necessary copying later
		 * on
		 */</comment>
		<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <operator>(</operator><name>TupleChunkListItem</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TupleChunkListItemData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tcItem</name><operator>-&gt;</operator><name>p_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name> <operator>=</operator> <name>tcSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tcItem</name><operator>-&gt;</operator><name>inplace</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>+</operator> <name>bytesProcessed</name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>bytesProcessed</name> <operator>+=</operator> <call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>TUPLE_CHUNK_ALIGN</name></expr></argument>, <argument><expr><name>tcSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>firstTcItem</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>firstTcItem</name> <operator>=</operator> <name>tcItem</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastTcItem</name> <operator>=</operator> <name>tcItem</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>lastTcItem</name><operator>-&gt;</operator><name>p_next</name></name> <operator>=</operator> <name>tcItem</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lastTcItem</name> <operator>=</operator> <name>tcItem</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"residual message %d bytes"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>firstTcItem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*=========================================================================
 * VISIBLE FUNCTIONS
 */</comment>

<comment type="block">/* 
 * InitMotionLayerIPC
 * Performs initialization of the MotionLayerIPC.  This should be called before
 * any work is performed through functions here.  Generally, this should only
 * need to be called only once during process startup.
 *
 * Errors are indicated by calls to ereport(), and are therefore not indicated
 * by a return code.
 *
 */</comment><function><type><name>void</name></type>
<name>InitMotionLayerIPC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>tcp_listener</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16</name></type>		<name>udp_listener</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_listener_port</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* activated = false; */</comment>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitMotionTCP</name><argument_list>(<argument><expr><operator>&amp;</operator><name>TCP_listenerFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcp_listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>InitMotionUDPIFC</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UDP_listenerFd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>udp_listener</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>px_listener_port</name> <operator>=</operator> <operator>(</operator><name>udp_listener</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>tcp_listener</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_info_debug</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Interconnect listening on tcp port %d udp port %d (0x%x)"</literal></expr></argument>, <argument><expr><name>tcp_listener</name></expr></argument>, <argument><expr><name>udp_listener</name></expr></argument>, <argument><expr><name>px_listener_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * CleanUpMotionLayerIPC
 * Performs any cleanup necessary by the Motion Layer IPC.	This is the cleanup
 * function that matches InitMotionLayerIPC, it should only be called during
 * shutdown of the process. This includes shutting down the Motion Listener.
 *
 * Errors are indicated by calls to ereport(), and are therefore not indicated
 * in the return code.
 */</comment>
<function><type><name>void</name></type>
<name>CleanUpMotionLayerIPC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Cleaning Up Motion Layer IPC..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CleanupMotionTCP</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CleanupMotionUDPIFC</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* close down the Interconnect listener socket. */</comment>
	<if_stmt><if>if <condition>(<expr><name>TCP_listenerFd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>TCP_listenerFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>UDP_listenerFd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>UDP_listenerFd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* be safe and reset global state variables. */</comment>
	<expr_stmt><expr><name>px_listener_port</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>TCP_listenerFd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>UDP_listenerFd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* 
 * SendTupleChunkToAMS
 * Sends a tuple chunk from the Postgres process to the local AMS process via
 * IPC.  This function does not block; if the IPC channel cannot accept the
 * tuple chunk for some reason, then this is indicated by a return-code.
 *
 * Errors are indicated by calls to ereport(), and are therefore not indicated
 * in the return code.
 *
 *
 * PARAMETERS:
 *	 - motNodeID:	motion node Id that the tcItem belongs to.
 *	 - targetRoute: route to send this tcItem out over.
 *	 - tcItem:		The tuple-chunk data to send.
 *
 */</comment>
<function><type><name>bool</name></type>
<name>SendTupleChunkToAMS</name><parameter_list>(<parameter><decl><type><name>MotionLayerState</name> <modifier>*</modifier></type><name>mlStates</name></decl></parameter>,
					<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>targetRoute</name></decl></parameter>,
					<parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>recount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>currItem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SendTupleChunkToAMS: no transport-states."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SendTupleChunkToAMS: transport states inactive"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* check em' */</comment>
	<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"sendtuplechunktoams: calling get_transport_state"</literal>
		 <literal type="string">"w/transportStates %p transportState-&gt;size %d motnodeid %d route %d"</literal></expr></argument>,
		 <argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>targetRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * tcItem can actually be a chain of tcItems.  we need to send out all of
	 * them.
	 */</comment>
	<expr_stmt><expr><name>currItem</name> <operator>=</operator> <name>tcItem</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>currItem</name> <operator>=</operator> <name>tcItem</name></expr>;</init> <condition><expr><name>currItem</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>currItem</name> <operator>=</operator> <name><name>currItem</name><operator>-&gt;</operator><name>p_next</name></name></expr></incr>)</control>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"SendTupleChunkToAMS: chunk length %d"</literal></expr></argument>, <argument><expr><name><name>currItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>targetRoute</name> <operator>==</operator> <name>BROADCAST_SEGIDX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>doBroadcast</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>currItem</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>recount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* handle pt-to-pt message. Primary */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetRoute</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>targetRoute</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>targetRoute</name></expr>;</expr_stmt>
			<comment type="block">/* only send to interested connections */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name><name>transportStates</name><operator>-&gt;</operator><name>SendChunk</name></name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>currItem</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>recount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* in 4.0 logical mirror xmit eliminated. */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>recount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we don't have any connections active, return false */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* if we found an active connection we're not done */</comment>
	<return>return <expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTransportDirectBuffer
 * The fetches a direct pointer into our transmit buffers, along with
 * an indication as to how much data can be safely shoved into the
 * buffer (started at the pointed location).
 *
 * This works a lot like SendTupleChunkToAMS().
 */</comment>
<function><type><name>void</name></type>
<name>getTransportDirectBuffer</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>targetRoute</name></decl></parameter>,
						 <parameter><decl><type><name><name>struct</name> <name>directTransportBuffer</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"getTransportDirectBuffer: no transport states"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"getTransportDirectBuffer: inactive transport states"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetRoute</name> <operator>==</operator> <name>BROADCAST_SEGIDX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"getTransportDirectBuffer: can't direct-transport to broadcast"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>b</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* handle pt-to-pt message. Primary */</comment>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>targetRoute</name></expr>;</expr_stmt>
		<comment type="block">/* only send to interested connections */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>pri</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>prilen</name></name> <operator>=</operator> <name>px_interconnect_max_packet_size</name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>

		<comment type="block">/* got buffer. */</comment>
		<return>return;</return>
	</block_content>}</block>
	while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

	<comment type="block">/* buffer is missing ? */</comment>

	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>pri</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><operator>-&gt;</operator><name>prilen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The fetches a direct pointer into our transmit buffers, along with
 * an indication as to how much data can be safely shoved into the
 * buffer (started at the pointed location).
 *
 * This works a lot like SendTupleChunkToAMS().
 */</comment>
<function><type><name>void</name></type>
<name>putTransportDirectBuffer</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>targetRoute</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"putTransportDirectBuffer: no transport states"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"putTransportDirectBuffer: inactive transport states"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>targetRoute</name> <operator>==</operator> <name>BROADCAST_SEGIDX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"putTransportDirectBuffer: can't direct-transport to broadcast"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* handle pt-to-pt message. Primary */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>targetRoute</name></expr>;</expr_stmt>
	<comment type="block">/* only send to interested connections */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* put buffer. */</comment>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * DeregisterReadInterest is called on receiving nodes when they
 * believe that they're done with the receiver
 */</comment>
<function><type><name>void</name></type>
<name>DeregisterReadInterest</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>srcRoute</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"DeregisterReadInterest: no transport states"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>srcRoute</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"Interconnect finished receiving "</literal>
			 <literal type="string">"from seg%d slice%d %s pid=%d sockfd=%d; %s"</literal></expr></argument>,
			 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
			 <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
			 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
			 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
			 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>,
			 <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"deregisterReadInterest set stillactive = false for node %d route %d (%s)"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>markUDPConnInactiveIFC</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * we also mark the connection as "done." The way synchronization
		 * works is strange. On QCs the "teardown" doesn't get called until
		 * all segments are finished, which means that we need some way for
		 * the PXs to know that Teardown should complete, otherwise we
		 * deadlock the entire query (PXs wait in their Teardown calls, while
		 * the QC waits for them to finish)
		 */</comment>
		<expr_stmt><expr><call><name>shutdown</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><name>SHUT_WR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MPP_FD_CLR</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>readSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* 
 * SetupInterconnect
 * The SetupInterconnect() function should be called at the beginning of
 * executing any DML statement that will need to use the interconnect.
 *
 * This function goes through the slicetable and makes any appropriate
 * outgoing connections as well as accepts any incoming connections.  Incoming
 * connections will have a "Register" message from them to see which remote
 * PxProcess sent it.
 *
 * So this function essentially performs all of the setup the interconnect has
 * to perform for all of the motion nodes in the upcoming DML statement.
 *
 * PARAMETERS
 *
 *	 mySliceTable - slicetable structure that correlates to the upcoming DML
 *					statement.
 *
 *	 mySliceId - the index of the slice in the slicetable that we are a member of.
 *
 */</comment>
<function><type><name>void</name></type>
<name>SetupInterconnect</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SetupInterconnect: already initialized."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SetupInterconnect: no slice table ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>allocate_interconnect_handle</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_InterconnectContext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>px_InterconnectContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetupUDPIFCInterconnect</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetupTCPInterconnect</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported expected interconnect type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* TeardownInterconnect() function is used to cleanup interconnect resources that
 * were allocated during SetupInterconnect().  This function should ALWAYS be
 * called after SetupInterconnect to avoid leaking resources (like sockets)
 * even if SetupInterconnect did not complete correctly.
 */</comment>
<function><type><name>void</name></type>
<name>TeardownInterconnect</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>hasErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>find_interconnect_handle</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_UDPIFC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TeardownUDPIFCInterconnect</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>hasErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>px_interconnect_type</name> <operator>==</operator> <name>INTERCONNECT_TYPE_TCP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TeardownTCPInterconnect</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>hasErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>h</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>destroy_interconnect_handle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*=========================================================================
 * HELPER FUNCTIONS
 */</comment>


<comment type="block">/* Function createChunkTransportState() is used to create a ChunkTransportState struct and
 * place it in the hashtab hashtable based on the motNodeID.
 *
 * PARAMETERS
 *
 *	 motNodeID - motion node ID for this ChunkTransportState.
 *
 *	 numConns  - number of primary connections for this motion node.
 *               All are incoming if this is a receiving motion node.
 *               All are outgoing if this is a sending motion node.
 *
 * RETURNS
 *	 An empty and initialized ChunkTransportState struct for the given motion node. If
 *	 a ChuckTransportState struct is already registered for the motNodeID an ERROR is
 *	 thrown.
 */</comment>
<function><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type>
<name>createChunkTransportState</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						  <parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>sendSlice</name></decl></parameter>,
						  <parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>recvSlice</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>numConns</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>motNodeID</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>motNodeID</name> <operator>=</operator> <name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>motNodeID</name> <operator>&gt;</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* increase size of our table */</comment>
		<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>newTable</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newTable</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name></expr></argument>, <argument><expr><name>motNodeID</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChunkTransportStateEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <name>newTable</name></expr>;</expr_stmt>
		<comment type="block">/* zero-out the new piece at the end */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>states</name><index>[<expr><name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>motNodeID</name> <operator>-</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChunkTransportStateEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>motNodeID</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pEntry</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: A HTAB entry for motion node %d already exists"</literal></expr></argument>,
						<argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"conns %p numConns %d first sock %d"</literal></expr></argument>,
						   <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr></argument>,
						   <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>sockfd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>motNodeId</name></name> <operator>=</operator> <name>motNodeID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name> <operator>=</operator> <name>numConns</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>scanStart</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name></name> <operator>=</operator> <name>sendSlice</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name></name> <operator>=</operator> <name>recvSlice</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Initialize MotionConn entry. */</comment>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsNull</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sent_record_typmod</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>pEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Function removeChunkTransportState() is used to remove a ChunkTransportState struct from
 * the hashtab hashtable.
 *
 * This should only be called after createChunkTransportState().
 *
 * PARAMETERS
 *
 *	 motNodeID - motion node ID to lookup the ChunkTransportState.
 *   pIncIdx - parent slice idx in child slice.  If not multiplexed, should be 1.
 *
 * RETURNS
 *	 The ChunkTransportState that was removed from the hashtab hashtable.
 */</comment>
<function><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type>
<name>removeChunkTransportState</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>motNodeID</name> <operator>&gt;</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Unexpected Motion Node Id: %d"</literal></expr></argument>,
						<argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"During remove. (size %d)"</literal></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Unexpected Motion Node Id: %d"</literal></expr></argument>,
						<argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"During remove. State not valid"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MPP_FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>readSet</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pEntry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the listener address associated with the slice to
 * the master address that is established through libpq
 * connection. This guarantees that the outgoing connections
 * will connect to an address that is reachable in the event
 * when the master can not be reached by segments through
 * the network interface recorded in the catalog.
 */</comment>
<function><type><name>void</name></type>
<name>adjustMasterRouting</name><parameter_list>(<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>recvSlice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>recvSlice-&gt;primaryProcesses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxProc</name> <init>= <expr><operator>(</operator><name>PxProcess</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>pxProc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * checkForCancelFromQC
 * 		Check for cancel from QC.
 *
 * Should be called only inside the dispatcher
 */</comment>
<function><type><name>void</name></type>
<name>checkForCancelFromQC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>pTransportStates</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pTransportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>estate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>pxdisp_checkForCancel</name><argument_list>(<argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><name>PX_MOTION_LOST_CONTACT_STRING</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* not reached */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>interconnect_handle_t</name> <modifier>*</modifier></type>
<name>allocate_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_InterconnectContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>px_InterconnectContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
													<argument><expr><literal type="string">"Interconnect Context"</literal></expr></argument>,
													<argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
													<argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
													<argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>px_InterconnectContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>interconnect_handle_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>owner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>open_interconnect_handles</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>open_interconnect_handles</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>open_interconnect_handles</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>h</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>open_interconnect_handles</name> <operator>=</operator> <name>h</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>interconnect_resowner_callback_registered</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RegisterResourceReleaseCallback</name><argument_list>(<argument><expr><name>interconnect_abort_callback</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>interconnect_resowner_callback_registered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroy_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* unlink from linked list first */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>open_interconnect_handles</name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>h</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>open_interconnect_handles</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>px_InterconnectContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>interconnect_handle_t</name> <modifier>*</modifier></type>
<name>find_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>icContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name>open_interconnect_handles</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>head</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>==</operator> <name>icContext</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>head</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanup_interconnect_handle</name><parameter_list>(<parameter><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>h</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>destroy_interconnect_handle</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>TeardownInterconnect</name><argument_list>(<argument><expr><name><name>h</name><operator>-&gt;</operator><name>interconnect_context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>interconnect_abort_callback</name><parameter_list>(<parameter><decl><type><name>ResourceReleasePhase</name></type> <name>phase</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>,
							<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>interconnect_handle_t</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>phase</name> <operator>!=</operator> <name>RESOURCE_RELEASE_AFTER_LOCKS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>next</name> <operator>=</operator> <name>open_interconnect_handles</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>next</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>curr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>curr</name><operator>-&gt;</operator><name>owner</name></name> <operator>==</operator> <name>CurrentResourceOwner</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"interconnect reference leak: %p still referenced"</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>cleanup_interconnect_handle</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * format_sockaddr
 *			Format a sockaddr to a human readable string
 *
 * This function must be kept threadsafe, elog/ereport/palloc etc are not
 * allowed within this function.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>format_sockaddr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>sa</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_host</name><index>[<expr><name>NI_MAXHOST</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>remote_port</name><index>[<expr><name>NI_MAXSERV</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getnameinfo_all</name><argument_list>(<argument><expr><name>sa</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_storage</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_host</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>remote_port</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remote_port</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>NI_NUMERICHOST</name> <operator>|</operator> <name>NI_NUMERICSERV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"?host?:?port?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>sa</name><operator>-&gt;</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"[%s]:%s"</literal></expr></argument>, <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><name>remote_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name>remote_host</name></expr></argument>, <argument><expr><name>remote_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>
</unit>
