<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/px/motion/ic_udpifc.c"><comment type="block">/*-------------------------------------------------------------------------
 * ic_udpifc.c
 *	   Interconnect code specific to UDP transport.
 *
 * Portions Copyright (c) 2005-2011, Greenplum Inc.
 * Portions Copyright (c) 2012-Present Pivotal Software, Inc.
 * Copyright (c) 2011-2012, EMC Corporation
 * Portions Copyright (c) 2021, Alibaba Group Holding Limited
 *
 *
 * IDENTIFICATION
 *	    src/backend/px/motion/ic_udpifc.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * Need this to get WSAPoll (poll). And it
 * has to be set before any header from the Win32 API is loaded.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_WIN32_WINNT</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_WINNT</name></cpp:macro> <cpp:value>0x0600</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/ip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq-be.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/execnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/pg_crc32c.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_disp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_dispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_icudpfaultinjection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_vars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/ml_ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/tupchunklist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>_WIN32_WINNT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WIN32_WINNT</name></cpp:macro> <cpp:value>0x0600</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ws2tcpip.h&gt;</cpp:file></cpp:include>

<comment type="block">/* If we have old platform sdk headers, WSAPoll() might not be there */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>POLLIN</name></cpp:ifndef>
<comment type="block">/* Event flag definitions for WSAPoll(). */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLRDNORM</name></cpp:macro>	<cpp:value>0x0100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLRDBAND</name></cpp:macro>	<cpp:value>0x0200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLIN</name></cpp:macro>		<cpp:value>(POLLRDNORM | POLLRDBAND)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLPRI</name></cpp:macro>		<cpp:value>0x0400</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLWRNORM</name></cpp:macro>	<cpp:value>0x0010</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLOUT</name></cpp:macro>		<cpp:value>(POLLWRNORM)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLWRBAND</name></cpp:macro>	<cpp:value>0x0020</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLERR</name></cpp:macro>		<cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLHUP</name></cpp:macro>		<cpp:value>0x0002</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLLNVAL</name></cpp:macro>	<cpp:value>0x0004</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>pollfd</name>
<block>{

	<decl_stmt><decl><type><name>SOCKET</name></type>		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHORT</name></type>		<name>events</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHORT</name></type>		<name>revents</name></decl>;</decl_stmt>

}</block></struct></type>			<name>WSAPOLLFD</name><operator>,</operator> *<name>PWSAPOLLFD</name><operator>,</operator> <name>FAR</name> <modifier>*</modifier> <name>LPWSAPOLLFD</name>;</typedef>

<macro><name>__control_entrypoint</name><argument_list>(<argument>DllExport</argument>)</argument_list></macro>
<function_decl><type><name>WINSOCK_API_LINKAGE</name>
<name>int</name>
			<name>WSAAPI</name></type>
<name>WSAPoll</name><parameter_list>(
		<parameter><decl><type><name>IN</name> <name>OUT</name> <name>LPWSAPOLLFD</name></type> <name>fdArray</name></decl></parameter>,
		<parameter><decl><type><name>IN</name> <name>ULONG</name></type> <name>fds</name></decl></parameter>,
		<parameter><decl><type><name>IN</name> <name>INT</name></type> <name>timeout</name></decl></parameter>
)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poll</name></cpp:macro> <cpp:value>WSAPoll</cpp:value></cpp:define>

<comment type="block">/*
 * Postgres normally uses it's own custom select implementation
 * on Windows, but they haven't implemented execeptfds, which
 * we use here.  So, undef this to use the normal Winsock version
 * for now
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>select</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TRY</name></cpp:macro> <cpp:value>(11)</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type>
			<name><name>timeoutArray</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><literal type="number">1</literal></expr>,
	<expr><literal type="number">1</literal></expr>,
	<expr><literal type="number">2</literal></expr>,
	<expr><literal type="number">4</literal></expr>,
	<expr><literal type="number">8</literal></expr>,
	<expr><literal type="number">16</literal></expr>,
	<expr><literal type="number">32</literal></expr>,
	<expr><literal type="number">64</literal></expr>,
	<expr><literal type="number">128</literal></expr>,
	<expr><literal type="number">256</literal></expr>,
	<expr><literal type="number">512</literal></expr>,
	<expr><literal type="number">512</literal></expr>							<comment type="block">/* MAX_TRY */</comment>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMEOUT</name><parameter_list>(<parameter><type><name>try</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((try) &lt; MAX_TRY ? (timeoutArray[(try)]) : (timeoutArray[MAX_TRY]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USECS_PER_SECOND</name></cpp:macro> <cpp:value>1000000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSECS_PER_SECOND</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/* 1/4 sec in msec */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RX_THREAD_POLL_TIMEOUT</name></cpp:macro> <cpp:value>(250)</cpp:value></cpp:define>

<comment type="block">/*
 * Flags definitions for flag-field of UDP-messages
 *
 * We use bit operations to test these, flags are powers of two only
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_RECEIVER_TO_SENDER</name></cpp:macro>  <cpp:value>(1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_ACK</name></cpp:macro>					<cpp:value>(2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_STOP</name></cpp:macro>				<cpp:value>(4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_EOS</name></cpp:macro>					<cpp:value>(8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_NAK</name></cpp:macro>					<cpp:value>(16)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_DISORDER</name></cpp:macro>    		<cpp:value>(32)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_DUPLICATE</name></cpp:macro>   		<cpp:value>(64)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UDPIC_FLAGS_CAPACITY</name></cpp:macro>    		<cpp:value>(128)</cpp:value></cpp:define>

<comment type="block">/*
 * ConnHtabBin
 *
 * A connection hash table bin.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>ConnHtabBin</name></name></type> <name>ConnHtabBin</name>;</typedef>
<struct>struct <name>ConnHtabBin</name>
<block>{
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ConnHtabBin</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * ConnHashTable
 *
 * Connection hash table definition.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>ConnHashTable</name></name></type> <name>ConnHashTable</name>;</typedef>
<struct>struct <name>ConnHashTable</name>
<block>{
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnHtabBin</name> <modifier>*</modifier><modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONN_HASH_VALUE</name><parameter_list>(<parameter><type><name>icpkt</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint32)((((icpkt)-&gt;srcPid ^ (icpkt)-&gt;dstPid)) + (icpkt)-&gt;dstContentId))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONN_HASH_MATCH</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a)-&gt;motNodeId == (b)-&gt;motNodeId &amp;&amp; \
								(a)-&gt;dstContentId == (b)-&gt;dstContentId &amp;&amp; \
								(a)-&gt;srcContentId == (b)-&gt;srcContentId &amp;&amp; \
								(a)-&gt;recvSliceIndex == (b)-&gt;recvSliceIndex &amp;&amp; \
								(a)-&gt;sendSliceIndex == (b)-&gt;sendSliceIndex &amp;&amp; \
								(a)-&gt;srcPid == (b)-&gt;srcPid &amp;&amp;			\
								(a)-&gt;dstPid == (b)-&gt;dstPid &amp;&amp; (a)-&gt;icId == (b)-&gt;icId))</cpp:value></cpp:define>


<comment type="block">/*
 * Cursor IC table definition.
 *
 * For cursor case, there may be several concurrent interconnect
 * instances on QC. The table is used to track the status of the
 * instances, which is quite useful for "ACK the past and NAK the future" paradigm.
 *
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURSOR_IC_TABLE_SIZE</name></cpp:macro> <cpp:value>(128)</cpp:value></cpp:define>

<comment type="block">/*
 * CursorICHistoryEntry
 *
 * The definition of cursor IC history entry.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>CursorICHistoryEntry</name></name></type> <name>CursorICHistoryEntry</name>;</typedef>
<struct>struct <name>CursorICHistoryEntry</name>
<block>{
	<comment type="block">/* Interconnect instance id. */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>icId</name></decl>;</decl_stmt>

	<comment type="block">/* Command id. */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>cid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Interconnect instance status. state 1 (value 1): interconnect is setup
	 * state 0 (value 0): interconnect was torn down.
	 */</comment>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>status</name></decl>;</decl_stmt>

	<comment type="block">/* Next entry. */</comment>
	<decl_stmt><decl><type><name>CursorICHistoryEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * CursorICHistoryTable
 *
 * Cursor IC history table. It is a small hash table.
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>CursorICHistoryTable</name></name></type> <name>CursorICHistoryTable</name>;</typedef>
<struct>struct <name>CursorICHistoryTable</name>
<block>{
	<decl_stmt><decl><type><name>uint32</name></type>		<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CursorICHistoryEntry</name> <modifier>*</modifier></type><name><name>table</name><index>[<expr><name>CURSOR_IC_TABLE_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Synchronization timeout values
 *
 * MAIN_THREAD_COND_TIMEOUT - 1/4 second
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAIN_THREAD_COND_TIMEOUT_MS</name></cpp:macro> <cpp:value>(250)</cpp:value></cpp:define>

<comment type="block">/*
 *  Used for synchronization between main thread (receiver) and background thread.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>ThreadWaitingState</name></name></type> <name>ThreadWaitingState</name>;</typedef>
<struct>struct <name>ThreadWaitingState</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>waiting</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>waitingNode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>waitingRoute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>reachRoute</name></decl>;</decl_stmt>

	<comment type="block">/* main_thread_waiting_query is needed to disambiguate for cursors */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>waitingQuery</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * ReceiveControlInfo
 *
 * The related control information for receiving data packets.
 * Main thread (Receiver) and background thread use the information in
 * this data structure to handle data packets.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>ReceiveControlInfo</name></name></type> <name>ReceiveControlInfo</name>;</typedef>
<struct>struct <name>ReceiveControlInfo</name>
<block>{
	<comment type="block">/* Main thread waiting state. */</comment>
	<decl_stmt><decl><type><name>ThreadWaitingState</name></type> <name>mainWaitingState</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Buffers used to assemble disorder messages at receiver side.
	 */</comment>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>disorderBuffer</name></decl>;</decl_stmt>

	<comment type="block">/* The last interconnect instance id which is torn down. */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lastTornIcId</name></decl>;</decl_stmt>

	<comment type="block">/* Cursor history table. */</comment>
	<decl_stmt><decl><type><name>CursorICHistoryTable</name></type> <name>cursorHistoryTable</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Last distributed transaction id when SetupUDPInterconnect is called.
	 * Coupled with cursorHistoryTable, it is used to handle multiple
	 * concurrent cursor cases.
	 */</comment>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>lastDXatId</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Main thread (Receiver) and background thread use the information in
 * this data structure to handle data packets.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ReceiveControlInfo</name></type> <name>rx_control_info</name></decl>;</decl_stmt>


<comment type="block">/*
 * RxBufferPool
 *
 * Receive thread buffer pool definition. The implementation of
 * receive side buffer pool is different from send side buffer pool.
 * It is because receive side buffer pool needs a ring buffer to
 * easily implement disorder message handling logic.
 */</comment>

<typedef>typedef <type><name><name>struct</name> <name>RxBufferPool</name></name></type> <name>RxBufferPool</name>;</typedef>
<struct>struct <name>RxBufferPool</name>
<block>{
	<comment type="block">/* The max number of buffers we can get from this pool. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxCount</name></decl>;</decl_stmt>

	<comment type="block">/* The number of allocated buffers */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<comment type="block">/* The list of free buffers. */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>freeList</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * The buffer pool used for keeping data packets.
 *
 * maxCount is set to 1 to make sure there is always a buffer
 * for picking packets from OS buffer.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>RxBufferPool</name></type> <name>rx_buffer_pool</name> <init>=
<expr><block>{
	<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * SendBufferPool
 *
 * The send side buffer pool definition.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>SendBufferPool</name></name></type> <name>SendBufferPool</name>;</typedef>
<struct>struct <name>SendBufferPool</name>
<block>{
	<comment type="block">/* The maximal number of buffers sender can use. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxCount</name></decl>;</decl_stmt>

	<comment type="block">/* The number of buffers sender already used. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<comment type="block">/* The free buffer list at the sender side. */</comment>
	<decl_stmt><decl><type><name>ICBufferList</name></type> <name>freeList</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * The sender side buffer pool.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SendBufferPool</name></type> <name>snd_buffer_pool</name></decl>;</decl_stmt>

<comment type="block">/*
 * SendControlInfo
 *
 * The related control information for sending data packets and handling acks.
 * Main thread use the information in this data structure to do ack handling
 * and congestion control.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>SendControlInfo</name></name></type> <name>SendControlInfo</name>;</typedef>
<struct>struct <name>SendControlInfo</name>
<block>{
	<comment type="block">/* The buffer used for accepting acks */</comment>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>ackBuffer</name></decl>;</decl_stmt>

	<comment type="block">/* congestion window */</comment>
	<decl_stmt><decl><type><name>float</name></type>		<name>cwnd</name></decl>;</decl_stmt>

	<comment type="block">/* minimal congestion control window */</comment>
	<decl_stmt><decl><type><name>float</name></type>		<name>minCwnd</name></decl>;</decl_stmt>

	<comment type="block">/* slow start threshold */</comment>
	<decl_stmt><decl><type><name>float</name></type>		<name>ssthresh</name></decl>;</decl_stmt>

}</block>;</struct>

<comment type="block">/*
 * Main thread use the information in this data structure to do ack handling
 * and congestion control.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SendControlInfo</name></type> <name>snd_control_info</name></decl>;</decl_stmt>

<comment type="block">/*
 * ICGlobalControlInfo
 *
 * Some shared control information that is used by main thread (senders, receivers, or both)
 * and the background thread.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>ICGlobalControlInfo</name></name></type> <name>ICGlobalControlInfo</name>;</typedef>
<struct>struct <name>ICGlobalControlInfo</name>
<block>{
	<comment type="block">/* The background thread handle. */</comment>
	<decl_stmt><decl><type><name>pthread_t</name></type>	<name>threadHandle</name></decl>;</decl_stmt>

	<comment type="block">/* Keep the udp socket buffer size used. */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>socketSendBufferSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>socketRecvBufferSize</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>lastExpirationCheckTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>lastDeadlockCheckTime</name></decl>;</decl_stmt>

	<comment type="block">/* Used to decide whether to retransmit for capacity based FC. */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>lastPacketSendTime</name></decl>;</decl_stmt>

	<comment type="block">/* MemoryContext for UDP interconnect. */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>memContext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lock and latch for coordination between main thread and background
	 * thread. It protects the shared data between the two threads (the
	 * connHtab, rx buffer pool and the mainWaitingState etc.).
	 */</comment>
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Latch</name></type>		<name>latch</name></decl>;</decl_stmt>

	<comment type="block">/* Am I a sender? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isSender</name></decl>;</decl_stmt>

	<comment type="block">/* Flag showing whether the thread is created. */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>threadCreated</name></decl>;</decl_stmt>

	<comment type="block">/* Error number. Actually int but we do not have pg_atomic_int32. */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>eno</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Global connection htab for both sending connections and receiving
	 * connections. Protected by the lock in this data structure.
	 */</comment>
	<decl_stmt><decl><type><name>ConnHashTable</name></type> <name>connHtab</name></decl>;</decl_stmt>

	<comment type="block">/* The connection htab used to cache future packets. */</comment>
	<decl_stmt><decl><type><name>ConnHashTable</name></type> <name>startupCacheHtab</name></decl>;</decl_stmt>

	<comment type="block">/* Used by main thread to ask the background thread to exit. */</comment>
	<decl_stmt><decl><type><name>pg_atomic_flag</name></type>		<name>shutdown</name></decl>;</decl_stmt>

	<comment type="block">/*
	* Used by ic thread in the PX to identify the current serving ic instance
	* and handle the mismatch packets. It is not used by QC because QC may have
	* cursors, QC may receive packets for open the cursors with lower instance
	* id, QC use cursorHistoryTable to handle packets mismatch.
	*/</comment>
	<decl_stmt><decl><type><name>uint32</name></type>      <name>ic_instance_id</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Shared control information that is used by senders, receivers and background thread.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ICGlobalControlInfo</name></type> <name>ic_control_info</name></decl>;</decl_stmt>

<comment type="block">/*
 * Macro for unack queue ring, round trip time (RTT) and expiration period (RTO)
 *
 * UNACK_QUEUE_RING_SLOTS_NUM - the number of slots in the unack queue ring.
 *                              this value should be greater than or equal to 2.
 * TIMER_SPAN                 - timer period in us
 * TIMER_CHECKING_PERIOD      - timer checking period in us
 * UNACK_QUEUE_RING_LENGTH    - the whole time span of the unack queue ring
 * DEFAULT_RTT                - default rtt in us.
 * MIN_RTT                    - min rtt in us
 * MAX_RTT                    - max rtt in us
 * RTT_SHIFT_COEFFICIENT      - coefficient for RTT computation
 *
 * DEFAULT_DEV                - default round trip standard deviation
 * MAX_DEV                    - max dev
 * DEV_SHIFT_COEFFICIENT      - coefficient for DEV computation
 *
 * MAX_EXPIRATION_PERIOD      - max expiration period in us
 * MIN_EXPIRATION_PERIOD      - min expiration period in us
 * MAX_TIME_NO_TIMER_CHECKING - max time without checking timer
 * DEADLOCK_CHECKING_TIME     - deadlock checking time
 *
 * MAX_SEQS_IN_DISORDER_ACK   - max number of sequences that can be transmitted in a
 *                              disordered packet ack.
 *
 *
 * Considerations on the settings of the values:
 *
 * TIMER_SPAN and UNACK_QUEUE_RING_SLOTS_NUM define the ring period.
 * Currently, it is UNACK_QUEUE_RING_LENGTH (default 10 seconds).
 *
 * The definition of UNACK_QUEUE_RING_LENGTH is quite related to the size of
 * sender side buffer and the size we may resend in a burst for an expiration event
 * (which may overwhelm switch or OS if it is too large).
 * Thus, we do not want to send too much data in a single expiration event. Here, a
 * relatively large UNACK_QUEUE_RING_SLOTS_NUM value is used to avoid that.
 *
 * If the sender side buffer is X (MB), then on each slot,
 * there are about X/UNACK_QUEUE_RING_SLOTS_NUM. Even we have a very large sender buffer,
 * for example, 100MB, there is about 96M/2000 = 50K per slot.
 * This is fine for the OS (with buffer 2M for each socket generally) and switch.
 *
 * Note that even when the buffers are not evenly distributed in the ring and there are some packet
 * losses, the congestion control mechanism, the disorder and duplicate packet handling logic will
 * assure the number of outstanding buffers (in unack queues) to be not very large.
 *
 * MIN_RTT/MAX_RTT/DEFAULT_RTT/MIN_EXPIRATION_PERIOD/MAX_EXPIRATION_PERIOD gives some heuristic values about
 * the computation of RTT and expiration period. RTT and expiration period (RTO) are not
 * constant for various kinds of hardware and workloads. Thus, they are computed dynamically.
 * But we also want to bound the values of RTT and MAX_EXPIRATION_PERIOD. It is
 * because there are some faults that may make RTT a very abnormal value. Thus, RTT and
 * expiration period are upper and lower bounded.
 *
 * MAX_SEQS_IN_DISORDER_ACK should be smaller than (MIN_PACKET_SIZE - sizeof(icpkthdr))/sizeof(uint32).
 * It is due to the limitation of the ack receive buffer size.
 *
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNACK_QUEUE_RING_SLOTS_NUM</name></cpp:macro> <cpp:value>(2000)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMER_SPAN</name></cpp:macro> <cpp:value>(px_interconnect_timer_period * 1000ULL)</cpp:value></cpp:define> <comment type="block">/* default: 5ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TIMER_CHECKING_PERIOD</name></cpp:macro> <cpp:value>(px_interconnect_timer_checking_period)</cpp:value></cpp:define>	<comment type="block">/* default: 20ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNACK_QUEUE_RING_LENGTH</name></cpp:macro> <cpp:value>(UNACK_QUEUE_RING_SLOTS_NUM * TIMER_SPAN)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_RTT</name></cpp:macro> <cpp:value>(px_interconnect_default_rtt * 1000)</cpp:value></cpp:define>	<comment type="block">/* default: 20ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_RTT</name></cpp:macro> <cpp:value>(100)</cpp:value></cpp:define>			<comment type="block">/* 0.1ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RTT</name></cpp:macro> <cpp:value>(200 * 1000)</cpp:value></cpp:define>	<comment type="block">/* 200ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RTT_SHIFT_COEFFICIENT</name></cpp:macro> <cpp:value>(3)</cpp:value></cpp:define>	<comment type="block">/* RTT_COEFFICIENT 1/8 (0.125) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_DEV</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_DEV</name></cpp:macro> <cpp:value>MIN_RTT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DEV</name></cpp:macro> <cpp:value>MAX_RTT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEV_SHIFT_COEFFICIENT</name></cpp:macro> <cpp:value>(2)</cpp:value></cpp:define>	<comment type="block">/* DEV_COEFFICIENT 1/4 (0.25) */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_EXPIRATION_PERIOD</name></cpp:macro> <cpp:value>(1000 * 1000)</cpp:value></cpp:define> <comment type="block">/* 1s */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_EXPIRATION_PERIOD</name></cpp:macro> <cpp:value>((uint64)px_interconnect_min_rto * 1000)</cpp:value></cpp:define>	<comment type="block">/* default: 20ms */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TIME_NO_TIMER_CHECKING</name></cpp:macro> <cpp:value>(50 * 1000)</cpp:value></cpp:define>	<comment type="block">/* 50ms */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEADLOCK_CHECKING_TIME</name></cpp:macro>  <cpp:value>(512 * 1000)</cpp:value></cpp:define>	<comment type="block">/* 512ms */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SEQS_IN_DISORDER_ACK</name></cpp:macro> <cpp:value>(4)</cpp:value></cpp:define>

<comment type="block">/*
 * UnackQueueRing
 *
 * An unacked queue ring is used to decide which packet is expired in constant time.
 *
 * Each slot of the ring represents a fixed time span, for example 1ms, and
 * each slot has a associated buffer list/queue which contains the packets
 * which will expire in the time span.
 *
 * If the current time pointer (time t) points to slot 1,
 * then slot 2 represents the time span from t + 1ms to t + 2ms.
 * When we check whether there are some packets expired, we start from the last
 * current time recorded, and resend all the packets in the queue
 * until we reach the slot that the updated current time points to.
 *
 */</comment>
<typedef>typedef <type><name><name>struct</name> <name>UnackQueueRing</name></name></type> <name>UnackQueueRing</name>;</typedef>
<struct>struct <name>UnackQueueRing</name>
<block>{
	<comment type="block">/* save the current time when we check the time wheel for expiration */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>currentTime</name></decl>;</decl_stmt>

	<comment type="block">/* the slot index corresponding to current time */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name></decl>;</decl_stmt>

	<comment type="block">/* the number of outstanding packets in unack queue ring */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numOutStanding</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * the number of outstanding packets that use the shared bandwidth in the
	 * congestion window.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>numSharedOutStanding</name></decl>;</decl_stmt>

	<comment type="block">/* time slots */</comment>
	<decl_stmt><decl><type><name>ICBufferList</name></type> <name><name>slots</name><index>[<expr><name>UNACK_QUEUE_RING_SLOTS_NUM</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * All connections in a process share this unack queue ring instance.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>UnackQueueRing</name></type> <name>unack_queue_ring</name> <init>=
<expr><block>{
	<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>ICSenderSocket</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint16</name></type> <name>ICSenderPort</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>ICSenderFamily</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * AckSendParam
 *
 * The parameters for ack sending.
 */</comment>
<typedef>typedef <type><struct>struct <name>AckSendParam</name>
<block>{
	<comment type="block">/* header for the ack */</comment>
	<decl_stmt><decl><type><name>icpkthdr</name></type>	<name>msg</name></decl>;</decl_stmt>

	<comment type="block">/* peer address for the ack */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>peer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>peer_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>AckSendParam</name>;</typedef>

<comment type="block">/*
 * ICStatistics
 *
 * A structure keeping various statistics about interconnect internal.
 *
 * Note that the statistics for ic are not accurate for multiple cursor case on QC.
 *
 * totalRecvQueueSize        - receive queue size sum when main thread is trying to get a packet.
 * recvQueueSizeCountingTime - counting times when computing totalRecvQueueSize.
 * totalCapacity             - the capacity sum when packets are tried to be sent.
 * capacityCountingTime      - counting times used to compute totalCapacity.
 * totalBuffers              - total buffers available when sending packets.
 * bufferCountingTime        - counting times when compute totalBuffers.
 * activeConnectionsNum      - the number of active connections.
 * retransmits               - the number of packet retransmits.
 * mismatchNum               - the number of mismatched packets received.
 * crcErrors                 - the number of crc errors.
 * sndPktNum                 - the number of packets sent by sender.
 * recvPktNum                - the number of packets received by receiver.
 * disorderedPktNum          - disordered packet number.
 * duplicatedPktNum          - duplicate packet number.
 * recvAckNum                - the number of Acks received.
 * statusQueryMsgNum         - the number of status query messages sent.
 *
 */</comment>
<typedef>typedef <type><struct>struct <name>ICStatistics</name>
<block>{
	<decl_stmt><decl><type><name>uint64</name></type>		<name>totalRecvQueueSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>recvQueueSizeCountingTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>totalCapacity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>capacityCountingTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>totalBuffers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>bufferCountingTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>activeConnectionsNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>retransmits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>startupCachedPktNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>mismatchNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>crcErrors</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>sndPktNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>recvPktNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>disorderedPktNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>duplicatedPktNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>recvAckNum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>statusQueryMsgNum</name></decl>;</decl_stmt>
}</block></struct></type> <name>ICStatistics</name>;</typedef>

<comment type="block">/* Statistics for UDP interconnect. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ICStatistics</name></type> <name>ic_statistics</name></decl>;</decl_stmt>

<comment type="block">/*=========================================================================
 * STATIC FUNCTIONS declarations
 */</comment>

<comment type="block">/* Cursor IC History table related functions. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initCursorICHistoryTable</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>cid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>updateCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CursorICHistoryEntry</name> <modifier>*</modifier></type><name>getCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pruneCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>purgeCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resetMainThreadWaiting</name><parameter_list>(<parameter><decl><type><name>ThreadWaitingState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setMainThreadWaiting</name><parameter_list>(<parameter><decl><type><name>ThreadWaitingState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>motNodeId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>route</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>icId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Background thread error handling functions. */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkRxThreadError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setRxThreadError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resetRxThreadError</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getSockAddr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name> <modifier>*</modifier></type> <name>peer_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>listenerAddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>listenerPort</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setXmitSocketOptions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txfd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>uint32</name></type> <name>setSocketBufferSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expectedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leastSize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setupUDPListeningSocket</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>listenerSocketFd</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>listenerPort</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>txFamily</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>startOutgoingUDPConnections</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
							<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>sendSlice</name></decl></parameter>,
							<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutgoingCount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setupOutgoingUDPConnection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						   <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Connection hash table functions. */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>initConnHashTable</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>connAddHash</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>MotionConn</name> <modifier>*</modifier></type><name>findConnByHeader</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroyConnHashTable</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>sendAckWithParam</name><parameter_list>(<parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendAck</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>extraSeq</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendDisorderAck</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>extraSeq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>lostPktCnt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendStatusQueryMessage</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>sendControlMessage</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name></type> <name>peerLen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>putRxBufferAndSendAck</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>putRxBufferToFreeList</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>icpkthdr</name> <modifier>*</modifier></type><name>getRxBufferFromFreeList</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>icpkthdr</name> <modifier>*</modifier></type><name>getRxBuffer</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ICBufferList functions. */</comment>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>icBufferListInitHeadLink</name><parameter_list>(<parameter><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type> <name>link</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>icBufferListInit</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBufferListType</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>icBufferListIsHead</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type> <name>link</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBufferLink</name> <modifier>*</modifier></type> <name>icBufferListFirst</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>icBufferListLength</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBuffer</name> <modifier>*</modifier></type> <name>icBufferListDelete</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBuffer</name> <modifier>*</modifier></type> <name>icBufferListPop</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>icBufferListFree</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBuffer</name> <modifier>*</modifier></type> <name>icBufferListAppend</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>icBufferListReturn</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inExpirationQueue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ChunkTransportState</name> <modifier>*</modifier></type><name>SetupUDPIFCInterconnect_Internal</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type> <name>sliceTable</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleChunkListItem</name></type> <name>RecvTupleChunkFromAnyUDPIFC_Internal</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
																	  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
																	  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleChunkListItem</name></type> <name>RecvTupleChunkFromUDPIFC_Internal</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
																   <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
																   <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TeardownUDPIFCInterconnect_Internal</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>hasErrors</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>freeDisorderedPackets</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>prepareRxConnForRead</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleChunkListItem</name></type> <name>RecvTupleChunkFromAnyUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
													  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
													  <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>TupleChunkListItem</name></type> <name>RecvTupleChunkFromUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
												   <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
												   <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleChunkListItem</name></type> <name>receiveChunksUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>pTransportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
											  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SendEosUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>SendChunkUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>doSendStopMessageUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>dispatcherAYT</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkQCConnectionAlive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>rxThreadFunc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>handleMismatch</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>peer_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handleAckedPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>ackConn</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>handleAcks</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handleStopMsgs</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handleDisorderPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>tailSeq</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>handleDataPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name> <modifier>*</modifier></type> <name>peerlen</name></decl></parameter>, <parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>wakeup_mainthread</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>handleAckForDuplicatePkt</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>handleAckForDisorderPkt</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>prepareXmit</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>addCRC</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>checkCRC</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendBuffers</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sendOnce</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type> <name>computeExpirationPeriod</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>retry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ICBuffer</name> <modifier>*</modifier></type> <name>getSndBuffer</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initSndBufferPool</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>putIntoUnackQueueRing</name><parameter_list>(<parameter><decl><type><name>UnackQueueRing</name> <modifier>*</modifier></type><name>uqr</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>expTime</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initUnackQueueRing</name><parameter_list>(<parameter><decl><type><name>UnackQueueRing</name> <modifier>*</modifier></type><name>uqr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkExpiration</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>triggerConn</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkDeadlock</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>cacheFuturePacket</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>peer_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cleanupStartupCache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>handleCachedPackets</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>getCurrentTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initMutex</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>logPkt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>aggregateStatistics</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type> <name>pollAcks</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>void</name></type> <name>px_check_qc_connection_alive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* #define TRANSFER_PROTOCOL_STATS */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
<typedef>typedef <type><name><name>enum</name> <name>TransProtoEvent</name></name></type> <name>TransProtoEvent</name>;</typedef>
<enum>enum <name>TransProtoEvent</name>
<block>{
	<decl><name>TPE_DATA_PKT_SEND</name></decl>,
	<decl><name>TPE_ACK_PKT_QUERY</name></decl>
}</block>;</enum>

<typedef>typedef <type><name><name>struct</name> <name>TransProtoStatEntry</name></name></type> <name>TransProtoStatEntry</name>;</typedef>
<struct>struct <name>TransProtoStatEntry</name>
<block>{
	<decl_stmt><decl><type><name>TransProtoStatEntry</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<comment type="block">/* Basic information */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransProtoEvent</name></type> <name>event</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dstPid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>seq</name></decl>;</decl_stmt>

	<comment type="block">/* more attributes can be added on demand. */</comment>

	<comment type="block">/*
	 * float			cwnd; int				capacity;
	 */</comment>
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>TransProtoStats</name></name></type> <name>TransProtoStats</name>;</typedef>
<struct>struct <name>TransProtoStats</name>
<block>{
	<decl_stmt><decl><type><name>pthread_mutex_t</name></type> <name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransProtoStatEntry</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransProtoStatEntry</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>startTime</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>TransProtoStats</name></type> <name>trans_proto_stats</name> <init>=
<expr><block>{
	<expr><name>PTHREAD_MUTEX_INITIALIZER</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * initTransProtoStats
 * 		Initialize the transport protocol states data structures.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initTransProtoStats</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransProtoStatEntry</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name><name>trans_proto_stats</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>startTime</name></name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>updateStats</name><parameter_list>(<parameter><decl><type><name>TransProtoEvent</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TransProtoStatEntry</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Add to list */</comment>
	<expr_stmt><expr><name>new</name> <operator>=</operator> <operator>(</operator><name>TransProtoStatEntry</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransProtoStatEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* change the list */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>trans_proto_stats</name><operator>.</operator><name>count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* 1st element */</comment>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call> <operator>-</operator> <name><name>trans_proto_stats</name><operator>.</operator><name>startTime</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>dstPid</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Other attributes can be added on demand new-&gt;cwnd =
	 * snd_control_info.cwnd; new-&gt;capacity = conn-&gt;capacity;
	 */</comment>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumpTransProtoStats</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>tmpbuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%d."</literal> <name>UINT64_FORMAT</name> <literal type="string">"txt"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>ofile</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>tmpbuf</name></expr></argument>, <argument><expr><literal type="string">"w+"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TransProtoStatEntry</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>cur</name> <operator>=</operator> <name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>head</name></name> <operator>=</operator> <name><name>trans_proto_stats</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>ofile</name></expr></argument>, <argument><expr><literal type="string">"time %d event %d seq %d destpid %d\n"</literal></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>event</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>cur</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>trans_proto_stats</name><operator>.</operator><name>tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>ofile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* TRANSFER_PROTOCOL_STATS */</comment>

<comment type="block">/*
 * initCursorICHistoryTable
 * 		Initialize cursor ic history table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initCursorICHistoryTable</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>t</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * addCursorIcEntry
 * 		Add an entry to the the cursor ic table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>cid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CursorICHistoryEntry</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>index</name> <init>= <expr><name>icId</name> <operator>%</operator> <name>CURSOR_IC_TABLE_SIZE</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ic_control_info</name><operator>.</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>CursorICHistoryEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>icId</name></name> <operator>=</operator> <name>icId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>cid</name></name> <operator>=</operator> <name>cid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"add icid %d cid %d status %d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>cid</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * updateCursorIcEntry
 * 		Update the status of the cursor ic entry for a given interconnect instance id.
 *
 * There are two states for an instance of interconnect.
 * 		state 1 (value 1): interconnect is setup
 * 		state 0 (value 0): interconnect was torn down.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>updateCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>, <parameter><decl><type><name>uint8</name></type> <name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>CursorICHistoryEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>index</name> <init>= <expr><name>icId</name> <operator>%</operator> <name>CURSOR_IC_TABLE_SIZE</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>icId</name></name> <operator>==</operator> <name>icId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>status</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* not found */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * getCursorIcEntry
 * 		Get the cursor entry given an interconnect id.
 */</comment>
<function><type><specifier>static</specifier> <name>CursorICHistoryEntry</name> <modifier>*</modifier></type>
<name>getCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>CursorICHistoryEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>index</name> <init>= <expr><name>icId</name> <operator>%</operator> <name>CURSOR_IC_TABLE_SIZE</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>icId</name></name> <operator>==</operator> <name>icId</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>p</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* not found */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pruneCursorIcEntry
 * 		Prune entries in the hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pruneCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>icId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>index</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>CURSOR_IC_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>CursorICHistoryEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>,
				   <decl><type ref="prev"><modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>q</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>p</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove an entry if it is older than the prune-point */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>icId</name></name> <operator>&lt;</operator> <name>icId</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>CursorICHistoryEntry</name></name> <modifier>*</modifier></type><name>trash</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>q</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>trash</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

				<comment type="block">/* set up next loop */</comment>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>trash</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>q</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * purgeCursorIcEntry
 *		Clean cursor ic history table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>purgeCursorIcEntry</name><parameter_list>(<parameter><decl><type><name>CursorICHistoryTable</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>index</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name>CURSOR_IC_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>CursorICHistoryEntry</name></name> <modifier>*</modifier></type><name>trash</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>index</name></expr>]</index></name> <operator>=</operator> <name><name>trash</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * resetMainThreadWaiting
 * 		Reset main thread waiting state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resetMainThreadWaiting</name><parameter_list>(<parameter><decl><type><name>ThreadWaitingState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waiting</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waitingNode</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waitingRoute</name></name> <operator>=</operator> <name>ANY_ROUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>reachRoute</name></name> <operator>=</operator> <name>ANY_ROUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waitingQuery</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setMainThreadWaiting
 * 		Set main thread waiting state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setMainThreadWaiting</name><parameter_list>(<parameter><decl><type><name>ThreadWaitingState</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>motNodeId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>route</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>icId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waiting</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waitingNode</name></name> <operator>=</operator> <name>motNodeId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waitingRoute</name></name> <operator>=</operator> <name>route</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>reachRoute</name></name> <operator>=</operator> <name>ANY_ROUTE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>waitingQuery</name></name> <operator>=</operator> <name>icId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkRxThreadError
 * 		Check whether there was error in the background thread in main thread.
 *
 * 	If error found, report it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkRxThreadError</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>eno</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>eno</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>eno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>eno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>eno</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect encountered an error"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><literal type="string">"in receive background thread"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setRxThreadError
 * 		Set the error no in background thread.
 *
 * 	Record the error in background thread. Main thread checks the errors periodically.
 * 	If main thread will find it, main thread will handle it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setRxThreadError</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>expected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* always let main thread know the error that occurred first. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>eno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expected</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>eno</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Interconnect error: in background thread, set ic_control_info.eno to %d, rx_buffer_pool.count %d, rx_buffer_pool.maxCount %d"</literal></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * resetRxThreadError
 * 		Reset the error no.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>resetRxThreadError</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>eno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * setupUDPListeningSocket
 * 		Setup udp listening socket.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setupUDPListeningSocket</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>listenerSocketFd</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>listenerPort</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>txFamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>errnoSave</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fun</name></decl>;</decl_stmt>


	<comment type="block">/*
	 * At the moment, we don't know which of IPv6 or IPv4 is wanted, or even
	 * supported, so just ask getaddrinfo...
	 *
	 * Perhaps just avoid this and try socket with AF_INET6 and AF_INT?
	 *
	 * Most implementation of getaddrinfo are smart enough to only return a
	 * particular address family if that family is both enabled, and at least
	 * one network adapter has an IP address of that family.
	 */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hints</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>our_addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>our_addr_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>service</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>service</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>addrinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt>	<comment type="block">/* Allow IPv4 or IPv6 */</comment>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_DGRAM</name></expr>;</expr_stmt> <comment type="block">/* Datagram socket */</comment>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_PASSIVE</name></expr>;</expr_stmt>	<comment type="block">/* For wildcard IP address */</comment>
	<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* Any protocol - UDP implied for network use
								 * due to SOCK_DGRAM */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_interconnect_udpic_network_enable_ipv6</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>hints</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_INET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"getaddrinfo"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>getaddrinfo</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hints</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"getaddrinfo says %s"</literal></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * getaddrinfo() returns a list of address structures, one for each valid
	 * address and family we can use.
	 *
	 * Try each address until we successfully bind. If socket (or bind) fails,
	 * we (close the socket and) try the next address.  This can happen if the
	 * system supports IPv6, but IPv6 is disabled from working, or if it
	 * supports IPv6 and IPv4 is disabled.
	 */</comment>

	<comment type="block">/*
	 * If there is both an AF_INET6 and an AF_INET choice, we prefer the
	 * AF_INET6, because on UNIX it can receive either protocol, whereas
	 * AF_INET can only get IPv4.  Otherwise we'd need to bind two sockets,
	 * one for each protocol.
	 *
	 * Why not just use AF_INET6 in the hints?	That works perfect if we know
	 * this machine supports IPv6 and IPv6 is enabled, but we don't know that.
	 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__darwin__</name></cpp:ifndef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_IPV6</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>&amp;&amp;</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name><operator>-&gt;</operator><name>ai_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We got both an INET and INET6 possibility, but we want to prefer
		 * the INET6 one if it works. Reverse the order we got from
		 * getaddrinfo so that we try things in our preferred order. If we got
		 * more possibilities (other AFs??), I don't think we care about them,
		 * so don't worry if the list is more that two, we just rearrange the
		 * first two.
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name></name></expr></init></decl>;</decl_stmt> <comment type="block">/* second node */</comment>

		<expr_stmt><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_next</name><operator>-&gt;</operator><name>ai_next</name></name></expr>;</expr_stmt>	<comment type="block">/* point old first node to
													 * third node if any */</comment>
		<expr_stmt><expr><name><name>temp</name><operator>-&gt;</operator><name>ai_next</name></name> <operator>=</operator> <name>addrs</name></expr>;</expr_stmt>	<comment type="block">/* point second node to first */</comment>
		<expr_stmt><expr><name>addrs</name> <operator>=</operator> <name>temp</name></expr>;</expr_stmt>			<comment type="block">/* start the list with the old second node */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Have both IPv6 and IPv4 choices"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>rp</name> <operator>=</operator> <name>addrs</name></expr>;</init> <condition><expr><name>rp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>rp</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>ai_next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"socket"</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * getaddrinfo gives us all the parameters for the socket() call as
		 * well as the parameters for the bind() call.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"receive socket ai_family %d ai_socktype %d ai_protocol %d"</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>socket</name><argument_list>(<argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"receive socket %d ai_family %d ai_socktype %d ai_protocol %d"</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"fcntl(O_NONBLOCK)"</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_set_noblock</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"bind"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"bind addrlen %d fam %d"</literal></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_addr</name><operator>-&gt;</operator><name>sa_family</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>bind</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>rp</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>txFamily</name> <operator>=</operator> <name><name>rp</name><operator>-&gt;</operator><name>ai_family</name></name></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* Success */</comment>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>rp</name> <operator>==</operator> <name>NULL</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"udp_listen_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>							<comment type="block">/* No address succeeded */</comment>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>freeaddrinfo</name><argument_list>(<argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* No longer needed */</comment>

	<comment type="block">/*
	 * Get our socket address (IP and Port), which we will save for others to
	 * connected to.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>our_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>our_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>our_addr_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>our_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"getsockname"</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>our_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>our_addr_len</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>our_addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>||</operator> <name><name>our_addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>listenerSocketFd</name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>our_addr</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>listenerPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>our_addr</name><operator>)</operator><operator>-&gt;</operator><name>sin6_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>listenerPort</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator>struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>our_addr</name><operator>)</operator><operator>-&gt;</operator><name>sin_port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>setXmitSocketOptions</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><name>errnoSave</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errnoSave</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Could not set up udp listener socket"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InitMutex
 * 		Initialize mutex.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initMutex</name><parameter_list>(<parameter><decl><type><name>pthread_mutex_t</name> <modifier>*</modifier></type><name>mutex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pthread_mutexattr_t</name></type> <name>m_atts</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutexattr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutexattr_settype</name><argument_list>(<argument><expr><operator>&amp;</operator><name>m_atts</name></expr></argument>, <argument><expr><name>PTHREAD_MUTEX_ERRORCHECK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><name>mutex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>m_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set up the udp interconnect pthread signal mask, we don't want to run our signal handlers
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_set_pthread_sigmasks</name><parameter_list>(<parameter><decl><type><name>sigset_t</name> <modifier>*</modifier></type><name>old_sigs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>sigset_t</name></type>	<name>sigs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>sigemptyset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * make our thread ignore these signals (which should allow that they be
	 * delivered to the main thread)
	 */</comment>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>SIGTERM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>SIGALRM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>SIGUSR1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sigaddset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_BLOCK</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sigs</name></expr></argument>, <argument><expr><name>old_sigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to get pthread signal masks with return value: %d"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>old_sigs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>ic_reset_pthread_sigmasks</name><parameter_list>(<parameter><decl><type><name>sigset_t</name> <modifier>*</modifier></type><name>sigs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<decl_stmt><decl><type><name>int</name></type>			<name>err</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>err</name> <operator>=</operator> <call><name>pthread_sigmask</name><argument_list>(<argument><expr><name>SIG_SETMASK</name></expr></argument>, <argument><expr><name>sigs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Failed to reset pthread signal masks with return value: %d"</literal></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>sigs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * InitMotionUDPIFC
 * 		Initialize UDP specific comms, and create rx-thread.
 */</comment>
<function><type><name>void</name></type>
<name>InitMotionUDPIFC</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>listenerSocketFd</name></decl></parameter>, <parameter><decl><type><name>uint16</name> <modifier>*</modifier></type><name>listenerPort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pthread_err</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>txFamily</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* attributes of the thread we're creating */</comment>
	<decl_stmt><decl><type><name>pthread_attr_t</name></type> <name>t_atts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sigset_t</name></type>	<name>pthread_sigs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>set_test_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Initialize global ic control data. */</comment>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>eno</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>isSender</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>socketSendBufferSize</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>socketRecvBufferSize</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>memContext</name></name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
													   <argument><expr><literal type="string">"UdpInterconnectMemContext"</literal></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
													   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initMutex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>shutdown</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>threadCreated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>ic_instance_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ic_control_info</name><operator>.</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initConnHashTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>initConnHashTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"failed to initialize connection htab for startup cache"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * setup listening socket and sending socket for Interconnect.
	 */</comment>
	<expr_stmt><expr><call><name>setupUDPListeningSocket</name><argument_list>(<argument><expr><name>listenerSocketFd</name></expr></argument>, <argument><expr><name>listenerPort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>txFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setupUDPListeningSocket</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ICSenderSocket</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ICSenderPort</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ICSenderFamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize receive control data. */</comment>
	<expr_stmt><expr><call><name>resetMainThreadWaiting</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate a buffer for sending disorder messages */</comment>
	<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>disorderBuffer</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MIN_PACKET_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>lastDXatId</name></name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>lastTornIcId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initCursorICHistoryTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize receive buffer pool */</comment>
	<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>freeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Initialize send control data */</comment>
	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>ackBuffer</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>MIN_PACKET_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>initMutex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>trans_proto_stats</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Start up our rx-thread */</comment>

	<comment type="block">/*
	 * save ourselves some memory: the defaults for thread stack size are
	 * large (1M+)
	 */</comment>
	<expr_stmt><expr><call><name>pthread_attr_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_attr_setstacksize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>PTHREAD_STACK_MIN</name></expr></argument>, <argument><expr><operator>(</operator><literal type="number">128</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_set_pthread_sigmasks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pthread_sigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pthread_err</name> <operator>=</operator> <call><name>pthread_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>threadHandle</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>, <argument><expr><name>rxThreadFunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ic_reset_pthread_sigmasks</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pthread_sigs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_attr_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t_atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pthread_err</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>threadCreated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"InitMotionLayerIPC: failed to create thread"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"pthread_create() failed with err %d"</literal></expr></argument>, <argument><expr><name>pthread_err</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>threadCreated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CleanupMotionUDPIFC
 * 		Clean up UDP specific stuff such as cursor ic hash table, thread etc.
 */</comment>
<function><type><name>void</name></type>
<name>CleanupMotionUDPIFC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"udp-ic: telling receiver thread to shutdown."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should not hold any lock when we reach here even when we report
	 * FATAL errors. Just in case, We still release the locks here.
	 */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Shutdown rx thread. */</comment>
	<expr_stmt><expr><call><name>pg_atomic_test_set_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>shutdown</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ic_control_info</name><operator>.</operator><name>threadCreated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pthread_join</name><argument_list>(<argument><expr><name><name>ic_control_info</name><operator>.</operator><name>threadHandle</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"udp-ic: receiver thread shutdown."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>purgeCursorIcEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>destroyConnHashTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* background thread exited, we can do the cleanup without locking. */</comment>
	<expr_stmt><expr><call><name>cleanupStartupCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>destroyConnHashTable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free the disorder buffer */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>rx_control_info</name><operator>.</operator><name>disorderBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>disorderBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* free the buffer for acks */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>snd_control_info</name><operator>.</operator><name>ackBuffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>ackBuffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name><name>ic_control_info</name><operator>.</operator><name>memContext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ICSenderSocket</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>ICSenderSocket</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>ICSenderSocket</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ICSenderPort</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ICSenderFamily</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>

	<comment type="block">/*
	 * Check malloc times, in Interconnect part, memory are carefully released
	 * in tear down code (even when error occurred). But if a FATAL error is
	 * reported, tear down code will not be executed. Thus, it is still
	 * possible the malloc times and free times do not match when we reach
	 * here. The process will die in this case, the mismatch does not
	 * introduce issues.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>icudp_malloc_times</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"WARNING: malloc times and free times do not match."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * initConnHashTable
 * 		Initialize a connection hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>initConnHashTable</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>MemoryContext</name></type> <name>cxt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name> <operator>=</operator> <name>cxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <ternary><condition><expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr> ?</condition><then> <expr><operator>(</operator><call><name>getPxWorkerCount</name><argument_list>()</argument_list></call> <operator>*</operator> <literal type="number">5</literal><operator>)</operator></expr> </then><else>: <expr><name>ic_htab_size</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <operator>(</operator>struct <name>ConnHtabBin</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>ConnHtabBin</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <operator>(</operator>struct <name>ConnHtabBin</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>ConnHtabBin</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * connAddHash
 * 		Add a connection to the hash table
 *
 * Note: we want to add a connection to the hashtable if it isn't
 * already there ... so we just have to check the pointer values -- no
 * need to use CONN_HASH_MATCH() at all!
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>connAddHash</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ConnHtabBin</name></name> <modifier>*</modifier></type><name>bin</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>newbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>old</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>CONN_HASH_VALUE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * check for collision -- if we already have an entry for this connection,
	 * don't add another one.
	 */</comment>
	<for>for <control>(<init><expr><name>bin</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>hashcode</name></expr>]</index></name></expr>;</init> <condition><expr><name>bin</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>bin</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>conn</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"connAddHash(): duplicate ?! node %d route %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>		<comment type="block">/* false *only* indicates memory-alloc
								 * failure. */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newbin</name> <operator>=</operator> <operator>(</operator>struct <name>ConnHtabBin</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ConnHtabBin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>newbin</name> <operator>=</operator> <operator>(</operator>struct <name>ConnHtabBin</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>ConnHtabBin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newbin</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>newbin</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newbin</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>hashcode</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>hashcode</name></expr>]</index></name> <operator>=</operator> <name>newbin</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>activeConnectionsNum</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * connDelHash
 * 		Delete a connection from the hash table
 *
 * Note: we want to remove a connection from the hashtable if it is
 * there ... so we just have to check the pointer values -- no need to
 * use CONN_HASH_MATCH() at all!
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>connDelHash</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ConnHtabBin</name></name> <modifier>*</modifier></type><name>c</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>trash</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>CONN_HASH_VALUE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>hashcode</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* find entry */</comment>
	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>c</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* found ? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* not found ? */</comment>
	<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* found the connection, remove from the chain. */</comment>
	<expr_stmt><expr><name>trash</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>hashcode</name></expr>]</index></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>activeConnectionsNum</name></name><operator>--</operator></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * findConnByHeader
 * 		Find the corresponding connection given a pkt header information.
 *
 * With the new mirroring scheme, the interconnect is no longer involved:
 * we don't have to disambiguate anymore.
 *
 * NOTE: the icpkthdr field dstListenerPort is used for disambiguation.
 * on receivers it may not match the actual port (it may have an extra bit
 * set (1&lt;&lt;31)).
 */</comment>
<function><type><specifier>static</specifier> <name>MotionConn</name> <modifier>*</modifier></type>
<name>findConnByHeader</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>ConnHtabBin</name></name> <modifier>*</modifier></type><name>bin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>CONN_HASH_VALUE</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call> <operator>%</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>bin</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>hashcode</name></expr>]</index></name></expr>;</init> <condition><expr><name>bin</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>bin</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>CONN_HASH_MATCH</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>DEBUG5</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"findConnByHeader: found. route %d state %d hashcode %d conn %p"</literal></expr></argument>,
						  <argument><expr><name><name>ret</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>ret</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>DEBUG5</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"findConnByHeader: not found! (hdr-&gt;srcPid %d "</literal>
				  <literal type="string">"hdr-&gt;srcContentId %d hdr-&gt;dstContentId %d hdr-&gt;dstPid %d sess(%d:%d) cmd(%d:%d)) hashcode %d"</literal></expr></argument>,
				  <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>dstContentId</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>,
				  <argument><expr><name>px_session_id</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>ic_instance_id</name></name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * destroyConnHashTable
 * 		Release the connection hash table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroyConnHashTable</name><parameter_list>(<parameter><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>ConnHtabBin</name></name> <modifier>*</modifier></type><name>trash</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>trash</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>trash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>ht</name><operator>-&gt;</operator><name>cxt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ht</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sendControlMessage
 * 		Helper function to send a control message.
 *
 * It is different from sendOnce which retries on interrupts...
 * Here, we leave it to retransmit logic to handle these cases.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>sendControlMessage</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr</name></name> <modifier>*</modifier></type><name>addr</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name></type> <name>peerLen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>testmode_inject_fault</name><argument_list>(<argument><expr><name>px_interconnect_udpic_dropacks_percent</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"THROW CONTROL MESSAGE with seq %d extraSeq %d srcpid %d despid %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Add CRC for the control message. */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_full_crc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>addCRC</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sendto</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>pkt</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>peerLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need to handle EAGAIN here: no-space just means that we dropped the
	 * packet: our ordinary retransmit mechanism will handle that case
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"sendcontrolmessage: got error %d errno %d seq %d"</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setAckSendParam
 * 		Set the ack sending parameters.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>setAckSendParam</name><parameter_list>(<parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>extraSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>extraSeq</name></name> <operator>=</operator> <name>extraSeq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>peer</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>peer_len</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sendAckWithParam
 * 		Send acknowledgment to sender.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>sendAckWithParam</name><parameter_list>(<parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sendControlMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>UDP_listenerFd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sendAck
 * 		Send acknowledgment to sender.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendAck</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>extraSeq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name></type>	<name>msg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>extraSeq</name></name> <operator>=</operator> <name>extraSeq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"sendack: flags 0x%x node %d route %d seq %d extraSeq %d"</literal></expr></argument>,
			  <argument><expr><name><name>msg</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>msg</name><operator>.</operator><name>extraSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>sendControlMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>UDP_listenerFd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * sendDisorderAck
 *		Send a disorder message to the sender.
 *
 * Whenever the receiver detects a disorder packet, it will assemble a disorder message
 * which contains the sequence numbers of the possibly lost packets.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendDisorderAck</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>extraSeq</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>lostPktCnt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>disorderBuffer</name> <init>= <expr><name><name>rx_control_info</name><operator>.</operator><name>disorderBuffer</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>disorderBuffer</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>disorderBuffer</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_DISORDER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disorderBuffer</name><operator>-&gt;</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disorderBuffer</name><operator>-&gt;</operator><name>extraSeq</name></name> <operator>=</operator> <name>extraSeq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>disorderBuffer</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>lostPktCnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"UDP Interconnect bug (in sendDisorderAck): trying to send ack when we don't know where to send to %s"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>sendControlMessage</name><argument_list>(<argument><expr><name>disorderBuffer</name></expr></argument>, <argument><expr><name>UDP_listenerFd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * sendStatusQueryMessage
 *		Used by senders to send a status query message for a connection to receivers.
 *
 * When receivers get such a message, they will respond with
 * the connection status (consumed seq, received seq ...).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendStatusQueryMessage</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>seq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name></type>	<name>msg</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>UDPIC_FLAGS_CAPACITY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>extraSeq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>msg</name><operator>.</operator><name>len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>updateStats</name><argument_list>(<argument><expr><name>TPE_ACK_PKT_QUERY</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>sendControlMessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msg</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * putRxBufferAndSendAck
 * 		Return a buffer and send an acknowledgment.
 *
 *  SHOULD BE CALLED WITH ic_control_info.lock *LOCKED*
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>putRxBufferAndSendAck</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>seq</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr>]</index></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"putRxBufferAndSendAck: buffer is NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>seq</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>seq</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"putRxBufferAndSendAck conn %p pkt [seq %d] for node %d route %d, [head seq] %d queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name> <operator>=</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name><operator>--</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"putRxBufferAndSendAck conn %p pkt [seq %d] for node %d route %d, [head seq] %d queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>putRxBufferToFreeList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>extraSeq</name></name> <operator>=</operator> <name>seq</name></expr>;</expr_stmt>

	<comment type="block">/* Send an Ack to the sender. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>seq</name> <operator>%</operator> <literal type="number">2</literal> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>param</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>sendAck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * MlPutRxBufferIFC
 *
 * The pxmotion code has discarded our pointer to the motion-conn
 * structure, but has enough info to fully specify it.
 */</comment>
<function><type><name>void</name></type>
<name>MlPutRxBufferIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>route</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AckSendParam</name></type> <name>param</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>route</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AckSendParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>putRxBufferAndSendAck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Interconnect error: tried to release a NULL buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * real ack sending is after lock release to decrease the lock holding
	 * time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>msg</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>sendAckWithParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getRxBuffer
 * 		Get a receive buffer.
 *
 * SHOULD BE CALLED WITH ic_control_info.lock *LOCKED*
 *
 * NOTE: This function MUST NOT contain elog or ereport statements.
 * elog is NOT thread-safe.  Developers should instead use something like:
 *
 *	if (DEBUG3 &gt;= log_min_messages)
 *		write_log("my brilliant log statement here.");
 *
 * NOTE: In threads, we cannot use palloc/pfree, because it's not thread safe.
 */</comment>
<function><type><specifier>static</specifier> <name>icpkthdr</name> <modifier>*</modifier></type>
<name>getRxBuffer</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>FINC_HAS_FAULT</name><argument_list>(<argument><expr><name>FINC_RX_BUF_NULL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>testmode_inject_fault</name><argument_list>(<argument><expr><name>px_interconnect_udpic_fault_inject_percent</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <name><name>p</name><operator>-&gt;</operator><name>maxCount</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG3</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Interconnect ran out of rx-buffers count/max %d/%d"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>maxCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* malloc is used for thread safty. */</comment>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Note: we return NULL if the malloc() fails -- and the
			 * background thread will set the error. Main thread will check
			 * the error, report it and start teardown.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* we have buffers available in our freelist */</comment>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>getRxBufferFromFreeList</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * putRxBufferToFreeList
 * 		Return a receive buffer to free list
 *
 *  SHOULD BE CALLED WITH ic_control_info.lock *LOCKED*
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>putRxBufferToFreeList</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* return the buffer into the free list. */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>buf</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>freeList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>freeList</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getRxBufferFromFreeList
 * 		Get a receive buffer from free list
 *
 * SHOULD BE CALLED WITH ic_control_info.lock *LOCKED*
 *
 * NOTE: This function MUST NOT contain elog or ereport statements.
 * elog is NOT thread-safe.  Developers should instead use something like:
 *
 *	if (DEBUG3 &gt;= log_min_messages)
 *		write_log("my brilliant log statement here.");
 *
 * NOTE: In threads, we cannot use palloc/pfree, because it's not thread safe.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>icpkthdr</name> <modifier>*</modifier></type>
<name>getRxBufferFromFreeList</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>p</name><operator>-&gt;</operator><name>freeList</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>freeList</name></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>freeList</name></name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * freeRxBuffer
 * 		Free a receive buffer.
 *
 * NOTE: This function MUST NOT contain elog or ereport statements.
 * elog is NOT thread-safe.  Developers should instead use something like:
 *
 *	if (DEBUG3 &gt;= log_min_messages)
 *		write_log("my brilliant log statement here.");
 *
 * NOTE: In threads, we cannot use palloc/pfree, because it's not thread safe.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>freeRxBuffer</name><parameter_list>(<parameter><decl><type><name>RxBufferPool</name> <modifier>*</modifier></type> <name>p</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>count</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setSocketBufferSize
 * 		Set socket buffer size.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32</name></type>
<name>setSocketBufferSize</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expectedSize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>leastSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>bufSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>errnoSave</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>skLen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fun</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"getsockopt"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>skLen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bufSize</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>getsockopt</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>bufSize</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>skLen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"UDP-IC: xmit default buffer size %d bytes"</literal></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We'll try the expected size first, and fall back to least size if that
	 * doesn't work.
	 */</comment>

	<expr_stmt><expr><name>bufSize</name> <operator>=</operator> <name>expectedSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>fun</name> <operator>=</operator> <literal type="string">"setsockopt"</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><call><name>setsockopt</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>SOL_SOCKET</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>bufSize</name></expr></argument>, <argument><expr><name>skLen</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"set_socket_buffer_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bufSize</name> <operator>=</operator> <name>bufSize</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bufSize</name> <operator>&lt;</operator> <name>leastSize</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"UDP-IC: xmit use buffer size %d bytes"</literal></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>bufSize</name></expr>;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><name>errnoSave</name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>closesocket</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>errnoSave</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Could not set up udp listener socket"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%s: %m"</literal></expr></argument>, <argument><expr><name>fun</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Make GCC not complain. */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * setXmitSocketOptions
 * 		Set transmit socket options.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setXmitSocketOptions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>txfd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>bufSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The px_interconnect_udp_bufsize_k guc should be set carefully.
	 *
	 * If it is small, such as 128K, and send queue depth and receive queue
	 * depth are large, then it is possible OS can not handle all of the UDP
	 * packets GPDB delivered to it. OS will introduce a lot of packet losses
	 * and disordered packets.
	 *
	 * In order to set px_interconnect_udp_bufsize_k to a larger value, the OS UDP buffer
	 * should be set to a large enough value.
	 *
	 */</comment>
	<expr_stmt><expr><name>bufSize</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>px_interconnect_udp_bufsize_k</name> <operator>!=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>px_interconnect_udp_bufsize_k</name> <operator>*</operator> <literal type="number">1024</literal></expr> </then><else>: <expr><literal type="number">2048</literal> <operator>*</operator> <literal type="number">1024</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>socketRecvBufferSize</name></name> <operator>=</operator> <call><name>setSocketBufferSize</name><argument_list>(<argument><expr><name>txfd</name></expr></argument>, <argument><expr><name>SO_RCVBUF</name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>, <argument><expr><literal type="number">128</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>socketSendBufferSize</name></name> <operator>=</operator> <call><name>setSocketBufferSize</name><argument_list>(<argument><expr><name>txfd</name></expr></argument>, <argument><expr><name>SO_SNDBUF</name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>, <argument><expr><literal type="number">128</literal> <operator>*</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ASSERT_CHECKING</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>AMS_VERBOSE_LOGGING</name></expr></argument>)</argument_list></call></expr></cpp:if>

<comment type="block">/*
 * icBufferListLog
 * 		Log the buffer list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>icBufferListLog</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>bufLink</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Length %d, type %d headptr %p"</literal></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>bufLink</name> <operator>!=</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ICBufferListType_Primary</name></expr> ?</condition><then> <expr><call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr>
						   </then><else>: <expr><call><name>GET_ICBUFFER_FROM_SECONDARY</name><argument_list>(<argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Node %d, linkptr %p"</literal></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"from list"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bufLink</name> <operator>=</operator> <name><name>bufLink</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * icBufferListCheck
 * 		Buffer list sanity check.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>icBufferListCheck</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>link</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NULL</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_buffer_list_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ICBufferList ERROR %s: NULL list"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>&lt;</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_buffer_list_length_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ICBufferList ERROR %s: list length %d &lt; 0 "</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>prev</name></name> <operator>!=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>next</name></name> <operator>&amp;&amp;</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>prev</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_buffer_list_length_error_2"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ICBufferList ERROR %s: length is 0, &amp;list-&gt;head %p, prev %p, next %p"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>prev</name></name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>link</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>link</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>link</name> <operator>!=</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"ic_buffer_link_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ICBufferList ERROR: %s len %d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>error</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>

<label><name>error</name>:</label>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"wait for 120s and then abort."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">120000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * icBufferListInitHeadLink
 * 		Initialize the pointers in the head link to point to itself.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>icBufferListInitHeadLink</name><parameter_list>(<parameter><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type> <name>link</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>link</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>link</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListInit
 * 		Initialize the buffer list with the given type.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>icBufferListInit</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBufferListType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>icBufferListInitHeadLink</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListInit"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListIsHead
 * 		Return whether the given link is the head link of the list.
 *
 * 	This function is often used as the end condition of an iteration of the list.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>icBufferListIsHead</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type> <name>link</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListIsHead"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><operator>(</operator><name>link</name> <operator>==</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListFirst
 * 		Return the first link after the head link.
 *
 * 	Note that the head link is a pseudo link used to only to ease the operations of the link list.
 * 	If the list only contains the head link, this function will return the head link.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBufferLink</name> <modifier>*</modifier></type>
<name>icBufferListFirst</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListFirst"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>next</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListLength
 * 		Get the list length.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>icBufferListLength</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListLength"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListDelete
 *		Remove an buffer from the buffer list and return the buffer.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBuffer</name> <modifier>*</modifier></type>
<name>icBufferListDelete</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>bufLink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListDelete"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>bufLink</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ICBufferListType_Primary</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>primary</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>secondary</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufLink</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>bufLink</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufLink</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>bufLink</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListPop
 * 		Remove the head buffer from the list.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBuffer</name> <modifier>*</modifier></type>
<name>icBufferListPop</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>bufLink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListPop"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bufLink</name> <operator>=</operator> <call><name>icBufferListFirst</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ICBufferListType_Primary</name></expr> ?</condition><then> <expr><call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr>
		   </then><else>: <expr><call><name>GET_ICBUFFER_FROM_SECONDARY</name><argument_list>(<argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufLink</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>bufLink</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufLink</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>bufLink</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>--</operator></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListFree
 * 		Free all the buffers in the list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>icBufferListFree</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListFree"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>icBufferListPop</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></function>

<comment type="block">/*
 * icBufferListAppend
 * 		Append a buffer to a list.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>ICBuffer</name> <modifier>*</modifier></type>
<name>icBufferListAppend</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>bufLink</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListAppend"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>bufLink</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>list</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>ICBufferListType_Primary</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>primary</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>secondary</name></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>bufLink</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>prev</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufLink</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>bufLink</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name><operator>.</operator><name>prev</name></name> <operator>=</operator> <name>bufLink</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * icBufferListReturn
 * 		Return the buffers in the list to the free buffer list.
 *
 * If the buf is also in an expiration queue, we also need to remove it from the expiration queue.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>icBufferListReturn</name><parameter_list>(<parameter><decl><type><name>ICBufferList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inExpirationQueue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>icBufferListCheck</name><argument_list>(<argument><expr><literal type="string">"icBufferListReturn"</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<while>while <condition>(<expr><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>icBufferListPop</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>inExpirationQueue</name></expr>)</condition>	<comment type="block">/* the buf is in also in the expiration queue */</comment>
		<block>{<block_content>
			<expr_stmt><expr><call><name>icBufferListDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unack_queue_ring</name><operator>.</operator><name>slots</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>numOutStanding</name></name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>numSharedOutStanding</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>snd_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * initUnackQueueRing
 *		Initialize an unack queue ring.
 *
 *	Align current time to a slot boundary and set current slot index (time pointer) to 0.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initUnackQueueRing</name><parameter_list>(<parameter><decl><type><name>UnackQueueRing</name> <modifier>*</modifier></type><name>uqr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>uqr</name><operator>-&gt;</operator><name>currentTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>uqr</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>uqr</name><operator>-&gt;</operator><name>numOutStanding</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>uqr</name><operator>-&gt;</operator><name>numSharedOutStanding</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>UNACK_QUEUE_RING_SLOTS_NUM</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>icBufferListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>uqr</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ICBufferListType_Secondary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * computeExpirationPeriod
 * 		Compute expiration period according to the connection information.
 *
 * Considerations on expiration period computation:
 *
 * RTT is dynamically computed, and expiration period is based on RTT values.
 * We cannot simply use RTT as the expiration value, since real workload does
 * not always have a stable RTT. A small constant value is multiplied to the RTT value
 * to make the resending logic insensitive to the frequent small changes of RTT.
 *
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint64</name></type>
<name>computeExpirationPeriod</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>retry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * In fault injection mode, we often use DEFAULT_RTT, because the
	 * intentional large percent of packet/ack losses will make the RTT too
	 * large. This will lead to a slow retransmit speed. In real hardware
	 * environment/workload, we do not expect such a packet loss pattern.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>px_enable_udp_testmode</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>DEFAULT_RTT</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>factor</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>retry</name> <operator>&lt;=</operator> <literal type="number">12</literal></expr> ?</condition><then> <expr><name>retry</name></expr> </then><else>: <expr><literal type="number">12</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

		<return>return <expr><call><name>Max</name><argument_list>(<argument><expr><name>MIN_EXPIRATION_PERIOD</name></expr></argument>, <argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>MAX_EXPIRATION_PERIOD</name></expr></argument>, <argument><expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>rtt</name></name> <operator>+</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>dev</name></name> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <operator>(</operator><name>factor</name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * initSndBufferPool
 * 		Initialize the send buffer pool.
 *
 * The initial maxCount is set to 1 for px_interconnect_snd_queue_depth = 1 case,
 * then there is at least an extra free buffer to send for that case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initSndBufferPool</name><parameter_list>(<parameter><decl><type><name>SendBufferPool</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>icBufferListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>, <argument><expr><name>ICBufferListType_Primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>maxCount</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>px_interconnect_snd_queue_depth</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * cleanSndBufferPool
 * 		Clean the send buffer pool.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>cleanSndBufferPool</name><parameter_list>(<parameter><decl><type><name>SendBufferPool</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>icBufferListFree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>maxCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getSndBuffer
 * 		Get a send buffer for a connection.
 *
 *  Different flow control mechanisms use different buffer management policies.
 *  Capacity based flow control uses per-connection buffer policy and Loss based
 *  flow control uses shared buffer policy.
 *
 * 	Return NULL when no free buffer available.
 */</comment>
<function><type><specifier>static</specifier> <name>ICBuffer</name> <modifier>*</modifier></type>
<name>getSndBuffer</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>totalBuffers</name></name> <operator>+=</operator> <operator>(</operator><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>snd_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name> <operator>-</operator> <name><name>snd_buffer_pool</name><operator>.</operator><name>count</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>bufferCountingTime</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Capacity based flow control does not use shared buffers */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_CAPACITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>px_interconnect_snd_queue_depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>px_interconnect_snd_queue_depth</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>snd_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>icBufferListPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>snd_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>snd_buffer_pool</name><operator>.</operator><name>count</name></name> <operator>&lt;</operator> <name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldContext</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>oldContext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>px_InterconnectContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ICBuffer</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>px_interconnect_max_packet_size</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ICBuffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icBufferListInitHeadLink</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>primary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icBufferListInitHeadLink</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><operator>-&gt;</operator><name>secondary</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * startOutgoingUDPConnections
 * 		Used to initially kick-off any outgoing connections for mySlice.
 *
 * This should not be called for root slices (i.e. QC ones) since they don't
 * ever have outgoing connections.
 *
 * PARAMETERS
 *
 *	 sendSlice	- Slice that this process is a member of.
 *
 * RETURNS
 *	 Initialized ChunkTransportState for the Sending Motion Node Id.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkTransportStateEntry</name> <modifier>*</modifier></type>
<name>startOutgoingUDPConnections</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
							<parameter><decl><type><name>ExecSlice</name> <modifier>*</modifier></type> <name>sendSlice</name></decl></parameter>,
							<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pOutgoingCount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>recvSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxProc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>pOutgoingCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>recvSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sendSlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Potentially introduce a Bug (PX-17186). The workaround is to turn off
	 * log_hostname guc.
	 */</comment>
	<expr_stmt><expr><call><name>adjustMasterRouting</name><argument_list>(<argument><expr><name>recvSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d setting up sending motion node"</literal></expr></argument>,
			 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>createChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>,
									   <argument><expr><name>sendSlice</name></expr></argument>,
									   <argument><expr><name>recvSlice</name></expr></argument>,
									   <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>recvSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name> <operator>&amp;&amp;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup a MotionConn entry for each of our outbound connections. Request
	 * a connection to each receiving backend's listening port. NB: Some
	 * mirrors could be down &amp; have no PxProcess entry.
	 */</comment>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>recvSlice-&gt;primaryProcesses</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>pxProc</name> <operator>=</operator> <operator>(</operator><name>PxProcess</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pxProc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>=</operator> <name>pxProc</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icBufferListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>, <argument><expr><name>ICBufferListType_Primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icBufferListInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>ICBufferListType_Primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>px_interconnect_queue_depth</name></expr>;</expr_stmt>

			<comment type="block">/* send buffer pool must be initialized before this. */</comment>
			<expr_stmt><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name> <operator>+=</operator> <name>px_interconnect_snd_queue_depth</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>=</operator> <call><name>getSndBuffer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* should have at least one buffer for each connection */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>rtt</name></name> <operator>=</operator> <name>DEFAULT_RTT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>dev</name></name> <operator>=</operator> <name>DEFAULT_DEV</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>sentSeq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>consumedSeq</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>curBuff</name><operator>-&gt;</operator><name>pkt</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsSetupOutgoingConnection</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name> <operator>=</operator> <name>i</name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>pOutgoingCount</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>conn</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name> <operator>=</operator> <name>ICSenderSocket</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txport</name></name> <operator>=</operator> <name>ICSenderPort</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd_family</name></name> <operator>=</operator> <name>ICSenderFamily</name></expr>;</expr_stmt>

	<return>return <expr><name>pEntry</name></expr>;</return>

</block_content>}</block></function>


<comment type="block">/*
 * getSockAddr
 * 		Convert IP addr and port to sockaddr
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getSockAddr</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name> <modifier>*</modifier></type> <name>peer_len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>listenerAddr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>listenerPort</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>portNumberStr</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>service</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name> <modifier>*</modifier></type><name>addrs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>addrinfo</name></name></type> <name>hint</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get socketaddr to connect to.
	 */</comment>

	<comment type="block">/* Initialize hint structure */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_socktype</name></name> <operator>=</operator> <name>SOCK_DGRAM</name></expr>;</expr_stmt>	<comment type="block">/* UDP */</comment>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name> <operator>=</operator> <name>AF_UNSPEC</name></expr>;</expr_stmt> <comment type="block">/* Allow for any family (v4, v6, even unix in
								 * the future)  */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AI_NUMERICSERV</name></cpp:ifdef>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name> <operator>|</operator> <name>AI_NUMERICSERV</name></expr>;</expr_stmt>	<comment type="block">/* Never do name
														 * resolution */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>hint</name><operator>.</operator><name>ai_flags</name></name> <operator>=</operator> <name>AI_NUMERICHOST</name></expr>;</expr_stmt> <comment type="block">/* Never do name resolution */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>portNumberStr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>listenerPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>service</name> <operator>=</operator> <name>portNumberStr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>pg_getaddrinfo_all</name><argument_list>(<argument><expr><name>listenerAddr</name></expr></argument>, <argument><expr><name>service</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hint</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>||</operator> <operator>!</operator><name>addrs</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>addrs</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>hint</name><operator>.</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error: Could not parse remote listener address: '%s' port '%d': %s"</literal></expr></argument>,
						<argument><expr><name>listenerAddr</name></expr></argument>, <argument><expr><name>listenerPort</name></expr></argument>, <argument><expr><call><name>gai_strerror</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"getaddrinfo() unable to parse address: '%s'"</literal></expr></argument>,
						   <argument><expr><name>listenerAddr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since we aren't using name resolution, getaddrinfo will return only 1
	 * entry
	 */</comment>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"GetSockAddr socket ai_family %d ai_socktype %d ai_protocol %d for %s "</literal></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_socktype</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_protocol</name></name></expr></argument>, <argument><expr><name>listenerAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_storage</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_addr</name></name></expr></argument>, <argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>peer_len</name> <operator>=</operator> <name><name>addrs</name><operator>-&gt;</operator><name>ai_addrlen</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pg_freeaddrinfo_all</name><argument_list>(<argument><expr><name><name>addrs</name><operator>-&gt;</operator><name>ai_family</name></name></expr></argument>, <argument><expr><name>addrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setupOutgoingUDPConnection
 *		Setup outgoing UDP connection.
 */</comment>
<function><type><name>void</name></type>
<name>setupOutgoingUDPConnection</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PxProcess</name> <modifier>*</modifier></type><name>pxProc</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name> <modifier>*</modifier></type><name>sliceTbl</name> <init>= <expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsSetupOutgoingConnection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>wakeup_ms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name> <operator>=</operator> <name><name>pxProc</name><operator>-&gt;</operator><name>contentid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name> <operator>=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Save the information for the error message if getaddrinfo fails */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"[%s]:%d"</literal></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"%s:%d"</literal></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Get socketaddr to connect to.
	 */</comment>
	<expr_stmt><expr><call><name>getSockAddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerAddr</name></name></expr></argument>, <argument><expr><name><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the destination IP address */</comment>
	<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>source_addr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>socklen_t</name></type>	<name>source_addr_len</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>source_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>source_addr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>source_addr_len</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>source_addr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>getsockname</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>source_addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>source_addr_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect Error: Could not get port from socket"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"%m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd_family</name></name> <operator>==</operator> <name><name>source_addr</name><operator>.</operator><name>ss_family</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * If the socket was created with a different address family than the
		 * place we are sending to, we might need to do something special.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd_family</name></name> <operator>!=</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If the socket was created AF_INET6, but the address we want to
			 * send to is IPv4 (AF_INET), we might need to change the address
			 * format.  On Linux, it isn't necessary:  glibc automatically
			 * handles this.  But on MAC OSX and Solaris, we need to convert
			 * the IPv4 address to an V4-MAPPED address in AF_INET6 format.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>temp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>sockaddr_in</name></name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><specifier>const</specifier> struct <name>sockaddr_in</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_in6</name></name> <modifier>*</modifier></type><name>in6_new</name> <init>= <expr><operator>(</operator>struct <name>sockaddr_in6</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>temp</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"We are inet6, remote is inet.  Converting to v4 mapped address."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Construct a V4-to-6 mapped address.  */</comment>
				<expr_stmt><expr><name><name>temp</name><operator>.</operator><name>ss_family</name></name> <operator>=</operator> <name>AF_INET6</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_family</name></name> <operator>=</operator> <name>AF_INET6</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_port</name></name> <operator>=</operator> <name><name>in</name><operator>-&gt;</operator><name>sin_port</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_flowinfo</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_addr</name></name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* in6_new-&gt;sin6_addr.s6_addr16[5] = 0xffff; */</comment>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_addr</name></name><operator>)</operator><index>[<expr><literal type="number">5</literal></expr>]</index> <operator>=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
				<comment type="block">/* in6_new-&gt;sin6_addr.s6_addr32[3] = in-&gt;sin_addr.s_addr; */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_addr</name></name><operator>)</operator> <operator>+</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>sin_addr</name></name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>in6_new</name><operator>-&gt;</operator><name>sin6_scope_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<comment type="block">/* copy it back */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>temp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>sockaddr_in6</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * If we get here, something is really wrong.  We created the
				 * socket as IPv4-only (AF_INET), but the address we are
				 * trying to send to is IPv6.  It's possible we could have a
				 * V4-mapped address that we could convert to an IPv4 address,
				 * but there is currently no code path where that could
				 * happen.  So this must be an error.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Trying to use an IPv4 (AF_INET) socket to send to an IPv6 address"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect connecting to seg%d slice%d %s "</literal>
								<literal type="string">"pid=%d sockfd=%d"</literal></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
								<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,
								<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* send connection request */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>motNodeId</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>motNodeId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>recvSliceIndex</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>sendSliceIndex</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>sendSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>srcContentId</name></name> <operator>=</operator> <name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstContentId</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>contentid</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"setupOutgoingUDPConnection: node %d route %d srccontent %d dstcontent %d: %s"</literal></expr></argument>,
			 <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>contentid</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>srcListenerPort</name></name> <operator>=</operator> <operator>(</operator><name>px_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>srcPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstPid</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstListenerPort</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>sessionId</name></name> <operator>=</operator> <name>px_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>icId</name></name> <operator>=</operator> <name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>connAddHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * No need to get the connection lock here, since background rx thread
	 * will never access send connections.
	 */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>								<comment type="block">/* setupOutgoingUDPConnection */</comment>

<comment type="block">/*
 * handleCachedPackets
 * 		Deal with cached packets.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handleCachedPackets</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>cachedConn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>setupConn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConnHtabBin</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>pkt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AckSendParam</name></type> <name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dummy</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>bin</name> <operator>=</operator> <name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name><operator>.</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>bin</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cachedConn</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>conn</name></name></expr><operator>,</operator>
				<expr><name>setupConn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>pkt</name> <operator>=</operator> <operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>pkt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name><operator>--</operator></expr>;</expr_stmt>

				<comment type="block">/* look up this pkt's connection in connHtab */</comment>
				<expr_stmt><expr><name>setupConn</name> <operator>=</operator> <call><name>findConnByHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>setupConn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* mismatch! */</comment>
					<expr_stmt><expr><call><name>putRxBufferToFreeList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>handleDataPacket</name><argument_list>(<argument><expr><name>setupConn</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cachedConn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cachedConn</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* no need to cache this packet */</comment>
					<expr_stmt><expr><call><name>putRxBufferToFreeList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>recvPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>msg</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sendAckWithParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>bin</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>connDelHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name></name></expr></argument>, <argument><expr><name>cachedConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * PX-19981 free the cached connections; otherwise memory leak
			 * would be introduced.
			 */</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cachedConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * SetupUDPIFCInterconnect_Internal
 * 		Internal function for setting up UDP interconnect.
 */</comment>
<function><type><specifier>static</specifier> <name>ChunkTransportState</name> <modifier>*</modifier></type>
<name>SetupUDPIFCInterconnect_Internal</name><parameter_list>(<parameter><decl><type><name>SliceTable</name> <modifier>*</modifier></type> <name>sliceTable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>mySlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>aSlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>incoming_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>outgoing_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>expectedTotalIncoming</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>expectedTotalOutgoing</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>sendingChunkTransportState</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>interconnect_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>px_interconnect_id</name> <operator>==</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		* QC use cursorHistoryTable to handle mismatch packets, no
		* need to update ic_control_info.ic_instance_id
		*/</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		* update ic_control_info.ic_instance_id, it is mainly used
		* by rx thread to handle mismatch packets
		*/</comment>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>ic_instance_id</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>interconnect_context</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ChunkTransportState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize state variables */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>CTS_INITIAL_SIZE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>CTS_INITIAL_SIZE</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ChunkTransportStateEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>networkTimeoutIsLogged</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>teardownActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>incompleteConns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceId</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>RecvTupleChunkFrom</name></name> <operator>=</operator> <name>RecvTupleChunkFromUDPIFC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>RecvTupleChunkFromAny</name></name> <operator>=</operator> <name>RecvTupleChunkFromAnyUDPIFC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>SendEos</name></name> <operator>=</operator> <name>SendEosUDPIFC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>SendChunk</name></name> <operator>=</operator> <name>SendChunkUDPIFC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>doSendStopMessage</name></name> <operator>=</operator> <name>doSendStopMessageUDPIFC</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>mySlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>mySlice</name> <operator>&amp;&amp;</operator>
		   <name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name> <operator>==</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>localSlice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>set_test_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>distTransId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Prune only when we are not in the save transaction and there is a
		 * large number of entries in the table
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>distTransId</name> <operator>!=</operator> <name><name>rx_control_info</name><operator>.</operator><name>lastDXatId</name></name> <operator>&amp;&amp;</operator> <name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <name>CURSOR_IC_TABLE_SIZE</name><operator>)</operator><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"prunce_cursor_ic_entry"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"prune cursor history table (count %d), icid %d"</literal></expr></argument>, <argument><expr><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pruneCursorIcEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name></name></expr></argument>, <argument><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>addCursorIcEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name></name></expr></argument>, <argument><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>, <argument><expr><name>px_command_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save the latest transaction id. */</comment>
		<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>lastDXatId</name></name> <operator>=</operator> <name>distTransId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* now we'll do some setup for each of our Receiving Motion Nodes. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mySlice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numProcs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childId</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>aSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>interconnect_context</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childId</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numProcs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Setup recving connections: my slice %d, childId %d"</literal></expr></argument>,
				 <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name>childId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>createChunkTransportState</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>aSlice</name></expr></argument>, <argument><expr><name>mySlice</name></expr></argument>, <argument><expr><name>numProcs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>=</operator> <call><name>list_nth</name><argument_list>(<argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>expectedTotalIncoming</name><operator>++</operator></expr>;</expr_stmt>

				<comment type="block">/* rx_buffer_queue */</comment>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name> <operator>=</operator> <name>px_interconnect_queue_depth</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* update the max buffer count of our rx buffer pool.  */</comment>
				<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</expr_stmt>


				<comment type="block">/*
				 * connection header info (defining characteristics of this
				 * connection)
				 */</comment>
				<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name> <operator>=</operator> <call><name>CreateTupleRemapper</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>incoming_count</name><operator>++</operator></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>motNodeId</name></name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>motNodeId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>recvSliceIndex</name></name> <operator>=</operator> <name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>sendSliceIndex</name></name> <operator>=</operator> <name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>srcContentId</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>contentid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstContentId</name></name> <operator>=</operator> <name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>srcListenerPort</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>listenerPort</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>srcPid</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pxProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstPid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstListenerPort</name></name> <operator>=</operator> <operator>(</operator><name>px_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>sessionId</name></name> <operator>=</operator> <name>px_session_id</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>icId</name></name> <operator>=</operator> <name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>=</operator> <name>UDPIC_FLAGS_RECEIVER_TO_SENDER</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>connAddHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>ssthresh</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Initiate outgoing connections. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>initSndBufferPool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snd_buffer_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initUnackQueueRing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unack_queue_ring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>isSender</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastPacketSendTime</name></name> <operator>=</operator> <name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastDeadlockCheckTime</name></name> <operator>=</operator> <name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>sendingChunkTransportState</name> <operator>=</operator> <call><name>startOutgoingUDPConnections</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>mySlice</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>expectedTotalOutgoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sendingChunkTransportState</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>						<comment type="block">/* loop to set up outgoing connections */</comment>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <operator>&amp;</operator><name><name>sendingChunkTransportState</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setupOutgoingUDPConnection</name><argument_list>(<argument><expr><name>interconnect_context</name></expr></argument>, <argument><expr><name>sendingChunkTransportState</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>outgoing_count</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name> <operator>=</operator> <name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>ssthresh</name></name> <operator>=</operator> <name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
		<expr_stmt><expr><call><name>initTransProtoStats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>isSender</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SetupUDPInterconnect will activate "</literal>
								<literal type="string">"%d incoming, %d outgoing routes for sliceTable-&gt;ic_instance_id %d. "</literal>
								<literal type="string">"Listening on ports=%d/%d sockfd=%d."</literal></expr></argument>,
								<argument><expr><name>expectedTotalIncoming</name></expr></argument>, <argument><expr><name>expectedTotalOutgoing</name></expr></argument>, <argument><expr><name><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>,
								<argument><expr><name>px_listener_port</name> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr></argument>, <argument><expr><operator>(</operator><name>px_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal></expr></argument>, <argument><expr><name>UDP_listenerFd</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If there are packets cached by background thread, add them to the
	 * connections.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_cache_future_packets</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>handleCachedPackets</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>interconnect_context</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>interconnect_context</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SetupUDPIFCInterconnect
 * 		setup UDP interconnect.
 */</comment>
<function><type><name>void</name></type>
<name>SetupUDPIFCInterconnect</name><parameter_list>(<parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>icContext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * The rx-thread might have set an error since last teardown,
		 * technically it is not part of current query, discard it directly.
		 */</comment>
		<expr_stmt><expr><call><name>resetRxThreadError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>px_reset_adps_thread_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>icContext</name> <operator>=</operator> <call><name>SetupUDPIFCInterconnect_Internal</name><argument_list>(<argument><expr><name><name>estate</name><operator>-&gt;</operator><name>es_sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"set_udp_connect_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"set_udp_connect_error for test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Internal error if we locked the mutex but forgot to unlock it. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Remove connections from hash table to avoid packet handling in the
		 * rx pthread, else the packet handling code could use memory whose
		 * context (px_InterconnectContext) would be soon reset - that could
		 * panic the process.
		 */</comment>
		<decl_stmt><decl><type><name>ConnHashTable</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ht</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>ConnHtabBin</name></name> <modifier>*</modifier></type><name>trash</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>trash</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>trash</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Get trash at first as trash will be pfree-ed in
				 * connDelHash.
				 */</comment>
				<expr_stmt><expr><name>trash</name> <operator>=</operator> <name><name>trash</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>connDelHash</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>icContext</name><operator>-&gt;</operator><name>estate</name></name> <operator>=</operator> <name>estate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>interconnect_context</name></name> <operator>=</operator> <name>icContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>estate</name><operator>-&gt;</operator><name>es_interconnect_is_setup</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Check if any of the PXs has already finished with error */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>icContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * freeDisorderedPackets
 * 		Put the disordered packets into free buffer list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeDisorderedPackets</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"CLEAR Out-of-order PKT: conn %p pkt [seq %d] for node %d route %d, [head seq] %d queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* return the buffer into the free list. */</comment>
			<expr_stmt><expr><call><name>putRxBufferToFreeList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * chunkTransportStateEntryInitialized
 *  	Check whether the transport state entry is initialized.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>chunkTransportStateEntryInitialized</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
									<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>motNodeID</name> <operator>&gt;</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>states</name><index>[<expr><name>motNodeID</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>valid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * computeNetworkStatistics
 * 		Compute the max/min/avg network statistics.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>computeNetworkStatistics</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>max</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>sum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <operator>*</operator><name>max</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;=</operator> <operator>*</operator><name>min</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>sum</name> <operator>+=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TeardownUDPIFCInterconnect_Internal
 * 		Helper function for TeardownUDPIFCInterconnect.
 *
 * Developers should pay attention to:
 *
 * 1) Do not handle interrupts/throw errors in Teardown, otherwise, Teardown may be called twice.
 *    It will introduce an undefined behavior. And memory leaks will be introduced.
 *
 * 2) Be careful about adding elog/ereport/write_log in Teardown function,
 *    esp, out of HOLD_INTERRUPTS/RESUME_INTERRUPTS pair, since elog/ereport/write_log may
 *    handle interrupts.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TeardownUDPIFCInterconnect_Internal</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>hasErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>mySlice</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>maxRtt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>avgRtt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>minRtt</name> <init>= <expr><operator>~</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>maxDev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>avgDev</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>minDev</name> <init>= <expr><operator>~</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>isReceiver</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>transportStates</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"miss_slice_table"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"TeardownUDPIFCInterconnect: missing slice table."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"miss_stats"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"TeardownUDPIFCInterconnect: missing states."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>mySlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceId</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the start of TeardownInterconnect. */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_TERSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hasErrors</name> <operator>||</operator> <operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG1</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>DEBUG4</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>elevel</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect seg%d slice%d cleanup state: "</literal>
									<literal type="string">"%s; setup was %s"</literal></expr></argument>,
									<argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>hasErrors</name></expr> ?</condition><then> <expr><literal type="string">"force"</literal></expr> </then><else>: <expr><literal type="string">"normal"</literal></expr></else></ternary></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr> ?</condition><then> <expr><literal type="string">"completed"</literal></expr> </then><else>: <expr><literal type="string">"exited"</literal></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* if setup did not complete, log the slicetable */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name> <operator>&amp;&amp;</operator>
			<name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog_node_display</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"local slice table"</literal></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * add lock to protect the hash table, since background thread is still
	 * working.
	 */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_cache_future_packets</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cleanupStartupCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now "normal" connections which made it through our peer-registration
	 * step. With these we have to worry about "in-flight" data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>parentSlice</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parentSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* cleanup a Sending motion node. */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d closing connections to slice%d (%d peers)"</literal></expr></argument>,
				 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>parentIndex</name></name></expr></argument>,
				 <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parentSlice</name><operator>-&gt;</operator><name>primaryProcesses</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In the olden days, we required that the error case successfully
		 * transmit and end-of-stream message here. But the introduction of
		 * pxdisp_check_estate_for_cancel() alleviates for the QC case, and
		 * the cross-connection of writer gangs in the dispatcher (propagation
		 * of cancel between them) fixes the I-S case.
		 *
		 * So the call to forceEosToPeers() is no longer required.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>chunkTransportStateEntryInitialized</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* now it is safe to remove. */</comment>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>removeChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>mySlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* connection array allocation may fail in interconnect setup. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* compute some statistics */</comment>
					<expr_stmt><expr><call><name>computeNetworkStatistics</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>rtt</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minRtt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxRtt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avgRtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>computeNetworkStatistics</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dev</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>minDev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maxDev</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>avgDev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>icBufferListReturn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>icBufferListReturn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_CAPACITY</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>connDelHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name>avgRtt</name> <operator>=</operator> <name>avgRtt</name> <operator>/</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>avgDev</name> <operator>=</operator> <name>avgDev</name> <operator>/</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</expr_stmt>

				<comment type="block">/* free all send side buffers */</comment>
				<expr_stmt><expr><call><name>cleanSndBufferPool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>snd_buffer_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
		<expr_stmt><expr><call><name>dumpTransProtoStats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Previously, there is a piece of code that deals with pending stops. Now
	 * it is delegated to background rx thread which will deal with any
	 * mismatched packets.
	 */</comment>

	<comment type="block">/*
	 * cleanup all of our Receiving Motion nodes, these get closed immediately
	 * (the receiver know for real if they want to shut down -- they aren't
	 * going to be processing any more data).
	 */</comment>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>mySlice-&gt;children</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ExecSlice</name>  <modifier>*</modifier></type><name>aSlice</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>childId</name> <init>= <expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>aSlice</name> <operator>=</operator> <operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>childId</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * First check whether the entry is initialized to avoid the potential
		 * errors thrown out from the removeChunkTransportState, which may
		 * introduce some memory leaks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>chunkTransportStateEntryInitialized</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove it */</comment>
			<expr_stmt><expr><name>pEntry</name> <operator>=</operator> <call><name>removeChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Interconnect closing connections from slice%d"</literal></expr></argument>,
					 <argument><expr><name><name>aSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>isReceiver</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * receivers know that they no longer care about data from
				 * below ... so we can safely discard data queued in both
				 * directions
				 */</comment>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<comment type="block">/* out of memory has occurred, break out */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>

					<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name> <operator>-=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>connDelHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * putRxBufferAndSendAck() dequeues messages and moves
					 * them to pBuff
					 */</comment>
					<while>while <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>putRxBufferAndSendAck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>

					<comment type="block">/* we also need to clear all the out-of-order packets */</comment>
					<expr_stmt><expr><call><name>freeDisorderedPackets</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* free up the packet queue */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

					<comment type="block">/* free up the tuple remapper */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>DestroyTupleRemapper</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remapper</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * now that we've moved active rx-buffers to the freelist, we can prune
	 * the freelist itself
	 */</comment>
	<while>while <condition>(<expr><name><name>rx_buffer_pool</name><operator>.</operator><name>count</name></name> <operator>&gt;</operator> <name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If this happened, there are some memory leaks.. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rx_buffer_pool</name><operator>.</operator><name>freeList</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"freelist NULL: count %d max %d buf %p"</literal></expr></argument>, <argument><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr></argument>, <argument><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>getRxBufferFromFreeList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freeRxBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Update the history of interconnect instance id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>updateCursorIcEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name></name></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>lastTornIcId</name></name> <operator>=</operator> <name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>px_interconnect_log_stats</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG1</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"Interconnect State: "</literal>
		 <literal type="string">"isSender %d isReceiver %d "</literal>
		 <literal type="string">"snd_queue_depth %d recv_queue_depth %d px_interconnect_max_packet_size %d "</literal>
		 <literal type="string">"UNACK_QUEUE_RING_SLOTS_NUM %d TIMER_SPAN %lld DEFAULT_RTT %d "</literal>
		 <literal type="string">"hasErrors %d, ic_instance_id %d ic_id_last_teardown %d "</literal>
		 <literal type="string">"snd_buffer_pool.count %d snd_buffer_pool.maxCount %d snd_sock_bufsize %d recv_sock_bufsize %d "</literal>
		 <literal type="string">"snd_pkt_count %d retransmits %d crc_errors %d"</literal>
		 <literal type="string">" recv_pkt_count %d recv_ack_num %d"</literal>
		 <literal type="string">" recv_queue_size_avg %f"</literal>
		 <literal type="string">" capacity_avg %f"</literal>
		 <literal type="string">" freebuf_avg %f "</literal>
		 <literal type="string">"mismatch_pkt_num %d disordered_pkt_num %d duplicated_pkt_num %d"</literal>
		 <literal type="string">" rtt/dev ["</literal> <name>UINT64_FORMAT</name> <literal type="string">"/"</literal> <name>UINT64_FORMAT</name> <literal type="string">", %f/%f, "</literal> <name>UINT64_FORMAT</name> <literal type="string">"/"</literal> <name>UINT64_FORMAT</name> <literal type="string">"] "</literal>
		 <literal type="string">" cwnd %f status_query_msg_num %d"</literal></expr></argument>,
		 <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>isSender</name></name></expr></argument>, <argument><expr><name>isReceiver</name></expr></argument>,
		 <argument><expr><name>px_interconnect_snd_queue_depth</name></expr></argument>, <argument><expr><name>px_interconnect_queue_depth</name></expr></argument>, <argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>,
		 <argument><expr><name>UNACK_QUEUE_RING_SLOTS_NUM</name></expr></argument>, <argument><expr><name>TIMER_SPAN</name></expr></argument>, <argument><expr><name>DEFAULT_RTT</name></expr></argument>,
		 <argument><expr><name>hasErrors</name></expr></argument>, <argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>, <argument><expr><name><name>rx_control_info</name><operator>.</operator><name>lastTornIcId</name></name></expr></argument>,
		 <argument><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr></argument>, <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>socketSendBufferSize</name></name></expr></argument>, <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>socketRecvBufferSize</name></name></expr></argument>,
		 <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>sndPktNum</name></name></expr></argument>, <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>retransmits</name></name></expr></argument>, <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>crcErrors</name></name></expr></argument>,
		 <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>recvPktNum</name></name></expr></argument>, <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>recvAckNum</name></name></expr></argument>,
		 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>ic_statistics</name><operator>.</operator><name>totalRecvQueueSize</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>ic_statistics</name><operator>.</operator><name>recvQueueSizeCountingTime</name></name><operator>)</operator></expr></argument>,
		 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>ic_statistics</name><operator>.</operator><name>totalCapacity</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>ic_statistics</name><operator>.</operator><name>capacityCountingTime</name></name><operator>)</operator></expr></argument>,
		 <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>ic_statistics</name><operator>.</operator><name>totalBuffers</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>ic_statistics</name><operator>.</operator><name>bufferCountingTime</name></name><operator>)</operator></expr></argument>,
		 <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>mismatchNum</name></name></expr></argument>, <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>disorderedPktNum</name></name></expr></argument>, <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>duplicatedPktNum</name></name></expr></argument>,
		 <argument><expr><operator>(</operator><ternary><condition><expr><name>minRtt</name> <operator>==</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>minRtt</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>minDev</name> <operator>==</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>minDev</name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>avgRtt</name></expr></argument>, <argument><expr><name>avgDev</name></expr></argument>, <argument><expr><name>maxRtt</name></expr></argument>, <argument><expr><name>maxDev</name></expr></argument>,
		 <argument><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name></expr></argument>, <argument><expr><name><name>ic_statistics</name><operator>.</operator><name>statusQueryMsgNum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>isSender</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ic_statistics</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ICStatistics</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* reset the rx thread network error flag */</comment>
	<expr_stmt><expr><call><name>resetRxThreadError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>px_reset_adps_thread_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>transportStates</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>transportStates</name><operator>-&gt;</operator><name>states</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_TERSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"TeardownUDPIFCInterconnect successful"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * TeardownUDPIFCInterconnect
 * 		Tear down UDP interconnect.
 *
 * This function is called to release the resources used by interconnect.
 */</comment>
<function><type><name>void</name></type>
<name>TeardownUDPIFCInterconnect</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>hasErrors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>TeardownUDPIFCInterconnect_Internal</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>hasErrors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * prepareRxConnForRead
 * 		Prepare the receive connection for reading.
 *
 * MUST BE CALLED WITH ic_control_info.lock LOCKED.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>prepareRxConnForRead</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"In prepareRxConnForRead: conn %p, q_head %d q_tail %d q_size %d"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgPos</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name><operator>)</operator><operator>-&gt;</operator><name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>recvBytes</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * receiveChunksUDPIFC
 * 		Receive chunks from the senders
 *
 * MUST BE CALLED WITH ic_control_info.lock LOCKED.
 */</comment>
<function><type><specifier>static</specifier> <name>TupleChunkListItem</name></type>
<name>receiveChunksUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>pTransportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>directed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>rxconn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"receivechunksUDP: motnodeid %d"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pTransportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>directed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>srcRoute</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setMainThreadWaiting</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name></name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>,
							 <argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* non-directed receive */</comment>
		<expr_stmt><expr><call><name>setMainThreadWaiting</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name></name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>ANY_ROUTE</name></expr></argument>,
							 <argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>sliceTable</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* we didn't have any data, so we've got to read it from the network. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>wakeEvents</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>waitFd</name></decl>;</decl_stmt>

		<comment type="block">/* 1. Do we have data ready */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>reachRoute</name></name> <operator>!=</operator> <name>ANY_ROUTE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>rxconn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>reachRoute</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>prepareRxConnForRead</name><argument_list>(<argument><expr><name>rxconn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"receiveChunksUDPIFC: non-directed rx woke on route %d"</literal></expr></argument>, <argument><expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>reachRoute</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>resetMainThreadWaiting</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>aggregateStatistics</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rxconn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rxconn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"got data with length %d"</literal></expr></argument>, <argument><expr><name><name>rxconn</name><operator>-&gt;</operator><name>recvBytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* successfully read into this connection's buffer. */</comment>
			<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name>RecvTupleChunk</name><argument_list>(<argument><expr><name>rxconn</name></expr></argument>, <argument><expr><name>pTransportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>directed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>srcRoute</name> <operator>=</operator> <name><name>rxconn</name><operator>-&gt;</operator><name>route</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><name>tcItem</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>retries</name><operator>++</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Ok, we've processed all the items currently in the queue. Arm the
		 * latch (before releasing the mutex), and wait for more messages to
		 * arrive. The RX thread will wake us up using the latch.
		 */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Wait for data to become ready.
		 *
		 * In the QC, also wake up immediately if one of the PXs report an
		 * error through the main QC-PX libpq connection. For that, ask the
		 * dispatcher for a file descriptor to wait on for that.
		 *
		 * XXX: We currently only get a single FD to wait on. That catches the
		 * common case that *all* the PXs report the same error more or less
		 * at the same time. WaitLatchOrSocket doesn't allow waiting for more
		 * than one socket at a time. PostgreSQL 9.6 introduces a more
		 * flexible "wait event" API for the latches, so once we merge with
		 * that, we could improve this.
		 */</comment>
		<expr_stmt><expr><name>wakeEvents</name> <operator>=</operator> <name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>waitFd</name> <operator>=</operator> <name>PGINVALID_SOCKET</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>waitFd</name> <operator>=</operator> <call><name>pxdisp_getWaitSocketFd</name><argument_list>(<argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>estate</name><operator>-&gt;</operator><name>dispatcherState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>waitFd</name> <operator>!=</operator> <name>PGINVALID_SOCKET</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>wakeEvents</name> <operator>|=</operator> <name>WL_SOCKET_READABLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"waiting (timed) on route %d %s"</literal></expr></argument>, <argument><expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingRoute</name></name></expr></argument>,
				 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingRoute</name></name> <operator>==</operator> <name>ANY_ROUTE</name></expr> ?</condition><then> <expr><literal type="string">"(any route)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatchOrSocket</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>latch</name></name></expr></argument>,
								 <argument><expr><name>wakeEvents</name></expr></argument>, <argument><expr><name>waitFd</name></expr></argument>,
								 <argument><expr><name>MAIN_THREAD_COND_TIMEOUT_MS</name></expr></argument>,
								 <argument><expr><name>WAIT_EVENT_PX_MOTION_WAIT_RECV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check the potential errors in rx thread. */</comment>
		<expr_stmt><expr><call><name>checkRxThreadError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check the potential errors in px ds thread */</comment>
		<expr_stmt><expr><call><name>px_check_adps_thread_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* do not check interrupts when holding the lock */</comment>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>pTransportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check to see if the dispatcher should cancel */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>checkForCancelFromQC</name><argument_list>(<argument><expr><name>pTransportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * 1. NIC on master (and thus the QC connection) may become bad, check
		 * it. 2. Postmaster may become invalid, check it
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>retries</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"check_alive"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>checkQCConnectionAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect failed to recv chunks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Postmaster is not alive."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></for>							<comment type="block">/* for (;;) */</comment>

	<comment type="block">/* We either got data, or get cancelled. We never make it out to here. */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* make GCC behave */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * RecvTupleChunkFromAnyUDPIFC_Internal
 * 		Receive tuple chunks from any route (connections)
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleChunkListItem</name></type>
<name>RecvTupleChunkFromAnyUDPIFC_Internal</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
									 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
									 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>index</name></decl>,
				<decl><type ref="prev"/><name>activeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAnyUDPIFC: missing context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAnyUDPIFC: interconnect context not active!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>scanStart</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>index</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>activeCount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>totalRecvQueueSize</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>recvQueueSizeCountingTime</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>prepareRxConnForRead</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name>RecvTupleChunk</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>srcRoute</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>scanStart</name></name> <operator>=</operator> <name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<return>return <expr><name>tcItem</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no data pending in our queue */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromAnyUDPIFC(): activeCount is %d"</literal></expr></argument>, <argument><expr><name>activeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>activeCount</name> <operator>==</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"active_count_fake"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* receiveChunksUDPIFC() releases ic_control_info.lock as a side-effect */</comment>
	<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name>receiveChunksUDPIFC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>scanStart</name></name> <operator>=</operator> <operator>*</operator><name>srcRoute</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>tcItem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RecvTupleChunkFromAnyUDPIFC
 * 		Receive tuple chunks from any route (connections)
 */</comment>
<function><type><specifier>static</specifier> <name>TupleChunkListItem</name></type>
<name>RecvTupleChunkFromAnyUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
							<parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
							<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>icItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>icItem</name> <operator>=</operator> <call><name>RecvTupleChunkFromAnyUDPIFC_Internal</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* error if mutex still held (debug build only) */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>icItem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RecvTupleChunkFromUDPIFC_Internal
 * 		Receive tuple chunks from a specific route (connection)
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>TupleChunkListItem</name></type>
<name>RecvTupleChunkFromUDPIFC_Internal</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
								  <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
								  <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>route</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>chunks</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromUDPIFC: missing context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromUDPIFC: interconnect context not active!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromUDPIFC()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* check em' */</comment>
	<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromUDPIFC(motNodID=%d, srcRoute=%d)"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>srcRoute</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"RecvTupleChunkFromUDPIFC(): connection inactive ?!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>totalRecvQueueSize</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>recvQueueSizeCountingTime</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>prepareRxConnForRead</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tcItem</name> <operator>=</operator> <call><name>RecvTupleChunk</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>transportStates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>tcItem</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* no existing data, we've got to read a packet */</comment>
	<comment type="block">/* receiveChunksUDPIFC() releases ic_control_info.lock as a side-effect */</comment>

	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>receiveChunksUDPIFC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>route</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RecvTupleChunkFromUDPIFC
 * 		Receive tuple chunks from a specific route (connection)
 */</comment>
<function><type><specifier>static</specifier> <name>TupleChunkListItem</name></type>
<name>RecvTupleChunkFromUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>,
						 <parameter><decl><type><name>int16</name></type> <name>srcRoute</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleChunkListItem</name></type> <name>icItem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>icItem</name> <operator>=</operator> <call><name>RecvTupleChunkFromUDPIFC_Internal</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>srcRoute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* error if mutex still held (debug build only) */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>icItem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * markUDPConnInactiveIFC
 * 		Mark the connection inactive.
 */</comment>
<function><type><name>void</name></type>
<name>markUDPConnInactiveIFC</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * aggregateStatistics
 * 		aggregate statistics.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>aggregateStatistics</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>connNo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We first clear the stats, and then compute new stats by aggregating the
	 * stats from each connection.
	 */</comment>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_ack_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_count_acks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_max_ack_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name> <operator>=</operator> <operator>~</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_count_resent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_max_resent</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_count_dropped</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>connNo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>connNo</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>connNo</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><operator>&amp;</operator><name><name>pEntry</name><operator>-&gt;</operator><name>conns</name><index>[<expr><name>connNo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_total_ack_time</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>stat_total_ack_time</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_count_acks</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>stat_count_acks</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_max_ack_time</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_max_ack_time</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_max_ack_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_count_resent</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>stat_count_resent</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_max_resent</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_max_resent</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_max_resent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>stat_count_dropped</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>stat_count_dropped</name></name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * logPkt
 * 		Log a packet.
 *
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>logPkt</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"%s [%s: seq %d extraSeq %d]: motNodeId %d, crc %d len %d "</literal>
			  <literal type="string">"srcContentId %d dstDesContentId %d "</literal>
			  <literal type="string">"srcPid %d dstPid %d "</literal>
			  <literal type="string">"srcListenerPort %d dstListernerPort %d "</literal>
			  <literal type="string">"sendSliceIndex %d recvSliceIndex %d "</literal>
			  <literal type="string">"sessionId %d icId %d "</literal>
			  <literal type="string">"flags %d "</literal></expr></argument>,
			  <argument><expr><name>prefix</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_RECEIVER_TO_SENDER</name></expr> ?</condition><then> <expr><literal type="string">"ACK"</literal></expr> </then><else>: <expr><literal type="string">"DATA"</literal></expr></else></ternary></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>crc</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstContentId</name></name></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcListenerPort</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstListenerPort</name></name></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>sendSliceIndex</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>recvSliceIndex</name></name></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * handleAckedPacket
 * 		Called by sender to process acked packet.
 *
 * 	Remove it from unack queue and unack queue ring, change the rtt ...
 *
 * 	RTT (Round Trip Time) is computed as the time between we send the packet
 * 	and receive the acknowledgement for the packet. When an acknowledgement
 * 	is received, an estimated RTT value (called SRTT, smoothed RTT) is updated
 * 	by using the following equation. And we also set a limitation of the max
 * 	value and min value for SRTT.
 *	    (1) SRTT = (1 - g) SRTT + g x RTT (0 &lt; g &lt; 1)
 *	where RTT is the measured round trip time of the packet. In implementation,
 *	g is set to 1/8. In order to compute expiration period, we also compute an
 *	estimated delay variance SDEV by using:
 *	    (2) SDEV = (1 - h) x SDEV + h x |SERR| (0 &lt; h &lt; 1, In implementation, h is set to 1/4)
 *	where SERR is calculated by using:
 *	    (3) SERR = RTT - SRTT
 *	Expiration period determines the timing we resend a packet. A long RTT means
 *	a long expiration period. Delay variance is used to incorporate the variance
 *	of workload/network variances at different time. When a packet is retransmitted,
 *	we back off exponentially the expiration period.
 *	    (4) exp_period = (SRTT + y x SDEV) &lt;&lt; retry
 *	Here y is a constant (In implementation, we use 4) and retry is the times the
 *	packet is retransmitted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handleAckedPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>ackConn</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>ackTime</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>bufIsHead</name> <init>= <expr><operator>(</operator><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>primary</name></name> <operator>==</operator> <call><name>icBufferListFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ackConn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>icBufferListDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ackConn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>icBufferListDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unack_queue_ring</name><operator>.</operator><name>slots</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>numOutStanding</name></name><operator>--</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ackConn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>numSharedOutStanding</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ackTime</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>sentTime</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * In px_enable_udp_testmode, we do not change rtt dynamically due to the large
		 * number of packet losses introduced by fault injection code. This
		 * can decrease the testing time.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>px_enable_udp_testmode</name></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>newRTT</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>newDEV</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newRTT</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>rtt</name></name> <operator>-</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>rtt</name></name> <operator>&gt;&gt;</operator> <name>RTT_SHIFT_COEFFICIENT</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>ackTime</name> <operator>&gt;&gt;</operator> <name>RTT_SHIFT_COEFFICIENT</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>newRTT</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>MAX_RTT</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>newRTT</name></expr></argument>, <argument><expr><name>MIN_RTT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>rtt</name></name> <operator>=</operator> <name>newRTT</name></expr>;</expr_stmt>

				<expr_stmt><expr><name>newDEV</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>dev</name></name> <operator>-</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>dev</name></name> <operator>&gt;&gt;</operator> <name>DEV_SHIFT_COEFFICIENT</name><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><call><name>Max</name><argument_list>(<argument><expr><name>ackTime</name></expr></argument>, <argument><expr><name>newRTT</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>Min</name><argument_list>(<argument><expr><name>ackTime</name></expr></argument>, <argument><expr><name>newRTT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;&gt;</operator> <name>DEV_SHIFT_COEFFICIENT</name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>newDEV</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>MAX_DEV</name></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>newDEV</name></expr></argument>, <argument><expr><name>MIN_DEV</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>dev</name></name> <operator>=</operator> <name>newDEV</name></expr>;</expr_stmt>

				<comment type="block">/* adjust the congestion control window. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>&lt;</operator> <name><name>snd_control_info</name><operator>.</operator><name>ssthresh</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>+=</operator> <literal type="number">1</literal> <operator>/</operator> <name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name></expr></argument>, <argument><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_total_ack_time</name></name> <operator>+=</operator> <name>ackTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_max_ack_time</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>ackTime</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_max_ack_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>ackTime</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_min_ack_time</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * only change receivedAckSeq when it is the smallest pkt we sent and have
	 * not received ack for it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>bufIsHead</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The first packet acts like a connect setup packet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsStarted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>snd_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"REMOVEPKT %d from unack queue for route %d (retry %d) sndbufmaxcount %d sndbufcount %d sndbuffreelistlen %d, sntSeq %d consumedSeq %d recvAckSeq %d capacity %d, sndQ %d, unackQ %d"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>, <argument><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>maxCount</name></name></expr></argument>, <argument><expr><name><name>snd_buffer_pool</name><operator>.</operator><name>count</name></name></expr></argument>, <argument><expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>snd_buffer_pool</name><operator>.</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sentSeq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>consumedSeq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>, <argument><expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * handleAck
 * 		handle acks incoming from our upstream peers.
 *
 * if we receive a stop message, return true (caller will clean up).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handleAcks</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>ackConn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>peer</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>socklen_t</name></type>	<name>peerlen</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>icpkthdr</name></name> <modifier>*</modifier></type><name>pkt</name> <init>= <expr><name><name>snd_control_info</name><operator>.</operator><name>ackBuffer</name></name></expr></init></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldSendBuffers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SliceTable</name>  <modifier>*</modifier></type><name>sliceTbl</name> <init>= <expr><name><name>transportStates</name><operator>-&gt;</operator><name>sliceTable</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>

		<comment type="block">/* ready to read on our socket ? */</comment>
		<expr_stmt><expr><name>peerlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>recvfrom</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pkt</name></expr></argument>, <argument><expr><name>MIN_PACKET_SIZE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
					 <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>peer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peerlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name></expr>)</condition>	<comment type="block">/* had nothing to read. */</comment>
			<block>{<block_content>
				<expr_stmt><expr><call><name>aggregateStatistics</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>ret</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error waiting for peer ack"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"During recvfrom() call."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>n</name> <operator>!=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * check the CRC of the payload.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_full_crc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkCRC</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ic_statistics</name><operator>.</operator><name>crcErrors</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>DEBUG2</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received network data error, dropping bad packet, user data unaffected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * read packet, is this the ack we want ?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>srcContentId</name></name> <operator>==</operator> <name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name> <operator>&amp;&amp;</operator>
			<name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name> <operator>==</operator> <name>MyProcPid</name> <operator>&amp;&amp;</operator>
			<name><name>pkt</name><operator>-&gt;</operator><name>srcListenerPort</name></name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>px_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>pkt</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <name>px_session_id</name> <operator>&amp;&amp;</operator>
			<name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name> <operator>==</operator> <name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * packet is for me. Note here we do not need to get a connection
			 * lock here, since background rx thread only read the hash table.
			 */</comment>
			<expr_stmt><expr><name>ackConn</name> <operator>=</operator> <call><name>findConnByHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ackConn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Received ack for unknown connection (flags 0x%x)"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>stat_count_acks</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>recvAckNum</name></name><operator>++</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * We simply disregard pkt losses (NAK) due to process start race
			 * (that is, sender is started earlier than receiver. rx
			 * background thread may receive packets when connections are not
			 * created yet).
			 *
			 * Another option is to resend the packet immediately, but
			 * experiments do not show any benefits.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_NAK</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><name>true</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
				<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pkt_duplicate"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_DUPLICATE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"pkt_disorder"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_DISORDER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_CAPACITY</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name> <operator>&gt;</operator> <name><name>ackConn</name><operator>-&gt;</operator><name>consumedSeq</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>capacity</name></name> <operator>+=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name> <operator>-</operator> <name><name>ackConn</name><operator>-&gt;</operator><name>consumedSeq</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>consumedSeq</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name>shouldSendBuffers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_DUPLICATE</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"GOTDUPACK [seq %d] from route %d; srcpid %d dstpid %d cmd %d flags 0x%x connseq %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>shouldSendBuffers</name> <operator>|=</operator> <operator>(</operator><call><name>handleAckForDuplicatePkt</name><argument_list>(<argument><expr><name>ackConn</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_DISORDER</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"GOTDISORDER [seq %d] from route %d; srcpid %d dstpid %d cmd %d flags 0x%x connseq %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><name>shouldSendBuffers</name> <operator>|=</operator> <operator>(</operator><call><name>handleAckForDisorderPkt</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>ackConn</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * don't get out of the loop if pkt-&gt;seq equals to
				 * ackConn-&gt;receivedAckSeq, need to check UDPIC_FLAGS_STOP
				 * flag
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;</operator> <name><name>ackConn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ack with bad seq?! expected (%d, %d] got %d flags 0x%x, capacity %d consumedSeq %d"</literal></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>sentSeq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>consumedSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* haven't gotten a stop request, maybe this is one ? */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_STOP</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ackConn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>&amp;&amp;</operator> <name><name>ackConn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"got ack with stop; srcpid %d dstpid %d cmd %d flags 0x%x pktseq %d connseq %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>ackConn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_STOP</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* continue to deal with acks */</comment>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <name><name>ackConn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ack with bad seq?! expected (%d, %d] got %d flags 0x%x, capacity %d consumedSeq %d"</literal></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>receivedAckSeq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>sentSeq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>capacity</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>consumedSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* deal with a regular ack. */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_ACK</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"GOTACK [seq %d] from route %d; srcpid %d dstpid %d cmd %d flags 0x%x connseq %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>ackConn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

					<expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>icBufferListFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ackConn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<while>while <condition>(<expr><operator>!</operator><call><name>icBufferListIsHead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ackConn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>handleAckedPacket</name><argument_list>(<argument><expr><name>ackConn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>shouldSendBuffers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>link</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></while>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></while>

			<comment type="block">/*
			 * When there is a capacity increase or some outstanding buffers
			 * removed from the unack queue ring, we should try to send
			 * buffers for the connection. Even when stop is received, we
			 * still send here, since in STOP/EOS race case, we may have been
			 * in EOS sending logic and will not check stop message.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>shouldSendBuffers</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendBuffers</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>ackConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"handleAck: not the ack we're looking for (flags 0x%x)...mot(%d) content(%d:%d) srcpid(%d:%d) dstpid(%d) srcport(%d:%d) dstport(%d) sess(%d:%d) cmd(%d:%d)"</literal></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcContentId</name></name></expr></argument>, <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcListenerPort</name></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>px_listener_port</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0ffff</literal><operator>)</operator></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstListenerPort</name></name></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>, <argument><expr><name>px_session_id</name></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>sliceTbl</name><operator>-&gt;</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * addCRC
 * 		add CRC field to the packet.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>addCRC</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>local_crc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>local_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>local_crc</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>local_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <name>local_crc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkCRC
 * 		check the validity of the packet.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>checkCRC</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_crc32c</name></type>	<name>rx_crc</name></decl>,
				<decl><type ref="prev"/><name>local_crc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rx_crc</name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>crc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pkt</name><operator>-&gt;</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_CRC32C</name><argument_list>(<argument><expr><name>local_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMP_CRC32C</name><argument_list>(<argument><expr><name>local_crc</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FIN_CRC32C</name><argument_list>(<argument><expr><name>local_crc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rx_crc</name> <operator>!=</operator> <name>local_crc</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * prepareXmit
 * 		Prepare connection for transmit.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>prepareXmit</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>crc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* increase the sequence no */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_full_crc</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>pkt</name> <init>= <expr><operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>addCRC</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * sendOnce
 * 		Send a packet.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendOnce</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>n</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>testmode_inject_fault</name><argument_list>(<argument><expr><name>px_interconnect_udpic_dropxmit_percent</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"THROW PKT with seq %d srcpid %d despid %d"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<label><name>xmit_retry</name>:</label>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>sendto</name><argument_list>(<argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"send_once_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>xmit_retry</name>;</goto></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* no space ? not an error. */</comment>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If Linux iptables (nf_conntrack?) drops an outgoing packet, it may
		 * return an EPERM to the application. This might be simply because of
		 * traffic shaping or congestion, so ignore it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EPERM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect error writing an outgoing packet: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"error during sendto() for Remote Connection: contentId=%d at %s"</literal></expr></argument>,
							   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Interconnect error writing an outgoing packet: %m"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"error during sendto() call (error:%d).\n"</literal>
								  <literal type="string">"For Remote Connection: contentId=%d at %s"</literal></expr></argument>,
								  <argument><expr><name>errno</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
								  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* not reached */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Interconnect error writing an outgoing packet [seq %d]: short transmit (given %d sent %d) during sendto() call."</literal>
					  <literal type="string">"For Remote Connection: contentId=%d at %s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
					  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteContentId</name></name></expr></argument>,
					  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"PKT DETAILS "</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * handleStopMsgs
 *		handle stop messages.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handleStopMsgs</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"handleStopMsgs: node %d"</literal></expr></argument>, <argument><expr><name>motionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"handleStopMsgs: node %d route %d %s %s"</literal></expr></argument>, <argument><expr><name>motionId</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>,
			 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr> ?</condition><then> <expr><literal type="string">"active"</literal></expr> </then><else>: <expr><literal type="string">"NOT active"</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name></expr> ?</condition><then> <expr><literal type="string">"stop requested"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"handleStopMsgs: node %d route %d msgSize %d"</literal></expr></argument>, <argument><expr><name>motionId</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * PX-2427: we're guaranteed to have recently flushed, but this might
		 * not be empty (if we got a stop on a buffer that wasn't the one we
		 * were sending) ... empty it first so the outbound buffer is empty
		 * when we get here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/* mark buffer empty */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<comment type="block">/* now send our stop-ack EOS */</comment>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_EOS</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>prepareXmit</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* now ready to actually send */</comment>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"handleStopMsgs: node %d route %d, seq %d"</literal></expr></argument>, <argument><expr><name>motionId</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* place it into the send queue */</comment>
			<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* return all buffers */</comment>
			<expr_stmt><expr><call><name>icBufferListReturn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icBufferListReturn</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_CAPACITY</name></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsEosSent</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pollAcks</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>handleAcks</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* more stops found, loop again. */</comment>
					<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * sendBuffers
 * 		Called by sender to send the buffers in the send queue.
 *
 * Send the buffers in the send queue of the connection if there is capacity left
 * and the congestion control condition is satisfied.
 *
 * Here, we make sure that a connection can have at least one outstanding buffer.
 * This is very important for two reasons:
 *
 * 1) The handling logic of the ack of the outstanding buffer can always send a buffer
 *    in the send queue. Otherwise, there may be a deadlock.
 * 2) This makes sure that any connection can have a minimum bandwidth for data
 *    sending.
 *
 * After sending a buffer, the buffer will be placed into both the unack queue and
 * the corresponding queue in the unack queue ring.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendBuffers</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>capacity</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			 <name><name>unack_queue_ring</name><operator>.</operator><name>numSharedOutStanding</name></name> <operator>&gt;=</operator> <operator>(</operator><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>-</operator> <name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* for connection setup, we only allow one outstanding packet. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>mcsSetupOutgoingConnection</name> <operator>&amp;&amp;</operator> <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>icBufferListPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>sentTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>capacity</name></name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>numOutStanding</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>numSharedOutStanding</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>putIntoUnackQueueRing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unack_queue_ring</name></expr></argument>,
								  <argument><expr><name>buf</name></expr></argument>,
								  <argument><expr><call><name>computeExpirationPeriod</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note the place of sendOnce here. If we send before appending it to
		 * the unack queue and putting it into unack queue ring, and there is
		 * a network error occurred in the sendOnce function, error message
		 * will be output. In the time of error message output, interrupts is
		 * potentially checked, if there is a pending query cancel, it will
		 * lead to a dangled buffer (memory leak).
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
		<expr_stmt><expr><call><name>updateStats</name><argument_list>(<argument><expr><name>TPE_DATA_PKT_SEND</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>sendOnce</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>sndPktNum</name></name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"SEND PKT DETAIL"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sentSeq</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * handleDisorderPacket
 * 		Called by rx thread to assemble and send a disorder message.
 *
 * In current implementation, we limit the number of lost packet sequence numbers
 * in the disorder message by the MIN_PACKET_SIZE. There are two reasons here:
 *
 * 1) The maximal number of lost packet sequence numbers are actually bounded by the
 *    receive queue depth whose maximal value is very large. Since we share the packet
 *    receive and ack receive in the background thread, the size of disorder should be
 *    also limited by the max packet size.
 * 2) We can use px_interconnect_max_packet_size here to limit the number of lost packet sequence numbers.
 *    But considering we do not want to let senders send many packets when getting a lost
 *    message. Here we use MIN_PACKET_SIZE.
 *
 *
 * the format of a disorder message:
 * I) pkt header
 *  - seq      -&gt; packet sequence number that triggers the disorder message
 *  - extraSeq -&gt; the largest seq of the received packets
 *  - flags    -&gt; UDPIC_FLAGS_DISORDER
 *  - len      -&gt; sizeof(icpkthdr) + sizeof(uint32) * (lost pkt count)
 * II) content
 *  - an array of lost pkt sequence numbers (uint32)
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handleDisorderPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>tailSeq</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>lostPktCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>curSeq</name> <init>= <expr><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>disorderBuffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>maxSeqs</name> <init>= <expr><name>MAX_SEQS_IN_DISORDER_ACK</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"PROCESS_DISORDER PKT BEGIN:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>start</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>start</name> <operator>!=</operator> <name>pos</name> <operator>&amp;&amp;</operator> <name>lostPktCnt</name> <operator>&lt;</operator> <name>maxSeqs</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>start</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>curSeq</name> <operator>=</operator> <name>tailSeq</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>lostPktCnt</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>curSeq</name><operator>++</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"PROCESS_DISORDER add seq [%d], lostPktCnt %d"</literal></expr></argument>, <argument><expr><operator>*</operator><name>curSeq</name></expr></argument>, <argument><expr><name>lostPktCnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>tailSeq</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><name>start</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"PROCESS_DISORDER PKT END:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* when reaching here, cnt must not be 0 */</comment>
	<expr_stmt><expr><call><name>sendDisorderAck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>lostPktCnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * handleAckForDisorderPkt
 * 		Called by sender to deal with acks for disorder packet.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handleAckForDisorderPkt</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
						<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
						<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name> <init>= <expr><call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name>	   <modifier>*</modifier></type><name>curLostPktSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>lostPktCnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>times</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type> <name>lastSeq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldSendBuffers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name> <operator>!=</operator> <name>lastSeq</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lastSeq</name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>times</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>times</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>times</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>curLostPktSeq</name> <operator>=</operator> <operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>pkt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lostPktCnt</name> <operator>=</operator> <operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * Resend all the missed packets and remove received packets from queues
	 */</comment>

	<expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>icBufferListFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"DISORDER: pktlen %d cnt %d pktseq %d first loss %d buf %p"</literal></expr></argument>,
			  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>lostPktCnt</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><operator>*</operator><name>curLostPktSeq</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * iterate the unack queue
	 */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>icBufferListIsHead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&amp;&amp;</operator> <name>lostPktCnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"DISORDER: bufseq %d curlostpkt %d cnt %d buf %p pkt-&gt;seq %d"</literal></expr></argument>,
				  <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><operator>*</operator><name>curLostPktSeq</name></expr></argument>, <argument><expr><name>lostPktCnt</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleAckedPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>shouldSendBuffers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <operator>*</operator><name>curLostPktSeq</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* this is a lost packet, retransmit */</comment>

			<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>icBufferListDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unack_queue_ring</name><operator>.</operator><name>slots</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>putIntoUnackQueueRing</name><argument_list>(<argument><expr><operator>&amp;</operator><name>unack_queue_ring</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
									  <argument><expr><call><name>computeExpirationPeriod</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
			<expr_stmt><expr><call><name>updateStats</name><argument_list>(<argument><expr><name>TPE_DATA_PKT_SEND</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><call><name>sendOnce</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"RESEND a buffer for DISORDER: seq %d"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"DISORDER RESEND DETAIL "</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>retransmits</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>curLostPktSeq</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>lostPktCnt</name><operator>--</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>link</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;</operator> <operator>*</operator><name>curLostPktSeq</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* remove packet already received. */</comment>

			<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>handleAckedPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>shouldSendBuffers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>link</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else					<comment type="block">/* buf-&gt;pkt-&gt;seq &gt; *curPktSeq */</comment>
		<block>{<block_content>
			<comment type="block">/*
			 * this case is introduced when the disorder message tell you a
			 * pkt is lost. But when we handle this message, a message (for
			 * example, duplicate ack, or another disorder message) arriving
			 * before this message already removed the pkt.
			 */</comment>
			<expr_stmt><expr><name>curLostPktSeq</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>lostPktCnt</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>ssthresh</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>=</operator> <name><name>snd_control_info</name><operator>.</operator><name>ssthresh</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"After DISORDER: sndQ %d unackQ %d"</literal></expr></argument>,
			  <argument><expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>icBufferListLog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<return>return <expr><name>shouldSendBuffers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * handleAckForDuplicatePkt
 * 		Called by sender to deal with acks for duplicate packet.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handleAckForDuplicatePkt</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name> <init>= <expr><call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldSendBuffers</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"RESEND the unacked buffers in the queue due to %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">"PROCESS_START_RACE"</literal></expr> </then><else>: <expr><literal type="string">"DISORDER"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Indicate a bug here. */</comment>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ERROR: invalid duplicate message: seq %d extraSeq %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>link</name> <operator>=</operator> <call><name>icBufferListFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deal with continuous pkts */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>icBufferListIsHead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>extraSeq</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>handleAckedPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shouldSendBuffers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>link</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* deal with the single duplicate packet */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>icBufferListIsHead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>link</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>handleAckedPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>shouldSendBuffers</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>link</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>shouldSendBuffers</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkNetworkTimeout
 *		check network timeout case.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>checkNetworkTimeout</name><parameter_list>(<parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>networkTimeoutIsLogged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Using only the time to first sent time to decide timeout is not enough,
	 * since there is a possibility the sender process is not scheduled or
	 * blocked by OS for a long time. In this case, only a few times are
	 * tried. Thus, the GUC px_interconnect_min_retries_before_timeout is
	 * added here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name> <operator>&amp;&amp;</operator>
		<name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>%</operator> <name>px_interconnect_debug_retry_interval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resending packet (seq %d) to %s (pid %d cid %d) with %d retries in %lu seconds"</literal></expr></argument>,
						<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
						<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstContentId</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>,
						<argument><expr><operator>(</operator><name>now</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>sentTime</name></name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>&gt;</operator> <name>px_interconnect_min_retries_before_timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>now</name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>sentTime</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>px_interconnect_transmit_timeout</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect encountered a network error, please check your network"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed to send packet (seq %d) to %s (pid %d cid %d) after %d retries in %d seconds."</literal></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstContentId</name></name></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>, <argument><expr><name>px_interconnect_transmit_timeout</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Default value of px_interconnect_transmit_timeout is one hours. It taks
	 * too long time to detect a network error and it is not user friendly.
	 *
	 * Packets would be dropped repeatly on some specific ports. We'd better
	 * have a warning messgage for this case and give the DBA a chance to
	 * detect this error earlier. Since packets would also be dropped when
	 * network is bad, we should not error out here, but just give a warning
	 * message. Erroring our is still handled by GUC
	 * px_interconnect_transmit_timeout as above. Note that warning message
	 * should be printed for each statement only once.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>&gt;=</operator> <name>px_interconnect_min_retries_before_timeout</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>networkTimeoutIsLogged</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect may encountered a network error, please check your network"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed to send packet (seq %d) to %s (pid %d cid %d) after %d retries."</literal></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>dstContentId</name></name></expr></argument>,
						   <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>networkTimeoutIsLogged</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkExpiration
 * 		Check whether packets expire. If a packet expires, resend the packet,
 * 		and adjust its position in the unack queue ring.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkExpiration</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
				<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>triggerConn</name></decl></parameter>,
				<parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* check for expiration */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retransmits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>unack_queue_ring</name><operator>.</operator><name>currentTime</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>now</name> <operator>&gt;=</operator> <operator>(</operator><name><name>unack_queue_ring</name><operator>.</operator><name>currentTime</name></name> <operator>+</operator> <name>TIMER_SPAN</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>count</name><operator>++</operator> <operator>&lt;</operator> <name>UNACK_QUEUE_RING_SLOTS_NUM</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* expired, need to resend them */</comment>
		<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>curBuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>curBuf</name> <operator>=</operator> <call><name>icBufferListPop</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unack_queue_ring</name><operator>.</operator><name>slots</name><index>[<expr><name><name>unack_queue_ring</name><operator>.</operator><name>idx</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>curBuf</name><operator>-&gt;</operator><name>nRetry</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>putIntoUnackQueueRing</name><argument_list>(
								  <argument><expr><operator>&amp;</operator><name>unack_queue_ring</name></expr></argument>,
								  <argument><expr><name>curBuf</name></expr></argument>,
								  <argument><expr><call><name>computeExpirationPeriod</name><argument_list>(<argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRANSFER_PROTOCOL_STATS</name></cpp:ifdef>
			<expr_stmt><expr><call><name>updateStats</name><argument_list>(<argument><expr><name>TPE_DATA_PKT_SEND</name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><call><name>sendOnce</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>curBuf</name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>retransmits</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>retransmits</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_count_resent</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_max_resent</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_max_resent</name></name></expr></argument>,
												<argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>stat_count_resent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>checkNetworkTimeout</name><argument_list>(<argument><expr><name>curBuf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>networkTimeoutIsLogged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"RESEND pkt with seq %d (retry %d, rtt "</literal> <name>UINT64_FORMAT</name> <literal type="string">") to route %d"</literal></expr></argument>,
					  <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>rtt</name></name></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"RESEND PKT in checkExpiration"</literal></expr></argument>, <argument><expr><name><name>curBuf</name><operator>-&gt;</operator><name>pkt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></while>

		<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>currentTime</name></name> <operator>+=</operator> <name>TIMER_SPAN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>idx</name></name> <operator>=</operator> <operator>(</operator><name><name>unack_queue_ring</name><operator>.</operator><name>idx</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <operator>(</operator><name>UNACK_QUEUE_RING_SLOTS_NUM</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * deal with case when there is a long time this function is not called.
	 */</comment>
	<expr_stmt><expr><name><name>unack_queue_ring</name><operator>.</operator><name>currentTime</name></name> <operator>=</operator> <name>now</name> <operator>-</operator> <operator>(</operator><name>now</name> <operator>%</operator> <name>TIMER_SPAN</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>retransmits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>ssthresh</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>/</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>snd_control_info</name><operator>.</operator><name>cwnd</name></name> <operator>=</operator> <name><name>snd_control_info</name><operator>.</operator><name>minCwnd</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkDeadlock
 * 		Check whether deadlock occurs on a connection.
 *
 * What this function does is to send a status query message to rx thread when
 * the connection has not received any acks for some time. This is to avoid
 * potential deadlock when there are continuous ack losses. Packet resending
 * logic does not help avoiding deadlock here since the packets in the unack
 * queue may already been removed when the sender knows that they have been
 * already buffered in the receiver side queue.
 *
 * Some considerations on deadlock check time period:
 *
 * Potential deadlock occurs rarely. According to our experiments on various
 * workloads and hardware. It occurred only when fault injection is enabled
 * and a large number packets and acknowledgments are discarded. Thus, here we
 * use a relatively large deadlock check period.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkDeadlock</name><parameter_list>(<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>, <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>deadlockCheckTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>capacity</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we must have received some acks before deadlock occurs. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>px_enable_udp_testmode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>deadlockCheckTime</name> <operator>=</operator> <literal type="number">100000</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<expr_stmt><expr><name>deadlockCheckTime</name> <operator>=</operator> <name>DEADLOCK_CHECKING_TIME</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* request the capacity to avoid the deadlock case */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>(</operator><name>now</name> <operator>-</operator> <name><name>ic_control_info</name><operator>.</operator><name>lastDeadlockCheckTime</name></name><operator>)</operator> <operator>&gt;</operator> <name>deadlockCheckTime</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>now</name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name><operator>)</operator> <operator>&gt;</operator> <name>deadlockCheckTime</name><operator>)</operator><operator>)</operator>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"send_status_query_message"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sendStatusQueryMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastDeadlockCheckTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>statusQueryMsgNum</name></name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/* check network error. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>now</name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>px_interconnect_transmit_timeout</name> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect encountered a network error, please check your network"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Did not get any response from %s (pid %d cid %d) in %d seconds."</literal></expr></argument>,
								   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>remoteHostAndPort</name></name></expr></argument>,
								   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstPid</name></name></expr></argument>,
								   <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstContentId</name></name></expr></argument>,
								   <argument><expr><name>px_interconnect_transmit_timeout</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pollAcks
 * 		Timeout polling of acks
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>pollAcks</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>nfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>nfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>fd</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error waiting for peer ack"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"During poll() call."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* not reached */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>					<comment type="block">/* timeout */</comment>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* got an ack to handle (possibly a stop message) */</comment>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>nfd</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <name>POLLIN</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/*
 * updateRetransmitStatistics
 * 		Update the retransmit statistics.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>updateRetransmitStatistics</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>retransmits</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_count_resent</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_max_resent</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_max_resent</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_count_resent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkExpirationCapacityFC
 * 		Check expiration for capacity based flow control method.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkExpirationCapacityFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
						  <parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
						  <parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>elapsed</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elapsed</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name><name>ic_control_info</name><operator>.</operator><name>lastPacketSendTime</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>elapsed</name> <operator>&gt;=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>timeout</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>bufLink</name> <init>= <expr><call><name>icBufferListFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sendOnce</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastPacketSendTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>updateRetransmitStatistics</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>checkNetworkTimeout</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>transportStates</name><operator>-&gt;</operator><name>networkTimeoutIsLogged</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * checkExceptions
 * 		Check exceptions including packet expiration, deadlock, bg thread error, NIC failure...
 * 		Caller should start from 0 with retry, so that the expensive check for deadlock and
 * 		QC connection can be avoided in a healthy state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkExceptions</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
				<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>retry</name></decl></parameter>,
				<parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_CAPACITY</name></expr>	<comment type="block">/* || conn-&gt;state ==
																		 * mcsSetupOutgoingConnection
		  * */</comment> )</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>checkExpirationCapacityFC</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name> <init>= <expr><call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>now</name> <operator>-</operator> <name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name> <operator>&gt;</operator> <name>TIMER_CHECKING_PERIOD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>checkExpiration</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>retry</name> <operator>&amp;</operator> <literal type="number">0x3</literal><operator>)</operator> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>checkDeadlock</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>checkRxThreadError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>px_check_adps_thread_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * 1. NIC on master (and thus the QC connection) may become bad, check it.
	 * 2. Postmaster may become invalid, check it
	 *
	 * We check modulo 2 to correlate with the deadlock check above at the
	 * initial iteration.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>retry</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>checkQCConnectionAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PostmasterIsAlive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect failed to send chunks"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Postmaster is not alive."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * computeTimeout
 * 		Compute timeout value in ms.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>computeTimeout</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>retry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ICBufferLink</name> <modifier>*</modifier></type><name>bufLink</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ICBuffer</name>   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TIMER_CHECKING_PERIOD</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>bufLink</name> <operator>=</operator> <call><name>icBufferListFirst</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>GET_ICBUFFER_FROM_PRIMARY</name><argument_list>(<argument><expr><name>bufLink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>retry</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_LOSS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TIMER_CHECKING_PERIOD</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* for capacity based flow control */</comment>
	<return>return <expr><call><name>TIMEOUT</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>nRetry</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SendChunkUDPIFC
 * 		is used to send a tcItem to a single destination. Tuples often are
 * 		*very small* we aggregate in our local buffer before sending into the kernel.
 *
 * PARAMETERS
 *	 conn - MotionConn that the tcItem is to be sent to.
 *	 tcItem - message to be sent.
 *	 motionId - Node Motion Id.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>SendChunkUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
				<parameter><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name></decl></parameter>,
				<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
				<parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>,
				<parameter><decl><type><name>int16</name></type> <name>motionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>int</name></type>			<name>length</name> <init>= <expr><call><name>TYPEALIGN</name><argument_list>(<argument><expr><name>TUPLE_CHUNK_ALIGN</name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doCheckExpiration</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>gotStops</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"sendChunk: msgSize %d this chunk length %d conn seq %d"</literal></expr></argument>,
		 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+</operator> <name>length</name> <operator>&lt;=</operator> <name>px_interconnect_max_packet_size</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_data</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* prepare this for transmit */</comment>

	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>totalCapacity</name></name> <operator>+=</operator> <name><name>conn</name><operator>-&gt;</operator><name>capacity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>capacityCountingTime</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* try to send it */</comment>

	<expr_stmt><expr><call><name>prepareXmit</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sendBuffers</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_fc_method</name> <operator>==</operator> <name>INTERCONNECT_FC_METHOD_CAPACITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>doCheckExpiration</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>doCheckExpiration</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>now</name> <operator>-</operator> <name><name>ic_control_info</name><operator>.</operator><name>lastExpirationCheckTime</name></name><operator>)</operator> <operator>&gt;</operator> <name>MAX_TIME_NO_TIMER_CHECKING</name></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* get a new buffer */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastPacketSendTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>doCheckExpiration</name> <operator>||</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>=</operator> <call><name>getSndBuffer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>doCheckExpiration</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>computeTimeout</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>retry</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pollAcks</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>handleAcks</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We make sure that we deal with the stop messages only after
				 * we get a buffer. Otherwise, if the stop message is not for
				 * this connection, this will lead to an error for the
				 * following data sending of this connection.
				 */</comment>
				<expr_stmt><expr><name>gotStops</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>checkExceptions</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>retry</name><operator>++</operator></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>doCheckExpiration</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name><name>conn</name><operator>-&gt;</operator><name>curBuff</name><operator>-&gt;</operator><name>pkt</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gotStops</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"send_chunk_stop"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		)</condition>
	<block>{<block_content>
		<comment type="block">/* handling stop message will make some connection not active anymore */</comment>
		<expr_stmt><expr><call><name>handleStopMsgs</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>motionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>gotStops</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reinitialize connection */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* now we can copy the input to the new buffer */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pBuff</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_data</name></name></expr></argument>, <argument><expr><name><name>tcItem</name><operator>-&gt;</operator><name>chunk_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>+=</operator> <name>length</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SendEosUDPIFC
 * 		broadcast eos messages to receivers.
 *
 * See ml_ipc.h
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SendEosUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>motNodeID</name></decl></parameter>,
			  <parameter><decl><type><name>TupleChunkListItem</name></type> <name>tcItem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>activeCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>now</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>transportStates</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SendEosUDPIFC: missing interconnect context."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"SendEosUDPIFC: context and teardown inactive."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"entering seneosudp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* check em' */</comment>
	<expr_stmt><expr><call><name>ML_CHECK_FOR_INTERRUPTS</name><argument_list>(<argument><expr><name><name>transportStates</name><operator>-&gt;</operator><name>teardownActive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Interconnect seg%d slice%d sending end-of-stream to slice%d"</literal></expr></argument>,
			 <argument><expr><name><name>PxIdentity</name><operator>.</operator><name>workerid</name></name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>recvSlice</name><operator>-&gt;</operator><name>sliceIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * we want to add our tcItem onto each of the outgoing buffers -- this is
	 * guaranteed to leave things in a state where a flush is *required*.
	 */</comment>
	<expr_stmt><expr><call><name>doBroadcast</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>tcItem</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendingEos</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>getCurrentTime</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now flush all of the buffers. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"sent eos to route %d tuplecount %d seq %d flags 0x%x stillActive %s icId %d %d"</literal></expr></argument>,
					 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>,
					 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>,
					 <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* prepare this for transmit */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pEntry</name><operator>-&gt;</operator><name>sendingEos</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_EOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>prepareXmit</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* place it into the send queue */</comment>
			<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sendBuffers</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>tupleCount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>msgSize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>curBuff</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>deadlockCheckBeginTime</name></name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>activeCount</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now waiting for acks from receivers.
	 *
	 * Note here waiting is done in a separate phase from the EOS sending
	 * phase to make the processing faster when a lot of connections are slow
	 * and have frequent packet losses. In fault injection tests, we found
	 * this.
	 *
	 */</comment>

	<while>while <condition>(<expr><name>activeCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>activeCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>retry</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>ic_control_info</name><operator>.</operator><name>lastPacketSendTime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<comment type="block">/* wait until this queue is emptied */</comment>
				<while>while <condition>(<expr><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
					   <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>timeout</name> <operator>=</operator> <call><name>computeTimeout</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>retry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>pollAcks</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name><name>pEntry</name><operator>-&gt;</operator><name>txfd</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>handleAcks</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<expr_stmt><expr><call><name>checkExceptions</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>pEntry</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>retry</name><operator>++</operator></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&gt;=</operator> <name>MAX_TRY</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></while>

				<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>pxProc</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>unackQueue</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
										 <call><name>icBufferListLength</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>sndQueue</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>mcsEosSent</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>activeCount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SendEosUDPIFC leaving, activeCount %d"</literal></expr></argument>, <argument><expr><name>activeCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * doSendStopMessageUDPIFC
 * 		Send stop messages to all senders.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>doSendStopMessageUDPIFC</name><parameter_list>(<parameter><decl><type><name>ChunkTransportState</name> <modifier>*</modifier></type><name>transportStates</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>motNodeID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ChunkTransportStateEntry</name> <modifier>*</modifier></type><name>pEntry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>transportStates</name><operator>-&gt;</operator><name>activated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>getChunkTransportState</name><argument_list>(<argument><expr><name>transportStates</name></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we're only concerned with receivers here.
	 */</comment>
	<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Interconnect needs no more input from slice%d; notifying senders to stop."</literal></expr></argument>,
			 <argument><expr><name>motNodeID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>numConns</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <name><name>pEntry</name><operator>-&gt;</operator><name>conns</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note here, the stillActive flag of a connection may have been set
		 * to false by markUDPConnInactiveIFC.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * we have a queued packet that has EOS in it. We've acked it,
				 * so we're done
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"do sendstop: already have queued EOS packet, we're done. node %d route %d"</literal></expr></argument>,
						 <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* need to drop the queues in the teardown function. */</comment>
				<while>while <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>putRxBufferAndSendAck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_STOP</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * The peer addresses for incoming connections will not be set
				 * until the first packet has arrived. However, when the lower
				 * slice does not have data to send, the corresponding peer
				 * address for the incoming connection will never be set. We
				 * will skip sending ACKs to those connections.
				 */</comment>

				<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET</name> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>peer</name><operator>.</operator><name>ss_family</name></name> <operator>==</operator> <name>AF_INET6</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>uint32</name></type>		<name>seq</name> <init>= <expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>sendAck</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_STOP</name> <operator>|</operator> <name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"sent stop message. node %d route %d seq %d"</literal></expr></argument>, <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"first packet did not arrive yet. don't sent stop message. node %d route %d"</literal></expr></argument>,
							 <argument><expr><name>motNodeID</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dispatcherAYT
 * 		Check the connection from the dispatcher to verify that it is still there.
 *
 * The connection is a struct Port, stored in the global MyProcPort.
 *
 * Return true if the dispatcher connection is still alive.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>dispatcherAYT</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type>		<name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>buf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For background worker or auxiliary process like gdd, there is no
	 * client. As a result, MyProcPort is NULL. We should skip dispatcherAYT
	 * check here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MSG_PEEK</name> <operator>|</operator> <name>MSG_DONTWAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>recv</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>sock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>MSG_PEEK</name> <operator>|</operator> <name>MSG_PARTIAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* socket has been closed. EOF */</comment>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>				<comment type="block">/* data waiting on socket, it must be OK. */</comment>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>				<comment type="block">/* error, or would be block. */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINPROGRESS</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if>		<comment type="block">/* connection intact, no data available */</comment>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* not reached */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkQCConnectionAlive
 * 		Check whether QC connection is still alive. If not, report error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkQCConnectionAlive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dispatcherAYT</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error segment lost contact with master (recv)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PX_INTERCONNECTION_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interconnect error master lost contact with client (recv)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px: polar check qd connection
 */</comment>
<function><type><name>void</name></type>
<name>px_check_qc_connection_alive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>checkQCConnectionAlive</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getCurrentTime
 * 		get current time
 *
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>getCurrentTime</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>newTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CLOCK_GETTIME</name></cpp:ifdef>
	<comment type="block">/* Use clock_gettime to return monotonic time value. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>clock_gettime</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newTime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newTime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>ts</name><operator>.</operator><name>tv_nsec</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newTime</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name><name>newTime</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <name>USECS_PER_SECOND</name> <operator>+</operator> <name><name>newTime</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
	<return>return <expr><name>t</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * putIntoUnackQueueRing
 * 		Put the buffer into the ring.
 *
 * expTime - expiration time from now
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>putIntoUnackQueueRing</name><parameter_list>(<parameter><decl><type><name>UnackQueueRing</name> <modifier>*</modifier></type><name>uqr</name></decl></parameter>, <parameter><decl><type><name>ICBuffer</name> <modifier>*</modifier></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>expTime</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The first packet, currentTime is not initialized */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>uqr</name><operator>-&gt;</operator><name>currentTime</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>uqr</name><operator>-&gt;</operator><name>currentTime</name></name> <operator>=</operator> <name>now</name> <operator>-</operator> <operator>(</operator><name>now</name> <operator>%</operator> <name>TIMER_SPAN</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>now</name> <operator>+</operator> <name>expTime</name> <operator>-</operator> <name><name>uqr</name><operator>-&gt;</operator><name>currentTime</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;=</operator> <name>UNACK_QUEUE_RING_LENGTH</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"putIntoUnackQueueRing:"</literal> <literal type="string">"now "</literal> <name>UINT64_FORMAT</name> <literal type="string">"expTime "</literal> <name>UINT64_FORMAT</name> <literal type="string">"diff "</literal> <name>UINT64_FORMAT</name> <literal type="string">"uqr-currentTime "</literal> <name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>expTime</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name><name>uqr</name><operator>-&gt;</operator><name>currentTime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>UNACK_QUEUE_RING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>diff</name> <operator>&lt;</operator> <name>TIMER_SPAN</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>diff</name> <operator>=</operator> <name>TIMER_SPAN</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name><name>uqr</name><operator>-&gt;</operator><name>idx</name></name> <operator>+</operator> <name>diff</name> <operator>/</operator> <name>TIMER_SPAN</name><operator>)</operator> <operator>%</operator> <name>UNACK_QUEUE_RING_SLOTS_NUM</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
	<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"PUTTW: curtime "</literal> <name>UINT64_FORMAT</name> <literal type="string">" now "</literal> <name>UINT64_FORMAT</name> <literal type="string">" (diff "</literal> <name>UINT64_FORMAT</name> <literal type="string">") expTime "</literal> <name>UINT64_FORMAT</name> <literal type="string">" previdx %d, nowidx %d, nextidx %d"</literal></expr></argument>, <argument><expr><name><name>uqr</name><operator>-&gt;</operator><name>currentTime</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>expTime</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name></expr></argument>, <argument><expr><name><name>uqr</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>unackQueueRingSlot</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>icBufferListAppend</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>unack_queue_ring</name><operator>.</operator><name>slots</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * handleDataPacket
 * 		Handling the data packet.
 *
 * On return, will set *wakeup_mainthread, if a packet was received successfully
 * and the caller should wake up the main thread, after releasing the mutex.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handleDataPacket</name><parameter_list>(<parameter><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>socklen_t</name> <modifier>*</modifier></type> <name>peerlen</name></decl></parameter>,
				 <parameter><decl><type><name>AckSendParam</name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>wakeup_mainthread</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>seq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>extraSeq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>headSeq</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_CAPACITY</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"status queuy message received, seq %d, srcpid %d, dstpid %d, icid %d, sid %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"STATUS QUERY MESSAGE"</literal></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>seq</name> <operator>=</operator> <ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>extraSeq</name> <operator>=</operator> <ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name></expr> ?</condition><then> <expr><name>seq</name></expr> </then><else>: <expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>extraSeq</name></name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>extraSeq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * when we're not doing a full-setup on every statement, we've got to
	 * update the peer info -- full setups do this at setup-time.
	 */</comment>

	<comment type="block">/*
	 * Note the change here, for process start race and disordered message, if
	 * we do not fill in peer address, then we may send some acks to unknown
	 * address. Thus, the following condition is used.
	 *
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fill in the peer.  Need to cast away "volatile".  ugly */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name>peer</name></expr></argument>, <argument><expr><operator>*</operator><name>peerlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name> <operator>=</operator> <operator>*</operator><name>peerlen</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>dstListenerPort</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>dstListenerPort</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>DEBUG2</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received the head packets when eliding setup, pkt seq %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* data packet */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>DEBUG3</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received packet with EOS motid %d route %d seq %d"</literal></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if we got a stop, but didn't request a stop -- ignore, this is a
	 * startup blip: we must have acked with a stop -- we don't want to do
	 * anything further with the stop-message if we didn't request a stop!
	 *
	 * this is especially important after eliding setup is enabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_STOP</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"non-requested stop flag, EOS! seq %d, flags 0x%x"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>stopRequested</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_DEBUG</name> <operator>&amp;&amp;</operator> <name>DEBUG5</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"rx_thread got packet on active connection marked stopRequested. "</literal>
					  <literal type="string">"(flags 0x%x) node %d route %d pkt seq %d conn seq %d"</literal></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* can we update stillActive ? */</comment>
		<if_stmt><if>if <condition>(<expr><name>DEBUG2</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_STOP</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>!</operator><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"stop requested but no stop flag on return packet ?!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_EOS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>&lt;</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> <comment type="block">/* note here */</comment>

		<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_STOP</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* we only update stillActive if eos has been sent by peer. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>DEBUG2</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"stop requested and acknowledged by sending peer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* dropped ack or timeout */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>duplicatedPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>DEBUG3</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"dropped ack ? ignored data packet w/ cmd %d conn-&gt;cmd %d node %d route %d seq %d expected %d flags 0x%x"</literal></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>,
					  <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>extraSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* sequence number is correct */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>stillActive</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* peer may have dropped ack */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_interconnect_log</name>  <operator>&gt;=</operator> <name>PXVARS_VERBOSITY_VERBOSE</name> <operator>&amp;&amp;</operator>
			<name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received on inactive connection node %d route %d (seq %d pkt-&gt;seq %d)"</literal></expr></argument>,
					  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>&lt;</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_STOP</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* headSeq is the seq for the head packet. */</comment>
	<expr_stmt><expr><name>headSeq</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>-</operator> <name>headSeq</name> <operator>&gt;=</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Error case: NO RX SPACE or out of range pkt This indicates a bug.
		 */</comment>
		<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"Interconnect error: received a packet when the queue is full "</literal></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>disorderedPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>stat_count_dropped</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* put the packet at the his position */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>toWakeup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name> <init>= <expr><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type> <name>polar_fault_inject</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_conn_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>FAULT_INJECTOR_PX_CONN_NULL</name>;</goto></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_conn_not_null"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator><call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>pos</name></expr>]</index></name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>polar_fault_inject</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>FAULT_INJECTOR_PX_CONN_NOT_NULL</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"px_handle_disorder_packet"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>FAULT_INJECTOR_PX_HANDLE_DISORDER_PACKET</name>;</goto></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<label><name>FAULT_INJECTOR_PX_CONN_NULL</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>pkt</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"SAVE pkt at QUEUE HEAD [seq %d] for node %d route %d, queue head seq %d, queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name>headSeq</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>toWakeup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* move the queue tail */</comment>
			<for>for <control>(<init>;</init> <condition><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>&lt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</condition><incr/>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name> <operator>=</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/* set the EOS flag */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name></expr>]</index></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>flags</name> <operator>&amp;</operator> <name>UDPIC_FLAGS_EOS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name> <operator>|=</operator> <name>UDPIC_FLAGS_EOS</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"RX_THREAD: the packet with EOS flag is available for access in the queue for route %d"</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* ack data packet */</comment>
			<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>extraSeq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"SAVE conn %p pkt at QUEUE TAIL [seq %d] at pos [%d] for node %d route %d, [head seq] %d, queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name>headSeq</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else					<comment type="block">/* deal with out-of-order packet */</comment>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<label><name>FAULT_INJECTOR_PX_HANDLE_DISORDER_PACKET</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"SAVE conn %p OUT-OF-ORDER pkt [seq %d] at pos [%d] for node %d route %d, [head seq] %d, queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr></argument>, <argument><expr><name>headSeq</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* send an ack for out-of-order packet */</comment>
			<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>disorderedPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>handleDisorderPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>headSeq</name> <operator>+</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else						<comment type="block">/* duplicate pkt */</comment>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<label><name>FAULT_INJECTOR_PX_CONN_NOT_NULL</name>:</label>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"DUPLICATE pkt [seq %d], [head seq] %d, queue size %d, queue head %d queue tail %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name>headSeq</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_head</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_tail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>setAckSendParam</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>UDPIC_FLAGS_DUPLICATE</name> <operator>|</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name><operator>.</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>duplicatedPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>polar_fault_inject</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Was the main thread waiting for something ? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waiting</name></name> <operator>&amp;&amp;</operator>
		<name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingNode</name></name> <operator>==</operator> <name><name>pkt</name><operator>-&gt;</operator><name>motNodeId</name></name> <operator>&amp;&amp;</operator>
		<name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingQuery</name></name> <operator>==</operator> <name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name> <operator>&amp;&amp;</operator> <name>toWakeup</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingRoute</name></name> <operator>==</operator> <name>ANY_ROUTE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>reachRoute</name></name> <operator>==</operator> <name>ANY_ROUTE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>reachRoute</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingRoute</name></name> <operator>==</operator> <name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>DEBUG2</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"rx thread: main_waiting waking it route %d"</literal></expr></argument>, <argument><expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>waitingRoute</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>rx_control_info</name><operator>.</operator><name>mainWaitingState</name><operator>.</operator><name>reachRoute</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>route</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* WAKE MAIN THREAD HERE */</comment>
		<expr_stmt><expr><operator>*</operator><name>wakeup_mainthread</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * rxThreadFunc
 * 		Main function of the receive background thread.
 *
 * NOTE: This function MUST NOT contain elog or ereport statements.
 * elog is NOT thread-safe.  Developers should instead use something like:
 *
 *	if (DEBUG3 &gt;= log_min_messages)
 *		write_log("my brilliant log statement here.");
 *
 * NOTE: In threads, we cannot use palloc/pfree, because it's not thread safe.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>rxThreadFunc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>pkt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skip_poll</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name>nfd</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check shutdown condition */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_atomic_unlocked_test_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>shutdown</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"udp-ic: rx-thread shutting down"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Try to get a buffer */</comment>
		<if_stmt><if>if <condition>(<expr><name>pkt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pkt</name> <operator>=</operator> <call><name>getRxBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>pkt</name> <operator>==</operator> <name>NULL</name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
				<operator>||</operator> <call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"rx_thread_error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeEnable</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>setRxThreadError</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip_poll</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do we have inbound traffic to handle ? */</comment>
			<expr_stmt><expr><name><name>nfd</name><operator>.</operator><name>fd</name></name> <operator>=</operator> <name>UDP_listenerFd</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nfd</name><operator>.</operator><name>events</name></name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nfd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>RX_THREAD_POLL_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_atomic_unlocked_test_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>shutdown</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"udp-ic: rx-thread shutting down"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * ERROR case: if simply break out the loop here, there will
				 * be a hung here, since main thread will never be waken up,
				 * and senders will not get responses anymore.
				 *
				 * Thus, we set an error flag, and let main thread to report
				 * an error.
				 */</comment>
				<expr_stmt><expr><call><name>setRxThreadError</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>skip_poll</name> <operator>||</operator> <operator>(</operator><name>n</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>nfd</name><operator>.</operator><name>events</name></name> <operator>&amp;</operator> <name>POLLIN</name><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we've got something interesting to read */</comment>
			<comment type="block">/* handle incoming */</comment>
			<comment type="block">/* ready to read on our socket */</comment>
			<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>read_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<decl_stmt><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name></type> <name>peer</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>socklen_t</name></type>	<name>peerlen</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>peerlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<expr_stmt><expr><name>read_count</name> <operator>=</operator> <call><name>recvfrom</name><argument_list>(<argument><expr><name>UDP_listenerFd</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>pkt</name></expr></argument>, <argument><expr><name>px_interconnect_max_packet_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><operator>(</operator>struct <name>sockaddr</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>peer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peerlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_atomic_unlocked_test_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>shutdown</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"udp-ic: rx-thread shutting down"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>DEBUG5</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received inbound len %d"</literal></expr></argument>, <argument><expr><name>read_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>read_count</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>skip_poll</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EWOULDBLOCK</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Interconnect error: recvfrom (%d)"</literal></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * ERROR case: if simply break out the loop here, there will
				 * be a hung here, since main thread will never be waken up,
				 * and senders will not get responses anymore.
				 *
				 * Thus, we set an error flag, and let main thread to report
				 * an error.
				 */</comment>
				<expr_stmt><expr><call><name>setRxThreadError</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>read_count</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Interconnect error: short conn receive (%d)"</literal></expr></argument>, <argument><expr><name>read_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * when we get a "good" recvfrom() result, we can skip poll()
			 * until we get a bad one.
			 */</comment>
			<expr_stmt><expr><name>skip_poll</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* length must be &gt;= 0 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG3</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received inbound with negative length"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name>read_count</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG3</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received inbound packet [%d], short: read %d bytes, pkt-&gt;len %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name>read_count</name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * check the CRC of the payload.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>px_interconnect_full_crc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>checkCRC</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>ic_statistics</name><operator>.</operator><name>crcErrors</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>DEBUG2</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"received network data error, dropping bad packet, user data unaffected."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
			<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"GOT MESSAGE"</literal></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<decl_stmt><decl><type><name>bool</name></type>		<name>wakeup_mainthread</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AckSendParam</name></type> <name>param</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AckSendParam</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Get the connection for the pkt.
			 *
			 * The connection hash table should be locked until finishing the
			 * processing of the packet to avoid the connection
			 * addition/removal from the hash table during the mean time.
			 */</comment>

			<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>findConnByHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>connHtab</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Handling a regular packet */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>handleDataPacket</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peerlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wakeup_mainthread</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>pkt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>recvPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * There may have two kinds of Mismatched packets: a) Past
				 * packets from previous command after I was torn down b)
				 * Future packets from current command before my connections
				 * are built.
				 *
				 * The handling logic is to "Ack the past and Nak the future".
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>pkt</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>UDPIC_FLAGS_RECEIVER_TO_SENDER</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"mismatched packet received, seq %d, srcpid %d, dstpid %d, icid %d, sid %d"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>srcPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>dstPid</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>sessionId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AMS_VERBOSE_LOGGING</name></cpp:ifdef>
					<expr_stmt><expr><call><name>logPkt</name><argument_list>(<argument><expr><literal type="string">"Got a Mismatched Packet"</literal></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

					<if_stmt><if>if <condition>(<expr><call><name>handleMismatch</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>peer</name></expr></argument>, <argument><expr><name>peerlen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>pkt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>mismatchNum</name></name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>wakeup_mainthread</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>latch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * real ack sending is after lock release to decrease the lock
			 * holding time.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>msg</name><operator>.</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>sendAckWithParam</name><argument_list>(<argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* pthread_yield(); */</comment>
	</block_content>}</block></for>

	<comment type="block">/* Before return, we release the packet. */</comment>
	<if_stmt><if>if <condition>(<expr><name>pkt</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pthread_mutex_lock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>freeRxBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pkt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_unlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* nothing to return */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * handleMismatch
 * 		If the mismatched packet is from an old connection, we may need to
 * 		send an acknowledgment.
 *
 * We are called with the receiver-lock held, and we never release it.
 *
 * For QC:
 * 1) Not in hashtable     : NAK it/Do nothing
 * 	  Causes:  a) Start race
 * 	           b) Before the entry for the ic instance is inserted, an error happened.
 * 	           c) From past transactions: should no happen.
 * 2) Active in hashtable  : NAK it/Do nothing
 *    Causes:  a) Error reported after the entry is inserted, and connections are
 *                not inserted to the hashtable yet, and before teardown is called.
 * 3) Inactive in hashtable: ACK it (with stop)
 *    Causes: a) Normal execution: after teardown is called on current command.
 *            b) Error case, 2a) after teardown is called.
 *            c) Normal execution: from past history transactions (should not happen).
 *
 * For PX:
 * 1) pkt-&gt;id &gt; sliceTbl-&gt;ic_instance_id : NAK it/Do nothing
 *    Causes: a) Start race
 *            b) Before sliceTbl-&gt;ic_instance_id is assigned to correct value, an error happened.
 * 2) lastTornIcId &lt; pkt-&gt;id == sliceTbl-&gt;ic_instance_id: NAK it/Do nothing
 *    Causes:  a) Error reported after sliceTbl-&gt;ic_instance_id is set, and connections are
 *                not inserted to the hashtable yet, and before teardown is called.
 * 3) lastTornIcId == pkt-&gt;id == sliceTbl-&gt;ic_instance_id: ACK it (with stop)
 *    Causes:  a) Normal execution: after teardown is called on current command
 * 4) pkt-&gt;id &lt; sliceTbl-&gt;ic_instance_id: NAK it/Do nothing/ACK it.
 *    Causes:  a) Should not happen.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>handleMismatch</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>peer_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>cached</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * we want to ack old packets; but *must* avoid acking connection
	 * requests:
	 *
	 * "ACK the past, NAK the future" explicit NAKs aren't necessary, we just
	 * don't want to ACK future packets, that confuses everyone.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>pkt</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <name>px_session_id</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>need_ack</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8</name></type>		<name>ack_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The QC-backends can't use a counter, they've potentially got
		 * multiple instances (one for each active cursor)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_QC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>struct</name> <name>CursorICHistoryEntry</name></name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getCursorIcEntry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rx_control_info</name><operator>.</operator><name>cursorHistoryTable</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Torn down. Ack the past. */</comment>
					<expr_stmt><expr><name>need_ack</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else			<comment type="block">/* p-&gt;status == 1 */</comment>
				<block>{<block_content>
					<comment type="block">/*
					 * Not torn down yet. It happens when an error
					 * (out-of-memory, network error...) occurred after the
					 * cursor entry is inserted into the table in interconnect
					 * setup process. The peer will be canceled.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"GOT A MISMATCH PACKET WITH ID %d HISTORY THINKS IT IS ACTIVE"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>cached</name></expr>;</return>	<comment type="block">/* ignore, no ack */</comment>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"GOT A MISMATCH PACKET WITH ID %d HISTORY HAS NO RECORD"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * No record means that two possibilities. 1) It is from the
				 * future. It is due to startup race. We do not ack future
				 * packets 2) Before the entry for the ic instance is
				 * inserted, an error happened. We do not ack for this case
				 * too. The peer will be canceled.
				 */</comment>
				<expr_stmt><expr><name>ack_flags</name> <operator>=</operator> <name>UDPIC_FLAGS_NAK</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>need_ack</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>px_interconnect_cache_future_packets</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cached</name> <operator>=</operator> <call><name>cacheFuturePacket</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>, <argument><expr><name>peer_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<comment type="block">/* The PXs get to use a simple counter. */</comment>
		<if type="elseif">else if <condition>(<expr><name>px_role</name> <operator>==</operator> <name>PX_ROLE_PX</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>ic_control_info</name><operator>.</operator><name>ic_instance_id</name></name> <operator>&gt;=</operator> <name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>need_ack</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * We want to "ACK the past, but NAK the future."
				 *
				 * handleAck() will retransmit.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name> <operator>&gt;</operator> <name><name>rx_control_info</name><operator>.</operator><name>lastTornIcId</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ack_flags</name> <operator>=</operator> <name>UDPIC_FLAGS_NAK</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>need_ack</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * ic_control_info.ic_instance_id &lt; pkt-&gt;icId, from the future
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>px_interconnect_cache_future_packets</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>cached</name> <operator>=</operator> <call><name>cacheFuturePacket</name><argument_list>(<argument><expr><name>pkt</name></expr></argument>, <argument><expr><name>peer</name></expr></argument>, <argument><expr><name>peer_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>need_ack</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MotionConn</name></type>	<name>dummyconn</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* numeric IP addresses shouldn't exceed
									 * about 50 chars, but play it safe */</comment>


			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dummyconn</name><operator>.</operator><name>conn_info</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dummyconn</name><operator>.</operator><name>peer</name></name> <operator>=</operator> <operator>*</operator><name>peer</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>dummyconn</name><operator>.</operator><name>peer_len</name></name> <operator>=</operator> <name>peer_len</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
			dummyconn.conn_info.flags |= ack_flags;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ACKING PACKET WITH FLAGS: pkt-&gt;seq %d 0x%x [pkt-&gt;icId %d last-teardown %d interconnect_id %d]"</literal></expr></argument>,
						  <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>dummyconn</name><operator>.</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>rx_control_info</name><operator>.</operator><name>lastTornIcId</name></name></expr></argument>, <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>format_sockaddr</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dummyconn</name><operator>.</operator><name>peer</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"ACKING PACKET TO %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
			if ((ack_flags &amp; UDPIC_FLAGS_NAK) == 0)
			{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>ack_flags</name> <operator>|=</operator> <name>UDPIC_FLAGS_STOP</name> <operator>|</operator> <name>UDPIC_FLAGS_ACK</name> <operator>|</operator> <name>UDPIC_FLAGS_CAPACITY</name> <operator>|</operator> <name>UDPIC_FLAGS_RECEIVER_TO_SENDER</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
			}
			else
			{
				ack_flags |= UDPIC_FLAGS_RECEIVER_TO_SENDER;
			}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * There are two cases, we may need to send a response to sender
			 * here. One is start race and the other is receiver becomes idle.
			 *
			 * ack_flags here can take two possible values 1) UDPIC_FLAGS_NAK
			 * | UDPIC_FLAGS_RECEIVER_TO_SENDER (for start race) 2)
			 * UDPIC_FLAGS_STOP | UDPIC_FLAGS_ACK | UDPIC_FLAGS_CAPACITY |
			 * UDPIC_FLAGS_RECEIVER_TO_SENDER (for idle receiver)
			 *
			 * The final flags in the packet may take some extra bits such as
			 * 1) UDPIC_FLAGS_STOP 2) UDPIC_FLAGS_EOS 3) UDPIC_FLAGS_CAPACITY
			 * which are from original packet
			 */</comment>
			<expr_stmt><expr><call><name>sendAck</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummyconn</name></expr></argument>, <argument><expr><name>ack_flags</name> <operator>|</operator> <name><name>dummyconn</name><operator>.</operator><name>conn_info</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>dummyconn</name><operator>.</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>dummyconn</name><operator>.</operator><name>conn_info</name><operator>.</operator><name>seq</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>DEBUG1</name> <operator>&gt;=</operator> <name>log_min_messages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"dropping packet from command-id %d seq %d (my cmd %d)"</literal></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>icId</name></name></expr></argument>, <argument><expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name></expr></argument>, <argument><expr><name><name>ic_control_info</name><operator>.</operator><name>ic_instance_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>cached</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cacheFuturePacket
 *		Cache the future packets during the setupUDPIFCInterconnect.
 *
 * Return true if packet is cached, otherwise false
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>cacheFuturePacket</name><parameter_list>(<parameter><decl><type><name>icpkthdr</name> <modifier>*</modifier></type><name>pkt</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>sockaddr_storage</name></name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>peer_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>findConnByHeader</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MotionConn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>setRxThreadError</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>conn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MotionConn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>conn_info</name></name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>icpkthdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_capacity</name></name> <operator>=</operator> <name>px_interconnect_queue_depth</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>=</operator> <name>px_interconnect_queue_depth</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>px_interconnect_queue_depth</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* malloc failed.  */</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setRxThreadError</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* We only use the array to store cached packets. */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>px_interconnect_queue_depth</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint8</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Put connection to the hashtable. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>connAddHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name></name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setRxThreadError</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Setup the peer sock information. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>peer</name></name></expr></argument>, <argument><expr><name>peer</name></expr></argument>, <argument><expr><name>peer_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>peer_len</name></name> <operator>=</operator> <name>peer_len</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Reject packets with invalid sequence numbers and packets which have
	 * been cached before.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>&gt;</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q_size</name></name> <operator>||</operator> <name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name><name>pkt</name><operator>-&gt;</operator><name>seq</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint8</name> <operator>*</operator><operator>)</operator> <name>pkt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ic_statistics</name><operator>.</operator><name>startupCachedPktNum</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * cleanupStartupCache
 *		Clean the startup cache.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cleanupStartupCache</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConnHtabBin</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MotionConn</name> <modifier>*</modifier></type><name>cachedConn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>icpkthdr</name>   <modifier>*</modifier></type><name>pkt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name><operator>.</operator><name>size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>bin</name> <operator>=</operator> <name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name><operator>.</operator><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<while>while <condition>(<expr><name>bin</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cachedConn</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>conn</name></name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q_size</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>pkt</name> <operator>=</operator> <operator>(</operator><name>icpkthdr</name> <operator>*</operator><operator>)</operator> <name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>pkt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>rx_buffer_pool</name><operator>.</operator><name>maxCount</name></name><operator>--</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>putRxBufferToFreeList</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rx_buffer_pool</name></expr></argument>, <argument><expr><name>pkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>bin</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>connDelHash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ic_control_info</name><operator>.</operator><name>startupCacheHtab</name></name></expr></argument>, <argument><expr><name>cachedConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * PX-19981 free the cached connections; otherwise memory leak
			 * would be introduced.
			 */</comment>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>cachedConn</name><operator>-&gt;</operator><name>pkt_q</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>cachedConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></for>
</block_content>}</block></function>

</unit>
