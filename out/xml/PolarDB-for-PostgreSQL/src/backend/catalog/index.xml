<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/catalog/index.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * index.c
 *	  code to create and destroy POSTGRES index relations
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/index.c
 *
 *
 * INTERFACE ROUTINES
 *		index_create()			- Create a cataloged index relation
 *		index_drop()			- Removes index relation from catalogs
 *		BuildIndexInfo()		- Prepare to insert index tuples
 *		FormIndexDatum()		- Construct datum vector for one index tuple
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/amapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relscan.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/visibilitymap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bootstrap/bootstrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/binary_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_depend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/polar_bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_rusage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tuplesort.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tqual.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/px_btbuild.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>

<comment type="block">/* Potentially set by pg_upgrade_support functions */</comment>
<decl_stmt><decl><type><name>Oid</name></type>			<name>binary_upgrade_next_index_pg_class_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* state info for validate_index bulkdelete callback */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Tuplesortstate</name> <modifier>*</modifier></type><name>tuplesort</name></decl>;</decl_stmt>	<comment type="block">/* for sorting the index TIDs */</comment>
	<comment type="block">/* statistics (for debug purposes only): */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>htups</name></decl>,
				<name>itups</name>,
				<name>tups_inserted</name>;</decl_stmt>
}</block></struct></type> <name>v_i_state</name>;</typedef>

<comment type="block">/*
 * Pointer-free representation of variables used when reindexing system
 * catalogs; we use this to propagate those values to parallel workers.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>currentlyReindexedHeap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>currentlyReindexedIndex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPendingReindexedIndexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pendingReindexedIndexes</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>SerializedReindexState</name>;</typedef>

<comment type="block">/* non-export function prototypes */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>relationHasPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TupleDesc</name></type> <name>ConstructTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexColNames</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>accessMethodObjectId</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationObjectId</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classObjectId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeAttributeOids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numatts</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AppendAttributeTuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numatts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateIndexRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>heapoid</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>parentIndexId</name></decl></parameter>,
					<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationOids</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classOids</name></decl></parameter>,
					<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>coloptions</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>primary</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isexclusion</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>immediate</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isvalid</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isready</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>index_update_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>hasindex</name></decl></parameter>,
				   <parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>IndexCheckExclusion</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
					<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64</name></type> <name>itemptr_encode</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>itemptr_decode</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>encoded</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>validate_index_callback</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>validate_index_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						<parameter><decl><type><name>v_i_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ReindexIsCurrentlyProcessingIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetReindexProcessing</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>heapOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResetReindexProcessing</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetReindexPending</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveReindexPending</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* POLAR */</comment>
<function_decl><type><name>Datum</name></type> <name>polar_get_root_ctid</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>polar_px_validate_index_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						<parameter><decl><type><name>v_i_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * relationHasPrimaryKey
 *		See whether an existing relation has a primary key.
 *
 * Caller must have suitable lock on the relation.
 *
 * Note: we intentionally do not check IndexIsValid here; that's because this
 * is used to enforce the rule that there can be only one indisprimary index,
 * and we want that to be true even if said index is invalid.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>relationHasPrimaryKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexoidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexoidscan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the list of index OIDs for the table from the relcache, and look up
	 * each one in the pg_index syscache until we find one marked primary key
	 * (hopefully there isn't more than one such).
	 */</comment>
	<expr_stmt><expr><name>indexoidlist</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>indexoidscan</argument>, <argument>indexoidlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexoid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexoidscan</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>indisprimary</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>indexoidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_check_primary_key
 *		Apply special checks needed before creating a PRIMARY KEY index
 *
 * This processing used to be in DefineIndex(), but has been split out
 * so that it can be applied during ALTER TABLE ADD PRIMARY KEY USING INDEX.
 *
 * We check for a pre-existing primary key, and that all columns of the index
 * are simple column references (not expressions), and that all those
 * columns are marked NOT NULL.  If they aren't (which can only happen during
 * ALTER TABLE ADD CONSTRAINT, since the parser forces such columns to be
 * created NOT NULL during CREATE TABLE), do an ALTER SET NOT NULL to mark
 * them so --- or fail if they are not in fact nonnull.
 *
 * As of PG v10, the SET NOT NULL is applied to child tables as well, so
 * that the behavior is like a manual SET NOT NULL.
 *
 * Caller had better have at least ShareLock on the table, else the not-null
 * checking isn't trustworthy.
 */</comment>
<function><type><name>void</name></type>
<name>index_check_primary_key</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRel</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>is_alter_table</name></decl></parameter>,
						<parameter><decl><type><name>IndexStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cmds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If ALTER TABLE and CREATE TABLE .. PARTITION OF, check that there isn't
	 * already a PRIMARY KEY.  In CREATE TABLE for an ordinary relations, we
	 * have faith that the parser rejected multiple pkey clauses; and CREATE
	 * INDEX doesn't have a way to say PRIMARY KEY, so it's no problem either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_alter_table</name> <operator>||</operator> <name><name>heapRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>relationHasPrimaryKey</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple primary keys for table \"%s\" are not allowed"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check that all of the attributes in a primary key are marked as not
	 * null, otherwise attempt to ALTER TABLE .. SET NOT NULL
	 */</comment>
	<expr_stmt><expr><name>cmds</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"primary keys cannot be expressions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* System attributes are never null, so no need to check */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attform</name><operator>-&gt;</operator><name>attnotnull</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Add a subcommand to make this one NOT NULL */</comment>
			<decl_stmt><decl><type><name>AlterTableCmd</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>AlterTableCmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>subtype</name></name> <operator>=</operator> <name>AT_SetNotNull</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cmd</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attform</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cmds</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * XXX: possible future improvement: when being called from ALTER TABLE,
	 * it would be more efficient to merge this with the outer ALTER TABLE, so
	 * as to avoid two scans.  But that seems to complicate DefineIndex's API
	 * unduly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmds</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EventTriggerAlterTableStart</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AlterTableInternal</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>cmds</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EventTriggerAlterTableEnd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		ConstructTupleDescriptor
 *
 * Build an index tuple descriptor for a new index
 */</comment>
<function><type><specifier>static</specifier> <name>TupleDesc</name></type>
<name>ConstructTupleDescriptor</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexColNames</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>accessMethodObjectId</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationObjectId</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classObjectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numatts</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numkeyatts</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>colnames_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name>indexColNames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name> <init>= <expr><call><name>list_head</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexAmRoutine</name> <modifier>*</modifier></type><name>amroutine</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>heapTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>indexTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name></decl>;</decl_stmt>			<comment type="block">/* #atts in heap rel --- for error checks */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* We need access to the index AM's API struct */</comment>
	<expr_stmt><expr><name>amroutine</name> <operator>=</operator> <call><name>GetIndexAmRoutineByAmId</name><argument_list>(<argument><expr><name>accessMethodObjectId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... and to the table's tuple descriptor */</comment>
	<expr_stmt><expr><name>heapTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>natts</name> <operator>=</operator> <call><name>RelationGetForm</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relnatts</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * allocate the new tuple descriptor
	 */</comment>
	<expr_stmt><expr><name>indexTupDesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>numatts</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For simple index columns, we copy the pg_attribute row from the parent
	 * relation and modify it as necessary.  For expressions we have to cons
	 * up a pg_attribute row the hard way.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>atnum</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>to</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>indexTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opclassTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>keyType</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>atnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple index column */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>from</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>atnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * here we are indexing on a system attribute (-1...-n)
				 */</comment>
				<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>atnum</name></expr></argument>,
												 <argument><expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * here we are indexing on a normal attribute (1...n)
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>atnum</name> <operator>&gt;</operator> <name>natts</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* safety check */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid column number %d"</literal></expr></argument>, <argument><expr><name>atnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>heapTupDesc</name></expr></argument>,
									 <argument><expr><call><name>AttrNumberGetAttrOffset</name><argument_list>(<argument><expr><name>atnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * now that we've determined the "from", let's copy the tuple desc
			 * data...
			 */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set the attribute name as specified by caller.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>colnames_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in colnames list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>colnames_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colnames_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>colnames_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Fix the stuff that should not be the same as the underlying
			 * attr
			 */</comment>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>atthasmissing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attinhcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>numkeyatts</name><operator>)</operator></expr> ?</condition><then>
				<expr><name><name>collationObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Expressional index */</comment>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Set the attribute name as specified by caller.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>colnames_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in colnames list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>to</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>colnames_item</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>colnames_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>colnames_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Lookup the expression type in pg_type for the type length etc.
			 */</comment>
			<expr_stmt><expr><name>keyType</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>keyType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>keyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Assign some of the attributes values. Leave the rest as 0.
			 */</comment>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>keyType</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>numkeyatts</name><operator>)</operator></expr> ?</condition><then>
				<expr><name><name>collationObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Make sure the expression yields a type that's safe to store in
			 * an index.  We need this defense because we have index opclasses
			 * for pseudo-types such as "record", and the actually stored type
			 * had better be safe; eg, a named composite type is okay, an
			 * anonymous record type is not.  The test is the same as for
			 * whether a table column is of a safe type (which is why we
			 * needn't check for the non-expression case).
			 */</comment>
			<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>to</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
							   <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * We do not yet have the correct relation OID for the index, so just
		 * set it invalid for now.  InitializeAttributeOids() will fix it
		 * later.
		 */</comment>
		<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attrelid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check the opclass and index AM to see if either provides a keytype
		 * (overriding the attribute type).  Opclass (if exists) takes
		 * precedence.
		 */</comment>
		<expr_stmt><expr><name>keyType</name> <operator>=</operator> <name><name>amroutine</name><operator>-&gt;</operator><name>amkeytype</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Code below is concerned to the opclasses which are not used with
		 * the included columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>classObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>,
					 <argument><expr><name><name>classObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>opclassTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>opclassTup</name><operator>-&gt;</operator><name>opckeytype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>keyType</name> <operator>=</operator> <name><name>opclassTup</name><operator>-&gt;</operator><name>opckeytype</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If keytype is specified as ANYELEMENT, and opcintype is
			 * ANYARRAY, then the attribute type must be an array (else it'd
			 * not have matched this opclass); use its element type.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>keyType</name> <operator>==</operator> <name>ANYELEMENTOID</name> <operator>&amp;&amp;</operator> <name><name>opclassTup</name><operator>-&gt;</operator><name>opcintype</name></name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>keyType</name> <operator>=</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>keyType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not get element type of array type %u"</literal></expr></argument>,
						 <argument><expr><name><name>to</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If a key type different from the heap value is specified, update
		 * the type-related fields in the index tupdesc.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>keyType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>keyType</name> <operator>!=</operator> <name><name>to</name><operator>-&gt;</operator><name>atttypid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>keyType</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>keyType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>keyType</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attlen</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attbyval</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attalign</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>=</operator> <name><name>typeTup</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>amroutine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>indexTupDesc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		InitializeAttributeOids
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeAttributeOids</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>numatts</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDescriptor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tupleDescriptor</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupleDescriptor</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attrelid</name> <operator>=</operator> <name>indexoid</name></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		AppendAttributeTuples
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AppendAttributeTuples</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numatts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_attribute</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>indexTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * open the attribute relation and its indexes
	 */</comment>
	<expr_stmt><expr><name>pg_attribute</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indstate</name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>pg_attribute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * insert data from new index's tupdesc into pg_attribute
	 */</comment>
	<expr_stmt><expr><name>indexTupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>indexTupDesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * There used to be very grotty code here to set these fields, but I
		 * think it's unnecessary.  They should be set already.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attnum</name></name> <operator>==</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcacheoff</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InsertPgAttributeTuple</name><argument_list>(<argument><expr><name>pg_attribute</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_attribute</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		UpdateIndexRelation
 *
 * Construct and insert a new entry in the pg_index catalog
 * ----------------------------------------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateIndexRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexoid</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>heapoid</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>parentIndexOid</name></decl></parameter>,
					<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationOids</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classOids</name></decl></parameter>,
					<parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>coloptions</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>primary</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isexclusion</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>immediate</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isvalid</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>isready</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>indkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indcollation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>indoption</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>exprsDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>predDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_index</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_index</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Copy the index key, opclass, and indoption info into arrays (should we
	 * make the caller pass them like this to start with?)
	 */</comment>
	<expr_stmt><expr><name>indkey</name> <operator>=</operator> <call><name>buildint2vector</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>indkey</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name>indcollation</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>collationOids</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>classOids</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>indoption</name> <operator>=</operator> <call><name>buildint2vector</name><argument_list>(<argument><expr><name>coloptions</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert the index expressions (if any) to a text datum
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprsString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprsString</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprsString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>exprsDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Convert the index predicate (if any) to a text datum.  Note we convert
	 * implicit-AND format to normal explicit-AND for storage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>predString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>predString</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><call><name>make_ands_explicit</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>predString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>predDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * open the system catalog index relation
	 */</comment>
	<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build a pg_index tuple
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indexrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>heapoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indnatts</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indnkeyatts</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisunique</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisprimary</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisexclusion</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isexclusion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indimmediate</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>immediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisclustered</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisvalid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isvalid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indcheckxmin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisready</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>isready</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indislive</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indisreplident</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indkey</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>indkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indcollation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>indcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indclass</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>indclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indoption</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>indoption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>exprsDatum</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>exprsDatum</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_index_indexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_index_indpred</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>predDatum</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>predDatum</name> <operator>==</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_index_indpred</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * insert the tuple into the pg_index catalog
	 */</comment>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * close the relation and free the tuple
	 */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * index_create
 *
 * heapRelation: table to build index on (suitably locked by caller)
 * indexRelationName: what it say
 * indexRelationId: normally, pass InvalidOid to let this routine
 *		generate an OID for the index.  During bootstrap this may be
 *		nonzero to specify a preselected OID.
 * parentIndexRelid: if creating an index partition, the OID of the
 *		parent index; otherwise InvalidOid.
 * parentConstraintId: if creating a constraint on a partition, the OID
 *		of the constraint in the parent; otherwise InvalidOid.
 * relFileNode: normally, pass InvalidOid to get new storage.  May be
 *		nonzero to attach an existing valid build.
 * indexInfo: same info executor uses to insert into the index
 * indexColNames: column names to use for index (List of char *)
 * accessMethodObjectId: OID of index AM to use
 * tableSpaceId: OID of tablespace to use
 * collationObjectId: array of collation OIDs, one per index column
 * classObjectId: array of index opclass OIDs, one per index column
 * coloptions: array of per-index-column indoption settings
 * reloptions: AM-specific options
 * flags: bitmask that can include any combination of these bits:
 *		INDEX_CREATE_IS_PRIMARY
 *			the index is a primary key
 *		INDEX_CREATE_ADD_CONSTRAINT:
 *			invoke index_constraint_create also
 *		INDEX_CREATE_SKIP_BUILD:
 *			skip the index_build() step for the moment; caller must do it
 *			later (typically via reindex_index())
 *		INDEX_CREATE_CONCURRENT:
 *			do not lock the table against writers.  The index will be
 *			marked "invalid" and the caller must take additional steps
 *			to fix it up.
 *		INDEX_CREATE_IF_NOT_EXISTS:
 *			do not throw an error if a relation with the same name
 *			already exists.
 *		INDEX_CREATE_PARTITIONED:
 *			create a partitioned index (table must be partitioned)
 * constr_flags: flags passed to index_constraint_create
 *		(only if INDEX_CREATE_ADD_CONSTRAINT is set)
 * allow_system_table_mods: allow table to be a system catalog
 * is_internal: if true, post creation hook for new index
 * constraintId: if not NULL, receives OID of created constraint
 *
 * Returns the OID of the created index.
 */</comment>
<function><type><name>Oid</name></type>
<name>index_create</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexRelationName</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>indexRelationId</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>parentIndexRelid</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>parentConstraintId</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>relFileNode</name></decl></parameter>,
			 <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
			 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexColNames</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>accessMethodObjectId</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name></type> <name>tableSpaceId</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collationObjectId</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>classObjectId</name></decl></parameter>,
			 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>coloptions</name></decl></parameter>,
			 <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>,
			 <parameter><decl><type><name>bits16</name></type> <name>flags</name></decl></parameter>,
			 <parameter><decl><type><name>bits16</name></type> <name>constr_flags</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>allow_system_table_mods</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
			 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>constraintId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapRelationId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>indexTupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shared_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mapped_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_exclusion</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relpersistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isprimary</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_IS_PRIMARY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>invalid</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_INVALID</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>concurrent</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_CONCURRENT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>partitioned</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_PARTITIONED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>relkind</name></decl>;</decl_stmt>

	<comment type="block">/* constraint flags can only be set when a constraint is requested */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>constr_flags</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		   <operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_ADD_CONSTRAINT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* partitioned indexes must never be "built" by themselves */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>partitioned</name> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_SKIP_BUILD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relkind</name> <operator>=</operator> <ternary><condition><expr><name>partitioned</name></expr> ?</condition><then> <expr><name>RELKIND_PARTITIONED_INDEX</name></expr> </then><else>: <expr><name>RELKIND_INDEX</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>is_exclusion</name> <operator>=</operator> <operator>(</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The index will be in the same namespace as its parent table, and is
	 * shared across databases if and only if the parent is.  Likewise, it
	 * will use the relfilenode map if and only if the parent does; and it
	 * inherits the parent's relpersistence.
	 */</comment>
	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shared_relation</name> <operator>=</operator> <name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mapped_relation</name> <operator>=</operator> <call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relpersistence</name> <operator>=</operator> <name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * check parameters
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"must index at least one column"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_system_table_mods</name> <operator>&amp;&amp;</operator>
		<call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"user-defined indexes on system catalog tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * concurrent index build on a system catalog is unsafe because we tend to
	 * release locks before committing in catalogs
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator>
		<call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"concurrent index creation on system catalog tables is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * This case is currently not supported, but there's no way to ask for it
	 * in the grammar anyway, so it can't happen.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>concurrent</name> <operator>&amp;&amp;</operator> <name>is_exclusion</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"concurrent index creation for exclusion constraints is not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We cannot allow indexing a shared relation after initdb (because
	 * there's no way to make the entry in other databases' pg_class).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared_relation</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shared indexes cannot be created after initdb"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Shared relations must be in pg_global, too (last-ditch check)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared_relation</name> <operator>&amp;&amp;</operator> <name>tableSpaceId</name> <operator>!=</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shared relations must be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for duplicate name (both as to the index, and as to the
	 * associated constraint if any).  Such cases would fail on the relevant
	 * catalogs' unique indexes anyway, but we prefer to give a friendlier
	 * error message.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>indexRelationName</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_IF_NOT_EXISTS</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists, skipping"</literal></expr></argument>,
							<argument><expr><name>indexRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidOid</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>indexRelationName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_ADD_CONSTRAINT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>ConstraintNameIsUsed</name><argument_list>(<argument><expr><name>CONSTRAINT_RELATION</name></expr></argument>, <argument><expr><name>heapRelationId</name></expr></argument>,
							 <argument><expr><name>indexRelationName</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * INDEX_CREATE_IF_NOT_EXISTS does not apply here, since the
		 * conflicting constraint is not an index.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
						<argument><expr><name>indexRelationName</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * construct tuple descriptor for index tuples
	 */</comment>
	<expr_stmt><expr><name>indexTupDesc</name> <operator>=</operator> <call><name>ConstructTupleDescriptor</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
											<argument><expr><name>indexInfo</name></expr></argument>,
											<argument><expr><name>indexColNames</name></expr></argument>,
											<argument><expr><name>accessMethodObjectId</name></expr></argument>,
											<argument><expr><name>collationObjectId</name></expr></argument>,
											<argument><expr><name>classObjectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate an OID for the index, unless we were told what to use.
	 *
	 * The OID will be the relfilenode as well, so make sure it doesn't
	 * collide with either pg_class OIDs or existing physical files.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use binary-upgrade override for pg_class.oid/relfilenode? */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>binary_upgrade_next_index_pg_class_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_class index OID value not set when in binary upgrade mode"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>indexRelationId</name> <operator>=</operator> <name>binary_upgrade_next_index_pg_class_oid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>binary_upgrade_next_index_pg_class_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>indexRelationId</name> <operator>=</operator>
				<call><name>GetNewRelFileNode</name><argument_list>(<argument><expr><name>tableSpaceId</name></expr></argument>, <argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * create the index relation's relcache entry and, if necessary, the
	 * physical disk file. (If we fail further down, it's the smgr's
	 * responsibility to remove the disk file again, if any.)
	 */</comment>
	<expr_stmt><expr><name>indexRelation</name> <operator>=</operator> <call><name>heap_create</name><argument_list>(<argument><expr><name>indexRelationName</name></expr></argument>,
								<argument><expr><name>namespaceId</name></expr></argument>,
								<argument><expr><name>tableSpaceId</name></expr></argument>,
								<argument><expr><name>indexRelationId</name></expr></argument>,
								<argument><expr><name>relFileNode</name></expr></argument>,
								<argument><expr><name>indexTupDesc</name></expr></argument>,
								<argument><expr><name>relkind</name></expr></argument>,
								<argument><expr><name>relpersistence</name></expr></argument>,
								<argument><expr><name>shared_relation</name></expr></argument>,
								<argument><expr><name>mapped_relation</name></expr></argument>,
								<argument><expr><name>allow_system_table_mods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexRelationId</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain exclusive lock on it.  Although no other transactions can see it
	 * until we commit, this prevents deadlock-risk complaints from lock
	 * manager in cases such as CLUSTER.
	 */</comment>
	<expr_stmt><expr><call><name>LockRelation</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill in fields of the index's pg_class entry that are not set correctly
	 * by heap_create.
	 *
	 * XXX should have a cleaner way to create cataloged indexes
	 */</comment>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name> <operator>=</operator> <name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>=</operator> <name>accessMethodObjectId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhasoids</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * store index's pg_class entry
	 */</comment>
	<expr_stmt><expr><call><name>InsertPgClassTuple</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>,
					   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
					   <argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* done with pg_class */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * now update the object id's of all the attribute tuple forms in the
	 * index relation's tuple descriptor
	 */</comment>
	<expr_stmt><expr><call><name>InitializeAttributeOids</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
							<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>,
							<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * append ATTRIBUTE tuples for the index
	 */</comment>
	<expr_stmt><expr><call><name>AppendAttributeTuples</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ----------------
	 *	  update pg_index
	 *	  (append INDEX tuple)
	 *
	 *	  Note that this stows away a representation of "predicate".
	 *	  (Or, could define a rule to maintain the predicate) --Nels, Feb '92
	 * ----------------
	 */</comment>
	<expr_stmt><expr><call><name>UpdateIndexRelation</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>heapRelationId</name></expr></argument>, <argument><expr><name>parentIndexRelid</name></expr></argument>,
						<argument><expr><name>indexInfo</name></expr></argument>,
						<argument><expr><name>collationObjectId</name></expr></argument>, <argument><expr><name>classObjectId</name></expr></argument>, <argument><expr><name>coloptions</name></expr></argument>,
						<argument><expr><name>isprimary</name></expr></argument>, <argument><expr><name>is_exclusion</name></expr></argument>,
						<argument><expr><operator>(</operator><name>constr_flags</name> <operator>&amp;</operator> <name>INDEX_CONSTR_CREATE_DEFERRABLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
						<argument><expr><operator>!</operator><name>concurrent</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>invalid</name></expr></argument>,
						<argument><expr><operator>!</operator><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Register relcache invalidation on the indexes' heap relation, to
	 * maintain consistency of its index list
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update pg_inherits, if needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexRelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>StoreSingleInheritance</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>parentIndexRelid</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Register constraint and dependencies for the index.
	 *
	 * If the index is from a CONSTRAINT clause, construct a pg_constraint
	 * entry.  The index will be linked to the constraint, which in turn is
	 * linked to the table.  If it's not a CONSTRAINT, we need to make a
	 * dependency directly on the table.
	 *
	 * We don't need a dependency on the namespace, because there'll be an
	 * indirect dependency via our parent table.
	 *
	 * During bootstrap we can't register any dependencies, and we don't try
	 * to make a constraint either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
					<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_ADD_CONSTRAINT</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name>constraintType</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>localaddr</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>isprimary</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_PRIMARY</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_UNIQUE</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>is_exclusion</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <name>CONSTRAINT_EXCLUSION</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"constraint must be PRIMARY, UNIQUE or EXCLUDE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>constraintType</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>localaddr</name> <operator>=</operator> <call><name>index_constraint_create</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
												<argument><expr><name>indexRelationId</name></expr></argument>,
												<argument><expr><name>parentConstraintId</name></expr></argument>,
												<argument><expr><name>indexInfo</name></expr></argument>,
												<argument><expr><name>indexRelationName</name></expr></argument>,
												<argument><expr><name>constraintType</name></expr></argument>,
												<argument><expr><name>constr_flags</name></expr></argument>,
												<argument><expr><name>allow_system_table_mods</name></expr></argument>,
												<argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>constraintId</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>constraintId</name> <operator>=</operator> <name><name>localaddr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>have_simple_col</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DependencyType</name></type> <name>deptype</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>deptype</name> <operator>=</operator> <ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexRelid</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr> </then><else>: <expr><name>DEPENDENCY_AUTO</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* Create auto dependencies on simply-referenced columns */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>heapRelationId</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>have_simple_col</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If there are no simply-referenced columns, give the index an
			 * auto dependency on the whole table.  In most cases, this will
			 * be redundant, but it might not be if the index expressions and
			 * predicate contain no Vars or only whole-row Vars.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_simple_col</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>heapRelationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* Store dependency on parent index, if any */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentIndexRelid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>parentIndexRelid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Store dependency on collations */</comment>
		<comment type="block">/* The default collation is pinned, so don't bother recording it */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>collationObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>collationObjectId</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>CollationRelationId</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>collationObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Store dependency on operator classes */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>classObjectId</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Store dependencies on anything mentioned in index expressions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>recordDependencyOnSingleRelExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>,
											<argument><expr><name>heapRelationId</name></expr></argument>,
											<argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>,
											<argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Store dependencies on anything mentioned in predicate */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>recordDependencyOnSingleRelExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>,
											<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>,
											<argument><expr><name>heapRelationId</name></expr></argument>,
											<argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>,
											<argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Bootstrap mode - assert we weren't asked for constraint support */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_ADD_CONSTRAINT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Post creation hook for new index */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
								  <argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advance the command counter so that we can see the newly-entered
	 * catalog tuples for the index.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In bootstrap mode, we have to fill in the index strategy structure with
	 * information from the catalogs.  If we aren't bootstrapping, then the
	 * relcache entry has already been rebuilt thanks to sinval update during
	 * CommandCounterIncrement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationInitIndexAccessInfo</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_indexcxt</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indnkeyatts</name></name> <operator>=</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is bootstrap (initdb) time, then we don't actually fill in the
	 * index yet.  We'll be creating more indexes and classes later, so we
	 * delay filling them in until just before we're done with bootstrapping.
	 * Similarly, if the caller specified to skip the build then filling the
	 * index is delayed till later (ALTER TABLE can save work in some cases
	 * with this).  Otherwise, we call the AM routine that constructs the
	 * index.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>index_register</name><argument_list>(<argument><expr><name>heapRelationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>INDEX_CREATE_SKIP_BUILD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Caller is responsible for filling the index later on.  However,
		 * we'd better make sure that the heap relation is correctly marked as
		 * having an index.
		 */</comment>
		<expr_stmt><expr><call><name>index_update_stats</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
						   <argument><expr><name>true</name></expr></argument>,
						   <argument><expr><operator>-</operator><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Make the above update visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>index_build</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>isprimary</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
					<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Close the index; but we keep the lock that we acquired above until end
	 * of transaction.  Closing the heap is caller's responsibility.
	 */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>indexRelationId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_constraint_create
 *
 * Set up a constraint associated with an index.  Return the new constraint's
 * address.
 *
 * heapRelation: table owning the index (must be suitably locked by caller)
 * indexRelationId: OID of the index
 * parentConstraintId: if constraint is on a partition, the OID of the
 *		constraint in the parent.
 * indexInfo: same info executor uses to insert into the index
 * constraintName: what it say (generally, should match name of index)
 * constraintType: one of CONSTRAINT_PRIMARY, CONSTRAINT_UNIQUE, or
 *		CONSTRAINT_EXCLUSION
 * flags: bitmask that can include any combination of these bits:
 *		INDEX_CONSTR_CREATE_MARK_AS_PRIMARY: index is a PRIMARY KEY
 *		INDEX_CONSTR_CREATE_DEFERRABLE: constraint is DEFERRABLE
 *		INDEX_CONSTR_CREATE_INIT_DEFERRED: constraint is INITIALLY DEFERRED
 *		INDEX_CONSTR_CREATE_UPDATE_INDEX: update the pg_index row
 *		INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS: remove existing dependencies
 *			of index on table's columns
 * allow_system_table_mods: allow table to be a system catalog
 * is_internal: index is constructed due to internal process
 */</comment>
<function><type><name>ObjectAddress</name></type>
<name>index_constraint_create</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>indexRelationId</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name></type> <name>parentConstraintId</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>constraintName</name></decl></parameter>,
						<parameter><decl><type><name>char</name></type> <name>constraintType</name></decl></parameter>,
						<parameter><decl><type><name>bits16</name></type> <name>constr_flags</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>allow_system_table_mods</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>conOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>deferrable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>initdeferred</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mark_as_primary</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>islocal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>noinherit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>inhcount</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>deferrable</name> <operator>=</operator> <operator>(</operator><name>constr_flags</name> <operator>&amp;</operator> <name>INDEX_CONSTR_CREATE_DEFERRABLE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>initdeferred</name> <operator>=</operator> <operator>(</operator><name>constr_flags</name> <operator>&amp;</operator> <name>INDEX_CONSTR_CREATE_INIT_DEFERRED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>mark_as_primary</name> <operator>=</operator> <operator>(</operator><name>constr_flags</name> <operator>&amp;</operator> <name>INDEX_CONSTR_CREATE_MARK_AS_PRIMARY</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* constraint creation support doesn't work while bootstrapping */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* enforce system-table restriction */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_system_table_mods</name> <operator>&amp;&amp;</operator>
		<call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"user-defined indexes on system catalog tables are not supported"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* primary/unique constraints shouldn't have any expressions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>&amp;&amp;</operator>
		<name>constraintType</name> <operator>!=</operator> <name>CONSTRAINT_EXCLUSION</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"constraints cannot have index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we're manufacturing a constraint for a pre-existing index, we need
	 * to get rid of the existing auto dependencies for the index (the ones
	 * that index_create() would have made instead of calling this function).
	 *
	 * Note: this code would not necessarily do the right thing if the index
	 * has any expressions or predicate, but we'd never be turning such an
	 * index into a UNIQUE or PRIMARY KEY constraint.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>constr_flags</name> <operator>&amp;</operator> <name>INDEX_CONSTR_CREATE_REMOVE_OLD_DEPS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>deleteDependencyRecordsForClass</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>,
										<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentConstraintId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>islocal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inhcount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>noinherit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>islocal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>inhcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>noinherit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Construct a pg_constraint entry.
	 */</comment>
	<expr_stmt><expr><name>conOid</name> <operator>=</operator> <call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name>constraintName</name></expr></argument>,
								   <argument><expr><name>namespaceId</name></expr></argument>,
								   <argument><expr><name>constraintType</name></expr></argument>,
								   <argument><expr><name>deferrable</name></expr></argument>,
								   <argument><expr><name>initdeferred</name></expr></argument>,
								   <argument><expr><name>true</name></expr></argument>,
								   <argument><expr><name>parentConstraintId</name></expr></argument>,
								   <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name></name></expr></argument>,
								   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr></argument>,
								   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no domain */</comment>
								   <argument><expr><name>indexRelationId</name></expr></argument>, <comment type="block">/* index OID */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no foreign key */</comment>
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>,
								   <argument><expr><literal type="char">' '</literal></expr></argument>,
								   <argument><expr><literal type="char">' '</literal></expr></argument>,
								   <argument><expr><literal type="char">' '</literal></expr></argument>,
								   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no check constraint */</comment>
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>NULL</name></expr></argument>,
								   <argument><expr><name>islocal</name></expr></argument>,
								   <argument><expr><name>inhcount</name></expr></argument>,
								   <argument><expr><name>noinherit</name></expr></argument>,
								   <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Register the index as internally dependent on the constraint.
	 *
	 * Note that the constraint has a dependency on the table, so we don't
	 * need (or want) any direct dependency from the index to the table.
	 */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>indexRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>ConstraintRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>conOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also, if this is a constraint on a partition, mark it as depending on
	 * the constraint in the parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentConstraintId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>parentConstr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ObjectAddressSet</name><argument_list>(<argument><expr><name>parentConstr</name></expr></argument>, <argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>parentConstraintId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parentConstr</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the constraint is deferrable, create the deferred uniqueness
	 * checking trigger.  (The trigger will be given an internal dependency on
	 * the constraint by CreateTrigger.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>deferrable</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CreateTrigStmt</name> <modifier>*</modifier></type><name>trigger</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>trigger</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CreateTrigStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>trigname</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>constraintType</name> <operator>==</operator> <name>CONSTRAINT_PRIMARY</name><operator>)</operator></expr> ?</condition><then>
			<expr><literal type="string">"PK_ConstraintTrigger"</literal></expr> </then><else>:
			<expr><literal type="string">"Unique_ConstraintTrigger"</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <call><name>SystemFuncName</name><argument_list>(<argument><expr><literal type="string">"unique_key_recheck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>row</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>timing</name></name> <operator>=</operator> <name>TRIGGER_TYPE_AFTER</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>events</name></name> <operator>=</operator> <name>TRIGGER_TYPE_INSERT</name> <operator>|</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>whenClause</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>isconstraint</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>deferrable</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>initdeferred</name></name> <operator>=</operator> <name>initdeferred</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>trigger</name><operator>-&gt;</operator><name>constrrel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>CreateTrigger</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>conOid</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If needed, mark the index as primary and/or deferred in pg_index.
	 *
	 * Note: When making an existing index into a constraint, caller must have
	 * a table lock that prevents concurrent table updates; otherwise, there
	 * is a risk that concurrent readers of the table will miss seeing this
	 * index at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>constr_flags</name> <operator>&amp;</operator> <name>INDEX_CONSTR_CREATE_UPDATE_INDEX</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>mark_as_primary</name> <operator>||</operator> <name>deferrable</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>mark_as_primary</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisprimary</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisprimary</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>deferrable</name> <operator>&amp;&amp;</operator> <name><name>indexForm</name><operator>-&gt;</operator><name>indimmediate</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indimmediate</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InvokeObjectPostAlterHookArg</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>indexRelationId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>referenced</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		index_drop
 *
 * NOTE: this routine should now only be called through performDeletion(),
 * else associated dependencies won't be cleaned up.
 */</comment>
<function><type><name>void</name></type>
<name>index_drop</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>concurrent</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>userHeapRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>userIndexRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hasexprs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LockRelId</name></type>	<name>heaprelid</name></decl>,
				<decl><type ref="prev"/><name>indexrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>heaplocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * A temporary relation uses a non-concurrent DROP.  Other backends can't
	 * access a temporary relation, so there's no harm in grabbing a stronger
	 * lock (see comments in RemoveRelations), and a non-concurrent DROP is
	 * more efficient.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>get_rel_persistence</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELPERSISTENCE_TEMP</name> <operator>||</operator>
		   <operator>!</operator><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To drop an index safely, we must grab exclusive lock on its parent
	 * table.  Exclusive lock on the index alone is insufficient because
	 * another backend might be about to execute a query on the parent table.
	 * If it relies on a previously cached list of index OIDs, then it could
	 * attempt to access the just-dropped index.  We must therefore take a
	 * table lock strong enough to prevent all queries on the table from
	 * proceeding until we commit and send out a shared-cache-inval notice
	 * that will make them update their index lists.
	 *
	 * In the concurrent case we avoid this requirement by disabling index use
	 * in multiple steps and waiting out any transactions that might be using
	 * the index, so we don't need exclusive lock on the parent table. Instead
	 * we take ShareUpdateExclusiveLock, to ensure that two sessions aren't
	 * doing CREATE/DROP INDEX CONCURRENTLY on the same index.  (We will get
	 * AccessExclusiveLock on the index below, once we're sure nobody else is
	 * using it.)
	 */</comment>
	<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <ternary><condition><expr><name>concurrent</name></expr> ?</condition><then> <expr><name>ShareUpdateExclusiveLock</name></expr> </then><else>: <expr><name>AccessExclusiveLock</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>userHeapRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>userIndexRelation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We might still have open queries using it in our own session, which the
	 * above locking won't prevent, so test explicitly.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Drop Index Concurrently is more or less the reverse process of Create
	 * Index Concurrently.
	 *
	 * First we unset indisvalid so queries starting afterwards don't use the
	 * index to answer queries anymore.  We have to keep indisready = true so
	 * transactions that are still scanning the index can continue to see
	 * valid index contents.  For instance, if they are using READ COMMITTED
	 * mode, and another transaction makes changes and commits, they need to
	 * see those new tuples in the index.
	 *
	 * After all transactions that could possibly have used the index for
	 * queries end, we can unset indisready and indislive, then wait till
	 * nobody could be touching it anymore.  (Note: we need indislive because
	 * this state must be distinct from the initial state during CREATE INDEX
	 * CONCURRENTLY, which has indislive true while indisready and indisvalid
	 * are false.  That's because in that state, transactions must examine the
	 * index for HOT-safety decisions, while in this state we don't want them
	 * to open it at all.)
	 *
	 * Since all predicate locks on the index are about to be made invalid, we
	 * must promote them to predicate locks on the heap.  In the
	 * non-concurrent case we can just do that now.  In the concurrent case
	 * it's a bit trickier.  The predicate locks must be moved when there are
	 * no index scans in progress on the index and no more can subsequently
	 * start, so that no new predicate locks can be made on the index.  Also,
	 * they must be moved before heap inserts stop maintaining the index, else
	 * the conflict with the predicate lock on the index gap could be missed
	 * before the lock on the heap relation is in place to detect a conflict
	 * based on the heap tuple insert.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>concurrent</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We must commit our transaction in order to make the first pg_index
		 * state update visible to other sessions.  If the DROP machinery has
		 * already performed any other actions (removal of other objects,
		 * pg_depend entries, etc), the commit would make those actions
		 * permanent, which would leave us with inconsistent catalog state if
		 * we fail partway through the following sequence.  Since DROP INDEX
		 * CONCURRENTLY is restricted to dropping just one index that has no
		 * dependencies, we should get here before anything's been done ---
		 * but let's check that to be sure.  We can verify that the current
		 * transaction has not executed any transactional updates by checking
		 * that no XID has been assigned.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DROP INDEX CONCURRENTLY must be first action in transaction"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Mark index invalid by updating its pg_index entry
		 */</comment>
		<expr_stmt><expr><call><name>index_set_state_flags</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>INDEX_DROP_CLEAR_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate the relcache for the table, so that after this commit
		 * all sessions will refresh any cached plans that might reference the
		 * index.
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>userHeapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* save lockrelid and locktag for below, then close but keep locks */</comment>
		<expr_stmt><expr><name>heaprelid</name> <operator>=</operator> <name><name>userHeapRelation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SET_LOCKTAG_RELATION</name><argument_list>(<argument><expr><name>heaplocktag</name></expr></argument>, <argument><expr><name><name>heaprelid</name><operator>.</operator><name>dbId</name></name></expr></argument>, <argument><expr><name><name>heaprelid</name><operator>.</operator><name>relId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>indexrelid</name> <operator>=</operator> <name><name>userIndexRelation</name><operator>-&gt;</operator><name>rd_lockInfo</name><operator>.</operator><name>lockRelId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>userHeapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We must commit our current transaction so that the indisvalid
		 * update becomes visible to other transactions; then start another.
		 * Note that any previously-built data structures are lost in the
		 * commit.  The only data we keep past here are the relation IDs.
		 *
		 * Before committing, get a session-level lock on the table, to ensure
		 * that neither it nor the index can be dropped before we finish. This
		 * cannot block, even if someone else is waiting for access, because
		 * we already have the same lock within our transaction.
		 */</comment>
		<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heaprelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexrelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PopActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we must wait until no running transaction could be using the
		 * index for a query.  Use AccessExclusiveLock here to check for
		 * running transactions that hold locks of any kind on the table. Note
		 * we do not need to worry about xacts that open the table for reading
		 * after this point; they will see the index as invalid when they open
		 * the relation.
		 *
		 * Note: the reason we use actual lock acquisition here, rather than
		 * just checking the ProcArray and sleeping, is that deadlock is
		 * possible if one of the transactions in question is blocked trying
		 * to acquire an exclusive lock on our table.  The lock code will
		 * detect deadlock and error out properly.
		 */</comment>
		<expr_stmt><expr><call><name>WaitForLockers</name><argument_list>(<argument><expr><name>heaplocktag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * No more predicate locks will be acquired on this index, and we're
		 * about to stop doing inserts into the index which could show
		 * conflicts with existing predicate locks, so now is the time to move
		 * them to the heap relation.
		 */</comment>
		<expr_stmt><expr><name>userHeapRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>userIndexRelation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we are sure that nobody uses the index for queries; they just
		 * might have it open for updating it.  So now we can unset indisready
		 * and indislive, then wait till nobody could be using it at all
		 * anymore.
		 */</comment>
		<expr_stmt><expr><call><name>index_set_state_flags</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>INDEX_DROP_SET_DEAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Invalidate the relcache for the table, so that after this commit
		 * all sessions will refresh the table's index list.  Forgetting just
		 * the index's relcache entry is not enough.
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>userHeapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close the relations again, though still holding session lock.
		 */</comment>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>userHeapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Again, commit the transaction to make the pg_index update visible
		 * to other sessions.
		 */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Wait till every transaction that saw the old index state has
		 * finished.
		 */</comment>
		<expr_stmt><expr><call><name>WaitForLockers</name><argument_list>(<argument><expr><name>heaplocktag</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Re-open relations to allow us to complete our actions.
		 *
		 * At this point, nothing should be accessing the index, but lets
		 * leave nothing to chance and grab AccessExclusiveLock on the index
		 * before the physical deletion.
		 */</comment>
		<expr_stmt><expr><name>userHeapRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>userIndexRelation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not concurrent, so just transfer predicate locks and we're good */</comment>
		<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Schedule physical removal of the files (if any)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>userIndexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Close and flush the index's relcache entry, to ensure relcache doesn't
	 * try to rebuild it while we're deleting catalog entries. We keep the
	 * lock though.
	 */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>userIndexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RelationForgetRelation</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fix INDEX relation, and check for expressional index
	 */</comment>
	<expr_stmt><expr><name>indexRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hasexprs</name> <operator>=</operator> <operator>!</operator><call><name>heap_attisnull</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_index_indexprs</name></expr></argument>,
							   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if it has any expression columns, we might have stored statistics about
	 * them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hasexprs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveStatistics</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * fix ATTRIBUTE relation
	 */</comment>
	<expr_stmt><expr><call><name>DeleteAttributeTuples</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fix RELATION relation
	 */</comment>
	<expr_stmt><expr><call><name>DeleteRelationTuple</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fix INHERITS relation
	 */</comment>
	<expr_stmt><expr><call><name>DeleteInheritsTuple</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We are presently too lazy to attempt to compute the new correct value
	 * of relhasindex (the next VACUUM will fix it if necessary). So there is
	 * no need to update the pg_class tuple for the owning relation. But we
	 * must send out a shared-cache-inval notice on the owning relation to
	 * ensure other backends update their relcache lists of indexes.  (In the
	 * concurrent case, this is redundant but harmless.)
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>userHeapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Close owning rel, but keep lock
	 */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>userHeapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Release the session locks before we go.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>concurrent</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>heaprelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockRelationIdForSession</name><argument_list>(<argument><expr><operator>&amp;</operator><name>indexrelid</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *						index_build support
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* ----------------
 *		BuildIndexInfo
 *			Construct an IndexInfo record for an open index
 *
 * IndexInfo stores the information about the index that's needed by
 * FormIndexDatum, which is used for both index_build() and later insertion
 * of individual index tuples.  Normally we build an IndexInfo for an index
 * just once per command, and then use it for (potentially) many tuples.
 * ----------------
 */</comment>
<function><type><name>IndexInfo</name> <modifier>*</modifier></type>
<name>BuildIndexInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>ii</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAtts</name></decl>;</decl_stmt>

	<comment type="block">/* check the number of keys, and copy attr numbers into the IndexInfo */</comment>
	<expr_stmt><expr><name>numAtts</name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>numAtts</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>numAtts</name></expr></argument> &gt;</argument_list></name> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid indnatts %d for index %u"</literal></expr></argument>,
			 <argument><expr><name>numAtts</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>=</operator> <name>numAtts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>&lt;=</operator> <name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAtts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* fetch any expressions needed for expressional indexes */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator> <call><name>RelationGetIndexExpressions</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* fetch index predicate if any */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>=</operator> <call><name>RelationGetIndexPredicate</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* fetch exclusion constraint info if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexStruct</name><operator>-&gt;</operator><name>indisexclusion</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationGetExclusionInfo</name><argument_list>(<argument><expr><name>index</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* other info */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name> <operator>=</operator> <call><name>IndexIsReady</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* assume not doing speculative insertion for now */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* initialize index-build state to default */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* set up for possible use by index AM */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Am</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>ii</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		BuildDummyIndexInfo
 *			Construct a dummy IndexInfo record for an open index
 *
 * This differs from the real BuildIndexInfo in that it will never run any
 * user-defined code that might exist in index expressions or predicates.
 * Instead of the real index expressions, we return null constants that have
 * the right types/typmods/collations.  Predicates and exclusion clauses are
 * just ignored.  This is sufficient for the purpose of truncating an index,
 * since we will not need to actually evaluate the expressions or predicates;
 * the only thing that's likely to be done with the data is construction of
 * a tupdesc describing the index's rowtype.
 * ----------------
 */</comment>
<function><type><name>IndexInfo</name> <modifier>*</modifier></type>
<name>BuildDummyIndexInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>ii</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexStruct</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rd_index</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numAtts</name></decl>;</decl_stmt>

	<comment type="block">/* check the number of keys, and copy attr numbers into the IndexInfo */</comment>
	<expr_stmt><expr><name>numAtts</name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnatts</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>numAtts</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>numAtts</name></expr></argument> &gt;</argument_list></name> <name>INDEX_MAX_KEYS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid indnatts %d for index %u"</literal></expr></argument>,
			 <argument><expr><name>numAtts</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>=</operator> <name>numAtts</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indnkeyatts</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>&lt;=</operator> <name><name>ii</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numAtts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* fetch dummy expressions for expressional indexes */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator> <call><name>RelationGetDummyIndexExpressions</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* pretend there is no predicate */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* We ignore the exclusion constraint if any */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* other info */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>=</operator> <name><name>indexStruct</name><operator>-&gt;</operator><name>indisunique</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name> <operator>=</operator> <call><name>IndexIsReady</name><argument_list>(<argument><expr><name>indexStruct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* assume not doing speculative insertion for now */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* initialize index-build state to default */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* set up for possible use by index AM */</comment>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Am</name></name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>ii</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CompareIndexInfo
 *		Return whether the properties of two indexes (in different tables)
 *		indicate that they have the "same" definitions.
 *
 * Note: passing collations and opfamilies separately is a kludge.  Adding
 * them to IndexInfo may result in better coding here and elsewhere.
 *
 * Use convert_tuples_by_name_map(index2, index1) to build the attmap.
 */</comment>
<function><type><name>bool</name></type>
<name>CompareIndexInfo</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>info1</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>info2</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations1</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collations2</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opfamilies1</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opfamilies2</name></decl></parameter>,
				 <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>attmap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maplen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>!=</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* indexes are only equivalent if they have the same access method */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_Am</name></name> <operator>!=</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_Am</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* and same number of attributes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>!=</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* and same number of key attributes */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>!=</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * and columns match through the attribute map (actual attribute numbers
	 * might differ!)  Note that this implies that index columns that are
	 * expressions appear in the same positions.  We will next compare the
	 * expressions themselves.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>info1</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>maplen</name> <operator>&lt;</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incorrect attribute map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* ignore expressions at this stage */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>info1</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>InvalidAttrNumber</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>attmap</name><index>[<expr><name><name>info2</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator>
			 <name><name>info1</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* collation and opfamily is not valid for including columns */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>info1</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>collations1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>collations2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>opfamilies1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>opfamilies2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * For expression indexes: either both are expression indexes, or neither
	 * is; if they are, make sure the expressions match.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>info1</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>info2</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>mapped</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mapped</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>,
									 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>maplen</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we could throw an error here, but seems out of scope for this
			 * routine.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>info1</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>, <argument><expr><name>mapped</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Partial index predicates must be identical, if they exist */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>info1</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name><name>info2</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_whole_row</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>mapped</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>mapped</name> <operator>=</operator> <call><name>map_variable_attnos</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>,
									 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>attmap</name></expr></argument>, <argument><expr><name>maplen</name></expr></argument>,
									 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found_whole_row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found_whole_row</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * we could throw an error here, but seems out of scope for this
			 * routine.
			 */</comment>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name><name>info1</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>mapped</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* No support currently for comparing exclusion indexes. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>info1</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>info2</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		BuildSpeculativeIndexInfo
 *			Add extra state to IndexInfo record
 *
 * For unique indexes, we usually don't want to add info to the IndexInfo for
 * checking uniqueness, since the B-Tree AM handles that directly.  However,
 * in the case of speculative insertion, additional support is required.
 *
 * Do this processing here rather than in BuildIndexInfo() to not incur the
 * overhead in the common non-speculative cases.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>BuildSpeculativeIndexInfo</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>ii</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * fetch info for checking unique indexes
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected non-btree speculative unique index"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueOps</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueProcs</name></name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueStrats</name></name> <operator>=</operator> <operator>(</operator><name>uint16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>indnkeyatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We have to look up the operator's strategy number.  This provides a
	 * cross-check that the operator does match the index.
	 */</comment>
	<comment type="block">/* We need the func OIDs and strategy numbers too */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indnkeyatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueStrats</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueOps</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator>
			<call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueStrats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueOps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueStrats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
				 <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_opcintype</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rd_opfamily</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueProcs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name><name>ii</name><operator>-&gt;</operator><name>ii_UniqueOps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* ----------------
 *		FormIndexDatum
 *			Construct values[] and isnull[] arrays for a new index tuple.
 *
 *	indexInfo		Info about the index
 *	slot			Heap tuple for which we must prepare an index entry
 *	estate			executor state for evaluating any index expressions
 *	values			Array of index Datums (output area)
 *	isnull			Array of is-null indicators (output area)
 *
 * When there are no index expressions, estate may be NULL.  Otherwise it
 * must be supplied, *and* the ecxt_scantuple slot of its per-tuple expr
 * context must point to the heap tuple passed in.
 *
 * Notice we don't actually call index_form_tuple() here; we just prepare
 * its input arrays values[] and isnull[].  This is because the index AM
 * may wish to alter the data before storage.
 * ----------------
 */</comment>
<function><type><name>void</name></type>
<name>FormIndexDatum</name><parameter_list>(<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
			   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
			   <parameter><decl><type><name>EState</name> <modifier>*</modifier></type><name>estate</name></decl></parameter>,
			   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
		<name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through, set up expression evaluation state */</comment>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator>
			<call><name>ExecPrepareExprList</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Check caller has set up context correctly */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ecxt_scantuple</name> <operator>==</operator> <name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>keycol</name> <init>= <expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>iDatum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>keycol</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Plain index column; get the value we need directly from the
			 * heap tuple.
			 */</comment>
			<expr_stmt><expr><name>iDatum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>keycol</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Index expression --- need to evaluate it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>iDatum</name> <operator>=</operator> <call><name>ExecEvalExprSwitchContext</name><argument_list>(<argument><expr><operator>(</operator><name>ExprState</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>iDatum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>isnull</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>isNull</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong number of index expressions"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * index_update_stats --- update pg_class entry after CREATE INDEX or REINDEX
 *
 * This routine updates the pg_class row of either an index or its parent
 * relation after CREATE INDEX or REINDEX.  Its rather bizarre API is designed
 * to ensure we can do all the necessary work in just one update.
 *
 * hasindex: set relhasindex to this value
 * reltuples: if &gt;= 0, set reltuples to this value; else no change
 *
 * If reltuples &gt;= 0, relpages and relallvisible are also updated (using
 * RelationGetNumberOfBlocks() and visibilitymap_count()).
 *
 * NOTE: an important side-effect of this operation is that an SI invalidation
 * message is sent out to all backends --- including me --- causing relcache
 * entries to be flushed or updated with the new data.  This must happen even
 * if we find that no change is needed in the pg_class row.  When updating
 * a heap entry, this ensures that other backends find out about the new
 * index.  When updating an index, it's important because some index AMs
 * expect a relcache flush to occur after REINDEX.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>index_update_stats</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>hasindex</name></decl></parameter>,
				   <parameter><decl><type><name>double</name></type> <name>reltuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We always update the pg_class row using a non-transactional,
	 * overwrite-in-place update.  There are several reasons for this:
	 *
	 * 1. In bootstrap mode, we have no choice --- UPDATE wouldn't work.
	 *
	 * 2. We could be reindexing pg_class itself, in which case we can't move
	 * its pg_class row because CatalogTupleInsert/CatalogTupleUpdate might
	 * not know about all the indexes yet (see reindex_relation).
	 *
	 * 3. Because we execute CREATE INDEX with just share lock on the parent
	 * rel (to allow concurrent index creations), an ordinary update could
	 * suffer a tuple-concurrently-updated failure against another CREATE
	 * INDEX committing at about the same time.  We can avoid that by having
	 * them both do nontransactional updates (we assume they will both be
	 * trying to change the pg_class row to the same thing, so it doesn't
	 * matter which goes first).
	 *
	 * It is safe to use a non-transactional update even though our
	 * transaction could still fail before committing.  Setting relhasindex
	 * true is safe even if there are no indexes (VACUUM will eventually fix
	 * it).  And of course the new relpages and reltuples counts are correct
	 * regardless.  However, we don't want to change relpages (or
	 * relallvisible) if the caller isn't providing an updated reltuples
	 * count, because that would bollix the reltuples/relpages ratio which is
	 * what's really important.
	 */</comment>

	<expr_stmt><expr><name>pg_class</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a copy of the tuple to update.  Normally we use the syscache, but
	 * we can't rely on that during bootstrap or while reindexing pg_class
	 * itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call> <operator>||</operator>
		<call><name>ReindexIsProcessingHeap</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* don't assume syscache will work */</comment>
		<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>pg_class_scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>ObjectIdAttributeNumber</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pg_class_scan</name> <operator>=</operator> <call><name>heap_beginscan_catalog</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>pg_class_scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>pg_class_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* normal case, use syscache */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>rd_rel</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Should this be a more comprehensive test? */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Apply required updates, if any, to copied tuple */</comment>

	<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>!=</operator> <name>hasindex</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name> <operator>=</operator> <name>hasindex</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>reltuples</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relpages</name> <init>= <expr><call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BlockNumber</name></type> <name>relallvisible</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>visibilitymap_count</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relallvisible</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>					<comment type="block">/* don't bother for indexes */</comment>
			<expr_stmt><expr><name>relallvisible</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>relpages</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>relpages</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>!=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>reltuples</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>reltuples</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>!=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>relallvisible</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>relallvisible</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If anything changed, write out the tuple
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>dirty</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* the above sends a cache inval message */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no need to change tuple, but force relcache inval anyway */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_class</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * index_build - invoke access-method-specific index build procedure
 *
 * On entry, the index's catalog entries are valid, and its physical disk
 * file has been created but is empty.  We call the AM-specific build
 * procedure to fill in the index contents.  We then update the pg_class
 * entries of the index and heap relation as needed, using statistics
 * returned by ambuild as well as data passed by the caller.
 *
 * isprimary tells whether to mark the index as a primary-key index.
 * isreindex indicates we are recreating a previously-existing index.
 * parallel indicates if parallelism may be useful.
 *
 * Note: when reindexing an existing index, isprimary can be false even if
 * the index is a PK; it's already properly marked and need not be re-marked.
 *
 * Note: before Postgres 8.2, the passed-in heap and index Relations
 * were automatically closed by this routine.  This is no longer the case.
 * The caller opened 'em, and the caller should close 'em.
 */</comment>
<function><type><name>void</name></type>
<name>index_build</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
			<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
			<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>isprimary</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>isreindex</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>parallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexBuildResult</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>RelationIsValid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ambuild</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine worker process details for parallel CREATE INDEX.  Currently,
	 * only btree has support for parallel builds.
	 *
	 * Note that planner considers parallel safety for us.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parallel</name> <operator>&amp;&amp;</operator> <call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name> <operator>==</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>=</operator>
			<call><name>plan_create_index_workers</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"building index \"%s\" on table \"%s\" serially"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"building index \"%s\" on table \"%s\" with request for %d parallel worker"</literal></expr></argument>,
							   <argument><expr><literal type="string">"building index \"%s\" on table \"%s\" with request for %d parallel workers"</literal></expr></argument>,
							   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call the access method's build procedure
	 */</comment>
	<expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ambuild</name></name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>,
												 <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>stats</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this is an unlogged index, we may need to write out an init fork for
	 * it -- but we must first check whether one already exists.  If, for
	 * example, an unlogged relation is truncated in the transaction that
	 * created it, or truncated twice in a subsequent transaction, the
	 * relfilenode won't change, and nothing needs to be done here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_UNLOGGED</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>smgrexists</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>smgrcreate</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_smgr</name></name></expr></argument>, <argument><expr><name>INIT_FORKNUM</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_amroutine</name><operator>-&gt;</operator><name>ambuildempty</name></name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we found any potentially broken HOT chains, mark the index as not
	 * being usable until the current transaction is below the event horizon.
	 * See src/backend/access/heap/README.HOT for discussion.  Also set this
	 * if early pruning/vacuuming is enabled for the heap relation.  While it
	 * might become safe to use the index earlier based on actual cleanup
	 * activity and other active transactions, the test for that would be much
	 * more complex and would require some form of blocking, so keep it simple
	 * and fast by just using the current transaction.
	 *
	 * However, when reindexing an existing index, we should do nothing here.
	 * Any HOT chains that are broken with respect to the index must predate
	 * the index's original creation, so there is no need to change the
	 * index's usability horizon.  Moreover, we *must not* try to change the
	 * index's pg_index entry while reindexing pg_index itself, and this
	 * optimization nicely prevents that.  The more complex rules needed for a
	 * reindex are handled separately after this function returns.
	 *
	 * We also need not set indcheckxmin during a concurrent index build,
	 * because we won't set indisvalid true until all transactions that care
	 * about the broken HOT chains or early pruning/vacuuming are gone.
	 *
	 * Therefore, this code path can only be taken during non-concurrent
	 * CREATE INDEX.  Thus the fact that heap_update will set the pg_index
	 * tuple's xmin doesn't matter, because that tuple was created in the
	 * current transaction anyway.  That also means we don't need to worry
	 * about any concurrent readers of the tuple; no other transaction can see
	 * it yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>||</operator> <call><name>EarlyPruningEnabled</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>isreindex</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexId</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If it's a new index, indcheckxmin shouldn't be set ... */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update heap and index pg_class rows
	 */</comment>
	<expr_stmt><expr><call><name>index_update_stats</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
					   <argument><expr><name>true</name></expr></argument>,
					   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>heap_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_update_stats</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
					   <argument><expr><name>false</name></expr></argument>,
					   <argument><expr><name><name>stats</name><operator>-&gt;</operator><name>index_tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make the updated catalog row versions visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's for an exclusion constraint, make a second pass over the heap
	 * to verify that the constraint is satisfied.  We must not do this until
	 * the index is fully valid.  (Broken HOT chains shouldn't matter, though;
	 * see comments for IndexCheckExclusion.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>IndexCheckExclusion</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IndexBuildHeapScan - scan the heap relation to find tuples to be indexed
 *
 * This is called back from an access-method-specific index build procedure
 * after the AM has done whatever setup it needs.  The parent heap relation
 * is scanned to find tuples that should be entered into the index.  Each
 * such tuple is passed to the AM's callback routine, which does the right
 * things to add it to the new index.  After we return, the AM's index
 * build procedure does whatever cleanup it needs.
 *
 * The total count of live heap tuples is returned.  This is for updating
 * pg_class statistics.  (It's annoying not to be able to do that here, but we
 * want to merge that update with others; see index_update_stats.)  Note that
 * the index AM itself must keep track of the number of index tuples; we don't
 * do so here because the AM might reject some of the tuples for its own
 * reasons, such as being unable to store NULLs.
 *
 * A side effect is to set indexInfo-&gt;ii_BrokenHotChain to true if we detect
 * any potentially broken HOT chains.  Currently, we set this if there are
 * any RECENTLY_DEAD or DELETE_IN_PROGRESS entries in a HOT chain, without
 * trying very hard to detect whether they're really incompatible with the
 * chain tip.
 */</comment>
<function><type><name>double</name></type>
<name>IndexBuildHeapScan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
				   <parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>,
				   <parameter><decl><type><name>IndexBuildCallback</name></type> <name>callback</name></decl></parameter>,
				   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>,
				   <parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IndexBuildHeapRangeScan</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>indexRelation</name></expr></argument>,
								   <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>allow_sync</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>InvalidBlockNumber</name></expr></argument>,
								   <argument><expr><name>callback</name></expr></argument>, <argument><expr><name>callback_state</name></expr></argument>, <argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * As above, except that instead of scanning the complete heap, only the given
 * number of blocks are scanned.  Scan to end-of-rel can be signalled by
 * passing InvalidBlockNumber as numblocks.  Note that restricting the range
 * to scan cannot be done when requesting syncscan.
 *
 * When "anyvisible" mode is requested, all tuples visible to any transaction
 * are indexed and counted as live, including those inserted or deleted by
 * transactions that are still in progress.
 */</comment>
<function><type><name>double</name></type>
<name>IndexBuildHeapRangeScan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>allow_sync</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>anyvisible</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>start_blockno</name></decl></parameter>,
						<parameter><decl><type><name>BlockNumber</name></type> <name>numblocks</name></decl></parameter>,
						<parameter><decl><type><name>IndexBuildCallback</name></type> <name>callback</name></decl></parameter>,
						<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_state</name></decl></parameter>,
						<parameter><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_system_catalog</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>checking_uniqueness</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>reltuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>need_unregister_snapshot</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>OldestXmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>root_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>root_offsets</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remember if it's a system catalog */</comment>
	<expr_stmt><expr><name>is_system_catalog</name> <operator>=</operator> <call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* See whether we're verifying uniqueness/exclusion properties */</comment>
	<expr_stmt><expr><name>checking_uniqueness</name> <operator>=</operator> <operator>(</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>||</operator>
						   <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * "Any visible" mode is not compatible with uniqueness checks; make sure
	 * only one of those is requested.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>anyvisible</name> <operator>&amp;&amp;</operator> <name>checking_uniqueness</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for scan of the base relation.  In a normal index build, we use
	 * SnapshotAny because we must retrieve all tuples and do our own time
	 * qual checks (because we have to index RECENTLY_DEAD tuples). In a
	 * concurrent build, or during bootstrap, we take a regular MVCC snapshot
	 * and index whatever's live according to that.
	 */</comment>
	<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>

	<comment type="block">/* okay to ignore lazy VACUUMs here */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>OldestXmin</name> <operator>=</operator> <call><name>GetOldestXmin</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>PROCARRAY_FLAGS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>scan</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Serial index build.
		 *
		 * Must begin our own heap scan in this case.  We may also need to
		 * register a snapshot whose lifetime is under our direct control.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>need_unregister_snapshot</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name>SnapshotAny</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
									<argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
									<argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* number of keys */</comment>
									<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
									<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
									<argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* syncscan OK? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Parallel index build.
		 *
		 * Parallel case never registers/unregisters own snapshot.  Snapshot
		 * is taken from parallel heap scan, and is SnapshotAny or an MVCC
		 * snapshot, based on same criteria as serial case.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>allow_sync</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_snapshot</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Must call GetOldestXmin() with SnapshotAny.  Should never call
	 * GetOldestXmin() with MVCC snapshot. (It's especially worth checking
	 * this for parallel builds, since ambuild routines that support parallel
	 * builds must work these details out for themselves.)
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name> <operator>||</operator> <call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><ternary><condition><expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name></expr> ?</condition><then> <expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr> </then><else>:
		   <expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>OldestXmin</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name> <operator>||</operator> <operator>!</operator><name>anyvisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set our scan endpoints */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_sync</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_setscanlimits</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>start_blockno</name></expr></argument>, <argument><expr><name>numblocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* syncscan can only be requested on whole relation */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>start_blockno</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numblocks</name> <operator>==</operator> <name>InvalidBlockNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan all tuples in the base relation.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>heapTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tupleIsAlive</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When dealing with a HOT-chain of updated tuples, we want to index
		 * the values of the live tuple (if any), but index it under the TID
		 * of the chain's root tuple.  This approach is necessary to preserve
		 * the HOT-chain structure in the heap. So we need to be able to find
		 * the root item offset for every tuple that's in a HOT-chain.  When
		 * first reaching a new page of the relation, call
		 * heap_get_root_tuples() to build a map of root item offsets on the
		 * page.
		 *
		 * It might look unsafe to use this information across buffer
		 * lock/unlock.  However, we hold ShareLock on the table so no
		 * ordinary insert/update/delete should occur; and we hold pin on the
		 * buffer continuously while visiting the page, so no pruning
		 * operation can occur either.
		 *
		 * Also, although our opinions about tuple liveness could change while
		 * we scan the page (due to concurrent transaction commits/aborts),
		 * the chain root locations won't, so this info doesn't need to be
		 * rebuilt after waiting for another transaction.
		 *
		 * Note the implied assumption that there is no more than one live
		 * tuple per HOT-chain --- else we could create more than one index
		 * entry pointing to the same root tuple.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>!=</operator> <name>root_blkno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_get_root_tuples</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>root_blkno</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>snapshot</name> <operator>==</operator> <name>SnapshotAny</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* do our own time qual check */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>indexIt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TransactionId</name></type> <name>xwait</name></decl>;</decl_stmt>

	<label><name>recheck</name>:</label>

			<comment type="block">/*
			 * We could possibly get away with not locking the buffer here,
			 * since caller should hold ShareLock on the relation, but let's
			 * be conservative about it.  (This remark is still correct even
			 * with HOT-pruning: our pin on the buffer prevents pruning.)
			 */</comment>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The criteria for counting a tuple as live in this block need to
			 * match what analyze.c's acquire_sample_rows() does, otherwise
			 * CREATE INDEX and ANALYZE may produce wildly different reltuples
			 * values, e.g. when there are many recently-dead tuples.
			 */</comment>
			<switch>switch <condition>(<expr><call><name>HeapTupleSatisfiesVacuum</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>OldestXmin</name></expr></argument>,
											 <argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HEAPTUPLE_DEAD</name></expr>:</case>
					<comment type="block">/* Definitely dead, we can ignore it */</comment>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_LIVE</name></expr>:</case>
					<comment type="block">/* Normal case, index and unique-check it */</comment>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* Count it as live, too */</comment>
					<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_RECENTLY_DEAD</name></expr>:</case>

					<comment type="block">/*
					 * If tuple is recently deleted then we must index it
					 * anyway to preserve MVCC semantics.  (Pre-existing
					 * transactions could try to use the index after we finish
					 * building it, and may need to see such tuples.)
					 *
					 * However, if it was HOT-updated then we must only index
					 * the live tuple at the end of the HOT-chain.  Since this
					 * breaks semantics for pre-existing snapshots, mark the
					 * index as unusable for them.
					 *
					 * We don't count recently-dead tuples in reltuples, even
					 * if we index them; see acquire_sample_rows().
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<comment type="block">/* mark the index as unsafe for old snapshots */</comment>
						<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<comment type="block">/* In any case, exclude the tuple from unique-checking */</comment>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_INSERT_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * In "anyvisible" mode, this tuple is visible and we
					 * don't need any further checks.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>anyvisible</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * Since caller should hold ShareLock or better, normally
					 * the only way to see this is if it was inserted earlier
					 * in our own transaction.  However, it can happen in
					 * system catalogs, since we tend to release write lock
					 * before commit there.  Give a warning if neither case
					 * applies.
					 */</comment>
					<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"concurrent insert in progress within table \"%s\""</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If we are performing uniqueness checks, indexing
						 * such a tuple could lead to a bogus uniqueness
						 * failure.  In that case we wait for the inserting
						 * transaction to finish and check again.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>checking_uniqueness</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Must drop the lock on the buffer before we wait
							 */</comment>
							<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>heapRelation</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
											  <argument><expr><name>XLTW_InsertIndexUnique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>recheck</name>;</goto>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * For consistency with acquire_sample_rows(), count
						 * HEAPTUPLE_INSERT_IN_PROGRESS tuples as live only
						 * when inserted by our own transaction.
						 */</comment>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<comment type="block">/*
					 * We must index such tuples, since if the index build
					 * commits then they're good.
					 */</comment>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAPTUPLE_DELETE_IN_PROGRESS</name></expr>:</case>

					<comment type="block">/*
					 * As with INSERT_IN_PROGRESS case, this is unexpected
					 * unless it's our own deletion or a system catalog; but
					 * in anyvisible mode, this tuple is visible.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>anyvisible</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>xwait</name> <operator>=</operator> <call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name><name>heapTuple</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_system_catalog</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"concurrent delete in progress within table \"%s\""</literal></expr></argument>,
								 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * If we are performing uniqueness checks, assuming
						 * the tuple is dead could lead to missing a
						 * uniqueness violation.  In that case we wait for the
						 * deleting transaction to finish and check again.
						 *
						 * Also, if it's a HOT-updated tuple, we should not
						 * index it but rather the live tuple at the end of
						 * the HOT-chain.  However, the deleting transaction
						 * could abort, possibly leaving this tuple as live
						 * after all, in which case it has to be indexed. The
						 * only way to know what to do is to wait for the
						 * deleting transaction to finish and check again.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>checking_uniqueness</name> <operator>||</operator>
							<call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Must drop the lock on the buffer before we wait
							 */</comment>
							<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>XactLockTableWait</name><argument_list>(<argument><expr><name>xwait</name></expr></argument>, <argument><expr><name>heapRelation</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>,
											  <argument><expr><name>XLTW_InsertIndexUnique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
							<goto>goto <name>recheck</name>;</goto>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Otherwise index it but don't check for uniqueness,
						 * the same as a RECENTLY_DEAD tuple.
						 */</comment>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

						<comment type="block">/*
						 * Count HEAPTUPLE_DELETE_IN_PROGRESS tuples as live,
						 * if they were not deleted by the current
						 * transaction.  That's what acquire_sample_rows()
						 * does, and we want the behavior to be consistent.
						 */</comment>
						<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>HeapTupleIsHotUpdated</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * It's a HOT-updated tuple deleted by our own xact.
						 * We can assume the deletion will commit (else the
						 * index contents don't matter), so treat the same as
						 * RECENTLY_DEAD HOT-updated tuples.
						 */</comment>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<comment type="block">/* mark the index as unsafe for old snapshots */</comment>
						<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/*
						 * It's a regular tuple deleted by our own xact. Index
						 * it, but don't check for uniqueness nor count in
						 * reltuples, the same as a RECENTLY_DEAD tuple.
						 */</comment>
						<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<comment type="block">/* In any case, exclude the tuple from unique-checking */</comment>
					<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected HeapTupleSatisfiesVacuum result"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>indexIt</name> <operator>=</operator> <name>tupleIsAlive</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>indexIt</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* heap_getnext did the time qual check */</comment>
			<expr_stmt><expr><name>tupleIsAlive</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>reltuples</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up for predicate or expression evaluation */</comment>
		<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In a partial index, discard tuples that don't satisfy the
		 * predicate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For the current heap tuple, extract all the attributes we use in
		 * this index, and note which are null.  This also performs evaluation
		 * of any expressions needed.
		 */</comment>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
					   <argument><expr><name>slot</name></expr></argument>,
					   <argument><expr><name>estate</name></expr></argument>,
					   <argument><expr><name>values</name></expr></argument>,
					   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * You'd think we should go ahead and build the index tuple here, but
		 * some index AMs want to do further processing on the data first.  So
		 * pass the values[] and isnull[] arrays, instead.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For a heap-only tuple, pretend its TID is that of the root. See
			 * src/backend/access/heap/README.HOT for discussion.
			 */</comment>
			<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>rootTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rootTuple</name> <operator>=</operator> <operator>*</operator><name>heapTuple</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name><name>root_offsets</name><index>[<expr><name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</literal></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>offnum</name></expr></argument>,
										 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rootTuple</name><operator>.</operator><name>t_self</name></name></expr></argument>,
									   <argument><expr><name><name>root_offsets</name><index>[<expr><name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Call the AM's callback routine to process the tuple */</comment>
			<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>tupleIsAlive</name></expr></argument>,
					 <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Call the AM's callback routine to process the tuple */</comment>
			<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>tupleIsAlive</name></expr></argument>,
					 <argument><expr><name>callback_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we can now forget our snapshot, if set and registered by us */</comment>
	<if_stmt><if>if <condition>(<expr><name>need_unregister_snapshot</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>reltuples</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * IndexCheckExclusion - verify that a new exclusion constraint is satisfied
 *
 * When creating an exclusion constraint, we first build the index normally
 * and then rescan the heap to check for conflicts.  We assume that we only
 * need to validate tuples that are live according to an up-to-date snapshot,
 * and that these were correctly indexed even in the presence of broken HOT
 * chains.  This should be OK since we are holding at least ShareLock on the
 * table, meaning there can be no uncommitted updates from other transactions.
 * (Note: that wouldn't necessarily work for system catalogs, since many
 * operations release write lock early on the system catalogs.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IndexCheckExclusion</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
					<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>snapshot</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we are reindexing the target index, mark it as no longer being
	 * reindexed, to forestall an Assert in index_beginscan when we try to use
	 * the index for probes.  This is OK because the index is now fully valid.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ReindexIsCurrentlyProcessingIndex</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetReindexProcessing</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan all live tuples in the base relation.
	 */</comment>
	<expr_stmt><expr><name>snapshot</name> <operator>=</operator> <call><name>RegisterSnapshot</name><argument_list>(<argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
								<argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
								<argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* number of keys */</comment>
								<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
								<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
								<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* syncscan OK */</comment>

	<while>while <condition>(<expr><operator>(</operator><name>heapTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set up for predicate or expression evaluation */</comment>
		<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In a partial index, ignore tuples that don't satisfy the predicate.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Extract index column values, including computing expressions.
		 */</comment>
		<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
					   <argument><expr><name>slot</name></expr></argument>,
					   <argument><expr><name>estate</name></expr></argument>,
					   <argument><expr><name>values</name></expr></argument>,
					   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check that this tuple has no conflicts.
		 */</comment>
		<expr_stmt><expr><call><name>check_exclusion_constraint</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
								   <argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>,
								   <argument><expr><name>estate</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnregisterSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * validate_index - support code for concurrent index builds
 *
 * We do a concurrent index build by first inserting the catalog entry for the
 * index via index_create(), marking it not indisready and not indisvalid.
 * Then we commit our transaction and start a new one, then we wait for all
 * transactions that could have been modifying the table to terminate.  Now
 * we know that any subsequently-started transactions will see the index and
 * honor its constraints on HOT updates; so while existing HOT-chains might
 * be broken with respect to the index, no currently live tuple will have an
 * incompatible HOT update done to it.  We now build the index normally via
 * index_build(), while holding a weak lock that allows concurrent
 * insert/update/delete.  Also, we index only tuples that are valid
 * as of the start of the scan (see IndexBuildHeapScan), whereas a normal
 * build takes care to include recently-dead tuples.  This is OK because
 * we won't mark the index valid until all transactions that might be able
 * to see those tuples are gone.  The reason for doing that is to avoid
 * bogus unique-index failures due to concurrent UPDATEs (we might see
 * different versions of the same row as being valid when we pass over them,
 * if we used HeapTupleSatisfiesVacuum).  This leaves us with an index that
 * does not contain any tuples added to the table while we built the index.
 *
 * Next, we mark the index "indisready" (but still not "indisvalid") and
 * commit the second transaction and start a third.  Again we wait for all
 * transactions that could have been modifying the table to terminate.  Now
 * we know that any subsequently-started transactions will see the index and
 * insert their new tuples into it.  We then take a new reference snapshot
 * which is passed to validate_index().  Any tuples that are valid according
 * to this snap, but are not in the index, must be added to the index.
 * (Any tuples committed live after the snap will be inserted into the
 * index by their originating transaction.  Any tuples committed dead before
 * the snap need not be indexed, because we will wait out all transactions
 * that might care about them before we mark the index valid.)
 *
 * validate_index() works by first gathering all the TIDs currently in the
 * index, using a bulkdelete callback that just stores the TIDs and doesn't
 * ever say "delete it".  (This should be faster than a plain indexscan;
 * also, not all index AMs support full-index indexscan.)  Then we sort the
 * TIDs, and finally scan the table doing a "merge join" against the TID list
 * to see which tuples are missing from the index.  Thus we will ensure that
 * all tuples valid according to the reference snapshot are in the index.
 *
 * Building a unique index this way is tricky: we might try to insert a
 * tuple that is already dead or is in process of being deleted, and we
 * mustn't have a uniqueness failure against an updated version of the same
 * row.  We could try to check the tuple to see if it's already dead and tell
 * index_insert() not to do the uniqueness check, but that still leaves us
 * with a race condition against an in-progress update.  To handle that,
 * we expect the index AM to recheck liveness of the to-be-inserted tuple
 * before it declares a uniqueness error.
 *
 * After completing validate_index(), we wait until all transactions that
 * were alive at the time of the reference snapshot are gone; this is
 * necessary to be sure there are none left with a transaction snapshot
 * older than the reference (and hence possibly able to see tuples we did
 * not index).  Then we mark the index "indisvalid" and commit.  Subsequent
 * transactions will be able to use it for queries.
 *
 * Doing two full table scans is a brute-force strategy.  We could try to be
 * cleverer, eg storing new tuples in a special area of the table (perhaps
 * making the table append-only by setting use_fsm).  However that would
 * add yet more locking issues.
 */</comment>
<function><type><name>void</name></type>
<name>validate_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>heapId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRelation</name></decl>,
				<decl><type ref="prev"/><name>indexRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexVacuumInfo</name></type> <name>ivinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>v_i_state</name></type>	<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>

	<comment type="block">/* Open and lock the parent heap relation */</comment>
	<expr_stmt><expr><name>heapRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareUpdateExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* And the target index relation */</comment>
	<expr_stmt><expr><name>indexRelation</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fetch info needed for index_insert.  (You might think this should be
	 * passed in from DefineIndex, but its copy is long gone due to having
	 * been built in a previous transaction.)
	 */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* mark build is concurrent just for consistency */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to the table owner's userid, so that any index functions are run
	 * as that user.  Also lock down security-restricted operations and
	 * arrange to make GUC variable changes local to this command.
	 */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_RESTRICTED_OPERATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan the index and gather up all the TIDs into a tuplesort object.
	 */</comment>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>indexRelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>analyze_only</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>estimated_count</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>message_level</name></name> <operator>=</operator> <name>DEBUG2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>num_heap_tuples</name></name> <operator>=</operator> <name><name>heapRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ivinfo</name><operator>.</operator><name>strategy</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Encode TIDs as int8 values for the sort, rather than directly sorting
	 * item pointers.  This can be significantly faster, primarily because TID
	 * is a pass-by-reference type on all platforms, whereas int8 is
	 * pass-by-value on most platforms.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>tuplesort</name></name> <operator>=</operator> <call><name>tuplesort_begin_datum</name><argument_list>(<argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><name>Int8LessOperator</name></expr></argument>,
											<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name>maintenance_work_mem</name></expr></argument>,
											<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>.</operator><name>htups</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>itups</name></name> <operator>=</operator> <name><name>state</name><operator>.</operator><name>tups_inserted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>index_bulk_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ivinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>validate_index_callback</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Execute the sort */</comment>
	<expr_stmt><expr><call><name>tuplesort_performsort</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>tuplesort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now scan the heap and "merge" it with the index
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PX_ENABLE_BTBUILD_CIC_PHASE2</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>polar_px_validate_index_heapscan</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
										<argument><expr><name>indexRelation</name></expr></argument>,
										<argument><expr><name>indexInfo</name></expr></argument>,
										<argument><expr><name>snapshot</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>validate_index_heapscan</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,
								<argument><expr><name>indexRelation</name></expr></argument>,
								<argument><expr><name>indexInfo</name></expr></argument>,
								<argument><expr><name>snapshot</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Done with tuplesort object */</comment>
	<expr_stmt><expr><call><name>tuplesort_end</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>tuplesort</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
		 <argument><expr><literal type="string">"validate_index found %.0f heap tuples, %.0f index tuples; inserted %.0f missing tuples"</literal></expr></argument>,
		 <argument><expr><name><name>state</name><operator>.</operator><name>htups</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>itups</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>.</operator><name>tups_inserted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Roll back any GUC changes executed by index functions */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore userid and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Close rels, but keep locks */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * itemptr_encode - Encode ItemPointer as int64/int8
 *
 * This representation must produce values encoded as int64 that sort in the
 * same order as their corresponding original TID values would (using the
 * default int8 opclass to produce a result equivalent to the default TID
 * opclass).
 *
 * As noted in validate_index(), this can be significantly faster.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int64</name></type>
<name>itemptr_encode</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name> <init>= <expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name> <init>= <expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>encoded</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use the 16 least significant bits for the offset.  32 adjacent bits are
	 * used for the block number.  Since remaining bits are unused, there
	 * cannot be negative encoded values (We assume a two's complement
	 * representation).
	 */</comment>
	<expr_stmt><expr><name>encoded</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <name>block</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>uint16</name><operator>)</operator> <name>offset</name></expr>;</expr_stmt>

	<return>return <expr><name>encoded</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * itemptr_decode - Decode int64/int8 representation back to ItemPointer
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>itemptr_decode</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>encoded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>block</name> <init>= <expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <operator>(</operator><name>encoded</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name> <init>= <expr><operator>(</operator><name>OffsetNumber</name><operator>)</operator> <operator>(</operator><name>encoded</name> <operator>&amp;</operator> <literal type="number">0xFFFF</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ItemPointerSet</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * validate_index_callback - bulkdelete callback to collect the index TIDs
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>validate_index_callback</name><parameter_list>(<parameter><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>opaque</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>v_i_state</name>  <modifier>*</modifier></type><name>state</name> <init>= <expr><operator>(</operator><name>v_i_state</name> <operator>*</operator><operator>)</operator> <name>opaque</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>encoded</name> <init>= <expr><call><name>itemptr_encode</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>tuplesort_putdatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplesort</name></name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>itups</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>				<comment type="block">/* never actually delete anything */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * validate_index_heapscan - second table scan for concurrent index build
 *
 * This has much code in common with IndexBuildHeapScan, but it's enough
 * different that it seems cleaner to have two routines not one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>validate_index_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						<parameter><decl><type><name>v_i_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>heapTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>predicate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>root_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name><name>root_offsets</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>in_index</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* state variables for the merge */</comment>
	<decl_stmt><decl><type><name>ItemPointer</name></type> <name>indexcursor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>decoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>tuplesort_empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Need an EState for evaluation of index expressions and partial-index
	 * predicates.  Also a slot to hold the current tuple.
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange for econtext's scan tuple to be the tuple under test */</comment>
	<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<comment type="block">/* Set up execution state for predicate, if any. */</comment>
	<expr_stmt><expr><name>predicate</name> <operator>=</operator> <call><name>ExecPrepareQual</name><argument_list>(<argument><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prepare for scan of the base relation.  We need just those tuples
	 * satisfying the passed-in reference snapshot.  We must disable syncscan
	 * here, because it's critical that we read from block zero forward to
	 * match the sorted TIDs.
	 */</comment>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>heap_beginscan_strat</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>,	<comment type="block">/* relation */</comment>
								<argument><expr><name>snapshot</name></expr></argument>,	<comment type="block">/* snapshot */</comment>
								<argument><expr><literal type="number">0</literal></expr></argument>,	<comment type="block">/* number of keys */</comment>
								<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* scan key */</comment>
								<argument><expr><name>true</name></expr></argument>,	<comment type="block">/* buffer access strategy OK */</comment>
								<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* syncscan not OK */</comment>

	<comment type="block">/*
	 * Scan all tuples matching the snapshot.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>heapTuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ItemPointer</name></type> <name>heapcursor</name> <init>= <expr><operator>&amp;</operator><name><name>heapTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>rootTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>root_offnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>htups</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * As commented in IndexBuildHeapScan, we should index heap-only
		 * tuples under the TIDs of their root tuples; so when we advance onto
		 * a new heap page, build a map of root item offsets on the page.
		 *
		 * This complicates merging against the tuplesort output: we will
		 * visit the live tuples in order by their offsets, but the root
		 * offsets that we need to compare against the index contents might be
		 * ordered differently.  So we might have to "look back" within the
		 * tuplesort output, but only within the current page.  We handle that
		 * by keeping a bool array in_index[] showing all the
		 * already-passed-over tuplesort output TIDs of the current page. We
		 * clear that array here, when advancing onto a new heap page.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name> <operator>!=</operator> <name>root_blkno</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Page</name></type>		<name>page</name> <init>= <expr><call><name>BufferGetPage</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_get_root_tuples</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name><name>scan</name><operator>-&gt;</operator><name>rs_cbuf</name></name></expr></argument>, <argument><expr><name>BUFFER_LOCK_UNLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>in_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>in_index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>root_blkno</name> <operator>=</operator> <name><name>scan</name><operator>-&gt;</operator><name>rs_cblock</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Convert actual tuple TID to root TID */</comment>
		<expr_stmt><expr><name>rootTuple</name> <operator>=</operator> <operator>*</operator><name>heapcursor</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <name><name>root_offsets</name><index>[<expr><name>root_offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>root_offnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</literal></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ItemPointerSetOffsetNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>, <argument><expr><name>root_offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * "merge" by skipping through the index tuples until we find or pass
		 * the current root tuple.
		 */</comment>
		<while>while <condition>(<expr><operator>!</operator><name>tuplesort_empty</name> <operator>&amp;&amp;</operator>
			   <operator>(</operator><operator>!</operator><name>indexcursor</name> <operator>||</operator>
				<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>ts_val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ts_isnull</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>indexcursor</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Remember index items seen earlier on the current heap page
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>root_blkno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>in_index</name><index>[<expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>tuplesort_empty</name> <operator>=</operator> <operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplesort</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>ts_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts_isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplesort_empty</name> <operator>||</operator> <operator>!</operator><name>ts_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuplesort_empty</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>itemptr_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decoded</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <operator>&amp;</operator><name>decoded</name></expr>;</expr_stmt>

				<comment type="block">/* If int8 is pass-by-ref, free (encoded) TID Datum memory */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Be tidy */</comment>
				<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If the tuplesort has overshot *and* we didn't see a match earlier,
		 * then this tuple is missing from the index, so insert it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplesort_empty</name> <operator>||</operator>
			 <call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>in_index</name><index>[<expr><name>root_offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Set up for predicate or expression evaluation */</comment>
			<expr_stmt><expr><call><name>ExecStoreTuple</name><argument_list>(<argument><expr><name>heapTuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>InvalidBuffer</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * In a partial index, discard tuples that don't satisfy the
			 * predicate.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>predicate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecQual</name><argument_list>(<argument><expr><name>predicate</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * For the current heap tuple, extract all the attributes we use
			 * in this index, and note which are null.  This also performs
			 * evaluation of any expressions needed.
			 */</comment>
			<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>,
						   <argument><expr><name>slot</name></expr></argument>,
						   <argument><expr><name>estate</name></expr></argument>,
						   <argument><expr><name>values</name></expr></argument>,
						   <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * You'd think we should go ahead and build the index tuple here,
			 * but some index AMs want to do further processing on the data
			 * first. So pass the values[] and isnull[] arrays, instead.
			 */</comment>

			<comment type="block">/*
			 * If the tuple is already committed dead, you might think we
			 * could suppress uniqueness checking, but this is no longer true
			 * in the presence of HOT, because the insert is actually a proxy
			 * for a uniqueness check on the whole HOT-chain.  That is, the
			 * tuple we have here could be dead because it was already
			 * HOT-updated, and if so the updating transaction will not have
			 * thought it should insert index entries.  The index AM will
			 * check the whole HOT-chain and correctly detect a conflict if
			 * there is one.
			 */</comment>

			<expr_stmt><expr><call><name>index_insert</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
						 <argument><expr><name>values</name></expr></argument>,
						 <argument><expr><name>isnull</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>,
						 <argument><expr><name>heapRelation</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr> ?</condition><then>
						 <expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></argument>,
						 <argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tups_inserted</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>heap_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * index_set_state_flags - adjust pg_index state flags
 *
 * This is used during CREATE/DROP INDEX CONCURRENTLY to adjust the pg_index
 * flags that denote the index's state.  Because the update is not
 * transactional and will not roll back on error, this must only be used as
 * the last step in a transaction that has not made any transactional catalog
 * updates!
 *
 * Note that heap_inplace_update does send a cache inval message for the
 * tuple, so other sessions will hear about the update as soon as we commit.
 *
 * NB: In releases prior to PostgreSQL 9.4, the use of a non-transactional
 * update here would have been unsafe; now that MVCC rules apply even for
 * system catalog scans, we could potentially use a transactional update here
 * instead.
 */</comment>
<function><type><name>void</name></type>
<name>index_set_state_flags</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>IndexStateFlagsAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>

	<comment type="block">/* Assert that current xact hasn't done any transactional updates */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call> <operator>==</operator> <name>InvalidTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Open pg_index and fetch a writable copy of the index's tuple */</comment>
	<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Perform the requested state change on the copy */</comment>
	<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>INDEX_CREATE_SET_READY</name></expr>:</case>
			<comment type="block">/* Set indisready during a CREATE INDEX CONCURRENTLY sequence */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indislive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INDEX_CREATE_SET_VALID</name></expr>:</case>
			<comment type="block">/* Set indisvalid during a CREATE INDEX CONCURRENTLY sequence */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indislive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INDEX_DROP_CLEAR_VALID</name></expr>:</case>

			<comment type="block">/*
			 * Clear indisvalid during a DROP INDEX CONCURRENTLY sequence
			 *
			 * If indisready == true we leave it set so the index still gets
			 * maintained by active transactions.  We only need to ensure that
			 * indisvalid is false.  (We don't assert that either is initially
			 * true, though, since we want to be able to retry a DROP INDEX
			 * CONCURRENTLY that failed partway through.)
			 *
			 * Note: the CLUSTER logic assumes that indisclustered cannot be
			 * set on any invalid index, so clear that flag too.
			 */</comment>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisclustered</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INDEX_DROP_SET_DEAD</name></expr>:</case>

			<comment type="block">/*
			 * Clear indisready/indislive during DROP INDEX CONCURRENTLY
			 *
			 * We clear both indisready and indislive, because we not only
			 * want to stop updates, we want to prevent sessions from touching
			 * the index at all.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indislive</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* ... and write it back in-place */</comment>
	<expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * IndexGetRelation: given an index's relation OID, get the OID of the
 * relation it is an index on.  Uses the system cache.
 */</comment>
<function><type><name>Oid</name></type>
<name>IndexGetRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexrelid</name></name> <operator>==</operator> <name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * reindex_index - This routine is used to recreate a single index
 */</comment>
<function><type><name>void</name></type>
<name>reindex_index</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>skip_constraint_checks</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>persistence</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>iRel</name></decl>,
				<decl><type ref="prev"/><name>heapRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>heapId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>bool</name></type> <name>skipped_constraint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGRUsage</name></type>	<name>ru0</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pg_rusage_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open and lock the parent heap relation.  ShareLock is sufficient since
	 * we only need to be sure no schema or data changes are going on.
	 */</comment>
	<expr_stmt><expr><name>heapId</name> <operator>=</operator> <call><name>IndexGetRelation</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>heapRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open the target index relation and get an exclusive lock on it, to
	 * ensure that no one else is touching this particular index.
	 */</comment>
	<expr_stmt><expr><name>iRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The case of reindexing partitioned tables and indexes is handled
	 * differently by upper layers, so this case shouldn't arise.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>iRel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported relation kind for index \"%s\""</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Don't allow reindex on temp tables of other backends ... their local
	 * buffer manager is not going to cope.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RELATION_IS_OTHER_TEMP</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reindex temporary tables of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also check for active uses of the index in the current transaction; we
	 * don't want to reindex underneath an open indexscan.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>, <argument><expr><literal type="string">"REINDEX INDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * All predicate locks on the index are about to be made invalid. Promote
	 * them to relation locks on the heap.
	 */</comment>
	<expr_stmt><expr><call><name>TransferPredicateLocksToHeapRelation</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch info needed for index_build */</comment>
	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If requested, skip checking uniqueness/exclusion constraints */</comment>
	<if_stmt><if>if <condition>(<expr><name>skip_constraint_checks</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>||</operator> <name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>skipped_constraint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Suppress use of the target index while rebuilding it */</comment>
	<expr_stmt><expr><call><name>SetReindexProcessing</name><argument_list>(<argument><expr><name>heapId</name></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a new physical relation for the index */</comment>
	<expr_stmt><expr><call><name>RelationSetNewRelfilenode</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>, <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>InvalidTransactionId</name></expr></argument>,
							  <argument><expr><name>InvalidMultiXactId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the index and rebuild */</comment>
	<comment type="block">/* Note: we do not need to re-establish pkey setting */</comment>
	<expr_stmt><expr><call><name>index_build</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>iRel</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Re-allow use of target index */</comment>
	<expr_stmt><expr><call><name>ResetReindexProcessing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the index is marked invalid/not-ready/dead (ie, it's from a failed
	 * CREATE INDEX CONCURRENTLY, or a DROP INDEX CONCURRENTLY failed midway),
	 * and we didn't skip a uniqueness check, we can now mark it valid.  This
	 * allows REINDEX to be used to clean up in such cases.
	 *
	 * We can also reset indcheckxmin, because we have now done a
	 * non-concurrent index build, *except* in the case where index_build
	 * found some still-broken HOT chains. If it did, and we don't have to
	 * change any of the other flags, we just leave indcheckxmin alone (note
	 * that index_build won't have changed it, because this is a reindex).
	 * This is okay and desirable because not updating the tuple leaves the
	 * index's usability horizon (recorded as the tuple's xmin value) the same
	 * as it was.
	 *
	 * But, if the index was invalid/not-ready/dead and there were broken HOT
	 * chains, we had better force indcheckxmin true, because the normal
	 * argument that the HOT chains couldn't conflict with the index is
	 * suspect for an invalid index.  (A conflict is definitely possible if
	 * the index was dead.  It probably shouldn't happen otherwise, but let's
	 * be conservative.)  In this case advancing the usability horizon is
	 * appropriate.
	 *
	 * Another reason for avoiding unnecessary updates here is that while
	 * reindexing pg_index itself, we must not try to update tuples in it.
	 * pg_index's indexes should always have these flags in their clean state,
	 * so that won't happen.
	 *
	 * If early pruning/vacuuming is enabled for the heap relation, the
	 * usability horizon must be advanced to the current transaction on every
	 * build or rebuild.  pg_index is OK in this regard because catalog tables
	 * are not subject to early cleanup.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skipped_constraint</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>indexTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_index</name></type> <name>indexForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>index_bad</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>early_pruning_enabled</name> <init>= <expr><call><name>EarlyPruningEnabled</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pg_index</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>IndexRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>indexTuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
										 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for index %u"</literal></expr></argument>, <argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>indexForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index_bad</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>||</operator>
					 <operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name> <operator>||</operator>
					 <operator>!</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indislive</name></name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>index_bad</name> <operator>||</operator>
			<operator>(</operator><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name><operator>)</operator> <operator>||</operator>
			<name>early_pruning_enabled</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>early_pruning_enabled</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>index_bad</name> <operator>||</operator> <name>early_pruning_enabled</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indcheckxmin</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indisready</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>indexForm</name><operator>-&gt;</operator><name>indislive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>indexTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>indexTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Invalidate the relcache for the table, so that after we commit
			 * all sessions will refresh the table's index list.  This ensures
			 * that if anyone misses seeing the pg_index row during this
			 * update, they'll refresh their list before attempting any update
			 * on the table.
			 */</comment>
			<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_index</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Log what we did */</comment>
	<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>REINDEXOPT_VERBOSE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" was reindexed"</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>,
									<argument><expr><call><name>pg_rusage_show</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ru0</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Close rels, but keep locks */</comment>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>iRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * reindex_relation - This routine is used to recreate all indexes
 * of a relation (and optionally its toast relation too, if any).
 *
 * "flags" is a bitmask that can include any combination of these bits:
 *
 * REINDEX_REL_PROCESS_TOAST: if true, process the toast table too (if any).
 *
 * REINDEX_REL_SUPPRESS_INDEX_USE: if true, the relation was just completely
 * rebuilt by an operation such as VACUUM FULL or CLUSTER, and therefore its
 * indexes are inconsistent with it.  This makes things tricky if the relation
 * is a system catalog that we might consult during the reindexing.  To deal
 * with that case, we mark all of the indexes as pending rebuild so that they
 * won't be trusted until rebuilt.  The caller is required to call us *without*
 * having made the rebuilt table visible by doing CommandCounterIncrement;
 * we'll do CCI after having collected the index list.  (This way we can still
 * use catalog indexes while collecting the list.)
 *
 * REINDEX_REL_CHECK_CONSTRAINTS: if true, recheck unique and exclusion
 * constraint conditions, else don't.  To avoid deadlocks, VACUUM FULL or
 * CLUSTER on a system catalog must omit this flag.  REINDEX should be used to
 * rebuild an index if constraint inconsistency is suspected.  For optimal
 * performance, other callers should include the flag only after transforming
 * the data in a manner that risks a change in constraint validity.
 *
 * REINDEX_REL_FORCE_INDEXES_UNLOGGED: if true, set the persistence of the
 * rebuilt indexes to unlogged.
 *
 * REINDEX_REL_FORCE_INDEXES_PERMANENT: if true, set the persistence of the
 * rebuilt indexes to permanent.
 *
 * Returns true if any indexes were rebuilt (including toast table's index
 * when relevant).  Note that a CommandCounterIncrement will occur after each
 * index rebuild.
 */</comment>
<function><type><name>bool</name></type>
<name>reindex_relation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toast_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexIds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>persistence</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Open and lock the relation.  ShareLock is sufficient since we only need
	 * to prevent schema and data changes in it.  The lock level used here
	 * should match ReindexTable().
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This may be useful when implemented someday; but that day is not today.
	 * For now, avoid erroring out when called in a multi-table context
	 * (REINDEX SCHEMA) and happen to come across a partitioned table.  The
	 * partitions may be reindexed on their own anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"REINDEX of partitioned tables is not yet implemented, skipping \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the list of index OIDs for this relation.  (We trust to the
	 * relcache to get this with a sequential scan if ignoring system
	 * indexes.)
	 */</comment>
	<expr_stmt><expr><name>indexIds</name> <operator>=</operator> <call><name>RelationGetIndexList</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REINDEX_REL_SUPPRESS_INDEX_USE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Suppress use of all the indexes until they are rebuilt */</comment>
		<expr_stmt><expr><call><name>SetReindexPending</name><argument_list>(<argument><expr><name>indexIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make the new heap contents visible --- now things might be
		 * inconsistent!
		 */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Compute persistence of indexes: same as that of owning rel, unless
	 * caller specified otherwise.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REINDEX_REL_FORCE_INDEXES_UNLOGGED</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>persistence</name> <operator>=</operator> <name>RELPERSISTENCE_UNLOGGED</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>REINDEX_REL_FORCE_INDEXES_PERMANENT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>persistence</name> <operator>=</operator> <name>RELPERSISTENCE_PERMANENT</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>persistence</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Reindex all the indexes. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>indexId</argument>, <argument>indexIds</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexOid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>reindex_index</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>, <argument><expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REINDEX_REL_CHECK_CONSTRAINTS</name><operator>)</operator></expr></argument>,
					  <argument><expr><name>persistence</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Index should no longer be in the pending list */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>ReindexIsProcessingIndex</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Close rel, but continue to hold the lock.
	 */</comment>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>indexIds</name> <operator>!=</operator> <name>NIL</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation has a secondary toast rel, reindex that too while we
	 * still hold the lock on the master table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>REINDEX_REL_PROCESS_TOAST</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>|=</operator> <call><name>reindex_relation</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *		System index reindexing support
 *
 * When we are busy reindexing a system index, this code provides support
 * for preventing catalog lookups from using that index.  We also make use
 * of this to catch attempted uses of user indexes during reindexing of
 * those indexes.  This information is propagated to parallel workers;
 * attempting to change it during a parallel operation is not permitted.
 * ----------------------------------------------------------------
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>currentlyReindexedHeap</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>currentlyReindexedIndex</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>pendingReindexedIndexes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>reindexingNestLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * ReindexIsProcessingHeap
 *		True if heap specified by OID is currently being reindexed.
 */</comment>
<function><type><name>bool</name></type>
<name>ReindexIsProcessingHeap</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>heapOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>heapOid</name> <operator>==</operator> <name>currentlyReindexedHeap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexIsCurrentlyProcessingIndex
 *		True if index specified by OID is currently being reindexed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ReindexIsCurrentlyProcessingIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>indexOid</name> <operator>==</operator> <name>currentlyReindexedIndex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ReindexIsProcessingIndex
 *		True if index specified by OID is currently being reindexed,
 *		or should be treated as invalid because it is awaiting reindex.
 */</comment>
<function><type><name>bool</name></type>
<name>ReindexIsProcessingIndex</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>indexOid</name> <operator>==</operator> <name>currentlyReindexedIndex</name> <operator>||</operator>
		<call><name>list_member_oid</name><argument_list>(<argument><expr><name>pendingReindexedIndexes</name></expr></argument>, <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SetReindexProcessing
 *		Set flag that specified heap/index are being reindexed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetReindexProcessing</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>heapOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>heapOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Reindexing is not re-entrant. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>currentlyReindexedHeap</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot reindex while reindexing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>currentlyReindexedHeap</name> <operator>=</operator> <name>heapOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentlyReindexedIndex</name> <operator>=</operator> <name>indexOid</name></expr>;</expr_stmt>
	<comment type="block">/* Index is no longer "pending" reindex. */</comment>
	<expr_stmt><expr><call><name>RemoveReindexPending</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* This may have been set already, but in case it isn't, do so now. */</comment>
	<expr_stmt><expr><name>reindexingNestLevel</name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ResetReindexProcessing
 *		Unset reindexing status.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResetReindexProcessing</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>currentlyReindexedHeap</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentlyReindexedIndex</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<comment type="block">/* reindexingNestLevel remains set till end of (sub)transaction */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * SetReindexPending
 *		Mark the given indexes as pending reindex.
 *
 * NB: we assume that the current memory context stays valid throughout.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetReindexPending</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Reindexing is not re-entrant. */</comment>
	<if_stmt><if>if <condition>(<expr><name>pendingReindexedIndexes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot reindex while reindexing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot modify reindex state during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pendingReindexedIndexes</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reindexingNestLevel</name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RemoveReindexPending
 *		Remove the given index from the pending list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveReindexPending</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>indexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot modify reindex state during a parallel operation"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pendingReindexedIndexes</name> <operator>=</operator> <call><name>list_delete_oid</name><argument_list>(<argument><expr><name>pendingReindexedIndexes</name></expr></argument>,
											  <argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ResetReindexState
 *		Clear all reindexing state during (sub)transaction abort.
 */</comment>
<function><type><name>void</name></type>
<name>ResetReindexState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nestLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Because reindexing is not re-entrant, we don't need to cope with nested
	 * reindexing states.  We just need to avoid messing up the outer-level
	 * state in case a subtransaction fails within a REINDEX.  So checking the
	 * current nest level against that of the reindex operation is sufficient.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reindexingNestLevel</name> <operator>&gt;=</operator> <name>nestLevel</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>currentlyReindexedHeap</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>currentlyReindexedIndex</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * We needn't try to release the contents of pendingReindexedIndexes;
		 * that list should be in a transaction-lifespan context, so it will
		 * go away automatically.
		 */</comment>
		<expr_stmt><expr><name>pendingReindexedIndexes</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>reindexingNestLevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * EstimateReindexStateSpace
 *		Estimate space needed to pass reindex state to parallel workers.
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateReindexStateSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>SerializedReindexState</name></expr></argument>, <argument><expr><name>pendingReindexedIndexes</name></expr></argument>)</argument_list></call>
		<operator>+</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>pendingReindexedIndexes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SerializeReindexState
 *		Serialize reindex state for parallel workers.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeReindexState</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SerializedReindexState</name> <modifier>*</modifier></type><name>sistate</name> <init>= <expr><operator>(</operator><name>SerializedReindexState</name> <operator>*</operator><operator>)</operator> <name>start_address</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>sistate</name><operator>-&gt;</operator><name>currentlyReindexedHeap</name></name> <operator>=</operator> <name>currentlyReindexedHeap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sistate</name><operator>-&gt;</operator><name>currentlyReindexedIndex</name></name> <operator>=</operator> <name>currentlyReindexedIndex</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sistate</name><operator>-&gt;</operator><name>numPendingReindexedIndexes</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>pendingReindexedIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>pendingReindexedIndexes</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>sistate</name><operator>-&gt;</operator><name>pendingReindexedIndexes</name><index>[<expr><name>c</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RestoreReindexState
 *		Restore reindex state in a parallel worker.
 */</comment>
<function><type><name>void</name></type>
<name>RestoreReindexState</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>reindexstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SerializedReindexState</name> <modifier>*</modifier></type><name>sistate</name> <init>= <expr><operator>(</operator><name>SerializedReindexState</name> <operator>*</operator><operator>)</operator> <name>reindexstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>currentlyReindexedHeap</name> <operator>=</operator> <name><name>sistate</name><operator>-&gt;</operator><name>currentlyReindexedHeap</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentlyReindexedIndex</name> <operator>=</operator> <name><name>sistate</name><operator>-&gt;</operator><name>currentlyReindexedIndex</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pendingReindexedIndexes</name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>sistate</name><operator>-&gt;</operator><name>numPendingReindexedIndexes</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pendingReindexedIndexes</name> <operator>=</operator>
			<call><name>lappend_oid</name><argument_list>(<argument><expr><name>pendingReindexedIndexes</name></expr></argument>,
						<argument><expr><name><name>sistate</name><operator>-&gt;</operator><name>pendingReindexedIndexes</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Note the worker has its own transaction nesting level */</comment>
	<expr_stmt><expr><name>reindexingNestLevel</name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR:
 * Input a ctid of tuple, and return its root ctid.
 */</comment>
<function><type><name>Datum</name></type>
<name>polar_get_root_ctid</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>Buffer</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>max_block_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>rel_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>root_offnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>root_ctid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OffsetNumber</name> <modifier>*</modifier></type><name>cached_root_offsets</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_memory_alloc</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the cached_blkno is invalid or the current blkno is a new BlockNumber,
	 * we should get the new cached_root_offsets.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>||</operator> <name>econtext</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>econtext</name><operator>-&gt;</operator><name>cached_blkno</name></name> <operator>==</operator> <name>InvalidBlockNumber</name> <operator>||</operator> <name>blkno</name> <operator>!=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>cached_blkno</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Page</name></type> <name>page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>==</operator> <name>InvalidBuffer</name> <operator>||</operator> <name>econtext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>cached_root_offsets</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OffsetNumber</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MaxHeapTuplesPerPage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>is_memory_alloc</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>polar_bulk_read_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rel_size</name> <operator>=</operator> <call><name>RelationGetNumberOfBlocks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>rel_size</name> <operator>&lt;=</operator> <name>blkno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"get root ctid, block number out of range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>max_block_count</name> <operator>=</operator> <name>rel_size</name> <operator>-</operator> <name>blkno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>polar_bulk_read_buffer_extended</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>RBM_NORMAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>max_block_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>ReadBuffer</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>blkno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LockBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BUFFER_LOCK_SHARE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_get_root_tuples</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>cached_root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>UnlockReleaseBuffer</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>buffer</name> <operator>!=</operator> <name>InvalidBuffer</name> <operator>&amp;&amp;</operator> <name>econtext</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cached_root_offsets</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>cached_root_offsets</name></name></expr>;</expr_stmt>
			<comment type="block">/* Buffer has already be locked by caller. */</comment>
			<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>BufferGetPage</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>heap_get_root_tuples</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>cached_root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>cached_blkno</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsHeapOnly</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a heap-only tuple, pretend its TID is that of the root. See
		 * src/backend/access/heap/README.HOT for discussion.
		 */</comment>
		<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>cached_root_offsets</name><index>[<expr><name>offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OffsetNumberIsValid</name><argument_list>(<argument><expr><name>root_offnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"failed to find parent tuple for heap-only tuple at (%u,%u) in table \"%s\""</literal></expr></argument>,
										<argument><expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>offnum</name></expr></argument>,
										<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_tableOid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <name>offnum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>root_ctid</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"(%u, %u)"</literal></expr></argument>, <argument><expr><name>blkno</name></expr></argument>, <argument><expr><name>root_offnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>tidin</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>root_ctid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_memory_alloc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cached_root_offsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>root_ctid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: This has much code in common with validate_index_heapscan. Second
 * table scan for concurrent index build. We don't support expressions and
 * predicates index in pxbtbuild, so we drop some operations about expressions
 * and predicates index.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>polar_px_validate_index_heapscan</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>,
						<parameter><decl><type><name>Relation</name></type> <name>indexRelation</name></decl></parameter>,
						<parameter><decl><type><name>IndexInfo</name> <modifier>*</modifier></type><name>indexInfo</name></decl></parameter>,
						<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>,
						<parameter><decl><type><name>v_i_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name><name>in_index</name><index>[<expr><name>MaxHeapTuplesPerPage</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* state variables for the merge */</comment>
	<decl_stmt><decl><type><name>ItemPointer</name></type>		<name>indexcursor</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>decoded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>tuplesort_empty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* px: build px sql init */</comment>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>old_enable_px</name> <init>= <expr><name>polar_enable_px</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>old_px_plancache</name> <init>= <expr><name>px_enable_plan_cache</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>old_px_index</name> <init>= <expr><name>px_optimizer_enable_indexscan</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>old_px_check_workers</name> <init>= <expr><name>px_enable_check_workers</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>old_px_tx</name> <init>= <expr><name>px_enable_transaction</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> 		<name>old_px_replay_wait</name> <init>= <expr><name>px_enable_replay_wait</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>indexRelation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* px: generate sql */</comment>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfo</name></type> <name>attrs</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdes</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>natts</name> <init>= <expr><name><name>tupdes</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>lastattr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdes</name></expr></argument>, <argument><expr><name>natts</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>natts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><literal type="string">"%s, "</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>attrs</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>lastattr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* should be order by ctid. PX scan table can not guarantee in sequence */</comment>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"select _root_ctid, %s from %s order by ctid"</literal></expr></argument>, 
							<argument><expr><name><name>attrs</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* invoke SPI interface */</comment>
	<expr_stmt><expr><name>polar_enable_px</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_optimizer_enable_indexscan</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_check_workers</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_plan_cache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_transaction</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_replay_wait</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_prepare_px</name><argument_list>(<argument><expr><name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare(\"%s\") failed"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open(\"%s\") failed"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* reset SPI interface */</comment>
	<expr_stmt><expr><name>polar_enable_px</name> <operator>=</operator> <name>old_enable_px</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_optimizer_enable_indexscan</name> <operator>=</operator> <name>old_px_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_check_workers</name> <operator>=</operator> <name>old_px_check_workers</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_plan_cache</name> <operator>=</operator> <name>old_px_plancache</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_transaction</name> <operator>=</operator> <name>old_px_tx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>px_enable_replay_wait</name> <operator>=</operator> <name>old_px_replay_wait</name></expr>;</expr_stmt>

	<comment type="block">/* fetch heap tuple */</comment>
	<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>px_btbuild_batch_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>BlockNumber</name></type>	<name>root_blkno</name> <init>= <expr><name>InvalidBlockNumber</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>root_offnum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type> <name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type> <name><name>nulls</name><index>[<expr><name>INDEX_MAX_KEYS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointer</name></type> <name>heapcursor</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ItemPointerData</name></type> <name>rootTuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tup</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* ctid for current heap tuple */</comment>
			<expr_stmt><expr><name>heapcursor</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rootTuple</name> <operator>=</operator> <operator>*</operator><name>heapcursor</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>root_blkno</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>root_offnum</name> <operator>=</operator> <call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>heapcursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			* "merge" by skipping through the index tuples until we find or pass
			* the current root tuple.
			*/</comment>
			<while>while <condition>(<expr><operator>!</operator><name>tuplesort_empty</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>!</operator><name>indexcursor</name> <operator>||</operator>
					<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Datum</name></type>		<name>ts_val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>ts_isnull</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>indexcursor</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					* Remember index items seen earlier on the current heap page
					*/</comment>
					<if_stmt><if>if <condition>(<expr><call><name>ItemPointerGetBlockNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>root_blkno</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>in_index</name><index>[<expr><call><name>ItemPointerGetOffsetNumber</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>tuplesort_empty</name> <operator>=</operator> <operator>!</operator><call><name>tuplesort_getdatum</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuplesort</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>ts_val</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts_isnull</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tuplesort_empty</name> <operator>||</operator> <operator>!</operator><name>ts_isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuplesort_empty</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>itemptr_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>decoded</name></expr></argument>, <argument><expr><call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <operator>&amp;</operator><name>decoded</name></expr>;</expr_stmt>

					<comment type="block">/* If int8 is pass-by-ref, free (encoded) TID Datum memory */</comment>
	<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_FLOAT8_BYVAL</name></cpp:ifndef>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>ts_val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* Be tidy */</comment>
					<expr_stmt><expr><name>indexcursor</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>

			<comment type="block">/*
			* If the tuplesort has overshot *and* we didn't see a match earlier,
			* then this tuple is missing from the index, so insert it.
			*/</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplesort_empty</name> <operator>||</operator>
				<call><name>ItemPointerCompare</name><argument_list>(<argument><expr><name>indexcursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>in_index</name><index>[<expr><name>root_offnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>index_insert</name><argument_list>(<argument><expr><name>indexRelation</name></expr></argument>,
								<argument><expr><name>values</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								<argument><expr><name>nulls</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rootTuple</name></expr></argument>,
								<argument><expr><name>heapRelation</name></expr></argument>,
								<argument><expr><ternary><condition><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name></expr> ?</condition><then>
								<expr><name>UNIQUE_CHECK_YES</name></expr> </then><else>: <expr><name>UNIQUE_CHECK_NO</name></expr></else></ternary></expr></argument>,
								<argument><expr><name>indexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tups_inserted</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>px_btbuild_batch_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These may have been pointing to the now-gone estate */</comment>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function></unit>
