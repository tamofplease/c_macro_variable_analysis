<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/catalog/namespace.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * namespace.c
 *	  code to support accessing and searching namespaces
 *
 * This is separate from pg_namespace.c, which contains the routines that
 * directly manipulate the pg_namespace system catalog.  This module
 * provides routines associated with defining a "namespace search path"
 * and implementing search-path-controlled searches.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/catalog/namespace.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/parallel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_func.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<comment type="block">/*
 * The namespace search path is a possibly-empty list of namespace OIDs.
 * In addition to the explicit list, implicitly-searched namespaces
 * may be included:
 *
 * 1. If a TEMP table namespace has been initialized in this session, it
 * is implicitly searched first.  (The only time this doesn't happen is
 * when we are obeying an override search path spec that says not to use the
 * temp namespace, or the temp namespace is included in the explicit list.)
 *
 * 2. The system catalog namespace is always searched.  If the system
 * namespace is present in the explicit path then it will be searched in
 * the specified order; otherwise it will be searched after TEMP tables and
 * *before* the explicit list.  (It might seem that the system namespace
 * should be implicitly last, but this behavior appears to be required by
 * SQL99.  Also, this provides a way to search the system namespace first
 * without thereby making it the default creation target namespace.)
 *
 * For security reasons, searches using the search path will ignore the temp
 * namespace when searching for any object type other than relations and
 * types.  (We must allow types since temp tables have rowtypes.)
 *
 * The default creation target namespace is always the first element of the
 * explicit list.  If the explicit list is empty, there is no default target.
 *
 * The textual specification of search_path can include "$user" to refer to
 * the namespace named the same as the current user, if any.  (This is just
 * ignored if there is no such namespace.)	Also, it can include "pg_temp"
 * to refer to the current backend's temp namespace.  This is usually also
 * ignorable if the temp namespace hasn't been set up, but there's a special
 * case: if "pg_temp" appears first then it should be the default creation
 * target.  We kluge this case a little bit so that the temp namespace isn't
 * set up until the first attempt to create something in it.  (The reason for
 * klugery is that we can't create the temp namespace outside a transaction,
 * but initial GUC processing of search_path happens outside a transaction.)
 * activeTempCreationPending is true if "pg_temp" appears first in the string
 * but is not reflected in activeCreationNamespace because the namespace isn't
 * set up yet.
 *
 * In bootstrap mode, the search path is set equal to "pg_catalog", so that
 * the system namespace is the only one searched or inserted into.
 * initdb is also careful to set search_path to "pg_catalog" for its
 * post-bootstrap standalone backend runs.  Otherwise the default search
 * path is determined by GUC.  The factory default path contains the PUBLIC
 * namespace (if it exists), preceded by the user's personal namespace
 * (if one exists).
 *
 * We support a stack of "override" search path settings for use within
 * specific sections of backend code.  namespace_search_path is ignored
 * whenever the override stack is nonempty.  activeSearchPath is always
 * the actually active path; it points either to the search list of the
 * topmost stack entry, or to baseSearchPath which is the list derived
 * from namespace_search_path.
 *
 * If baseSearchPathValid is false, then baseSearchPath (and other
 * derived variables) need to be recomputed from namespace_search_path.
 * We mark it invalid upon an assignment to namespace_search_path or receipt
 * of a syscache invalidation event for pg_namespace.  The recomputation
 * is done during the next non-overridden lookup attempt.  Note that an
 * override spec is never subject to recomputation.
 *
 * Any namespaces mentioned in namespace_search_path that are not readable
 * by the current user ID are simply left out of baseSearchPath; so
 * we have to be willing to recompute the path when current userid changes.
 * namespaceUser is the userid the path has been computed for.
 *
 * Note: all data pointed to by these List variables is in TopMemoryContext.
 */</comment>

<comment type="block">/* These variables define the actually active state: */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>activeSearchPath</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* default place to create stuff; if InvalidOid, no default */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>activeCreationNamespace</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* if true, activeCreationNamespace is wrong, it should be temp namespace */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>activeTempCreationPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* These variables are the values last derived from namespace_search_path: */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>baseSearchPath</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>baseCreationNamespace</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>baseTempCreationPending</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>namespaceUser</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* The above four values are valid only if baseSearchPathValid */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>baseSearchPathValid</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Override requests are remembered in a stack of OverrideStackEntry structs */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>searchPath</name></decl>;</decl_stmt>		<comment type="block">/* the desired search path */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>creationNamespace</name></decl>;</decl_stmt>	<comment type="block">/* the desired creation namespace */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nestLevel</name></decl>;</decl_stmt>		<comment type="block">/* subtransaction nesting level */</comment>
}</block></struct></type> <name>OverrideStackEntry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>overrideStack</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * myTempNamespace is InvalidOid until and unless a TEMP namespace is set up
 * in a particular backend session (this happens when a CREATE TEMP TABLE
 * command is first executed).  Thereafter it's the OID of the temp namespace.
 *
 * myTempToastNamespace is the OID of the namespace for my temp tables' toast
 * tables.  It is set when myTempNamespace is, and is InvalidOid before that.
 *
 * myTempNamespaceSubID shows whether we've created the TEMP namespace in the
 * current subtransaction.  The flag propagates up the subtransaction tree,
 * so the main transaction will correctly recognize the flag if all
 * intermediate subtransactions commit.  When it is InvalidSubTransactionId,
 * we either haven't made the TEMP namespace yet, or have successfully
 * committed its creation, depending on whether myTempNamespace is valid.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>myTempNamespace</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>myTempToastNamespace</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>SubTransactionId</name></type> <name>myTempNamespaceSubID</name> <init>= <expr><name>InvalidSubTransactionId</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This is the user's textual search path specification --- it's the value
 * of the GUC variable 'search_path'.
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>namespace_search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* Local functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>recomputeNamespacePath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AccessTempTableNamespace</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitTempTableNamespace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveTempRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tempNamespaceId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RemoveTempRelationsCallback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NamespaceCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MatchNamedCall</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnumbers</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * RangeVarGetRelidExtended
 *		Given a RangeVar describing an existing relation,
 *		select the proper namespace and look up the relation OID.
 *
 * If the schema or relation is not found, return InvalidOid if flags contains
 * RVR_MISSING_OK, otherwise raise an error.
 *
 * If flags contains RVR_NOWAIT, throw an error if we'd have to wait for a
 * lock.
 *
 * If flags contains RVR_SKIP_LOCKED, return InvalidOid if we'd have to wait
 * for a lock.
 *
 * flags cannot contain both RVR_NOWAIT and RVR_SKIP_LOCKED.
 *
 * Note that if RVR_MISSING_OK and RVR_SKIP_LOCKED are both specified, a
 * return value of InvalidOid could either mean the relation is missing or it
 * could not be locked.
 *
 * Callback allows caller to check permissions or acquire additional locks
 * prior to grabbing the relation lock.
 */</comment>
<function><type><name>Oid</name></type>
<name>RangeVarGetRelidExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
						 <parameter><decl><type><name>uint32</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>RangeVarGetRelidCallback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>callback_arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>inval_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldRelId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>missing_ok</name> <init>= <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RVR_MISSING_OK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* verify that flags do no conflict */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RVR_NOWAIT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RVR_SKIP_LOCKED</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We check the catalog name and then ignore it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>catalogname</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: \"%s.%s.%s\""</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * DDL operations can change the results of a name lookup.  Since all such
	 * operations will generate invalidation messages, we keep track of
	 * whether any such messages show up while we're performing the operation,
	 * and retry until either (1) no more invalidation messages show up or (2)
	 * the answer doesn't change.
	 *
	 * But if lockmode = NoLock, then we assume that either the caller is OK
	 * with the answer changing under them, or that they already hold some
	 * appropriate lock, and therefore return the first answer we get without
	 * checking for invalidation messages.  Also, if the requested lock is
	 * already held, LockRelationOid will not AcceptInvalidationMessages, so
	 * we may fail to notice a change.  We could protect against that case by
	 * calling AcceptInvalidationMessages() before beginning this loop, but
	 * that would add a significant amount overhead, so for now we don't.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Remember this value, so that, after looking up the relation name
		 * and locking its OID, we can check whether any invalidation messages
		 * have been processed that might require a do-over.
		 */</comment>
		<expr_stmt><expr><name>inval_count</name> <operator>=</operator> <name>SharedInvalidMessageCounter</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Some non-default relpersistence value may have been specified.  The
		 * parser never generates such a RangeVar in simple DML, but it can
		 * happen in contexts such as "CREATE TEMP TABLE foo (f1 int PRIMARY
		 * KEY)".  Such a command will generate an added CREATE INDEX
		 * operation, which must be careful to find the temp table, even when
		 * pg_temp is not first in the search path.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>relId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* this probably can't happen? */</comment>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * For missing_ok, allow a non-existent schema name to
					 * return InvalidOid.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>!=</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"temporary tables cannot specify a schema name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>relId</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

			<comment type="block">/* use exact schema given */</comment>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>relId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>relId</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* search the namespace path */</comment>
			<expr_stmt><expr><name>relId</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Invoke caller-supplied callback, if any.
		 *
		 * This callback is a good place to check permissions: we haven't
		 * taken the table lock yet (and it's really best to check permissions
		 * before locking anything!), but we've gotten far enough to know what
		 * OID we think we should lock.  Of course, concurrent DDL might
		 * change things while we're waiting for the lock, but in that case
		 * the callback will be invoked again for the new OID.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>callback</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>callback</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>relId</name></expr></argument>, <argument><expr><name>oldRelId</name></expr></argument>, <argument><expr><name>callback_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If no lock requested, we assume the caller knows what they're
		 * doing.  They should have already acquired a heavyweight lock on
		 * this relation earlier in the processing of this same statement, so
		 * it wouldn't be appropriate to AcceptInvalidationMessages() here, as
		 * that might pull the rug out from under them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>==</operator> <name>NoLock</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If, upon retry, we get back the same OID we did last time, then the
		 * invalidation messages we processed did not change the final answer.
		 * So we're done.
		 *
		 * If we got a different OID, we've locked the relation that used to
		 * have this name rather than the one that does now.  So release the
		 * lock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>retry</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>relId</name> <operator>==</operator> <name>oldRelId</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>oldRelId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Lock relation.  This will also accept any pending invalidation
		 * messages.  If we got back InvalidOid, indicating not found, then
		 * there's nothing to lock, but we accept invalidation messages
		 * anyway, to flush any negative catcache entries that may be
		 * lingering.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AcceptInvalidationMessages</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>RVR_NOWAIT</name> <operator>|</operator> <name>RVR_SKIP_LOCKED</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RVR_SKIP_LOCKED</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on relation \"%s.%s\""</literal></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_LOCK_NOT_AVAILABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not obtain lock on relation \"%s\""</literal></expr></argument>,
								<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<return>return <expr><name>InvalidOid</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If no invalidation message were processed, we're done!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>inval_count</name> <operator>==</operator> <name>SharedInvalidMessageCounter</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Something may have changed.  Let's repeat the name lookup, to make
		 * sure this name still references the same relation it did
		 * previously.
		 */</comment>
		<expr_stmt><expr><name>retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldRelId</name> <operator>=</operator> <name>relId</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name> <init>= <expr><ternary><condition><expr><name>missing_ok</name></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s.%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist"</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>relId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RangeVarGetCreationNamespace
 *		Given a RangeVar describing a to-be-created relation,
 *		choose which namespace to create it in.
 *
 * Note: calling this may result in a CommandCounterIncrement operation.
 * That will happen on the first request for a temp table in any particular
 * backend run; we will need to either create or clean out the temp schema.
 */</comment>
<function><type><name>Oid</name></type>
<name>RangeVarGetCreationNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>newRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We check the catalog name and then ignore it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newRelation</name><operator>-&gt;</operator><name>catalogname</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>newRelation</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: \"%s.%s.%s\""</literal></expr></argument>,
							<argument><expr><name><name>newRelation</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><name><name>newRelation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
							<argument><expr><name><name>newRelation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>newRelation</name><operator>-&gt;</operator><name>schemaname</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for pg_temp alias */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>newRelation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Initialize temp namespace */</comment>
			<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>myTempNamespace</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name><name>newRelation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we do not check for USAGE rights here! */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>newRelation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize temp namespace */</comment>
		<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>myTempNamespace</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* use the default creation namespace */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>activeTempCreationPending</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Need to initialize temp namespace */</comment>
			<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>myTempNamespace</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <name>activeCreationNamespace</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Note: callers will check for CREATE rights when appropriate */</comment>

	<return>return <expr><name>namespaceId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RangeVarGetAndCheckCreationNamespace
 *
 * This function returns the OID of the namespace in which a new relation
 * with a given name should be created.  If the user does not have CREATE
 * permission on the target namespace, this function will instead signal
 * an ERROR.
 *
 * If non-NULL, *existing_oid is set to the OID of any existing relation with
 * the same name which already exists in that namespace, or to InvalidOid if
 * no such relation exists.
 *
 * If lockmode != NoLock, the specified lock mode is acquired on the existing
 * relation, if any, provided that the current user owns the target relation.
 * However, if lockmode != NoLock and the user does not own the target
 * relation, we throw an ERROR, as we must not try to lock relations the
 * user does not have permissions on.
 *
 * As a side effect, this function acquires AccessShareLock on the target
 * namespace.  Without this, the namespace could be dropped before our
 * transaction commits, leaving behind relations with relnamespace pointing
 * to a no-longer-existent namespace.
 *
 * As a further side-effect, if the selected namespace is a temporary namespace,
 * we mark the RangeVar as RELPERSISTENCE_TEMP.
 */</comment>
<function><type><name>Oid</name></type>
<name>RangeVarGetAndCheckCreationNamespace</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>relation</name></decl></parameter>,
									 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>existing_relation_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>inval_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nspid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oldnspid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retry</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We check the catalog name and then ignore it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>catalogname</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: \"%s.%s.%s\""</literal></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>catalogname</name></name></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>schemaname</name></name></expr></argument>,
							<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * As in RangeVarGetRelidExtended(), we guard against concurrent DDL
	 * operations by tracking whether any invalidation messages are processed
	 * while we're doing the name lookups and acquiring locks.  See comments
	 * in that function for a more detailed explanation of this logic.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>inval_count</name> <operator>=</operator> <name>SharedInvalidMessageCounter</name></expr>;</expr_stmt>

		<comment type="block">/* Look up creation namespace and check for existing relation. */</comment>
		<expr_stmt><expr><name>nspid</name> <operator>=</operator> <call><name>RangeVarGetCreationNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>existing_relation_id</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>relid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * In bootstrap processing mode, we don't bother with permissions or
		 * locking.  Permissions might not be working yet, and locking is
		 * unnecessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Check namespace permissions. */</comment>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
						   <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>retry</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* If nothing changed, we're done. */</comment>
			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>oldrelid</name> <operator>&amp;&amp;</operator> <name>nspid</name> <operator>==</operator> <name>oldnspid</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* If creation namespace has changed, give up old lock. */</comment>
			<if_stmt><if>if <condition>(<expr><name>nspid</name> <operator>!=</operator> <name>oldnspid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockDatabaseObject</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>oldnspid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									 <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* If name points to something different, give up old lock. */</comment>
			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name>oldrelid</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>oldrelid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>lockmode</name> <operator>!=</operator> <name>NoLock</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>oldrelid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Lock namespace. */</comment>
		<if_stmt><if>if <condition>(<expr><name>nspid</name> <operator>!=</operator> <name>oldnspid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockDatabaseObject</name><argument_list>(<argument><expr><name>NamespaceRelationId</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Lock relation, if required if and we have permission. */</comment>
		<if_stmt><if>if <condition>(<expr><name>lockmode</name> <operator>!=</operator> <name>NoLock</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>ACLCHECK_NOT_OWNER</name></expr></argument>, <argument><expr><call><name>get_relkind_objtype</name><argument_list>(<argument><expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>!=</operator> <name>oldrelid</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If no invalidation message were processed, we're done! */</comment>
		<if_stmt><if>if <condition>(<expr><name>inval_count</name> <operator>==</operator> <name>SharedInvalidMessageCounter</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Something may have changed, so recheck our work. */</comment>
		<expr_stmt><expr><name>retry</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldrelid</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldnspid</name> <operator>=</operator> <name>nspid</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>RangeVarAdjustRelationPersistence</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>existing_relation_id</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>existing_relation_id</name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>nspid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the relpersistence for an about-to-be-created relation based on the
 * creation namespace, and throw an error for invalid combinations.
 */</comment>
<function><type><name>void</name></type>
<name>RangeVarAdjustRelationPersistence</name><parameter_list>(<parameter><decl><type><name>RangeVar</name> <modifier>*</modifier></type><name>newRelation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>newRelation</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create relations in temporary schemas of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary relation in non-temporary schema"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newRelation</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>=</operator> <name>RELPERSISTENCE_TEMP</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create relations in temporary schemas of other sessions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only temporary relations may be created in temporary schemas"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * RelnameGetRelid
 *		Try to resolve an unqualified relation name.
 *		Returns OID if relation found in search path, else InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>RelnameGetRelid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>relid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RelationIsVisible
 *		Determine whether a relation (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified relation name".
 */</comment>
<function><type><name>bool</name></type>
<name>RelationIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>relnamespace</name> <operator>=</operator> <name><name>relform</name><operator>-&gt;</operator><name>relnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>relnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another relation of the same name earlier in the path. So
		 * we must do a slow check for conflicting relations.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>relform</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>relnamespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * TypenameGetTypid
 *		Wrapper for binary compatibility.
 */</comment>
<function><type><name>Oid</name></type>
<name>TypenameGetTypid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>TypenameGetTypidExtended</name><argument_list>(<argument><expr><name>typname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TypenameGetTypidExtended
 *		Try to resolve an unqualified datatype name.
 *		Returns OID if type found in search path, else InvalidOid.
 *
 * This is essentially the same as RelnameGetRelid.
 */</comment>
<function><type><name>Oid</name></type>
<name>TypenameGetTypidExtended</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>temp_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_ok</name> <operator>&amp;&amp;</operator> <name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<expr_stmt><expr><name>typid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>typid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TypeIsVisible
 *		Determine whether a type (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified type name".
 */</comment>
<function><type><name>bool</name></type>
<name>TypeIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>typnamespace</name> <operator>=</operator> <name><name>typform</name><operator>-&gt;</operator><name>typnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>typnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another type of the same name earlier in the path. So we
		 * must do a slow check for conflicting types.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>typname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typform</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>typnamespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>typname</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * FuncnameGetCandidates
 *		Given a possibly-qualified function name and argument count,
 *		retrieve a list of the possible matches.
 *
 * If nargs is -1, we return all functions matching the given name,
 * regardless of argument count.  (argnames must be NIL, and expand_variadic
 * and expand_defaults must be false, in this case.)
 *
 * If argnames isn't NIL, we are considering a named- or mixed-notation call,
 * and only functions having all the listed argument names will be returned.
 * (We assume that length(argnames) &lt;= nargs and all the passed-in names are
 * distinct.)  The returned structs will include an argnumbers array showing
 * the actual argument index for each logical argument position.
 *
 * If expand_variadic is true, then variadic functions having the same number
 * or fewer arguments will be retrieved, with the variadic argument and any
 * additional argument positions filled with the variadic element type.
 * nvargs in the returned struct is set to the number of such arguments.
 * If expand_variadic is false, variadic arguments are not treated specially,
 * and the returned nvargs will always be zero.
 *
 * If expand_defaults is true, functions that could match after insertion of
 * default argument values will also be retrieved.  In this case the returned
 * structs could have nargs &gt; passed-in nargs, and ndargs is set to the number
 * of additional args (which can be retrieved from the function's
 * proargdefaults entry).
 *
 * It is not possible for nvargs and ndargs to both be nonzero in the same
 * list entry, since default insertion allows matches to functions with more
 * than nargs arguments while the variadic transformation requires the same
 * number or less.
 *
 * When argnames isn't NIL, the returned args[] type arrays are not ordered
 * according to the functions' declarations, but rather according to the call:
 * first any positional arguments, then the named arguments, then defaulted
 * arguments (if needed and allowed by expand_defaults).  The argnumbers[]
 * array can be used to map this back to the catalog information.
 * argnumbers[k] is set to the proargtypes index of the k'th call argument.
 *
 * We search a single namespace if the function name is qualified, else
 * all namespaces in the search path.  In the multiple-namespace case,
 * we arrange for entries in earlier namespaces to mask identical entries in
 * later namespaces.
 *
 * When expanding variadics, we arrange for non-variadic functions to mask
 * variadic ones if the expanded argument list is the same.  It is still
 * possible for there to be conflicts between different variadic functions,
 * however.
 *
 * It is guaranteed that the return list will never contain multiple entries
 * with identical argument lists.  When expand_defaults is true, the entries
 * could have more than nargs positions, but we still guarantee that they are
 * distinct in the first nargs positions.  However, if argnames isn't NIL or
 * either expand_variadic or expand_defaults is true, there might be multiple
 * candidate functions that expand to identical argument lists.  Rather than
 * throw error here, we report such situations by returning a single entry
 * with oid = 0 that represents a set of such conflicting candidates.
 * The caller might end up discarding such an entry anyway, but if it selects
 * such an entry it should react as though the call were ambiguous.
 *
 * If missing_ok is true, an empty list (NULL) is returned if the name was
 * schema- qualified with a schema that does not exist.  Likewise if no
 * candidate is found for other reasons.
 */</comment>
<function><type><name>FuncCandidateList</name></type>
<name>FuncnameGetCandidates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>expand_variadic</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>expand_defaults</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>resultList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>any_special</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>funcname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* check for caller error */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name>expand_variadic</name> <operator>|</operator> <name>expand_defaults</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* flag to indicate we need namespace search */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Search syscache by name only */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pronargs</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>effective_nargs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pathpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>variadic</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>use_defaults</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>va_elem_type</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>argnumbers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>newResult</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Consider only procs in specified namespace */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name> <operator>!=</operator> <name>namespaceId</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Consider only procs that are in the search path and are not in
			 * the temp namespace.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nsp</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>nsp</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name> <operator>!=</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>pathpos</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>nsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* proc is not in search path */</comment>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>argnames</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Call uses named or mixed notation
			 *
			 * Named or mixed notation can match a variadic function only if
			 * expand_variadic is off; otherwise there is no way to match the
			 * presumed-nameless parameters expanded from the variadic array.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>provariadic</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>expand_variadic</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>va_elem_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>variadic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check argument count.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* -1 not supported with argnames */</comment>

			<if_stmt><if>if <condition>(<expr><name>pronargs</name> <operator>&gt;</operator> <name>nargs</name> <operator>&amp;&amp;</operator> <name>expand_defaults</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Ignore if not enough default expressions */</comment>
				<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>+</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronargdefaults</name></name> <operator>&lt;</operator> <name>pronargs</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>use_defaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>use_defaults</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Ignore if it doesn't match requested argument count */</comment>
			<if_stmt><if>if <condition>(<expr><name>pronargs</name> <operator>!=</operator> <name>nargs</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_defaults</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Check for argument name match, generate positional mapping */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>MatchNamedCall</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argnames</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>argnumbers</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Named argument matching is always "special" */</comment>
			<expr_stmt><expr><name>any_special</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Call uses positional notation
			 *
			 * Check if function is variadic, and get variadic element type if
			 * so.  If expand_variadic is false, we should just ignore
			 * variadic-ness.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pronargs</name> <operator>&lt;=</operator> <name>nargs</name> <operator>&amp;&amp;</operator> <name>expand_variadic</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>va_elem_type</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>provariadic</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>variadic</name> <operator>=</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>va_elem_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>any_special</name> <operator>|=</operator> <name>variadic</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>va_elem_type</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>variadic</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Check if function can match by using parameter defaults.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>pronargs</name> <operator>&gt;</operator> <name>nargs</name> <operator>&amp;&amp;</operator> <name>expand_defaults</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Ignore if not enough default expressions */</comment>
				<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>+</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronargdefaults</name></name> <operator>&lt;</operator> <name>pronargs</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>use_defaults</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>any_special</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>use_defaults</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* Ignore if it doesn't match requested argument count */</comment>
			<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pronargs</name> <operator>!=</operator> <name>nargs</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>variadic</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>use_defaults</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * We must compute the effective argument list so that we can easily
		 * compare it to earlier results.  We waste a palloc cycle if it gets
		 * masked by an earlier result, but really that's a pretty infrequent
		 * case so it's not worth worrying about.
		 */</comment>
		<expr_stmt><expr><name>effective_nargs</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>pronargs</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newResult</name> <operator>=</operator> <operator>(</operator><name>FuncCandidateList</name><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr>struct <name>_FuncCandidateList</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>+</operator>
				   <name>effective_nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>pathpos</name></name> <operator>=</operator> <name>pathpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name>effective_nargs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>argnumbers</name></name> <operator>=</operator> <name>argnumbers</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>argnumbers</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Re-order the argument types into call's logical order */</comment>
			<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>proargtypes</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pronargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>proargtypes</name><index>[<expr><name><name>argnumbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Simple positional case, just copy proargtypes as-is */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
				   <argument><expr><name>pronargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>variadic</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>nvargs</name></name> <operator>=</operator> <name>effective_nargs</name> <operator>-</operator> <name>pronargs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<comment type="block">/* Expand variadic argument into N copies of element type */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>pronargs</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>effective_nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>va_elem_type</name></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>nvargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>ndargs</name></name> <operator>=</operator> <ternary><condition><expr><name>use_defaults</name></expr> ?</condition><then> <expr><name>pronargs</name> <operator>-</operator> <name>nargs</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * Does it have the same arguments as something we already accepted?
		 * If so, decide what to do to avoid returning duplicate argument
		 * lists.  We can skip this check for the single-namespace case if no
		 * special (named, variadic or defaults) match has been made, since
		 * then the unique index on pg_proc guarantees all the matches have
		 * different argument lists.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>resultList</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>any_special</name> <operator>||</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we have an ordered list from SearchSysCacheList (the normal
			 * case), then any conflicting proc must immediately adjoin this
			 * one in the list, so we only need to look at the newest result
			 * item.  If we have an unordered list, we have to scan the whole
			 * result list.  Also, if either the current candidate or any
			 * previous candidate is a special match, we can't assume that
			 * conflicts are adjacent.
			 *
			 * We ignore defaulted arguments in deciding what is a match.
			 */</comment>
			<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>prevResult</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>catlist</name><operator>-&gt;</operator><name>ordered</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>any_special</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ndargs must be 0 if !any_special */</comment>
				<if_stmt><if>if <condition>(<expr><name>effective_nargs</name> <operator>==</operator> <name><name>resultList</name><operator>-&gt;</operator><name>nargs</name></name> <operator>&amp;&amp;</operator>
					<call><name>memcmp</name><argument_list>(<argument><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
						   <argument><expr><name><name>resultList</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
						   <argument><expr><name>effective_nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>prevResult</name> <operator>=</operator> <name>resultList</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>prevResult</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>cmp_nargs</name> <init>= <expr><name><name>newResult</name><operator>-&gt;</operator><name>nargs</name></name> <operator>-</operator> <name><name>newResult</name><operator>-&gt;</operator><name>ndargs</name></name></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>prevResult</name> <operator>=</operator> <name>resultList</name></expr>;</init>
					 <condition><expr><name>prevResult</name></expr>;</condition>
					 <incr><expr><name>prevResult</name> <operator>=</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>cmp_nargs</name> <operator>==</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>nargs</name></name> <operator>-</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>ndargs</name></name> <operator>&amp;&amp;</operator>
						<call><name>memcmp</name><argument_list>(<argument><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
							   <argument><expr><name><name>prevResult</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
							   <argument><expr><name>cmp_nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>prevResult</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We have a match with a previous result.  Decide which one
				 * to keep, or mark it ambiguous if we can't decide.  The
				 * logic here is preference &gt; 0 means prefer the old result,
				 * preference &lt; 0 means prefer the new, preference = 0 means
				 * ambiguous.
				 */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>preference</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>pathpos</name> <operator>!=</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>pathpos</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Prefer the one that's earlier in the search path.
					 */</comment>
					<expr_stmt><expr><name>preference</name> <operator>=</operator> <name>pathpos</name> <operator>-</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>pathpos</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>variadic</name> <operator>&amp;&amp;</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>nvargs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * With variadic functions we could have, for example,
					 * both foo(numeric) and foo(variadic numeric[]) in the
					 * same namespace; if so we prefer the non-variadic match
					 * on efficiency grounds.
					 */</comment>
					<expr_stmt><expr><name>preference</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name>variadic</name> <operator>&amp;&amp;</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>nvargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>preference</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*----------
					 * We can't decide.  This can happen with, for example,
					 * both foo(numeric, variadic numeric[]) and
					 * foo(variadic numeric[]) in the same namespace, or
					 * both foo(int) and foo (int, int default something)
					 * in the same namespace, or both foo(a int, b text)
					 * and foo(b text, a int) in the same namespace.
					 *----------
					 */</comment>
					<expr_stmt><expr><name>preference</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>preference</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* keep previous result */</comment>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>preference</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* remove previous result from the list */</comment>
					<if_stmt><if>if <condition>(<expr><name>prevResult</name> <operator>==</operator> <name>resultList</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>resultList</name> <operator>=</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>prevPrevResult</name></decl>;</decl_stmt>

						<for>for <control>(<init><expr><name>prevPrevResult</name> <operator>=</operator> <name>resultList</name></expr>;</init>
							 <condition><expr><name>prevPrevResult</name></expr>;</condition>
							 <incr><expr><name>prevPrevResult</name> <operator>=</operator> <name><name>prevPrevResult</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><name>prevResult</name> <operator>==</operator> <name><name>prevPrevResult</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><name><name>prevPrevResult</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
								<break>break;</break>
							</block_content>}</block></if></if_stmt>
						</block_content>}</block></for>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>prevPrevResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assert we found it */</comment>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prevResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* fall through to add newResult to list */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* mark old result as ambiguous, discard new */</comment>
					<expr_stmt><expr><name><name>prevResult</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newResult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Okay to add it to result list
		 */</comment>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>resultList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultList</name> <operator>=</operator> <name>newResult</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>resultList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * MatchNamedCall
 *		Given a pg_proc heap tuple and a call's list of argument names,
 *		check whether the function could match the call.
 *
 * The call could match if all supplied argument names are accepted by
 * the function, in positions after the last positional argument, and there
 * are defaults for all unsupplied arguments.
 *
 * The number of positional arguments is nargs - list_length(argnames).
 * Note caller has already done basic checks on argument count.
 *
 * On match, return true and fill *argnumbers with a palloc'd array showing
 * the mapping from call argument positions to actual function argument
 * numbers.  Defaulted arguments are included in this map, at positions
 * after the last supplied argument.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MatchNamedCall</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>proctup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>argnames</name></decl></parameter>,
			   <parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>argnumbers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pronargs</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numposargs</name> <init>= <expr><name>nargs</name> <operator>-</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pronallargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>p_argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>p_argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p_argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>arggiven</name><index>[<expr><name>FUNC_MAX_ARGS</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ap</name></decl>;</decl_stmt>				<comment type="block">/* call args position */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pp</name></decl>;</decl_stmt>				<comment type="block">/* proargs position */</comment>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argnames</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numposargs</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nargs</name> <operator>&lt;=</operator> <name>pronargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ignore this function if its proargnames is null */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>proctup</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proargnames</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, let's extract the argument names and types */</comment>
	<expr_stmt><expr><name>pronallargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>p_argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p_argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>p_argnames</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* initialize state for matching */</comment>
	<expr_stmt><expr><operator>*</operator><name>argnumbers</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pronargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>arggiven</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pronargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* there are numposargs positional args before the named args */</comment>
	<for>for <control>(<init><expr><name>ap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ap</name> <operator>&lt;</operator> <name>numposargs</name></expr>;</condition> <incr><expr><name>ap</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argnumbers</name><operator>)</operator><index>[<expr><name>ap</name></expr>]</index> <operator>=</operator> <name>ap</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>arggiven</name><index>[<expr><name>ap</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* now examine the named args */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>argnames</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>pp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pronallargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* consider only input parameters */</comment>
			<if_stmt><if>if <condition>(<expr><name>p_argmodes</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>p_argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>FUNC_PARAM_IN</name> <operator>&amp;&amp;</operator>
				 <name><name>p_argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>FUNC_PARAM_INOUT</name> <operator>&amp;&amp;</operator>
				 <name><name>p_argmodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>FUNC_PARAM_VARIADIC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>p_argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>p_argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>argname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* fail if argname matches a positional argument */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>arggiven</name><index>[<expr><name>pp</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>arggiven</name><index>[<expr><name>pp</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argnumbers</name><operator>)</operator><index>[<expr><name>ap</name></expr>]</index> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* increase pp only for input parameters */</comment>
			<expr_stmt><expr><name>pp</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* if name isn't in proargnames, fail */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ap</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ap</name> <operator>==</operator> <name>nargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* processed all actual parameters */</comment>

	<comment type="block">/* Check for default arguments */</comment>
	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <name>pronargs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>first_arg_with_default</name> <init>= <expr><name>pronargs</name> <operator>-</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronargdefaults</name></name></expr></init></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>pp</name> <operator>=</operator> <name>numposargs</name></expr>;</init> <condition><expr><name>pp</name> <operator>&lt;</operator> <name>pronargs</name></expr>;</condition> <incr><expr><name>pp</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>arggiven</name><index>[<expr><name>pp</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* fail if arg not given and no default available */</comment>
			<if_stmt><if>if <condition>(<expr><name>pp</name> <operator>&lt;</operator> <name>first_arg_with_default</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argnumbers</name><operator>)</operator><index>[<expr><name>ap</name><operator>++</operator></expr>]</index> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ap</name> <operator>==</operator> <name>pronargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* processed all function parameters */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FunctionIsVisible
 *		Determine whether a function (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified function name with exact argument matches".
 */</comment>
<function><type><name>bool</name></type>
<name>FunctionIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>proctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pronamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>proctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>pronamespace</name> <operator>=</operator> <name><name>procform</name><operator>-&gt;</operator><name>pronamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pronamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>pronamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another proc of the same name and arguments earlier in
		 * the path.  So we must do a slow check to see if this is the same
		 * proc that would be found by FuncnameGetCandidates.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><name><name>procform</name><operator>-&gt;</operator><name>pronargs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>clist</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>clist</name> <operator>=</operator> <call><name>FuncnameGetCandidates</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>proname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init>;</init> <condition><expr><name>clist</name></expr>;</condition> <incr><expr><name>clist</name> <operator>=</operator> <name><name>clist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><name>clist</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>procform</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
					   <argument><expr><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found the expected entry; is it the right proc? */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <operator>(</operator><name><name>clist</name><operator>-&gt;</operator><name>oid</name></name> <operator>==</operator> <name>funcid</name><operator>)</operator></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>proctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OpernameGetOprid
 *		Given a possibly-qualified operator name and exact input datatypes,
 *		look up the operator.  Returns InvalidOid if not found.
 *
 * Pass oprleft = InvalidOid for a prefix op, oprright = InvalidOid for
 * a postfix op.
 *
 * If the operator name is not schema-qualified, it is sought in the current
 * namespace search path.  If the name is schema-qualified and the given
 * schema does not exist, InvalidOid is returned.
 */</comment>
<function><type><name>Oid</name></type>
<name>OpernameGetOprid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oprleft</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oprright</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opername</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* search only in exact schema given */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>opertup</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>OPERNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opername</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Search syscache by name and argument types */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList3</name><argument_list>(<argument><expr><name>OPERNAMENSP</name></expr></argument>,
								  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opername</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprleft</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprright</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no hope, fall out early */</comment>
		<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have to find the list member that is first in the search path, if
	 * there's more than one.  This doubly-nested loop looks ugly, but in
	 * practice there should usually be few catlist members.
	 */</comment>
	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name> <operator>==</operator> <name>namespaceId</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OpernameGetCandidates
 *		Given a possibly-qualified operator name and operator kind,
 *		retrieve a list of the possible matches.
 *
 * If oprkind is '\0', we return all operators matching the given name,
 * regardless of arguments.
 *
 * We search a single namespace if the operator name is qualified, else
 * all namespaces in the search path.  The return list will never contain
 * multiple entries with identical argument lists --- in the multiple-
 * namespace case, we arrange for entries in earlier namespaces to mask
 * identical entries in later namespaces.
 *
 * The returned items always have two args[] entries --- one or the other
 * will be InvalidOid for a prefix or postfix oprkind.  nargs is 2, too.
 */</comment>
<function><type><name>FuncCandidateList</name></type>
<name>OpernameGetCandidates</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>oprkind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_schema_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>resultList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>resultSpace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nextResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opername</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_schema_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_schema_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* flag to indicate we need namespace search */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Search syscache by name only */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>OPERNAMENSP</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>opername</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In typical scenarios, most if not all of the operators found by the
	 * catcache search will end up getting returned; and there can be quite a
	 * few, for common operator names such as '=' or '+'.  To reduce the time
	 * spent in palloc, we allocate the result space as an array large enough
	 * to hold all the operators.  The original coding of this routine did a
	 * separate palloc for each operator, but profiling revealed that the
	 * pallocs used an unreasonably large fraction of parsing time.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPACE_PER_OP</name></cpp:macro> <cpp:value>MAXALIGN(offsetof(struct _FuncCandidateList, args) + \
							  2 * sizeof(Oid))</cpp:value></cpp:define>

	<if_stmt><if>if <condition>(<expr><name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>resultSpace</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name> <operator>*</operator> <name>SPACE_PER_OP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opertup</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>operform</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>pathpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>newResult</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore operators of wrong kind, if specific kind requested */</comment>
		<if_stmt><if>if <condition>(<expr><name>oprkind</name> <operator>&amp;&amp;</operator> <name><name>operform</name><operator>-&gt;</operator><name>oprkind</name></name> <operator>!=</operator> <name>oprkind</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Consider only opers in specified namespace */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name> <operator>!=</operator> <name>namespaceId</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<comment type="block">/* No need to check args, they must all be different */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Consider only opers that are in the search path and are not in
			 * the temp namespace.
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>nsp</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>nsp</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>operform</name><operator>-&gt;</operator><name>oprnamespace</name></name> <operator>!=</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>pathpos</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><name>nsp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* oper is not in search path */</comment>

			<comment type="block">/*
			 * Okay, it's in the search path, but does it have the same
			 * arguments as something we already accepted?	If so, keep only
			 * the one that appears earlier in the search path.
			 *
			 * If we have an ordered list from SearchSysCacheList (the normal
			 * case), then any conflicting oper must immediately adjoin this
			 * one in the list, so we only need to look at the newest result
			 * item.  If we have an unordered list, we have to scan the whole
			 * result list.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>resultList</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FuncCandidateList</name></type> <name>prevResult</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>catlist</name><operator>-&gt;</operator><name>ordered</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name> <operator>==</operator> <name><name>resultList</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
						<name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name> <operator>==</operator> <name><name>resultList</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>prevResult</name> <operator>=</operator> <name>resultList</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>prevResult</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<for>for <control>(<init><expr><name>prevResult</name> <operator>=</operator> <name>resultList</name></expr>;</init>
						 <condition><expr><name>prevResult</name></expr>;</condition>
						 <incr><expr><name>prevResult</name> <operator>=</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name> <operator>==</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
							<name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name> <operator>==</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>prevResult</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We have a match with a previous result */</comment>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pathpos</name> <operator>!=</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>pathpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>pathpos</name> <operator>&gt;</operator> <name><name>prevResult</name><operator>-&gt;</operator><name>pathpos</name></name></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* keep previous result */</comment>
					<comment type="block">/* replace previous result */</comment>
					<expr_stmt><expr><name><name>prevResult</name><operator>-&gt;</operator><name>pathpos</name></name> <operator>=</operator> <name>pathpos</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>prevResult</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<continue>continue;</continue>	<comment type="block">/* args are same, of course */</comment>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Okay to add it to result list
		 */</comment>
		<expr_stmt><expr><name>newResult</name> <operator>=</operator> <operator>(</operator><name>FuncCandidateList</name><operator>)</operator> <operator>(</operator><name>resultSpace</name> <operator>+</operator> <name>nextResult</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextResult</name> <operator>+=</operator> <name>SPACE_PER_OP</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>pathpos</name></name> <operator>=</operator> <name>pathpos</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>oid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>opertup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>nvargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>ndargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>argnumbers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>operform</name><operator>-&gt;</operator><name>oprleft</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>operform</name><operator>-&gt;</operator><name>oprright</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newResult</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>resultList</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>resultList</name> <operator>=</operator> <name>newResult</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>resultList</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OperatorIsVisible
 *		Determine whether an operator (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified operator name with exact argument matches".
 */</comment>
<function><type><name>bool</name></type>
<name>OperatorIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oprid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oprtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>oprform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oprnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oprtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>oprtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>oprform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oprtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>oprnamespace</name> <operator>=</operator> <name><name>oprform</name><operator>-&gt;</operator><name>oprnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oprnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>oprnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another operator of the same name and arguments earlier
		 * in the path.  So we must do a slow check to see if this is the same
		 * operator that would be found by OpernameGetOprid.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oprname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>oprform</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <operator>(</operator><call><name>OpernameGetOprid</name><argument_list>(<argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>oprname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name><name>oprform</name><operator>-&gt;</operator><name>oprleft</name></name></expr></argument>, <argument><expr><name><name>oprform</name><operator>-&gt;</operator><name>oprright</name></name></expr></argument>)</argument_list></call>
				   <operator>==</operator> <name>oprid</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>oprtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * OpclassnameGetOpcid
 *		Try to resolve an unqualified index opclass name.
 *		Returns OID if opclass found in search path, else InvalidOid.
 *
 * This is essentially the same as TypenameGetTypid, but we have to have
 * an extra argument for the index AM OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>OpclassnameGetOpcid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>amid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<expr_stmt><expr><name>opcid</name> <operator>=</operator> <call><name>GetSysCacheOid3</name><argument_list>(<argument><expr><name>CLAAMNAMENSP</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>opcid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OpclassIsVisible
 *		Determine whether an opclass (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified opclass name".
 */</comment>
<function><type><name>bool</name></type>
<name>OpclassIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opctup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>opcform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opctup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opctup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opcform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>opcnamespace</name> <operator>=</operator> <name><name>opcform</name><operator>-&gt;</operator><name>opcnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>opcnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>opcnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another opclass of the same name earlier in the path. So
		 * we must do a slow check to see if this opclass would be found by
		 * OpclassnameGetOpcid.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opcname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opcform</name><operator>-&gt;</operator><name>opcname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <operator>(</operator><call><name>OpclassnameGetOpcid</name><argument_list>(<argument><expr><name><name>opcform</name><operator>-&gt;</operator><name>opcmethod</name></name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>opcid</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opctup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OpfamilynameGetOpfid
 *		Try to resolve an unqualified index opfamily name.
 *		Returns OID if opfamily found in search path, else InvalidOid.
 *
 * This is essentially the same as TypenameGetTypid, but we have to have
 * an extra argument for the index AM OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>OpfamilynameGetOpfid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>amid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opfname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<expr_stmt><expr><name>opfid</name> <operator>=</operator> <call><name>GetSysCacheOid3</name><argument_list>(<argument><expr><name>OPFAMILYAMNAMENSP</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>amid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>opfname</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>opfid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OpfamilyIsVisible
 *		Determine whether an opfamily (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified opfamily name".
 */</comment>
<function><type><name>bool</name></type>
<name>OpfamilyIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>opftup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opfamily</name></type> <name>opfform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opftup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPFAMILYOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>opftup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>opfform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opfamily</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>opftup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>opfnamespace</name> <operator>=</operator> <name><name>opfform</name><operator>-&gt;</operator><name>opfnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>opfnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>opfnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another opfamily of the same name earlier in the path. So
		 * we must do a slow check to see if this opfamily would be found by
		 * OpfamilynameGetOpfid.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opfname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>opfform</name><operator>-&gt;</operator><name>opfname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <operator>(</operator><call><name>OpfamilynameGetOpfid</name><argument_list>(<argument><expr><name><name>opfform</name><operator>-&gt;</operator><name>opfmethod</name></name></expr></argument>, <argument><expr><name>opfname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>opfid</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>opftup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup_collation
 *		If there's a collation of the given name/namespace, and it works
 *		with the given encoding, return its OID.  Else return InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>lookup_collation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collnamespace</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>colltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collform</name></decl>;</decl_stmt>

	<comment type="block">/* Check for encoding-specific entry (exact match) */</comment>
	<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>GetSysCacheOid3</name><argument_list>(<argument><expr><name>COLLNAMEENCNSP</name></expr></argument>,
							 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>collid</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check for any-encoding entry.  This takes a bit more work: while libc
	 * collations with collencoding = -1 do work with all encodings, ICU
	 * collations only work with certain encodings, so we have to check that
	 * aspect before deciding it's a match.
	 */</comment>
	<expr_stmt><expr><name>colltup</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>COLLNAMEENCNSP</name></expr></argument>,
							  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>collform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>collform</name><operator>-&gt;</operator><name>collprovider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>is_encoding_supported_by_icu</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>collid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>collid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CollationGetCollid
 *		Try to resolve an unqualified collation name.
 *		Returns OID if collation found in search path, else InvalidOid.
 *
 * Note that this will only find collations that work with the current
 * database's encoding.
 */</comment>
<function><type><name>Oid</name></type>
<name>CollationGetCollid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>collname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dbencoding</name> <init>= <expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>collid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<expr_stmt><expr><name>collid</name> <operator>=</operator> <call><name>lookup_collation</name><argument_list>(<argument><expr><name>collname</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>dbencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>collid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CollationIsVisible
 *		Determine whether a collation (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified collation name".
 *
 * Note that only collations that work with the current database's encoding
 * will be considered visible.
 */</comment>
<function><type><name>bool</name></type>
<name>CollationIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>colltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>collform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>colltup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>collform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>collnamespace</name> <operator>=</operator> <name><name>collform</name><operator>-&gt;</operator><name>collnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>collnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>collnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another collation of the same name earlier in the path,
		 * or it might not work with the current DB encoding.  So we must do a
		 * slow check to see if this collation would be found by
		 * CollationGetCollid.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>collform</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <operator>(</operator><call><name>CollationGetCollid</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>collid</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>colltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ConversionGetConid
 *		Try to resolve an unqualified conversion name.
 *		Returns OID if conversion found in search path, else InvalidOid.
 *
 * This is essentially the same as RelnameGetRelid.
 */</comment>
<function><type><name>Oid</name></type>
<name>ConversionGetConid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>conname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>conid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<expr_stmt><expr><name>conid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>CONNAMENSP</name></expr></argument>,
								<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>conid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>conid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ConversionIsVisible
 *		Determine whether a conversion (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified conversion name".
 */</comment>
<function><type><name>bool</name></type>
<name>ConversionIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>contup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_conversion</name></type> <name>conform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>connamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>contup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONVOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>conid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for conversion %u"</literal></expr></argument>, <argument><expr><name>conid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>conform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_conversion</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>connamespace</name> <operator>=</operator> <name><name>conform</name><operator>-&gt;</operator><name>connamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>connamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>connamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another conversion of the same name earlier in the path.
		 * So we must do a slow check to see if this conversion would be found
		 * by ConversionGetConid.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>conform</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <operator>(</operator><call><name>ConversionGetConid</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>conid</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>contup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_statistics_object_oid - find a statistics object by possibly qualified name
 *
 * If not found, returns InvalidOid if missing_ok, else throws error
 */</comment>
<function><type><name>Oid</name></type>
<name>get_statistics_object_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stats_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>stats_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stats_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>stats_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stats_oid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>STATEXTNAMENSP</name></expr></argument>,
										<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stats_name</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>
			<expr_stmt><expr><name>stats_oid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>STATEXTNAMENSP</name></expr></argument>,
										<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stats_name</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>stats_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>stats_oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statistics object \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>stats_oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StatisticsObjIsVisible
 *		Determine whether a statistics object (identified by OID) is visible in
 *		the current search path.  Visible means "would be found by searching
 *		for the unqualified statistics object name".
 */</comment>
<function><type><name>bool</name></type>
<name>StatisticsObjIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>stxtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_statistic_ext</name></type> <name>stxform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>stxnamespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stxtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>stxtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for statistics object %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>stxform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic_ext</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>stxtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>stxnamespace</name> <operator>=</operator> <name><name>stxform</name><operator>-&gt;</operator><name>stxnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stxnamespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>stxnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another statistics object of the same name earlier in the
		 * path. So we must do a slow check for conflicting objects.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stxname</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>stxform</name><operator>-&gt;</operator><name>stxname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>stxnamespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>STATEXTNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>stxname</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>stxtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ts_parser_oid - find a TS parser by possibly qualified name
 *
 * If not found, returns InvalidOid if missing_ok, else throws error
 */</comment>
<function><type><name>Oid</name></type>
<name>get_ts_parser_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>parser_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>prsoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>parser_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>prsoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>prsoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSPARSERNAMENSP</name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parser_name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<expr_stmt><expr><name>prsoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSPARSERNAMENSP</name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>parser_name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>prsoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>prsoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search parser \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>prsoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TSParserIsVisible
 *		Determine whether a parser (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified parser name".
 */</comment>
<function><type><name>bool</name></type>
<name>TSParserIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>prsId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_ts_parser</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSPARSEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search parser %u"</literal></expr></argument>, <argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_parser</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>namespace</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>prsnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another parser of the same name earlier in the path. So
		 * we must do a slow check for conflicting parsers.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>prsname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>namespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>TSPARSERNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ts_dict_oid - find a TS dictionary by possibly qualified name
 *
 * If not found, returns InvalidOid if failOK, else throws error
 */</comment>
<function><type><name>Oid</name></type>
<name>get_ts_dict_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>dict_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dictoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dict_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dictoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dictoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSDICTNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dict_name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<expr_stmt><expr><name>dictoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSDICTNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dict_name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dictoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dictoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search dictionary \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>dictoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TSDictionaryIsVisible
 *		Determine whether a dictionary (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified dictionary name".
 */</comment>
<function><type><name>bool</name></type>
<name>TSDictionaryIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dictId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_ts_dict</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dictId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search dictionary %u"</literal></expr></argument>,
			 <argument><expr><name>dictId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_dict</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>namespace</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>dictnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another dictionary of the same name earlier in the path.
		 * So we must do a slow check for conflicting dictionaries.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>dictname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>namespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>TSDICTNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ts_template_oid - find a TS template by possibly qualified name
 *
 * If not found, returns InvalidOid if missing_ok, else throws error
 */</comment>
<function><type><name>Oid</name></type>
<name>get_ts_template_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>template_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tmploid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>template_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmploid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmploid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSTEMPLATENAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>template_name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<expr_stmt><expr><name>tmploid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSTEMPLATENAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>template_name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tmploid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>tmploid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search template \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tmploid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TSTemplateIsVisible
 *		Determine whether a template (identified by OID) is visible in the
 *		current search path.  Visible means "would be found by searching
 *		for the unqualified template name".
 */</comment>
<function><type><name>bool</name></type>
<name>TSTemplateIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tmplId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_ts_template</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSTEMPLATEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>tmplId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search template %u"</literal></expr></argument>, <argument><expr><name>tmplId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_template</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>namespace</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>tmplnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another template of the same name earlier in the path. So
		 * we must do a slow check for conflicting templates.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>tmplname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>namespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>TSTEMPLATENAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ts_config_oid - find a TS config by possibly qualified name
 *
 * If not found, returns InvalidOid if missing_ok, else throws error
 */</comment>
<function><type><name>Oid</name></type>
<name>get_ts_config_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>config_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cfgoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>config_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cfgoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cfgoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSCONFIGNAMENSP</name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>config_name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<expr_stmt><expr><name>cfgoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TSCONFIGNAMENSP</name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>config_name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cfgoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cfgoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search configuration \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cfgoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * TSConfigIsVisible
 *		Determine whether a text search configuration (identified by OID)
 *		is visible in the current search path.  Visible means "would be found
 *		by searching for the unqualified text search configuration name".
 */</comment>
<function><type><name>bool</name></type>
<name>TSConfigIsVisible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>cfgid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_ts_config</name></type> <name>form</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>visible</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>cfgid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search configuration %u"</literal></expr></argument>,
			 <argument><expr><name>cfgid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>form</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_config</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Quick check: if it ain't in the path at all, it ain't visible. Items in
	 * the system namespace are surely in the path and so we needn't even do
	 * list_member_oid() for them.
	 */</comment>
	<expr_stmt><expr><name>namespace</name> <operator>=</operator> <name><name>form</name><operator>-&gt;</operator><name>cfgnamespace</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>namespace</name> <operator>!=</operator> <name>PG_CATALOG_NAMESPACE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>, <argument><expr><name>namespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If it is in the path, it might still not be visible; it could be
		 * hidden by another configuration of the same name earlier in the
		 * path. So we must do a slow check for conflicting configurations.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>form</name><operator>-&gt;</operator><name>cfgname</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>namespace</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found it first in path */</comment>
				<expr_stmt><expr><name>visible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists2</name><argument_list>(<argument><expr><name>TSCONFIGNAMENSP</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found something else first in path */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>visible</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * DeconstructQualifiedName
 *		Given a possibly-qualified name expressed as a list of String nodes,
 *		extract the schema name and object name.
 *
 * *nspname_p is set to NULL if there is no explicit schema name.
 */</comment>
<function><type><name>void</name></type>
<name>DeconstructQualifiedName</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nspname_p</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objname_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>catalogname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>objname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>objname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><name>catalogname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>schemaname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>objname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * We check the catalog name and then ignore it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>catalogname</name></expr></argument>, <argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cross-database references are not implemented: %s"</literal></expr></argument>,
								<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper qualified name (too many dotted names): %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>nspname_p</name> <operator>=</operator> <name>schemaname</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>objname_p</name> <operator>=</operator> <name>objname</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LookupNamespaceNoError
 *		Look up a schema name.
 *
 * Returns the namespace OID, or InvalidOid if not found.
 *
 * Note this does NOT perform any permissions check --- callers are
 * responsible for being sure that an appropriate check is made.
 * In the majority of cases LookupExplicitNamespace is preferable.
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupNamespaceNoError</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* check for pg_temp alias */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>InvokeNamespaceSearchHook</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>myTempNamespace</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Since this is used only for looking up existing objects, there is
		 * no point in trying to initialize the temp namespace here; and doing
		 * so might create problems for some callers. Just report "not found".
		 */</comment>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LookupExplicitNamespace
 *		Process an explicitly-specified schema name: look up the schema
 *		and verify we have USAGE (lookup) rights in it.
 *
 * Returns the namespace OID
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupExplicitNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/* check for pg_temp alias */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>myTempNamespace</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Since this is used only for looking up existing objects, there is
		 * no point in trying to initialize the temp namespace here; and doing
		 * so might create problems for some callers --- just fall through.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Schema search hook for this lookup */</comment>
	<expr_stmt><expr><call><name>InvokeNamespaceSearchHook</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>namespaceId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * LookupCreationNamespace
 *		Look up the schema and verify we have CREATE rights on it.
 *
 * This is just like LookupExplicitNamespace except for the different
 * permission check, and that we are willing to create pg_temp if needed.
 *
 * Note: calling this may result in a CommandCounterIncrement operation,
 * if we have to create or clean out the temp namespace.
 */</comment>
<function><type><name>Oid</name></type>
<name>LookupCreationNamespace</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>

	<comment type="block">/* check for pg_temp alias */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Initialize temp namespace */</comment>
		<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>myTempNamespace</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_CREATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>aclcheck_error</name><argument_list>(<argument><expr><name>aclresult</name></expr></argument>, <argument><expr><name>OBJECT_SCHEMA</name></expr></argument>,
					   <argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>namespaceId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common checks on switching namespaces.
 *
 * We complain if either the old or new namespaces is a temporary schema
 * (or temporary toast schema), or if either the old or new namespaces is the
 * TOAST schema.
 */</comment>
<function><type><name>void</name></type>
<name>CheckSetNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oldNspOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>nspOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* disallow renaming into or out of temp schemas */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>nspOid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>oldNspOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move objects into or out of temporary schemas"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* same for TOAST schema */</comment>
	<if_stmt><if>if <condition>(<expr><name>nspOid</name> <operator>==</operator> <name>PG_TOAST_NAMESPACE</name> <operator>||</operator> <name>oldNspOid</name> <operator>==</operator> <name>PG_TOAST_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot move objects into or out of TOAST schema"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * QualifiedNameGetCreationNamespace
 *		Given a possibly-qualified name for an object (in List-of-Values
 *		format), determine what namespace the object should be created in.
 *		Also extract and return the object name (last component of list).
 *
 * Note: this does not apply any permissions check.  Callers must check
 * for CREATE rights on the selected namespace when appropriate.
 *
 * Note: calling this may result in a CommandCounterIncrement operation,
 * if we have to create or clean out the temp namespace.
 */</comment>
<function><type><name>Oid</name></type>
<name>QualifiedNameGetCreationNamespace</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>objname_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><name>objname_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* check for pg_temp alias */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Initialize temp namespace */</comment>
			<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>myTempNamespace</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* we do not check for USAGE rights here! */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* use the default creation namespace */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>activeTempCreationPending</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Need to initialize temp namespace */</comment>
			<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>myTempNamespace</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <name>activeCreationNamespace</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no schema has been selected to create in"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>namespaceId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_namespace_oid - given a namespace name, look up the OID
 *
 * If missing_ok is false, throw an error if namespace name not found.  If
 * true, just return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_namespace_oid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>oid</name> <operator>=</operator> <call><name>GetSysCacheOid1</name><argument_list>(<argument><expr><name>NAMESPACENAME</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_SCHEMA</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"schema \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>nspname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>oid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * makeRangeVarFromNameList
 *		Utility routine to convert a qualified-name list into RangeVar form.
 */</comment>
<function><type><name>RangeVar</name> <modifier>*</modifier></type>
<name>makeRangeVarFromNameList</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>catalogname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>schemaname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"improper relation name (too many dotted names): %s"</literal></expr></argument>,
							<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * NameListToString
 *		Utility routine to convert a qualified-name list into a string.
 *
 * This is used primarily to form error messages, and so we do not quote
 * the list elements, for the sake of legibility.
 *
 * In most scenarios the list elements should always be Value strings,
 * but we also allow A_Star for the convenience of ColumnRef processing.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>NameListToString</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>names</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected node type in name list: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>string</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * NameListToQuotedString
 *		Utility routine to convert a qualified-name list into a string.
 *
 * Same as above except that names will be double-quoted where necessary,
 * so the string could be re-parsed (eg, by textToQualifiedNameList).
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>NameListToQuotedString</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>names</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>names</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>string</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name><name>string</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isTempNamespace - is the given namespace my temporary-table namespace?
 */</comment>
<function><type><name>bool</name></type>
<name>isTempNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>myTempNamespace</name> <operator>==</operator> <name>namespaceId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isTempToastNamespace - is the given namespace my temporary-toast-table
 *		namespace?
 */</comment>
<function><type><name>bool</name></type>
<name>isTempToastNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempToastNamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>myTempToastNamespace</name> <operator>==</operator> <name>namespaceId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isTempOrTempToastNamespace - is the given namespace my temporary-table
 *		namespace or my temporary-toast-table namespace?
 */</comment>
<function><type><name>bool</name></type>
<name>isTempOrTempToastNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>myTempNamespace</name> <operator>==</operator> <name>namespaceId</name> <operator>||</operator> <name>myTempToastNamespace</name> <operator>==</operator> <name>namespaceId</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isAnyTempNamespace - is the given namespace a temporary-table namespace
 * (either my own, or another backend's)?  Temporary-toast-table namespaces
 * are included, too.
 */</comment>
<function><type><name>bool</name></type>
<name>isAnyTempNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<comment type="block">/* True if the namespace name starts with "pg_temp_" or "pg_toast_temp_" */</comment>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no such namespace? */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp_"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><call><name>strncmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_temp_"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isOtherTempNamespace - is the given namespace some other backend's
 * temporary-table namespace (including temporary-toast-table namespaces)?
 *
 * Note: for most purposes in the C code, this function is obsolete.  Use
 * RELATION_IS_OTHER_TEMP() instead to detect non-local temp relations.
 */</comment>
<function><type><name>bool</name></type>
<name>isOtherTempNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If it's my own temp namespace, say "false" */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Else, if it's any temp namespace, say "true" */</comment>
	<return>return <expr><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkTempNamespaceStatus - is the given namespace owned and actively used
 * by a backend?
 *
 * Note: this can be used while scanning relations in pg_class to detect
 * orphaned temporary tables or namespaces with a backend connected to a
 * given database.  The result may be out of date quickly, so the caller
 * must be careful how to handle this information.
 */</comment>
<function><type><name>TempNamespaceStatus</name></type>
<name>checkTempNamespaceStatus</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>backendId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>backendId</name> <operator>=</operator> <call><name>GetTempNamespaceBackendId</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No such namespace, or its name shows it's not temp? */</comment>
	<if_stmt><if>if <condition>(<expr><name>backendId</name> <operator>==</operator> <name>InvalidBackendId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TEMP_NAMESPACE_NOT_TEMP</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Is the backend alive? */</comment>
	<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>BackendIdGetProc</name><argument_list>(<argument><expr><name>backendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>proc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TEMP_NAMESPACE_IDLE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Is the backend connected to the same database we are looking at? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>databaseId</name></name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TEMP_NAMESPACE_IDLE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Does the backend own the temporary namespace? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>!=</operator> <name>namespaceId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TEMP_NAMESPACE_IDLE</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Yup, so namespace is busy */</comment>
	<return>return <expr><name>TEMP_NAMESPACE_IN_USE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isTempNamespaceInUse - oversimplified, deprecated version of
 * checkTempNamespaceStatus
 */</comment>
<function><type><name>bool</name></type>
<name>isTempNamespaceInUse</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>checkTempNamespaceStatus</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEMP_NAMESPACE_IN_USE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetTempNamespaceBackendId - if the given namespace is a temporary-table
 * namespace (either my own, or another backend's), return the BackendId
 * that owns it.  Temporary-toast-table namespaces are included, too.
 * If it isn't a temp namespace, return InvalidBackendId.
 */</comment>
<function><type><name>int</name></type>
<name>GetTempNamespaceBackendId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>

	<comment type="block">/* See if the namespace name starts with "pg_temp_" or "pg_toast_temp_" */</comment>
	<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidBackendId</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* no such namespace? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp_"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>nspname</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_temp_"</literal></expr></argument>, <argument><expr><literal type="number">14</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>nspname</name> <operator>+</operator> <literal type="number">14</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetTempToastNamespace - get the OID of my temporary-toast-table namespace,
 * which must already be assigned.  (This is only used when creating a toast
 * table for a temp table, so we must have already done InitTempTableNamespace)
 */</comment>
<function><type><name>Oid</name></type>
<name>GetTempToastNamespace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempToastNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>myTempToastNamespace</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetTempNamespaceState - fetch status of session's temporary namespace
 *
 * This is used for conveying state to a parallel worker, and is not meant
 * for general-purpose access.
 */</comment>
<function><type><name>void</name></type>
<name>GetTempNamespaceState</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>tempNamespaceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>tempToastNamespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Return namespace OIDs, or 0 if session has not created temp namespace */</comment>
	<expr_stmt><expr><operator>*</operator><name>tempNamespaceId</name> <operator>=</operator> <name>myTempNamespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>tempToastNamespaceId</name> <operator>=</operator> <name>myTempToastNamespace</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SetTempNamespaceState - set status of session's temporary namespace
 *
 * This is used for conveying state to a parallel worker, and is not meant for
 * general-purpose access.  By transferring these namespace OIDs to workers,
 * we ensure they will have the same notion of the search path as their leader
 * does.
 */</comment>
<function><type><name>void</name></type>
<name>SetTempNamespaceState</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tempNamespaceId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>tempToastNamespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Worker should not have created its own namespaces ... */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myTempNamespace</name> <operator>==</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myTempToastNamespace</name> <operator>==</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>myTempNamespaceSubID</name> <operator>==</operator> <name>InvalidSubTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign same namespace OIDs that leader has */</comment>
	<expr_stmt><expr><name>myTempNamespace</name> <operator>=</operator> <name>tempNamespaceId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>myTempToastNamespace</name> <operator>=</operator> <name>tempToastNamespaceId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's fine to leave myTempNamespaceSubID == InvalidSubTransactionId.
	 * Even if the namespace is new so far as the leader is concerned, it's
	 * not new to the worker, and we certainly wouldn't want the worker trying
	 * to destroy it.
	 */</comment>

	<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* may need to rebuild list */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * GetOverrideSearchPath - fetch current search path definition in form
 * used by PushOverrideSearchPath.
 *
 * The result structure is allocated in the specified memory context
 * (which might or might not be equal to CurrentMemoryContext); but any
 * junk created by revalidation calculations will be in CurrentMemoryContext.
 */</comment>
<function><type><name>OverrideSearchPath</name> <modifier>*</modifier></type>
<name>GetOverrideSearchPath</name><parameter_list>(<parameter><decl><type><name>MemoryContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>schemas</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>OverrideSearchPath</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OverrideSearchPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>schemas</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>schemas</name> <operator>&amp;&amp;</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>schemas</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>activeCreationNamespace</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>schemas</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>addTemp</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name>schemas</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>addCatalog</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>schemas</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>schemas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>schemas</name></name> <operator>=</operator> <name>schemas</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CopyOverrideSearchPath - copy the specified OverrideSearchPath.
 *
 * The result structure is allocated in CurrentMemoryContext.
 */</comment>
<function><type><name>OverrideSearchPath</name> <modifier>*</modifier></type>
<name>CopyOverrideSearchPath</name><parameter_list>(<parameter><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>OverrideSearchPath</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OverrideSearchPath</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>schemas</name></name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>schemas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>addCatalog</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>addCatalog</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>addTemp</name></name> <operator>=</operator> <name><name>path</name><operator>-&gt;</operator><name>addTemp</name></name></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OverrideSearchPathMatchesCurrent - does path match current setting?
 */</comment>
<function><type><name>bool</name></type>
<name>OverrideSearchPathMatchesCurrent</name><parameter_list>(<parameter><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>lcp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We scan down the activeSearchPath to see if it matches the input. */</comment>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If path-&gt;addTemp, first item should be my temp namespace. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>addTemp</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>&amp;&amp;</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* If path-&gt;addCatalog, next item should be pg_catalog. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>path</name><operator>-&gt;</operator><name>addCatalog</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>&amp;&amp;</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* We should now be looking at the activeCreationNamespace. */</comment>
	<if_stmt><if>if <condition>(<expr><name>activeCreationNamespace</name> <operator>!=</operator> <operator>(</operator><ternary><condition><expr><name>lc</name></expr> ?</condition><then> <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* The remainder of activeSearchPath should match path-&gt;schemas. */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lcp</argument>, <argument>path-&gt;schemas</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lc</name> <operator>&amp;&amp;</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lcp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><name>lc</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PushOverrideSearchPath - temporarily override the search path
 *
 * We allow nested overrides, hence the push/pop terminology.  The GUC
 * search_path variable is ignored while an override is active.
 *
 * It's possible that newpath-&gt;useTemp is set but there is no longer any
 * active temp namespace, if the path was saved during a transaction that
 * created a temp namespace and was later rolled back.  In that case we just
 * ignore useTemp.  A plausible alternative would be to create a new temp
 * namespace, but for existing callers that's not necessary because an empty
 * temp namespace wouldn't affect their results anyway.
 *
 * It's also worth noting that other schemas listed in newpath might not
 * exist anymore either.  We don't worry about this because OIDs that match
 * no existing namespace will simply not produce any hits during searches.
 */</comment>
<function><type><name>void</name></type>
<name>PushOverrideSearchPath</name><parameter_list>(<parameter><decl><type><name>OverrideSearchPath</name> <modifier>*</modifier></type><name>newpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OverrideStackEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>firstNS</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Copy the list for safekeeping, and insert implicitly-searched
	 * namespaces as needed.  This code should track recomputeNamespacePath.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name><name>newpath</name><operator>-&gt;</operator><name>schemas</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember the first member of the explicit list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oidlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstNS</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstNS</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Add any implicitly-searched namespaces to the list.  Note these go on
	 * the front, not the back; also notice that we do not check USAGE
	 * permissions for these.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newpath</name><operator>-&gt;</operator><name>addCatalog</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>newpath</name><operator>-&gt;</operator><name>addTemp</name></name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>, <argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Build the new stack entry, then insert it at the head of the list.
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>OverrideStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OverrideStackEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name> <operator>=</operator> <name>oidlist</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>creationNamespace</name></name> <operator>=</operator> <name>firstNS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>nestLevel</name></name> <operator>=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>overrideStack</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And make it active. */</comment>
	<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>creationNamespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* XXX is this OK? */</comment>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * PopOverrideSearchPath - undo a previous PushOverrideSearchPath
 *
 * Any push during a (sub)transaction will be popped automatically at abort.
 * But it's caller error if a push isn't popped in normal control flow.
 */</comment>
<function><type><name>void</name></type>
<name>PopOverrideSearchPath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OverrideStackEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<comment type="block">/* Sanity checks. */</comment>
	<if_stmt><if>if <condition>(<expr><name>overrideStack</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus PopOverrideSearchPath call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>OverrideStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>nestLevel</name></name> <operator>!=</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus PopOverrideSearchPath call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Pop the stack and free storage. */</comment>
	<expr_stmt><expr><name>overrideStack</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Activate the next level down. */</comment>
	<if_stmt><if>if <condition>(<expr><name>overrideStack</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>OverrideStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>creationNamespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* XXX is this OK? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If not baseSearchPathValid, this is useless but harmless */</comment>
		<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name>baseSearchPath</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name>baseCreationNamespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>baseTempCreationPending</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_collation_oid - find a collation by possibly qualified name
 *
 * Note that this will only find collations that work with the current
 * database's encoding.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_collation_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collation_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>dbencoding</name> <init>= <expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>colloid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>collation_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>colloid</name> <operator>=</operator> <call><name>lookup_collation</name><argument_list>(<argument><expr><name>collation_name</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>dbencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>colloid</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<expr_stmt><expr><name>colloid</name> <operator>=</operator> <call><name>lookup_collation</name><argument_list>(<argument><expr><name>collation_name</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>dbencoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>colloid</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Not found in path */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"collation \"%s\" for encoding \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GetDatabaseEncodingName</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_conversion_oid - find a conversion by possibly qualified name
 */</comment>
<function><type><name>Oid</name></type>
<name>get_conversion_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>schemaname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>conversion_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>conoid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* deconstruct the name list */</comment>
	<expr_stmt><expr><call><name>DeconstructQualifiedName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>schemaname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>conversion_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>schemaname</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use exact schema given */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>LookupExplicitNamespace</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>conoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>conoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>CONNAMENSP</name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>conversion_name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* search for it in search path */</comment>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* do not look in temp namespace */</comment>

			<expr_stmt><expr><name>conoid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>CONNAMENSP</name></expr></argument>,
									 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>conversion_name</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>conoid</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Not found in path */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conversion \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>conoid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FindDefaultConversionProc - find default encoding conversion proc
 */</comment>
<function><type><name>Oid</name></type>
<name>FindDefaultConversionProc</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>for_encoding</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>to_encoding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not look in temp namespace */</comment>

		<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>FindDefaultConversion</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>for_encoding</name></expr></argument>, <argument><expr><name>to_encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>proc</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Not found in path */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * recomputeNamespacePath - recompute path derived variables if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>recomputeNamespacePath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oidlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>temp_missing</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>firstNS</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if an override search spec is active. */</comment>
	<if_stmt><if>if <condition>(<expr><name>overrideStack</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Do nothing if path is already valid. */</comment>
	<if_stmt><if>if <condition>(<expr><name>baseSearchPathValid</name> <operator>&amp;&amp;</operator> <name>namespaceUser</name> <operator>==</operator> <name>roleid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Need a modifiable copy of namespace_search_path string */</comment>
	<expr_stmt><expr><name>rawname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>namespace_search_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in name list */</comment>
		<comment type="block">/* this should not happen if GUC checked check_search_path */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid list syntax"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Convert the list of names to a list of OIDs.  If any names are not
	 * recognizable or we don't have read access, just leave them out of the
	 * list.  (We can't raise an error, since the search_path setting has
	 * already been accepted.)	Don't make duplicate entries, either.
	 */</comment>
	<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_missing</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>namelist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curname</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><literal type="string">"$user"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* $user --- substitute namespace matching user name, if any */</comment>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rname</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>rolname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>rname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
										  <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACLCHECK_OK</name> <operator>&amp;&amp;</operator>
					<call><name>InvokeNamespaceSearchHook</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><literal type="string">"pg_temp"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* pg_temp --- substitute temp namespace, if any */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>InvokeNamespaceSearchHook</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* If it ought to be the creation namespace, set flag */</comment>
				<if_stmt><if>if <condition>(<expr><name>oidlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>temp_missing</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* normal namespace reference */</comment>
			<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>curname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>pg_namespace_aclcheck</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
									  <argument><expr><name>ACL_USAGE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACLCHECK_OK</name> <operator>&amp;&amp;</operator>
				<call><name>InvokeNamespaceSearchHook</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Remember the first member of the explicit list.  (Note: this is
	 * nominally wrong if temp_missing, but we need it anyway to distinguish
	 * explicit from implicit mention of pg_catalog.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oidlist</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstNS</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>firstNS</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Add any implicitly-searched namespaces to the list.  Note these go on
	 * the front, not the back; also notice that we do not check USAGE
	 * permissions for these.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>, <argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>, <argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oidlist</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>, <argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now that we've successfully built the new list of namespace OIDs, save
	 * it in permanent storage.
	 */</comment>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newpath</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now safe to assign to state variables. */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>baseSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>baseSearchPath</name> <operator>=</operator> <name>newpath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>baseCreationNamespace</name> <operator>=</operator> <name>firstNS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>baseTempCreationPending</name> <operator>=</operator> <name>temp_missing</name></expr>;</expr_stmt>

	<comment type="block">/* Mark the path valid. */</comment>
	<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>namespaceUser</name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>

	<comment type="block">/* And make it active. */</comment>
	<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name>baseSearchPath</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name>baseCreationNamespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>baseTempCreationPending</name></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>oidlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AccessTempTableNamespace
 *		Provide access to a temporary namespace, potentially creating it
 *		if not present yet.  This routine registers if the namespace gets
 *		in use in this transaction.  'force' can be set to true to allow
 *		the caller to enforce the creation of the temporary namespace for
 *		use in this backend, which happens if its creation is pending.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AccessTempTableNamespace</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Make note that this temporary namespace has been accessed in this
	 * transaction.
	 */</comment>
	<expr_stmt><expr><name>MyXactFlags</name> <operator>|=</operator> <name>XACT_FLAGS_ACCESSEDTEMPNAMESPACE</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the caller attempting to access a temporary schema expects the
	 * creation of the namespace to be pending and should be enforced, then go
	 * through the creation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The temporary tablespace does not exist yet and is wanted, so
	 * initialize it.
	 */</comment>
	<expr_stmt><expr><call><name>InitTempTableNamespace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitTempTableNamespace
 *		Initialize temp table namespace on first use in a particular backend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitTempTableNamespace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>namespaceName</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toastspaceId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, do permission check to see if we are authorized to make temp
	 * tables.  We use a nonstandard error message here since "databasename:
	 * permission denied" might be a tad cryptic.
	 *
	 * Note that ACL_CREATE_TEMP rights are rechecked in pg_namespace_aclmask;
	 * that's necessary since current user ID could change during the session.
	 * But there's no need to make the namespace in the first place until a
	 * temp table creation request is made by someone with appropriate rights.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_database_aclcheck</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
							 <argument><expr><name>ACL_CREATE_TEMP</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to create temporary tables in database \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Do not allow a Hot Standby session to make temp tables.  Aside from
	 * problems with modifying the system catalogs, there is a naming
	 * conflict: pg_temp_N belongs to the session with BackendId N on the
	 * master, not to a hot standby session with the same BackendId.  We
	 * should not be able to get here anyway due to XactReadOnly checks, but
	 * let's just make real sure.  Note that this also backstops various
	 * operations that allow XactReadOnly transactions to modify temp tables;
	 * they'd need RecoveryInProgress checks if not for this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary tables during recovery"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Parallel workers can't create temporary tables, either. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsParallelWorker</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_READ_ONLY_SQL_TRANSACTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot create temporary tables during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>namespaceName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>namespaceName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_temp_%d"</literal></expr></argument>, <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>namespaceName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First use of this temp namespace in this database; create it. The
		 * temp namespaces are always owned by the superuser.  We leave their
		 * permissions at default --- i.e., no access except to superuser ---
		 * to ensure that unprivileged users can't peek at other backends'
		 * temp tables.  This works because the places that access the temp
		 * namespace for my own backend skip permissions checks on it.
		 */</comment>
		<expr_stmt><expr><name>namespaceId</name> <operator>=</operator> <call><name>NamespaceCreate</name><argument_list>(<argument><expr><name>namespaceName</name></expr></argument>, <argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Advance command counter to make namespace visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the namespace already exists, clean it out (in case the former
		 * owner crashed without doing so).
		 */</comment>
		<expr_stmt><expr><call><name>RemoveTempRelations</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the corresponding toast-table namespace doesn't exist yet, create
	 * it. (We assume there is no need to clean it out if it does exist, since
	 * dropping a parent table should make its toast table go away.)
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>namespaceName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>namespaceName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"pg_toast_temp_%d"</literal></expr></argument>,
			 <argument><expr><name>MyBackendId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>toastspaceId</name> <operator>=</operator> <call><name>get_namespace_oid</name><argument_list>(<argument><expr><name>namespaceName</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toastspaceId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>toastspaceId</name> <operator>=</operator> <call><name>NamespaceCreate</name><argument_list>(<argument><expr><name>namespaceName</name></expr></argument>, <argument><expr><name>BOOTSTRAP_SUPERUSERID</name></expr></argument>,
									   <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Advance command counter to make namespace visible */</comment>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay, we've prepared the temp namespace ... but it's not committed yet,
	 * so all our work could be undone by transaction rollback.  Set flag for
	 * AtEOXact_Namespace to know what to do.
	 */</comment>
	<expr_stmt><expr><name>myTempNamespace</name> <operator>=</operator> <name>namespaceId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>myTempToastNamespace</name> <operator>=</operator> <name>toastspaceId</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark MyProc as owning this namespace which other processes can use to
	 * decide if a temporary namespace is in use or not.  We assume that
	 * assignment of namespaceId is an atomic operation.  Even if it is not,
	 * the temporary relation which resulted in the creation of this temporary
	 * namespace is still locked until the current transaction commits, and
	 * its pg_namespace row is not visible yet.  However it does not matter:
	 * this flag makes the namespace as being in use, so no objects created on
	 * it would be removed concurrently.
	 */</comment>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>=</operator> <name>namespaceId</name></expr>;</expr_stmt>

	<comment type="block">/* It should not be done already. */</comment>
	<expr_stmt><expr><call><name>AssertState</name><argument_list>(<argument><expr><name>myTempNamespaceSubID</name> <operator>==</operator> <name>InvalidSubTransactionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>myTempNamespaceSubID</name> <operator>=</operator> <call><name>GetCurrentSubTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* need to rebuild list */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * End-of-transaction cleanup for namespaces.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_Namespace</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>parallel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we abort the transaction in which a temp namespace was selected,
	 * we'll have to do any creation or cleanout work over again.  So, just
	 * forget the namespace entirely until next time.  On the other hand, if
	 * we commit then register an exit callback to clean out the temp tables
	 * at backend shutdown.  (We only want to register the callback once per
	 * session, so this is a good place to do it.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>myTempNamespaceSubID</name> <operator>!=</operator> <name>InvalidSubTransactionId</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>parallel</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>before_shmem_exit</name><argument_list>(<argument><expr><name>RemoveTempRelationsCallback</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>myTempNamespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>myTempToastNamespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* need to rebuild list */</comment>

			<comment type="block">/*
			 * Reset the temporary namespace flag in MyProc.  We assume that
			 * this operation is atomic.
			 *
			 * Because this transaction is aborting, the pg_namespace row is
			 * not visible to anyone else anyway, but that doesn't matter:
			 * it's not a problem if objects contained in this namespace are
			 * removed concurrently.
			 */</comment>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>myTempNamespaceSubID</name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clean up if someone failed to do PopOverrideSearchPath
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>overrideStack</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"leaked override search path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<while>while <condition>(<expr><name>overrideStack</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OverrideStackEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>OverrideStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>overrideStack</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>
		<comment type="block">/* If not baseSearchPathValid, this is useless but harmless */</comment>
		<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name>baseSearchPath</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name>baseCreationNamespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>baseTempCreationPending</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AtEOSubXact_Namespace
 *
 * At subtransaction commit, propagate the temp-namespace-creation
 * flag to the parent subtransaction.
 *
 * At subtransaction abort, forget the flag if we set it up.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOSubXact_Namespace</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>SubTransactionId</name></type> <name>mySubid</name></decl></parameter>,
					  <parameter><decl><type><name>SubTransactionId</name></type> <name>parentSubid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OverrideStackEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>myTempNamespaceSubID</name> <operator>==</operator> <name>mySubid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>myTempNamespaceSubID</name> <operator>=</operator> <name>parentSubid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>myTempNamespaceSubID</name> <operator>=</operator> <name>InvalidSubTransactionId</name></expr>;</expr_stmt>
			<comment type="block">/* TEMP namespace creation failed, so reset state */</comment>
			<expr_stmt><expr><name>myTempNamespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>myTempToastNamespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* need to rebuild list */</comment>

			<comment type="block">/*
			 * Reset the temporary namespace flag in MyProc.  We assume that
			 * this operation is atomic.
			 *
			 * Because this subtransaction is aborting, the pg_namespace row
			 * is not visible to anyone else anyway, but that doesn't matter:
			 * it's not a problem if objects contained in this namespace are
			 * removed concurrently.
			 */</comment>
			<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>tempNamespaceId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Clean up if someone failed to do PopOverrideSearchPath
	 */</comment>
	<while>while <condition>(<expr><name>overrideStack</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>OverrideStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>nestLevel</name></name> <operator>&lt;</operator> <call><name>GetCurrentTransactionNestLevel</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"leaked override search path"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>overrideStack</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Activate the next level down. */</comment>
	<if_stmt><if>if <condition>(<expr><name>overrideStack</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>OverrideStackEntry</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>overrideStack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>searchPath</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>creationNamespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* XXX is this OK? */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* If not baseSearchPathValid, this is useless but harmless */</comment>
		<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name>baseSearchPath</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name>baseCreationNamespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>baseTempCreationPending</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all relations in the specified temp namespace.
 *
 * This is called at backend shutdown (if we made any temp relations).
 * It is also called when we begin using a pre-existing temp namespace,
 * in order to clean out any relations that might have been created by
 * a crashed backend.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveTempRelations</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tempNamespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We want to get rid of everything in the target namespace, but not the
	 * namespace itself (deleting it only to recreate it later would be a
	 * waste of cycles).  Hence, specify SKIP_ORIGINAL.  It's also an INTERNAL
	 * deletion, and we want to not drop any extensions that might happen to
	 * own temp objects.
	 */</comment>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>tempNamespaceId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>,
					<argument><expr><name>PERFORM_DELETION_INTERNAL</name> <operator>|</operator>
					<name>PERFORM_DELETION_QUIETLY</name> <operator>|</operator>
					<name>PERFORM_DELETION_SKIP_ORIGINAL</name> <operator>|</operator>
					<name>PERFORM_DELETION_SKIP_EXTENSIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback to remove temp relations at backend exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RemoveTempRelationsCallback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* should always be true */</comment>
	<block>{<block_content>
		<comment type="block">/* Need to ensure we have a usable transaction. */</comment>
		<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RemoveTempRelations</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all temp tables from the temporary namespace.
 */</comment>
<function><type><name>void</name></type>
<name>ResetTempTableNamespace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveTempRelations</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Routines for handling the GUC variable 'search_path'.
 */</comment>

<comment type="block">/* check_hook: validate new search_path value */</comment>
<function><type><name>bool</name></type>
<name>check_search_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>namelist</name></decl>;</decl_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>namelist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in name list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We used to try to check that the named schemas exist, but there are
	 * many valid use-cases for having search_path settings that include
	 * schemas that don't exist; and often, we are not inside a transaction
	 * here and so can't consult the system catalogs anyway.  So now, the only
	 * requirement is syntactic validity of the identifier list.
	 */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>namelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* assign_hook: do extra actions as needed */</comment>
<function><type><name>void</name></type>
<name>assign_search_path</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We mark the path as needing recomputation, but don't do anything until
	 * it's needed.  This avoids trying to do database access during GUC
	 * initialization, or outside a transaction.
	 */</comment>
	<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * InitializeSearchPath: initialize module during InitPostgres.
 *
 * This is called after we are up enough to be able to do catalog lookups.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeSearchPath</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In bootstrap mode, the search path must be 'pg_catalog' so that
		 * tables are created in the proper namespace; ignore the GUC setting.
		 */</comment>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>baseSearchPath</name> <operator>=</operator> <call><name>list_make1_oid</name><argument_list>(<argument><expr><name>PG_CATALOG_NAMESPACE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>baseCreationNamespace</name> <operator>=</operator> <name>PG_CATALOG_NAMESPACE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>baseTempCreationPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>namespaceUser</name> <operator>=</operator> <call><name>GetUserId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeSearchPath</name> <operator>=</operator> <name>baseSearchPath</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeCreationNamespace</name> <operator>=</operator> <name>baseCreationNamespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>activeTempCreationPending</name> <operator>=</operator> <name>baseTempCreationPending</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In normal mode, arrange for a callback on any syscache invalidation
		 * of pg_namespace rows.
		 */</comment>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>,
									  <argument><expr><name>NamespaceCallback</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Force search path to be recomputed on next use */</comment>
		<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * NamespaceCallback
 *		Syscache inval callback function
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NamespaceCallback</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Force search path to be recomputed on next use */</comment>
	<expr_stmt><expr><name>baseSearchPathValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the active search path. The return value is a palloc'ed list
 * of OIDs; the caller is responsible for freeing this storage as
 * appropriate.
 *
 * The returned list includes the implicitly-prepended namespaces only if
 * includeImplicit is true.
 *
 * Note: calling this may result in a CommandCounterIncrement operation,
 * if we have to create or clean out the temp namespace.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>fetch_search_path</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>includeImplicit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the temp namespace should be first, force it to exist.  This is so
	 * that callers can trust the result to reflect the actual default
	 * creation namespace.  It's a bit bogus to do this here, since
	 * current_schema() is supposedly a stable function without side-effects,
	 * but the alternatives seem worse.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>activeTempCreationPending</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>AccessTempTableNamespace</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_copy</name><argument_list>(<argument><expr><name>activeSearchPath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>includeImplicit</name></expr>)</condition>
	<block>{<block_content>
		<while>while <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>activeCreationNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the active search path into a caller-allocated array of OIDs.
 * Returns the number of path entries.  (If this is more than sarray_len,
 * then the data didn't fit and is not all stored.)
 *
 * The returned list always includes the implicitly-prepended namespaces,
 * but never includes the temp namespace.  (This is suitable for existing
 * users, which would want to ignore the temp namespace anyway.)  This
 * definition allows us to not worry about initializing the temp namespace.
 */</comment>
<function><type><name>int</name></type>
<name>fetch_search_path_array</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>sarray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sarray_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recomputeNamespacePath</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>activeSearchPath</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>namespaceId</name> <operator>==</operator> <name>myTempNamespace</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* do not include temp namespace */</comment>

		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>sarray_len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sarray</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name>namespaceId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Export the FooIsVisible functions as SQL-callable functions.
 *
 * Note: as of Postgres 8.4, these will silently return NULL if called on
 * a nonexistent object OID, rather than failing.  This is to avoid race
 * condition errors when a query that's scanning a catalog using an MVCC
 * snapshot uses one of these functions.  The underlying IsVisible functions
 * always use an up-to-date snapshot and so might see the object as already
 * gone when it's still visible to the transaction snapshot.  (There is no race
 * condition in the current coding because we don't accept sinval messages
 * between the SearchSysCacheExists test and the subsequent lookup.)
 */</comment>

<function><type><name>Datum</name></type>
<name>pg_table_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_type_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>TypeIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_function_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>FunctionIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_operator_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>OperatorIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_opclass_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>OpclassIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_opfamily_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>OPFAMILYOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>OpfamilyIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_collation_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>CollationIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_conversion_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>CONVOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>ConversionIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_statistics_obj_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>STATEXTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>StatisticsObjIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_ts_parser_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TSPARSEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>TSParserIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_ts_dict_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>TSDictionaryIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_ts_template_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TSTEMPLATEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>TSTemplateIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_ts_config_is_visible</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>TSConfigIsVisible</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_my_temp_schema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_OID</name><argument_list>(<argument><expr><name>myTempNamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>pg_is_other_temp_schema</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>isOtherTempNamespace</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
