<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/catalog/toasting.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * toasting.c
 *	  This file contains routines to support creation of toast tables
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/catalog/toasting.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tuptoaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/binary_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/* Potentially set by pg_upgrade_support functions */</comment>
<decl_stmt><decl><type><name>Oid</name></type>			<name>binary_upgrade_next_toast_pg_type_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckAndCreateToastTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>,
						 <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>create_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>toastOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>toastIndexOid</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>needs_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * CreateToastTable variants
 *		If the table needs a toast table, and doesn't already have one,
 *		then create a toast table for it.
 *
 * reloptions for the toast table can be passed, too.  Pass (Datum) 0
 * for default reloptions.
 *
 * We expect the caller to have verified that the relation is a table and have
 * already done any necessary permission checks.  Callers expect this function
 * to end with CommandCounterIncrement if it makes any changes.
 */</comment>
<function><type><name>void</name></type>
<name>AlterTableCreateToastTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckAndCreateToastTable</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>NewHeapCreateToastTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckAndCreateToastTable</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>NewRelationCreateToastTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>CheckAndCreateToastTable</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckAndCreateToastTable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relOid</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create_toast_table does all the work */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>create_toast_table</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a toast table during bootstrap
 *
 * Here we need to prespecify the OIDs of the toast table and its index
 */</comment>
<function><type><name>void</name></type>
<name>BootstrapToastTable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relName</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>toastOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>toastIndexOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_openrv</name><argument_list>(<argument><expr><call><name>makeRangeVar</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>relName</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a table or materialized view"</literal></expr></argument>,
						<argument><expr><name>relName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* create_toast_table does all the work */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>create_toast_table</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>toastOid</name></expr></argument>, <argument><expr><name>toastIndexOid</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
							<argument><expr><name>AccessExclusiveLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" does not require a toast table"</literal></expr></argument>,
			 <argument><expr><name>relName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * create_toast_table --- internal workhorse
 *
 * rel is already opened and locked
 * toastOid and toastIndexOid are normally InvalidOid, but during
 * bootstrap they can be nonzero to specify hand-assigned OIDs
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>create_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>toastOid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>toastIndexOid</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>, <parameter><decl><type><name>LOCKMODE</name></type> <name>lockmode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relOid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shared_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mapped_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>toast_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>class_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toast_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toast_typid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>namespaceid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>toast_relname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>toast_idxname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>collationObjectId</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>classObjectId</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>coloptions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>baseobject</name></decl>,
				<decl><type ref="prev"/><name>toastobject</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Toast table is shared if and only if its parent is.
	 *
	 * We cannot allow toasting a shared relation after initdb (because
	 * there's no way to mark it toasted in other databases' pg_class).
	 */</comment>
	<expr_stmt><expr><name>shared_relation</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>shared_relation</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"shared tables cannot be toasted after initdb"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* It's mapped if and only if its parent is, too */</comment>
	<expr_stmt><expr><name>mapped_relation</name> <operator>=</operator> <call><name>RelationIsMapped</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Is it already toasted?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check to see whether the table actually needs a TOAST table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsBinaryUpgrade</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Normal mode, normal check */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>needs_toast_table</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * In binary-upgrade mode, create a TOAST table if and only if
		 * pg_upgrade told us to (ie, a TOAST table OID has been provided).
		 *
		 * This indicates that the old cluster had a TOAST table for the
		 * current table.  We must create a TOAST table to receive the old
		 * TOAST file, even if the table seems not to need one.
		 *
		 * Contrariwise, if the old cluster did not have a TOAST table, we
		 * should be able to get along without one even if the new version's
		 * needs_toast_table rules suggest we should have one.  There is a lot
		 * of daylight between where we will create a TOAST table and where
		 * one is really necessary to avoid failures, so small cross-version
		 * differences in the when-to-create heuristic shouldn't be a problem.
		 * If we tried to create a TOAST table anyway, we would have the
		 * problem that it might take up an OID that will conflict with some
		 * old-cluster table we haven't seen yet.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>binary_upgrade_next_toast_pg_class_oid</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>binary_upgrade_next_toast_pg_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If requested check lockmode is sufficient. This is a cross check in
	 * case of errors or conflicting decisions in earlier code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check</name> <operator>&amp;&amp;</operator> <name>lockmode</name> <operator>!=</operator> <name>AccessExclusiveLock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AccessExclusiveLock required to add toast table."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the toast table and its index
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>toast_relname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>toast_relname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"pg_toast_%u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>toast_idxname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>toast_idxname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
			 <argument><expr><literal type="string">"pg_toast_%u_index"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* this is pretty painful...  need a tuple descriptor */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>,
					   <argument><expr><literal type="string">"chunk_id"</literal></expr></argument>,
					   <argument><expr><name>OIDOID</name></expr></argument>,
					   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>,
					   <argument><expr><literal type="string">"chunk_seq"</literal></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>,
					   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>,
					   <argument><expr><literal type="string">"chunk_data"</literal></expr></argument>,
					   <argument><expr><name>BYTEAOID</name></expr></argument>,
					   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure that the toast table doesn't itself get toasted, or we'll be
	 * toast :-(.  This is essential for chunk_data because type bytea is
	 * toastable; hit the other two just to be sure.
	 */</comment>
	<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Toast tables for regular relations go in pg_toast; those for temp
	 * relations go into the per-backend temp-toast-table namespace.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isTempOrTempToastNamespace</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>namespaceid</name> <operator>=</operator> <call><name>GetTempToastNamespace</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>namespaceid</name> <operator>=</operator> <name>PG_TOAST_NAMESPACE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Use binary-upgrade override for pg_type.oid, if supplied.  We might be
	 * in the post-schema-restore phase where we are doing ALTER TABLE to
	 * create TOAST tables that didn't exist in the old cluster.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsBinaryUpgrade</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>binary_upgrade_next_toast_pg_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>toast_typid</name> <operator>=</operator> <name>binary_upgrade_next_toast_pg_type_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>binary_upgrade_next_toast_pg_type_oid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>toast_relid</name> <operator>=</operator> <call><name>heap_create_with_catalog</name><argument_list>(<argument><expr><name>toast_relname</name></expr></argument>,
										   <argument><expr><name>namespaceid</name></expr></argument>,
										   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
										   <argument><expr><name>toastOid</name></expr></argument>,
										   <argument><expr><name>toast_typid</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>,
										   <argument><expr><name>tupdesc</name></expr></argument>,
										   <argument><expr><name>NIL</name></expr></argument>,
										   <argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>,
										   <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>,
										   <argument><expr><name>shared_relation</name></expr></argument>,
										   <argument><expr><name>mapped_relation</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><literal type="number">0</literal></expr></argument>,
										   <argument><expr><name>ONCOMMIT_NOOP</name></expr></argument>,
										   <argument><expr><name>reloptions</name></expr></argument>,
										   <argument><expr><name>false</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name>InvalidOid</name></expr></argument>,
										   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>toast_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make the toast relation visible, else heap_open will fail */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ShareLock is not really needed here, but take it anyway */</comment>
	<expr_stmt><expr><name>toast_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>toast_relid</name></expr></argument>, <argument><expr><name>ShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create unique index on chunk_id, chunk_seq.
	 *
	 * NOTE: the normal TOAST access routines could actually function with a
	 * single-column index on chunk_id only. However, the slice access
	 * routines use both columns for faster access to an individual chunk. In
	 * addition, we want it to be unique as a check against the possibility of
	 * duplicate TOAST chunk OIDs. The index might also be a little more
	 * efficient this way, since btree isn't all that happy with large numbers
	 * of equal keys.
	 */</comment>

	<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>IndexInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexAttrs</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_NumIndexKeyAttrs</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_IndexAttrNumbers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Expressions</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExpressionsState</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Predicate</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_PredicateState</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionProcs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ExclusionStrats</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Unique</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ReadyForInserts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Concurrent</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_BrokenHotChain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_ParallelWorkers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Am</name></name> <operator>=</operator> <name>BTREE_AM_OID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_AmCache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexInfo</name><operator>-&gt;</operator><name>ii_Context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>collationObjectId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>collationObjectId</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>classObjectId</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>OID_BTREE_OPS_OID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>classObjectId</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>INT4_BTREE_OPS_OID</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>coloptions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>coloptions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>index_create</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>, <argument><expr><name>toast_idxname</name></expr></argument>, <argument><expr><name>toastIndexOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
				 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
				 <argument><expr><name>indexInfo</name></expr></argument>,
				 <argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><literal type="string">"chunk_id"</literal></expr></argument>, <argument><expr><literal type="string">"chunk_seq"</literal></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><name>BTREE_AM_OID</name></expr></argument>,
				 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
				 <argument><expr><name>collationObjectId</name></expr></argument>, <argument><expr><name>classObjectId</name></expr></argument>, <argument><expr><name>coloptions</name></expr></argument>, <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
				 <argument><expr><name>INDEX_CREATE_IS_PRIMARY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>toast_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store the toast table's OID in the parent relation's pg_class row
	 */</comment>
	<expr_stmt><expr><name>class_rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>reltoastrelid</name> <operator>=</operator> <name>toast_relid</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* normal case, use a transactional update */</comment>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* While bootstrapping, we cannot UPDATE, so overwrite in-place */</comment>
		<expr_stmt><expr><call><name>heap_inplace_update</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>class_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Register dependency from the toast table to the master, so that the
	 * toast table will be deleted if the master is.  Skip this in bootstrap
	 * mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>toast_relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Make changes visible
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check to see whether the table needs a TOAST table.  It does only if
 * (1) there are any toastable attributes, and (2) the maximum length
 * of a tuple could exceed TOAST_TUPLE_THRESHOLD.  (We don't want to
 * create a toast table for something like "f1 varchar(20)".)
 * No need to create a TOAST table for partitioned tables.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>needs_toast_table</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>data_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>maxlength_unknown</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_toastable_attrs</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tuple_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>data_length</name> <operator>=</operator> <call><name>att_align_nominal</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Fixed-length types are never toastable */</comment>
			<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32</name></type>		<name>maxlen</name> <init>= <expr><call><name>type_maximum_size</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												   <argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>maxlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>maxlength_unknown</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>data_length</name> <operator>+=</operator> <name>maxlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>has_toastable_attrs</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_toastable_attrs</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to toast? */</comment>
	<if_stmt><if>if <condition>(<expr><name>maxlength_unknown</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* any unlimited-length attrs? */</comment>
	<expr_stmt><expr><name>tuple_length</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>SizeofHeapTupleHeader</name> <operator>+</operator>
							<call><name>BITMAPLEN</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><name>data_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>tuple_length</name> <operator>&gt;</operator> <name>TOAST_TUPLE_THRESHOLD</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
