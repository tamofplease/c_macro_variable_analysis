<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/nodes/read.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * read.c
 *	  routines to convert a string (legal ascii representation of node) back
 *	  to nodes
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/read.c
 *
 * HISTORY
 *	  AUTHOR			DATE			MAJOR EVENT
 *	  Andrew Yu			Nov 2, 1994		file creation
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/readfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/value.h"</cpp:file></cpp:include>


<comment type="block">/* Static state for pg_strtok */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>pg_strtok_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * stringToNode -
 *	  returns a Node with a given legal ASCII representation
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>stringToNode</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>save_strtok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We save and restore the pre-existing state of pg_strtok. This makes the
	 * world safe for re-entrant invocation of stringToNode, without incurring
	 * a lot of notational overhead by having to pass the next-character
	 * pointer around through all the readfuncs.c code.
	 */</comment>
	<expr_stmt><expr><name>save_strtok</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>		<comment type="block">/* point pg_strtok at the string to read */</comment>

	<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>nodeRead</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* do the reading */</comment>

	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>save_strtok</name></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 * the lisp token parser
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * pg_strtok --- retrieve next "token" from a string.
 *
 * Works kinda like strtok, except it never modifies the source string.
 * (Instead of storing nulls into the string, the length of the token
 * is returned to the caller.)
 * Also, the rules about what is a token are hard-wired rather than being
 * configured by passing a set of terminating characters.
 *
 * The string is assumed to have been initialized already by stringToNode.
 *
 * The rules for tokens are:
 *	* Whitespace (space, tab, newline) always separates tokens.
 *	* The characters '(', ')', '{', '}' form individual tokens even
 *	  without any whitespace around them.
 *	* Otherwise, a token is all the characters up to the next whitespace
 *	  or occurrence of one of the four special characters.
 *	* A backslash '\' can be used to quote whitespace or one of the four
 *	  special characters, so that it is treated as a plain token character.
 *	  Backslashes themselves must also be backslashed for consistency.
 *	  Any other character can be, but need not be, backslashed as well.
 *	* If the resulting token is '&lt;&gt;' (with no backslash), it is returned
 *	  as a non-NULL pointer to the token but with length == 0.  Note that
 *	  there is no other way to get a zero-length token.
 *
 * Returns a pointer to the start of the next token, and the length of the
 * token (including any embedded backslashes!) in *length.  If there are
 * no more tokens, NULL and 0 are returned.
 *
 * NOTE: this routine doesn't remove backslashes; the caller must do so
 * if necessary (see "debackslash").
 *
 * NOTE: prior to release 7.0, this routine also had a special case to treat
 * a token starting with '"' as extending to the next '"'.  This code was
 * broken, however, since it would fail to cope with a string containing an
 * embedded '"'.  I have therefore removed this special case, and instead
 * introduced rules for using backslashes to quote characters.  Higher-level
 * code should add backslashes to a string constant to ensure it is treated
 * as a single token.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>pg_strtok</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>local_str</name></decl>;</decl_stmt>		<comment type="block">/* working pointer to string */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ret_str</name></decl>;</decl_stmt>		<comment type="block">/* start of token to return */</comment>

	<expr_stmt><expr><name>local_str</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>			<comment type="block">/* no more tokens */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now pointing at start of next token.
	 */</comment>
	<expr_stmt><expr><name>ret_str</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator>
		<operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* special 1-character token */</comment>
		<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Normal token, possibly containing backslashes */</comment>
		<while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\t'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>local_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_str</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <name>local_str</name> <operator>-</operator> <name>ret_str</name></expr>;</expr_stmt>

	<comment type="block">/* Recognize special case for "empty" token */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>length</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ret_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>ret_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>

	<return>return <expr><name>ret_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * debackslash -
 *	  create a palloc'd string holding the given token.
 *	  any protective backslashes in the token are removed.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>debackslash</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>length</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>token</name><operator>++</operator></expr><operator>,</operator> <expr><name>length</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>token</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>length</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHT_PAREN</name></cpp:macro> <cpp:value>(1000000 + 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_PAREN</name></cpp:macro>	<cpp:value>(1000000 + 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFT_BRACE</name></cpp:macro>	<cpp:value>(1000000 + 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OTHER_TOKEN</name></cpp:macro> <cpp:value>(1000000 + 4)</cpp:value></cpp:define>

<comment type="block">/*
 * nodeTokenType -
 *	  returns the type of the node token contained in token.
 *	  It returns one of the following valid NodeTags:
 *		T_Integer, T_Float, T_String, T_BitString
 *	  and some of its own:
 *		RIGHT_PAREN, LEFT_PAREN, LEFT_BRACE, OTHER_TOKEN
 *
 *	  Assumption: the ascii representation is legal
 */</comment>
<function><type><specifier>static</specifier> <name>NodeTag</name></type>
<name>nodeTokenType</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numlen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check if the token is a number
	 */</comment>
	<expr_stmt><expr><name>numptr</name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>numlen</name> <operator>=</operator> <name>length</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>numptr</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>numptr</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>numlen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>numlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>numptr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>numlen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>numptr</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>numptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Yes.  Figure out whether it is integral or float; this requires
		 * both a syntax check and a range check. strtoint() can do both for
		 * us. We know the token will end at a character that strtoint will
		 * stop at, so we do not need to modify the string.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>strtoint</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>length</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>T_Float</name></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>T_Integer</name></expr>;</return>
	</block_content>}</block></if>

	<comment type="block">/*
	 * these three cases do not need length checks, since pg_strtok() will
	 * always treat them as single-byte tokens
	 */</comment>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>LEFT_PAREN</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>RIGHT_PAREN</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>LEFT_BRACE</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <name>length</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><name>length</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>T_String</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>token</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>T_BitString</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>OTHER_TOKEN</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * nodeRead -
 *	  Slightly higher-level reader.
 *
 * This routine applies some semantic knowledge on top of the purely
 * lexical tokenizer pg_strtok().   It can read
 *	* Value token nodes (integers, floats, or strings);
 *	* General nodes (via parseNodeString() from readfuncs.c);
 *	* Lists of the above;
 *	* Lists of integers or OIDs.
 * The return value is declared void *, not Node *, to avoid having to
 * cast it explicitly in callers that assign to fields of different types.
 *
 * External callers should always pass NULL/0 for the arguments.  Internally
 * a non-NULL token may be passed when the upper recursion level has already
 * scanned the first token of a node's representation.
 *
 * We assume pg_strtok is already initialized with a string to read (hence
 * this should only be invoked from within a stringToNode operation).
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>nodeRead</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tok_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NodeTag</name></type>		<name>type</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition>			<comment type="block">/* need to read a token? */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* end of input */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>nodeTokenType</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LEFT_BRACE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>parseNodeString</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"did not find '}' at end of input node"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>LEFT_PAREN</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*----------
				 * Could be an integer list:	(i int int ...)
				 * or an OID list:				(o int int ...)
				 * or a list of nodes/values:	(node node ...)
				 *----------
				 */</comment>
				<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* List of integers */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>val</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>tok_len</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized integer: \"%.*s\""</literal></expr></argument>,
								 <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* List of OIDs */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>val</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>token</name> <operator>+</operator> <name>tok_len</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OID: \"%.*s\""</literal></expr></argument>,
								 <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* List of other node types */</comment>
					<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
					<block>{<block_content>
						<comment type="block">/* We have already scanned next token... */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>token</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><call><name>nodeRead</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unterminated List structure"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>l</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>RIGHT_PAREN</name></expr>:</case>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected right parenthesis"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler happy */</comment>
			<break>break;</break>
		<case>case <expr><name>OTHER_TOKEN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>tok_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* must be "&lt;&gt;" --- represents a null pointer */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized token: \"%.*s\""</literal></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler happy */</comment>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Integer</name></expr>:</case>

			<comment type="block">/*
			 * we know that the token terminates on a char atoi will stop at
			 */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeInteger</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fval</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>tok_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fval</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fval</name><index>[<expr><name>tok_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeFloat</name><argument_list>(<argument><expr><name>fval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_String</name></expr>:</case>
			<comment type="block">/* need to remove leading and trailing quotes, and backslashes */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeString</name><argument_list>(<argument><expr><call><name>debackslash</name><argument_list>(<argument><expr><name>token</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tok_len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitString</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>tok_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* skip leading 'b' */</comment>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>token</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tok_len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>val</name><index>[<expr><name>tok_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeBitString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler happy */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Based on function pg_strtok, but don't modify pg_strtok_ptr
 * We only want to get token value
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>polar_pg_strtok</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>local_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* working pointer to string */</comment>
    <decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ret_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* start of token to return */</comment>

    <expr_stmt><expr><name>local_str</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\t'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <return>return <expr><name>NULL</name></expr>;</return>            <comment type="block">/* no more tokens */</comment>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Now pointing at start of next token.
     */</comment>
    <expr_stmt><expr><name>ret_str</name> <operator>=</operator> <name>local_str</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator>
        <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* special 1-character token */</comment>
        <expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <comment type="block">/* Normal token, possibly containing backslashes */</comment>
        <while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
               <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator>
               <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'\t'</literal> <operator>&amp;&amp;</operator>
               <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'('</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator>
               <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>local_str</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>local_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>local_str</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
            <else>else<block type="pseudo"><block_content>
                <expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
        </block_content>}</block></while>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <name>local_str</name> <operator>-</operator> <name>ret_str</name></expr>;</expr_stmt>

    <comment type="block">/* Recognize special case for "empty" token */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>length</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ret_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>ret_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>ret_str</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px: for a serialize plan, to find the PLANGEN_PX from it.
 * PLANGEN_PX is used to deserialize some nodes from parallel execution
 * plan.
 */</comment>
<function><type><name>bool</name></type>
<name>has_px_plangen_filed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>local_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>has_px_plangen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>local_str</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>local_str</name></expr></argument>, <argument><expr><literal type="string">":planGen"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>has_px_plangen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>has_px_plangen</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>read_binary_string_filed</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>pg_strtok_ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_strtok_ptr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>polar_get_node_output_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>local_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>local_str</name> <operator>=</operator> <name>pg_strtok_ptr</name></expr>;</expr_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>local_str</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>local_str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>local_str</name></expr></argument>, <argument><expr><literal type="string">":POLAR_NOV"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* skip :fldname */</comment> \
        <expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>pg_strtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* get field value */</comment> \
        <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment></unit>
