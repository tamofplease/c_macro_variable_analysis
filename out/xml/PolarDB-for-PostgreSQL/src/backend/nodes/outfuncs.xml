<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/nodes/outfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * outfuncs.c
 *	  Output functions for Postgres tree nodes.
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/nodes/outfuncs.c
 *
 * NOTES
 *	  Every node type that can appear in stored rules' parsetrees *must*
 *	  have an output function defined here (as well as an input function
 *	  in readfuncs.c).  In addition, plan nodes should have input and
 *	  output functions so that they can be sent to parallel workers.
 *
 *	  For use in debugging, we also provide output functions for nodes
 *	  that appear in raw parsetrees and planner Paths.  These node types
 *	  need not have input functions.  Output support for raw parsetrees
 *	  is somewhat incomplete, too; in particular, utility statements are
 *	  almost entirely unsupported.  We try to support everything that can
 *	  appear in a raw SELECT, though.
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/plannodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"px/px_gang.h"</cpp:file></cpp:include>

<comment type="block">/* POLAR px: write flag for plangen from PXOPT */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_px_out_plangen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>outChar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Macros to simplify output of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.  Note that these
 * hard-wire conventions about the names of the local variables in an Out
 * routine.
 */</comment>

<comment type="block">/* Write the label for the node type */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_TYPE</name><parameter_list>(<parameter><type><name>nodelabel</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfoString(str, nodelabel)</cpp:value></cpp:define>

<comment type="block">/* Write an integer field (anything written as ":fldname %d") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/*
 * POLAR px: Write an integer field
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_INT16_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %hd", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an unsigned integer field (anything written as ":fldname %u") */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an unsigned integer field (anything written with UINT64_FORMAT) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_UINT64_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " UINT64_FORMAT, \
					 node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write an OID field (don't hard-wire assumption that OID is same as uint) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %u", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a long-integer field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LONG_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %ld", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a char field (ie, one ascii character) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_CHAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfo(str, " :" CppAsString(fldname) " "), \
	 outChar(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write an enumerated-type field as an integer code */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ENUM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>enumtype</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", \
					 (int) node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a float field --- caller must give format to define precision */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FLOAT_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>,<parameter><type><name>format</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " format, node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a boolean field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BOOL_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %s", \
					 booltostr(node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a character-string (possibly NULL) field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfoString(str, " :" CppAsString(fldname) " "), \
	 outToken(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a parse location field (actually same as INT case) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " %d", node-&gt;fldname)</cpp:value></cpp:define>

<comment type="block">/* Write a Node field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfoString(str, " :" CppAsString(fldname) " "), \
	 outNode(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* Write a bitmapset field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(appendStringInfoString(str, " :" CppAsString(fldname) " "), \
	 outBitmapset(str, node-&gt;fldname))</cpp:value></cpp:define>

<comment type="block">/* POLAR px */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_PX_VERSION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :" CppAsString(fldname) " " "%.1f", PX_VERSION_NUMBER)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>booltostr</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>((x) ? "true" : "false")</cpp:value></cpp:define>

<comment type="block">/* POLAR */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NODE_OUTPUT_VERSION_FIELD</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>appendStringInfo(str, " :POLAR_NOV %d", POLAR_NODE_OUTPUT_VERSION)</cpp:value></cpp:define>
<comment type="block">/* POLAR px */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_ATTRNUMBER_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		int i = 0; \
		appendStringInfoString(str, " :" CppAsString(fldname) " "); \
		for (i = 0; i &lt; len; i++) \
			appendStringInfo(str, " %d", node-&gt;fldname[i]); \
	} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_OID_ARRAY</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		int i = 0; \
		appendStringInfoString(str, " :" CppAsString(fldname) " "); \
		for (i = 0; i &lt; len; i++) \
			appendStringInfo(str, " %u", node-&gt;fldname[i]); \
	} while(0)</cpp:value></cpp:define>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * outToken
 *	  Convert an ordinary string (eg, an identifier) into a form that
 *	  will be decoded back to a plain token by read.c's functions.
 *
 *	  If a null or empty string is given, it is encoded as "&lt;&gt;".
 */</comment>
<function><type><name>void</name></type>
<name>outToken</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look for characters or patterns that are treated specially by read.c
	 * (either in pg_strtok() or in nodeRead()), and therefore need a
	 * protective backslash.
	 */</comment>
	<comment type="block">/* These characters only need to be quoted at the start of the string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>||</operator>
		<operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator>
		<call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		 <operator>(</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* These chars must be backslashed anywhere in the string */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator>
			<operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'('</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">')'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'{'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'}'</literal> <operator>||</operator>
			<operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Convert one char.  Goes through outToken() so that special characters are
 * escaped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>outChar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>in</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outList</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'o'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>node</argument>)</argument_list></macro>
	<block>{<block_content>
		<comment type="block">/*
		 * For the sake of backward compatibility, we emit a slightly
		 * different whitespace format for lists of nodes vs. other types of
		 * lists. XXX: is this necessary?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized list node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * outBitmapset -
 *	   converts a bitmap set of integers
 *
 * Note: the output format is "(b int int ...)", similar to an integer List.
 */</comment>
<function><type><name>void</name></type>
<name>outBitmapset</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Print the value of a Datum given its type.
 */</comment>
<function><type><name>void</name></type>
<name>outDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>length</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>datumGetSize</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>value</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%u [ "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>Size</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"0 [ ]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%u [ "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	Stuff from plannodes.h
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannedStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannedStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNEDSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>WRITE_NODE_OUTPUT_VERSION_FIELD</name><argument_list>()</argument_list></call></expr>;</expr_stmt><comment type="block">/* POLAR*/</comment>
	<comment type="block">/*
	 * POLAR px: Write PLANGEN_PX at the beginning of _outPlannedStmt.
	 * So is_px_read_plangen will be set to true at the beginning of _readPlannedStmt.
	 * Other nodes will be read depend on is_px_read_plangen.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>planGen</name></name> <operator>==</operator> <name>PLANGEN_PX</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>is_px_out_plangen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>planGen</name></expr></argument>, <argument><expr><name>PlanGenerator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_px_out_plangen</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT64_FIELD</name><argument_list>(<argument><expr><name>queryId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasReturning</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>transientPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dependsOnRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>jitFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>planTree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>nonleafResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rootResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Don't serialize invalItems when dispatching. The TIDs of the invalidated items wouldn't
	 * make sense in segments.
	 */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>invalItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_px_out_plangen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		* POLAR px: write slices filed if there is any.
		*/</comment>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>numSlices</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :subplan_sliceIds"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>subplans</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>subplan_sliceIds</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>isDirectDispatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>directDispatch</name><operator>.</operator><name>contentIds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nParamExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Plan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>plan_rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>plan_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_aware</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>plan_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lefttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>righttree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>initPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>extParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>allParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_px_out_plangen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>flow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>px_scan_partial</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Scan
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outScanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Scan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>scanrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Join
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinPlanInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Join</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inner_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_px_out_plangen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>prefetch_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Plan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outResult</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Result</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resconstantqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_px_out_plangen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numHashFilterCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :hashFilterColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashFilterColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :hashFilterFuncs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numHashFilterCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashFilterFuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outProjectSet</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProjectSet</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PROJECTSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outModifyTable</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModifyTable</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MODIFYTABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rootResultRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwPrivLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fdwDirectModifyPlans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>onConflictAction</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterIndexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>exclRelRTI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>isSplitUpdates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Append</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPEND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>appendplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>first_partial_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_prune_paramids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergeAppend</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergeAppend</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEAPPEND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :collations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :nullsFirst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>booltostr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRecursiveUnion</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecursiveUnion</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RECURSIVEUNION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :dupColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :dupOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSequence</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sequence</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SEQUENCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapAnd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapAnd</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPAND"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapOr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapOr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGather</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Gather</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rescan_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>single_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>invisible</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGatherMerge</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GatherMerge</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHERMERGE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rescan_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :collations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :nullsFirst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>booltostr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>initParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Scan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSeqScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SeqScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SEQSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSampleScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SampleScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SAMPLESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbyops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexOnlyScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexOnlyScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXONLYSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexorderdir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapIndexScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapIndexScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPINDEXSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isshared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapHeapScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapHeapScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPHEAPSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapqualorig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTidScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TidScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TIDSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubqueryScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubqueryScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBQUERYSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFunctionScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCTIONSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableFuncScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFuncScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNCSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outValuesScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ValuesScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VALUESSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCteScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CteScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CTESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ctePlanId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cteParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNamedTuplestoreScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedTuplestoreScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NAMEDTUPLESTORESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWorkTableScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WorkTableScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WORKTABLESCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>fs_server</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_recheck_quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>fs_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>fsSystemCol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCustomScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CustomScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CUSTOMSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outScanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Scan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_scan_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>custom_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* CustomName is a key to lookup CustomScanMethods */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :methods "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Join</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"JOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNestLoop</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NestLoop</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NESTLOOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>nestParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergeJoin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergeJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numCols</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEJOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_mark_restore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numCols</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeclauses</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :mergeFamilies"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeFamilies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :mergeCollations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeCollations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :mergeStrategies"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeStrategies</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :mergeNullsFirst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numCols</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>booltostr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>mergeNullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outHashJoin</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HashJoin</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"HASHJOIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Join</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAgg</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Agg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :grpColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :grpOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>aggParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>chain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_px_out_plangen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>streaming</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowAgg</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowAgg</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWAGG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>partNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :partColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :partOperations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>partNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>partOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ordNumCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :ordColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :ordOperations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>ordNumCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>ordOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroup</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Group</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :grpColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>grpColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :grpOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>grpOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMaterial</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Material</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MATERIAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>px_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>px_shield_child_from_rescans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outShareInputScan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ShareInputScan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SHAREINPUTSCAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cross_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>share_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>producer_slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>this_slice_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nconsumers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSort</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Sort</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :collations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :nullsFirst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>booltostr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* POLAR px */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_px_out_plangen</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>noduplicates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUnique</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Unique</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UNIQUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :uniqColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>uniqColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :uniqOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>uniqOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outHash</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Hash</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"HASH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>skewTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>skewColumn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skewInherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows_total</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetOp</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>SetOpCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>SetOpStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :dupColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :dupOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>dupOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>flagColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LONG_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockRows</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockRows</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKROWS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLimit</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Limit</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LIMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNestLoopParam</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NestLoopParam</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NESTLOOPPARAM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlanRowMark</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlanRowMark</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANROWMARK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>prti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rowmarkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>markType</name></expr></argument>, <argument><expr><name>RowMarkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>allMarkTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isParent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionPruneInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionPruneInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>prune_infos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>other_subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionedRelPruneInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionedRelPruneInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONEDRELPRUNEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>present_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nparts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :subplan_map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>subplan_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :subpart_map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>subpart_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :hasexecparam"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nexprs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>booltostr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hasexecparam</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>do_initial_prune</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>do_exec_prune</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>execparamids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>initial_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exec_pruning_steps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :relid_map"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nparts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>relid_map</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionPruneStepOp</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionPruneStepOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>opstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cmpfns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionPruneStepCombine</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionPruneStepCombine</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONPRUNESTEPCOMBINE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>step</name><operator>.</operator><name>step_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>combineOp</name></expr></argument>, <argument><expr><name>PartitionPruneCombineOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>source_stepids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlanInvalItem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlanInvalItem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANINVALITEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cacheId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from primnodes.h.
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlias</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Alias</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALIAS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeVar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGEVAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * we deliberately ignore catalogname here, since it is presently not
	 * semantically meaningful
	 */</comment>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLEFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>notnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ordinalitycol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIntoClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IntoClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INTOCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>onCommit</name></expr></argument>, <argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>viewQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outVar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Var</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"VAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>varnoold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>varoattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConst</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :constvalue "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outParam</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Param</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARAM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>paramkind</name></expr></argument>, <argument><expr><name>ParamKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>paramcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAggref</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Aggref</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGGREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggtranstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdirectargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>aggvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>wincollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>winstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>winagg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outArrayRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ARRAYREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refarraytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>reftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>refcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refupperindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>reflowerindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFuncExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>funcresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>funcformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>funccollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isGlobalFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNamedArgExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NAMEDARGEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>argnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outOpExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"OPEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDistinctExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DistinctExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DISTINCTEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNullIfExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NULLIFEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SCALARARRAYOPEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBoolExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BoolExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>opstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BOOLEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* do-it-yourself enum representation */</comment>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>boolop</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AND_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opstr</name> <operator>=</operator> <literal type="string">"and"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>OR_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opstr</name> <operator>=</operator> <literal type="string">"or"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOT_EXPR</name></expr>:</case>
			<expr_stmt><expr><name>opstr</name> <operator>=</operator> <literal type="string">"not"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :boolop "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubLink</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBLINK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>subLinkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>operName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubPlan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>, <argument><expr><name>SubLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>plan_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>firstColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstColTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>firstColCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unknownEqFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>parParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>per_call_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ALTERNATIVESUBPLAN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFieldSelect</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldSelect</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FIELDSELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFieldStore</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldStore</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FIELDSTORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fieldnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRelabelType</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelabelType</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RELABELTYPE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>relabelformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoerceViaIO</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COERCEVIAIO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outArrayCoerceExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ARRAYCOERCEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>elemexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConvertRowtypeExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONVERTROWTYPEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>convertformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCollateExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollateExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLLATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCaseExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CASE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>casetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>casecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCaseWhen</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseWhen</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WHEN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCaseTestExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseTestExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CASETESTEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outArrayExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ARRAY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>array_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>multidims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>row_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>row_format</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowCompareExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowCompareExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROWCOMPARE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rctype</name></expr></argument>, <argument><expr><name>RowCompareType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>inputcollids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoalesceExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COALESCE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>coalescetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>coalescecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMinMaxExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MINMAX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>minmaxcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>MinMaxOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSQLValueFunction</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SQLValueFunction</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SQLVALUEFUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SQLValueFunctionOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outXmlExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XmlExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"XMLEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>XmlExprOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>named_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>XmlOptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNullTest</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NullTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NULLTEST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulltesttype</name></expr></argument>, <argument><expr><name>NullTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>argisrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBooleanTest</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BooleanTest</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BOOLEANTEST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>booltesttype</name></expr></argument>, <argument><expr><name>BoolTestType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoerceToDomain</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>coercionformat</name></expr></argument>, <argument><expr><name>CoercionForm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCoerceToDomainValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COERCETODOMAINVALUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetToDefault</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetToDefault</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETTODEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCurrentOfExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CurrentOfExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CURRENTOFEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>cvarno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cursor_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNextValueExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NextValueExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NEXTVALUEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>seqid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outInferenceElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InferenceElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INFERENCEELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>infercollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTargetEntry</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TARGETENTRY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ressortgroupref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>resorigtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resorigcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTblRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETBLREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"JOINEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNatural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFromExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FromExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FROMEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outOnConflictExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ONCONFLICTEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>, <argument><expr><name>OnConflictAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from relation.h.
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from Path
 *
 * Note we do NOT print the parent, else we'd be in infinite recursion.
 * We can print the parent's relids for identification purposes, though.
 * We print the pathtarget only if it's not the default one for the rel.
 * We also do not print the whole of param_info, since it's printed by
 * _outRelOptInfo; it's sufficient and less cluttering to print just the
 * required outer relids.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPathInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Path</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>pathtype</name></expr></argument>, <argument><expr><name>NodeTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :parent_relids "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>pathtarget</name></name> <operator>!=</operator> <name><name>node</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>reltarget</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pathtarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :required_outer "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>param_info</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>param_info</name><operator>-&gt;</operator><name>ppi_req_outer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_aware</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_cost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from JoinPath
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outJoinPathInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inner_unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>outerjoinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>innerjoinpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinrestrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Path</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexqualcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexorderbycols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>indexscandir</name></expr></argument>, <argument><expr><name>ScanDirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>indextotalcost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>indexselectivity</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapHeapPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapHeapPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPHEAPPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapAndPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapAndPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPANDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>bitmapselectivity</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outBitmapOrPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BitmapOrPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"BITMAPORPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>bitmapquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>bitmapselectivity</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTidPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TidPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TIDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tidquals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSubqueryScanPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubqueryScanPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SUBQUERYSCANPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_outerpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdw_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCustomPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CustomPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CUSTOMPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>custom_private</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :methods "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>methods</name><operator>-&gt;</operator><name>CustomName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppendPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AppendPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPENDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>first_partial_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergeAppendPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergeAppendPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEAPPENDPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>limit_tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outResultPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResultPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESULTPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMaterialPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MaterialPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MATERIALPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUniquePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UniquePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UNIQUEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>umethod</name></expr></argument>, <argument><expr><name>UniquePathMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>in_operators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>uniq_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGatherPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GatherPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHERPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>single_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outProjectionPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProjectionPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PROJECTIONPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dummypp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outProjectSetPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ProjectSetPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PROJECTSETPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSortPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORTPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outUpperUniquePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UpperUniquePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"UPPERUNIQUEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAggPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AGGPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>, <argument><expr><name>AggSplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRollupData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RollupData</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROLLUP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>gsets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>gsets_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_hashed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSetData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSetData</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GSDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSetsPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSetsPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSETSPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>aggstrategy</name></expr></argument>, <argument><expr><name>AggStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rollups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMinMaxAggPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxAggPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MINMAXAGGPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mmaggregates</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowAggPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowAggPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWAGGPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>winclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetOpPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOpPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETOPPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>SetOpCmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>SetOpStrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>flagColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>firstFlag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRecursiveUnionPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RecursiveUnionPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RECURSIVEUNIONPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>leftpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rightpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wtParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>numGroups</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockRowsPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockRowsPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKROWSPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outModifyTablePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ModifyTablePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MODIFYTABLEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>operation</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>nominalRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpaths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subroots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptionLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onconflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>epqParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLimitPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LimitPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LIMITPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGatherMergePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GatherMergePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GATHERMERGEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>Path</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNestPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NestPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NESTPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMergePath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MergePath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MERGEPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>path_mergeclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>outersortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>innersortkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_mark_restore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>materialize_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outHashPath</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>HashPath</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"HASHPATH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outJoinPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>JoinPath</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>path_hashclauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>num_batches</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>inner_rows_total</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannerGlobal</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannerGlobal</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNERGLOBAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>rewindPlanIDs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>finalrtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>finalrowmarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>resultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>nonleafResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rootResultRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relationOids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>invalItems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramExecTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>lastPHId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>lastRowMarkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>lastPlanNodeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>transientPlan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>dependsOnRole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>parallelModeNeeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>maxParallelHazard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nParamExec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannerInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannerInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNERINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>parse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>query_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>plan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>all_baserels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullable_baserels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_rel_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>join_cur_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>init_plans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cte_plan_ids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>multiexpr_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>eq_classes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>canon_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>left_join_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>right_join_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>full_join_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>join_info_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>append_rel_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>placeholder_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fkey_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>query_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>group_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>window_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinct_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sort_pathkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>processed_tlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>minmax_aggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>total_table_pages</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>tuple_fraction</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>limit_tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>qual_security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>inhTargetKind</name></expr></argument>, <argument><expr><name>InheritanceKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasJoinRTEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasLateralRTEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDeletedRTEs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasHavingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasPseudoConstantQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>wt_param_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>curOuterRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>curOuterParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>partColsUpdated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRelOptInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RELOPTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>reloptkind</name></expr></argument>, <argument><expr><name>RelOptKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_startup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_param_startup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_parallel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>reltarget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pathlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ppilist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partial_pathlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_startup_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_total_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_unique_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cheapest_parameterized_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>direct_lateral_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>lateral_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>reltablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>, <argument><expr><name>RTEKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>min_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>max_attr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lateral_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>lateral_referencers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>statlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>allvisfrac</name></expr></argument>, <argument><expr><literal type="string">"%.6f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplan_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>rel_parallel_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>serverid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>userid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useridiscurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we don't try to print fdwroutine or fdw_private */</comment>
	<comment type="block">/* can't print unique_for_rels/non_unique_for_rels; BMSes aren't Nodes */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>baserestrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>baserestrict_min_security</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joininfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>has_eclass_joins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>consider_partitionwise_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>top_parent_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitioned_child_rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexOptInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexOptInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXOPTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Do NOT print rel field, else infinite recursion */</comment>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>tuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>tree_height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* array fields aren't really worth the trouble to print */</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* indexprs is redundant since we print indextlist */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indpred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indextlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indrestrictinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>predOK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>immediate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hypothetical</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we don't bother with fields copied from the index AM's API struct */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignKeyOptInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignKeyOptInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNKEYOPTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>con_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ref_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :conkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :confkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :conpfeqop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nmatched_ec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nmatched_rcols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nmatched_ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* for compactness, just print the number of matches per column: */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :eclass"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>eclass</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :rinfos"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>rinfos</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outStatisticExtInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>StatisticExtInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"STATISTICEXTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>statOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't write rel, leads to infinite recursion in plan tree dump */</comment>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outEquivalenceClass</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EquivalenceClass</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * To simplify reading, we just chase up to the topmost merged EC and
	 * print that, without bothering to show the merge-ees separately.
	 */</comment>
	<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>ec_merged</name></name></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EQUIVALENCECLASS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>ec_collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_members</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_sources</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ec_derives</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ec_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_has_const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_has_volatile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_below_outer_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ec_broken</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ec_sortref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ec_min_security</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ec_max_security</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outEquivalenceMember</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>EquivalenceMember</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EQUIVALENCEMEMBER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>em_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>em_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>em_nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>em_is_const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>em_is_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>em_datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPathKey</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PathKey</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PATHKEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pk_eclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>pk_opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>pk_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pk_nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPathTarget</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PathTarget</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PATHTARGET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>sortgrouprefs</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortgrouprefs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>exprs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortgrouprefs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name><name>cost</name><operator>.</operator><name>startup</name></name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name><name>cost</name><operator>.</operator><name>per_tuple</name></name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outParamPathInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamPathInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARAMPATHINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ppi_req_outer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>ppi_rows</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ppi_clauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRestrictInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESTRICTINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* NB: this isn't a complete set of fields */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_pushed_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>outerjoin_delayed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>can_join</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pseudoconstant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>leakproof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>clause_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>required_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>left_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>right_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>orclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't write parent_ec, leads to infinite recursion in plan tree dump */</comment>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>norm_selec</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>outer_selec</name></expr></argument>, <argument><expr><literal type="string">"%.4f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>mergeopfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* don't write left_ec, leads to infinite recursion in plan tree dump */</comment>
	<comment type="block">/* don't write right_ec, leads to infinite recursion in plan tree dump */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>left_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>right_em</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>outer_is_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>hashjoinoperator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlaceHolderVar</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlaceHolderVar</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLACEHOLDERVAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>phexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>phrels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>phlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSpecialJoinInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SPECIALJOININFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>syn_lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>syn_righthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lhs_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>delay_upper_joins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>semi_can_btree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>semi_can_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>semi_operators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>semi_rhs_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAppendRelInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"APPENDRELINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>parent_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>child_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>parent_reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>child_reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>translated_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlaceHolderInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLACEHOLDERINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ph_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_eval_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ph_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMinMaxAggInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxAggInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MINMAXAGGINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>aggsortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We intentionally omit subroot --- too large, not interesting enough */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>pathcost</name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPlannerParamItem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlannerParamItem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PLANNERPARAMITEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from extensible.h
 *
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outExtensibleNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>extnodename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"EXTENSIBLENODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* serialize the private fields */</comment>
	<expr_stmt><expr><call><name><name>methods</name><operator>-&gt;</operator><name>nodeOut</name></name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *
 *	Stuff from parsenodes.h.
 *
 *****************************************************************************/</comment>

<comment type="block">/*
 * print the basic stuff of all nodes that inherit from CreateStmt
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateStmtInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>inhRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ofTypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>oncommit</name></expr></argument>, <argument><expr><name>OnCommitAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outCreateStmtInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateForeignTableStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATEFOREIGNTABLESTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outCreateStmtInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>CreateStmt</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outImportForeignSchemaStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ImportForeignSchemaStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"IMPORTFOREIGNSCHEMASTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>server_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>remote_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>local_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>list_type</name></expr></argument>, <argument><expr><name>ImportForeignSchemaType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>idxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexIncludingParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>excludeOpNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>idxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>transformed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCreateStatsStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CREATESTATSSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>defnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>stxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outNotifyStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NotifyStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"NOTIFY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DECLARECURSOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSelectStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SelectStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFuncCall</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncCall</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FUNCCALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_within_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>func_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>over</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDefElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DEFELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>defnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>defaction</name></expr></argument>, <argument><expr><name>DefElemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableLikeClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableLikeClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLELIKECLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outLockingClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockingClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"LOCKINGCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lockedRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outXmlSerialize</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XmlSerialize</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"XMLSERIALIZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>, <argument><expr><name>XmlOptionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outDMLActionExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DMLActionExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"DMLACTIONEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTriggerTransition</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TriggerTransition</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TRIGGERTRANSITION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outColumnDef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnDef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLUMNDEF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>inhcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_from_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cooked_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>identitySequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTypeName</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TYPENAME"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>setof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pct_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>typemod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arrayBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTypeCast</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeCast</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TYPECAST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCollateClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollateClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLLATECLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outIndexElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"INDEXELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexcolname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>ordering</name></expr></argument>, <argument><expr><name>SortByDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>nulls_ordering</name></expr></argument>, <argument><expr><name>SortByNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outQuery</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Query</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"QUERY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>, <argument><expr><name>CmdType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>, <argument><expr><name>QuerySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we intentionally do not print the queryId field */</comment>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Hack to work around missing outfuncs routines for a lot of the
	 * utility-statement node types.  (The only one we actually *need* for
	 * rules support is NotifyStmt.)  Someday we ought to support 'em all, but
	 * for the meantime do this to avoid getting lots of warnings when running
	 * with debug_print_parse on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>utilityStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :utilityStmt ?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :utilityStmt &lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasTargetSRFs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>, <argument><expr><name>OverridingKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* withCheckOptions intentionally omitted, see comment in parsenodes.h */</comment>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWithCheckOption</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WithCheckOption</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WITHCHECKOPTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>WCOKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cascaded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSortGroupClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORTGROUPCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>tleSortGroupRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outGroupingSet</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSet</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"GROUPINGSET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>GroupingSetKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>copiedOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRowMarkClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowMarkClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ROWMARKCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>LockClauseStrength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>LockWaitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWithClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WithClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WITHCLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>recursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outCommonTableExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CommonTableExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COMMONTABLEEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>aliascolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>ctematerialized</name></expr></argument>, <argument><expr><name>CTEMaterialize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>cterecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>cterefcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSetOperationStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOperationStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SETOPERATIONSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>SetOperation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTblEntry</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RTE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* put alias + eref first to make dump more legible */</comment>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>eref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>, <argument><expr><name>RTEKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RTE_RELATION</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>security_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_JOIN</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>JoinType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinaliasvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_VALUES</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_CTE</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>self_reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RTE_NAMEDTUPLESTORE</name></expr>:</case>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_FLOAT_FIELD</name><argument_list>(<argument><expr><name>enrtuples</name></expr></argument>, <argument><expr><literal type="string">"%.0f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized RTE kind: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>rtekind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>inFromCl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_UINT_FIELD</name><argument_list>(<argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>checkAsUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>selectedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>securityQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTblFunction</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblFunction</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETBLFUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>funccolcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>funcparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTableSampleClause</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TABLESAMPLECLAUSE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>tsmhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"AEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AEXPR_OP</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ANY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ANY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OP_ALL</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ALL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_DISTINCT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" DISTINCT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_DISTINCT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NOT_DISTINCT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NULLIF</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NULLIF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_OF</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" OF "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_IN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" IN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_LIKE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" LIKE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_ILIKE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ILIKE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_SIMILAR</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" SIMILAR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" BETWEEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NOT_BETWEEN "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_BETWEEN_SYM</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" BETWEEN_SYM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_NOT_BETWEEN_SYM</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" NOT_BETWEEN_SYM "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>AEXPR_PAREN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" PAREN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" ??"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outValue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Value</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>

			<comment type="block">/*
			 * We assume the value is a valid numeric literal and so does not
			 * need quoting.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_String</name></expr>:</case>

			<comment type="block">/*
			 * We use outToken to provide escaping of the string's content,
			 * but we don't want it to do anything with an empty string.
			 */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>outToken</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BitString</name></expr>:</case>
			<comment type="block">/* internal representation already has leading 'b' */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Null</name></expr>:</case>
			<comment type="block">/* this is seen only within A_Const, not in transformed trees */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outColumnRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"COLUMNREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outParamRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARAMREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Node types found in raw parse trees (supported for debug purposes)
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRawStmt</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RawStmt</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RAWSTMT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAConst</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Const</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_CONST"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :val "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_outValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_Star</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Star</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_STAR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_Indices</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Indices</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_INDICES"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_Indirection</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Indirection</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_INDIRECTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outA_ArrayExpr</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"A_ARRAYEXPR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outResTarget</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RESTARGET"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMultiAssignRef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MultiAssignRef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MULTIASSIGNREF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSortBy</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortBy</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SORTBY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>sortby_dir</name></expr></argument>, <argument><expr><name>SortByDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>sortby_nulls</name></expr></argument>, <argument><expr><name>SortByNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>useOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outWindowDef</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowDef</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"WINDOWDEF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeSubselect</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeSubselect</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGESUBSELECT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeFunction</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeFunction</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGEFUNCTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>ordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_rowsfrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTableSample</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableSample</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETABLESAMPLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTableFunc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableFunc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETABLEFUNC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outRangeTableFuncCol</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableFuncCol</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"RANGETABLEFUNCCOL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>for_ordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>colexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outConstraint</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Constraint</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"CONSTRAINT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :contype "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CONSTR_NULL</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_NOTNULL</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"NOT_NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"DEFAULT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cooked_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_IDENTITY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"IDENTITY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cooked_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>generated_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_no_inherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>cooked_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_PRIMARY</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"PRIMARY_KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>including</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* access_method and where_clause not currently used */</comment>
			<break>break;</break>

		<case>case <expr><name>CONSTR_UNIQUE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"UNIQUE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>including</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* access_method and where_clause not currently used */</comment>
			<break>break;</break>

		<case>case <expr><name>CONSTR_EXCLUSION</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"EXCLUSION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclusions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>including</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>access_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_FOREIGN</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"FOREIGN_KEY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pktable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>fk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>pk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_matchtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_upd_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>fk_del_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>old_conpfeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>old_pktable_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>initially_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_ATTR_DEFERRABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"ATTR_DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_ATTR_NOT_DEFERRABLE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"ATTR_NOT_DEFERRABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_ATTR_DEFERRED</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"ATTR_DEFERRED"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>CONSTR_ATTR_IMMEDIATE</name></expr>:</case>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"ATTR_IMMEDIATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;unrecognized_constraint %d&gt;"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outForeignKeyCacheInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ForeignKeyCacheInfo</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FOREIGNKEYCACHEINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>conrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>confrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>nkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :conkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>conkey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :confkey"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>confkey</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :conpfeqop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>conpfeqop</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionElem</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionElem</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONELEM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONSPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>partParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionBoundSpec</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONBOUNDSPEC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_CHAR_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>is_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>lowerdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>upperdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionRangeDatum</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONRANGEDATUM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>PartitionRangeDatumKind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPxProcess</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PxProcess</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PXPROCESS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>listenerAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>listenerPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>contentid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POLAR px */</comment>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>contentCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>remotePort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSliceTable</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SliceTable</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SLICETABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>localSlice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numSlices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSlices</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sliceIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rootIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>parentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>planNumSegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of int index */</comment>
		<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gangType</name></expr></argument>, <argument><expr><name>GangType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of int */</comment>
		<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>primaryProcesses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* List of (PXProcess *) */</comment>
		<expr_stmt><expr><call><name>WRITE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name><name>slices</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>processesMap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>hasMotions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>instrument_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>ic_instance_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outMotion</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Motion</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"MOTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>motionID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>motionType</name></expr></argument>, <argument><expr><name>MotionType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>sendSorted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>hashExprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :hashFuncs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashExprs</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>hashFuncs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numSortCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortColIdx"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %d"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortColIdx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :sortOperators"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>sortOperators</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :collations"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>collations</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :nullsFirst"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>numSortCols</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>booltostr</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nullsFirst</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>segidColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * POLAR px : _outSplitUpdate
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSplitUpdate</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SplitUpdate</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SPLITUPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>actionColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>tupleoidColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>insertColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>deleteColIdx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outQueryDispatchDesc</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>QueryDispatchDesc</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"QUERYDISPATCHDESC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_STRING_FIELD</name><argument_list>(<argument><expr><name>intoTableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>oidAssignments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>sliceTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>cursorPositions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>useChangedAOOpts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outSerializedParamExternData</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SerializedParamExternData</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"SERIALIZEDPARAMEXTERNDATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT16_FIELD</name><argument_list>(<argument><expr><name>pflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT16_FIELD</name><argument_list>(<argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name>pbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">" :paramvalue "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>outDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>value</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>plen</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>pbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outFlow</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Flow</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"FLOW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_ENUM_FIELD</name><argument_list>(<argument><expr><name>flotype</name></expr></argument>, <argument><expr><name>FlowType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>worker_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>numsegments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outTupleDescNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TupleDescNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>==</operator> <name>RECORDOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"TUPLEDESCNODE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendBinaryStringInfoPX</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>attrs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ATTRIBUTE_FIXED_PART_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tuple</name><operator>-&gt;</operator><name>constr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_OID_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_BOOL_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdhasoid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name><name>tuple</name><operator>-&gt;</operator><name>tdrefcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* POLAR px */</comment>
<comment type="block">/*
 * _outPartitionSelector
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outPartitionSelector</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionSelector</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"PARTITIONSELECTOR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>part_prune_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * _outAssertOp
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_outAssertOp</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AssertOp</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>WRITE_NODE_TYPE</name><argument_list>(<argument><expr><literal type="string">"ASSERTOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>WRITE_NODE_FIELD</name><argument_list>(<argument><expr><name>errmessage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>WRITE_INT_FIELD</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>_outPlanInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<comment type="block">/*
 * outNode -
 *	  converts a Node into ascii string and append it to 'str'
 */</comment>
<function><type><name>void</name></type>
<name>outNode</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>obj</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"&lt;&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>List</name></expr></argument>)</argument_list></call> <operator>||</operator><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>IntList</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>OidList</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>_outList</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Integer</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>Float</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>BitString</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nodeRead does not want to see { } around these! */</comment>
		<expr_stmt><expr><call><name>_outValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_PlannedStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannedStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Plan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Result</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResult</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectSet</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectSet</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ModifyTable</name></expr>:</case>
				<expr_stmt><expr><call><name>_outModifyTable</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Append</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppend</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeAppend</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeAppend</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RecursiveUnion</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRecursiveUnion</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<comment type="block">/* POLAR px */</comment>
			<case>case <expr><name>T_Sequence</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSequence</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapAnd</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapAnd</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapOr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapOr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Gather</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGather</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherMerge</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherMerge</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Scan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SeqScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSeqScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SampleScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSampleScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexOnlyScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexOnlyScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapIndexScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapHeapScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapHeapScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TidScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTidScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubqueryScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubqueryScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FunctionScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFunctionScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFuncScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFuncScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ValuesScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outValuesScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CteScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCteScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedTuplestoreScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNamedTuplestoreScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WorkTableScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWorkTableScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CustomScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCustomScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Join</name></expr>:</case>
				<expr_stmt><expr><call><name>_outJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoop</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestLoop</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeJoin</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_HashJoin</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHashJoin</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Agg</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAgg</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowAgg</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowAgg</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Group</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroup</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Material</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMaterial</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<comment type="block">/* POLAR px */</comment>
			<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outShareInputScan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Sort</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSort</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Unique</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUnique</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Hash</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHash</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockRows</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockRows</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Limit</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLimit</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestLoopParam</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestLoopParam</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanRowMark</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlanRowMark</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionedRelPruneInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionedRelPruneInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneStepOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionPruneStepCombine</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionPruneStepCombine</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlanInvalItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlanInvalItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Alias</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlias</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeVar</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IntoClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIntoClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Var</name></expr>:</case>
				<expr_stmt><expr><call><name>_outVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Const</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConst</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Param</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParam</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Aggref</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAggref</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFuncExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNamedArgExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OpExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOpExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDistinctExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNullIfExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outScalarArrayOpExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BoolExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBoolExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubLink</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubLink</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubPlan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAlternativeSubPlan</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldSelect</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFieldSelect</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FieldStore</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFieldStore</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RelabelType</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRelabelType</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceViaIO</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayCoerceExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConvertRowtypeExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCollateExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseWhen</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseWhen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCaseTestExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outArrayExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowCompareExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoalesceExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSQLValueFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outXmlExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NullTest</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNullTest</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BooleanTest</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBooleanTest</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceToDomain</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCoerceToDomainValue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetToDefault</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetToDefault</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCurrentOfExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNextValueExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_InferenceElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outInferenceElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TargetEntry</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTargetEntry</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_JoinExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outJoinExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FromExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFromExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outOnConflictExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Path</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapHeapPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapHeapPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapAndPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapAndPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_BitmapOrPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outBitmapOrPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TidPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTidPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SubqueryScanPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSubqueryScanPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CustomPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCustomPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AppendPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppendPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergeAppendPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergeAppendPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ResultPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResultPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MaterialPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMaterialPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UniquePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUniquePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectionPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectionPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ProjectSetPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outProjectSetPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_UpperUniquePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outUpperUniquePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AggPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAggPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetsPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSetsPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxAggPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxAggPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowAggPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowAggPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOpPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOpPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RecursiveUnionPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRecursiveUnionPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockRowsPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockRowsPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ModifyTablePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outModifyTablePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LimitPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLimitPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GatherMergePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGatherMergePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NestPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNestPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MergePath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMergePath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_HashPath</name></expr>:</case>
				<expr_stmt><expr><call><name>_outHashPath</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlannerGlobal</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannerGlobal</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlannerInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannerInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RelOptInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRelOptInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexOptInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexOptInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignKeyOptInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignKeyOptInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_EquivalenceClass</name></expr>:</case>
				<expr_stmt><expr><call><name>_outEquivalenceClass</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_EquivalenceMember</name></expr>:</case>
				<expr_stmt><expr><call><name>_outEquivalenceMember</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PathKey</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPathKey</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PathTarget</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPathTarget</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ParamPathInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParamPathInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RestrictInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRestrictInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlaceHolderVar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SpecialJoinInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSpecialJoinInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AppendRelInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAppendRelInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlaceHolderInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlaceHolderInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MinMaxAggInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMinMaxAggInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PlannerParamItem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPlannerParamItem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RollupData</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRollupData</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSetData</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSetData</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_StatisticExtInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outStatisticExtInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ExtensibleNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outExtensibleNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateForeignTableStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outImportForeignSchemaStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCreateStatsStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outNotifyStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDeclareCursorStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SelectStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSelectStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnDef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnDef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeName</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTypeName</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TypeCast</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTypeCast</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CollateClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCollateClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_IndexElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outIndexElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Query</name></expr>:</case>
				<expr_stmt><expr><call><name>_outQuery</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWithCheckOption</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortGroupClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_GroupingSet</name></expr>:</case>
				<expr_stmt><expr><call><name>_outGroupingSet</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RowMarkClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRowMarkClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WithClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWithClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outCommonTableExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSetOperationStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblEntry</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTblFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableSampleClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Expr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ColumnRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outColumnRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ParamRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outParamRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RawStmt</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRawStmt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Const</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAConst</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Star</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Star</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indices</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Indices</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_Indirection</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_Indirection</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outA_ArrayExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ResTarget</name></expr>:</case>
				<expr_stmt><expr><call><name>_outResTarget</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMultiAssignRef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SortBy</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSortBy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_WindowDef</name></expr>:</case>
				<expr_stmt><expr><call><name>_outWindowDef</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeSubselect</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeSubselect</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeFunction</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeFunction</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTableSample</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTableSample</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTableFunc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTableFunc</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_RangeTableFuncCol</name></expr>:</case>
				<expr_stmt><expr><call><name>_outRangeTableFuncCol</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Constraint</name></expr>:</case>
				<expr_stmt><expr><call><name>_outConstraint</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_FuncCall</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFuncCall</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DefElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDefElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTableLikeClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_LockingClause</name></expr>:</case>
				<expr_stmt><expr><call><name>_outLockingClause</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
				<expr_stmt><expr><call><name>_outXmlSerialize</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_ForeignKeyCacheInfo</name></expr>:</case>
				<expr_stmt><expr><call><name>_outForeignKeyCacheInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TriggerTransition</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTriggerTransition</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionElem</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionElem</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionBoundSpec</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionRangeDatum</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionRangeDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<comment type="block">/* POLAR px */</comment>
			<case>case <expr><name>T_Motion</name></expr>:</case>
				<expr_stmt><expr><call><name>_outMotion</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PxProcess</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPxProcess</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SliceTable</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSliceTable</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_QueryDispatchDesc</name></expr>:</case>
				<expr_stmt><expr><call><name>_outQueryDispatchDesc</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SerializedParamExternData</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSerializedParamExternData</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Flow</name></expr>:</case>
				<expr_stmt><expr><call><name>_outFlow</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_TupleDescNode</name></expr>:</case>
				<expr_stmt><expr><call><name>_outTupleDescNode</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_AssertOp</name></expr>:</case>
				<expr_stmt><expr><call><name>_outAssertOp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_PartitionSelector</name></expr>:</case>
				<expr_stmt><expr><call><name>_outPartitionSelector</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_SplitUpdate</name></expr>:</case>
				<expr_stmt><expr><call><name>_outSplitUpdate</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_DMLActionExpr</name></expr>:</case>
				<expr_stmt><expr><call><name>_outDMLActionExpr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<comment type="block">/* POLAR end */</comment>

			<default>default:</default>

				<comment type="block">/*
				 * This should be an ERROR, but it's too useful to be able to
				 * dump structures that outNode only understands part of.
				 */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"could not dump unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * nodeToString -
 *	   returns the ascii representation of the Node as a palloc'd string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>nodeToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<comment type="block">/* see stringinfo.h for an explanation of this maneuver */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * bmsToString -
 *	   returns the ascii representation of the Bitmapset as a palloc'd string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>bmsToString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<comment type="block">/* see stringinfo.h for an explanation of this maneuver */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>outBitmapset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>bms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR px: we don't use the fast binary function from GPDB, we use
 * outNode with string function.
 * nodeToBinaryStringFast -
 *	   returns a binary representation of the Node as a palloc'd string
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>nodeToBinaryStringFast</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>

	<comment type="block">/* see stringinfo.h for an explanation of this maneuver */</comment>
	<expr_stmt><expr><call><name>initStringInfoOfSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>outNode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>length</name> <operator>=</operator> <name><name>str</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
