<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/backend/nodes/equalfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * equalfuncs.c
 *	  Equality functions to compare node trees.
 *
 * NOTE: we currently support comparing all node types found in parse
 * trees.  We do not support comparing executor state trees; there
 * is no need for that, and no point in maintaining all the code that
 * would be needed.  We also do not support comparing Path trees, mainly
 * because the circular linkages between RelOptInfo and Path nodes can't
 * be handled easily in a simple depth-first traversal.
 *
 * Currently, in fact, equal() doesn't know how to compare Plan trees
 * either.  This might need to be fixed someday.
 *
 * NOTE: it is intentional that parse location fields (in nodes that have
 * one) are not compared.  This is because we want, for example, a variable
 * "x" to be considered equal() to another reference to "x" in the query.
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/nodes/equalfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/extensible.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Macros to simplify comparison of different kinds of fields.  Use these
 * wherever possible to reduce the chance for silly typos.  Note that these
 * hard-wire the convention that the local variables in an Equal routine are
 * named 'a' and 'b'.
 */</comment>

<comment type="block">/* Compare a simple scalar field (int, float, bool, enum, etc) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_SCALAR_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (a-&gt;fldname != b-&gt;fldname) \
			return false; \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Compare a field that is a pointer to some kind of Node or Node tree */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_NODE_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!equal(a-&gt;fldname, b-&gt;fldname)) \
			return false; \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Compare a field that is a pointer to a Bitmapset */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_BITMAPSET_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!bms_equal(a-&gt;fldname, b-&gt;fldname)) \
			return false; \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Compare a field that is a pointer to a C string, or perhaps NULL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_STRING_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (!equalstr(a-&gt;fldname, b-&gt;fldname)) \
			return false; \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Macro for comparing string fields that might be NULL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>equalstr</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>(((a) != NULL &amp;&amp; (b) != NULL) ? (strcmp(a, b) == 0) : (a) == (b))</cpp:value></cpp:define>

<comment type="block">/* Compare a field that is a pointer to a simple palloc'd object of size sz */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_POINTER_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>, <parameter><type><name>sz</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (memcmp(a-&gt;fldname, b-&gt;fldname, (sz)) != 0) \
			return false; \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Compare a parse location field (this is a no-op, per note above) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_LOCATION_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((void) 0)</cpp:value></cpp:define>

<comment type="block">/* Compare a CoercionForm field (also a no-op, per comment in primnodes.h) */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPARE_COERCIONFORM_FIELD</name><parameter_list>(<parameter><type><name>fldname</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((void) 0)</cpp:value></cpp:define>


<comment type="block">/*
 *	Stuff from primnodes.h
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlias</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Alias</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Alias</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>aliasname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeVar</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>catalogname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTableFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableFunc</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableFunc</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_uris</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ns_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>notnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ordinalitycol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalIntoClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IntoClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IntoClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>onCommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpaceName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>viewQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We don't need an _equalExpr because Expr is an abstract supertype which
 * should never actually get instantiated.  Also, since it has no common
 * fields except NodeTag, there's no need for a helper routine to factor
 * out comparing the common fields...
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Var</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Var</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>varno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>vartypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>varcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>varlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>varnoold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>varoattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalConst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Const</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Const</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>consttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>constcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>constlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>constisnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>constbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We treat all NULL constants of the same type as equal. Someday this
	 * might need to change?  But datumIsEqual doesn't work on nulls, so...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>constisnull</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>datumIsEqual</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
						<argument><expr><name><name>a</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalParam</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Param</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Param</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>paramkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>paramid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>paramtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>paramtypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>paramcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAggref</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Aggref</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Aggref</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ignore aggtranstype since it might not be set yet */</comment>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggargtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdirectargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggorder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>aggsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalGroupingFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GroupingFunc</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingFunc</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We must not compare the refs or cols field
	 */</comment>

	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>agglevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalWindowFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WindowFunc</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowFunc</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>winfnoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>wintype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>wincollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aggfilter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>winstar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>winagg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalArrayRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArrayRef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayRef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>refarraytype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>refelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>reftypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>refcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>refupperindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>reflowerindexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>refexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>refassgnexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFuncExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funcresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funcretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funcvariadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>funcformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funccollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* POALR px */</comment>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isGlobalFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalNamedArgExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NamedArgExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>argnumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalOpExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OpExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OpExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special-case opfuncid: it is allowable for it to differ if one node
	 * contains zero and the other doesn't.  This just means that the one node
	 * isn't as far along in the parse/plan pipeline and hasn't had the
	 * opfuncid cache filled yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>&amp;&amp;</operator>
		<name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDistinctExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DistinctExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DistinctExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special-case opfuncid: it is allowable for it to differ if one node
	 * contains zero and the other doesn't.  This just means that the one node
	 * isn't as far along in the parse/plan pipeline and hasn't had the
	 * opfuncid cache filled yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>&amp;&amp;</operator>
		<name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalNullIfExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NullIfExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special-case opfuncid: it is allowable for it to differ if one node
	 * contains zero and the other doesn't.  This just means that the one node
	 * isn't as far along in the parse/plan pipeline and hasn't had the
	 * opfuncid cache filled yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>&amp;&amp;</operator>
		<name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opresulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opretset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalScalarArrayOpExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Special-case opfuncid: it is allowable for it to differ if one node
	 * contains zero and the other doesn't.  This just means that the one node
	 * isn't as far along in the parse/plan pipeline and hasn't had the
	 * opfuncid cache filled yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>&amp;&amp;</operator>
		<name><name>a</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>b</name><operator>-&gt;</operator><name>opfuncid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>useOr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalBoolExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BoolExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BoolExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>boolop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSubLink</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubLink</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>subLinkId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>operName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>subselect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSubPlan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SubPlan</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>subLinkType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>testexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>paramIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>plan_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>plan_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>firstColType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>firstColTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>firstColCollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>useHashTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>unknownEqFalse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>parallel_safe</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>setParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>parParam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>startup_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>per_call_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlternativeSubPlan</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlternativeSubPlan</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>subplans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFieldSelect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldSelect</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldSelect</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>fieldnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFieldStore</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FieldStore</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FieldStore</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>newvals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fieldnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRelabelType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RelabelType</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RelabelType</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>relabelformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCoerceViaIO</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceViaIO</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalArrayCoerceExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>elemexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>coerceformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalConvertRowtypeExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConvertRowtypeExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>convertformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCollateExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CollateExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollateExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCaseExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaseExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>casetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>casecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>defresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCaseWhen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaseWhen</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseWhen</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCaseTestExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CaseTestExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CaseTestExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalArrayExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ArrayExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>array_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>array_collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>element_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>multidims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRowExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RowExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>row_typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>row_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRowCompareExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RowCompareExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowCompareExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>rctype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilies</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>inputcollids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>largs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCoalesceExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoalesceExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>coalescetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>coalescecollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalMinMaxExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MinMaxExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>minmaxtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>minmaxcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inputcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSQLValueFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SQLValueFunction</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SQLValueFunction</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalXmlExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XmlExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XmlExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>named_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalNullTest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NullTest</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NullTest</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>nulltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>argisrow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalBooleanTest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>BooleanTest</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>BooleanTest</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>booltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCoerceToDomain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceToDomain</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resulttypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resultcollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_COERCIONFORM_FIELD</name><argument_list>(<argument><expr><name>coercionformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCoerceToDomainValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CoerceToDomainValue</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSetToDefault</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SetToDefault</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetToDefault</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeMod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCurrentOfExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CurrentOfExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CurrentOfExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>cvarno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>cursor_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>cursor_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalNextValueExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NextValueExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NextValueExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>seqid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalInferenceElem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InferenceElem</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InferenceElem</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>infercollid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inferopclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTargetEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>resname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ressortgroupref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resorigtbl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resorigcol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resjunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeTblRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTblRef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblRef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalJoinExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>JoinExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>JoinExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isNatural</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>rtindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFromExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FromExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FromExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>quals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalOnConflictExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnConflictExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arbiterWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>constraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictWhere</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclRelTlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stuff from relation.h
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPathKey</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PathKey</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PathKey</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We assume pointer equality is sufficient to compare the eclasses */</comment>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pk_eclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pk_opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pk_strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pk_nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRestrictInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RestrictInfo</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_pushed_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>outerjoin_delayed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>security_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>required_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>outer_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>nullable_relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We ignore all the remaining fields, since they may not be set yet, and
	 * should be derivable from the clause anyway.
	 */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPlaceHolderVar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PlaceHolderVar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlaceHolderVar</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We intentionally do not compare phexpr.  Two PlaceHolderVars with the
	 * same ID and levelsup should be considered equal even if the contained
	 * expressions have managed to mutate to different states.  This will
	 * happen during final plan construction when there are nested PHVs, since
	 * the inner PHV will get replaced by a Param in some copies of the outer
	 * PHV.  Another way in which it can happen is that initplan sublinks
	 * could get replaced by differently-numbered Params when sublink folding
	 * is done.  (The end result of such a situation would be some
	 * unreferenced initplans, which is annoying but not really a problem.) On
	 * the same reasoning, there is no need to examine phrels.
	 *
	 * COMPARE_NODE_FIELD(phexpr);
	 *
	 * COMPARE_BITMAPSET_FIELD(phrels);
	 */</comment>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>phlevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSpecialJoinInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>min_lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>min_righthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>syn_lefthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>syn_righthand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>lhs_strict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>delay_upper_joins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>semi_can_btree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>semi_can_hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>semi_operators</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>semi_rhs_exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAppendRelInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AppendRelInfo</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>parent_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>child_relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>parent_reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>child_reltype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>translated_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>parent_reloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPlaceHolderInfo</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PlaceHolderInfo</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>phid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ph_var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* should be redundant */</comment>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_eval_at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>ph_needed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ph_width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stuff from extensible.h
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalExtensibleNode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExtensibleNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ExtensibleNodeMethods</name> <modifier>*</modifier></type><name>methods</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>extnodename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* At this point, we know extnodename is the same for both nodes. */</comment>
	<expr_stmt><expr><name>methods</name> <operator>=</operator> <call><name>GetExtensibleNodeMethods</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>extnodename</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* compare the private fields */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>methods</name><operator>-&gt;</operator><name>nodeEqual</name></name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stuff from parsenodes.h
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalQuery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Query</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Query</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>commandType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>querySource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* we intentionally ignore queryId, since it might not be set */</comment>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>canSetTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>utilityStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>resultRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasAggs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasWindowFuncs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasTargetSRFs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasDistinctOn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasRecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasModifyingCTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasForUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hasRowSecurity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>cteList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rtable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>jointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupingSets</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowMarks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>setOperations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraintDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>withCheckOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRawStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RawStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RawStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>stmt_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalInsertStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InsertStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InsertStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>selectStmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>onConflictClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDeleteStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeleteStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeleteStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>usingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalUpdateStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UpdateStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UpdateStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>returningList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSelectStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SelectStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SelectStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>distinctClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>intoClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>havingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>windowClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>valuesLists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>sortClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>limitCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>lockingClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>withClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSetOperationStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SetOperationStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SetOperationStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>larg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colTypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colCollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>groupClauses</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterTableStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterTableStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTableStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>cmds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterTableCmd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterTableCmd</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTableCmd</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterCollationStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterCollationStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterCollationStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterDomainStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterDomainStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterDomainStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalGrantStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GrantStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>targtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>privileges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>grantees</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>grant_option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalObjectWithArgs</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ObjectWithArgs</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ObjectWithArgs</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>objname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>objargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>args_unspecified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAccessPriv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AccessPriv</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AccessPriv</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>priv_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalGrantRoleStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GrantRoleStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GrantRoleStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>granted_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>grantee_roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_grant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>admin_opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>grantor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterDefaultPrivilegesStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterDefaultPrivilegesStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterDefaultPrivilegesStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDeclareCursorStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeclareCursorStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalClosePortalStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ClosePortalStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ClosePortalStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCallStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CallStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CallStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccall</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalClusterStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ClusterStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ClusterStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCopyStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CopyStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>attlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tableElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>inhRelations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>partbound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>partspec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ofTypename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>oncommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTableLikeClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableLikeClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableLikeClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDefineStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DefineStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefineStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>oldstyle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>defnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>definition</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>removeType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTruncateStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TruncateStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TruncateStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>restart_seqs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCommentStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CommentStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CommentStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSecLabelStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SecLabelStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SecLabelStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>provider</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFetchStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FetchStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FetchStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>howMany</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>portalname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ismove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalIndexStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>idxname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>accessMethod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>tableSpace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexIncludingParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>excludeOpNames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>idxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>indexOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>oldNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>unique</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>primary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>transformed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateStatsStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateStatsStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>defnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>stat_types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>exprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>stxcomment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateFunctionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateFunctionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_procedure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>returnType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFunctionParameter</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FunctionParameter</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FunctionParameter</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>argType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>defexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterFunctionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterFunctionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDoStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DoStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DoStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRenameStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RenameStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RenameStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>renameType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relationType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterObjectDependsStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterObjectDependsStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterObjectSchemaStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterObjectSchemaStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>newschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterOwnerStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterOwnerStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objectType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>newowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterOperatorStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterOperatorStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterOperatorStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRuleStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RuleStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RuleStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>rulename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>instead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>actions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalNotifyStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>NotifyStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>NotifyStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>payload</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalListenStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ListenStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ListenStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalUnlistenStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>UnlistenStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>UnlistenStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conditionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTransactionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TransactionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TransactionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>savepoint_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>gid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCompositeTypeStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CompositeTypeStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typevar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateEnumStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateEnumStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateEnumStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateRangeStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateRangeStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateRangeStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterEnumStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterEnumStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterEnumStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>oldVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>newVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>newValNeighbor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>newValIsAfter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>skipIfNewValExists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalViewStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ViewStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ViewStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aliases</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>withCheckOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalLoadStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LoadStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LoadStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateDomainStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateDomainStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateDomainStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>domainname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateOpClassStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateOpClassStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateOpClassStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclassname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isDefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateOpClassItem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateOpClassItem</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateOpClassItem</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>itemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>order_family</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>class_args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>storedtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateOpFamilyStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateOpFamilyStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateOpFamilyStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterOpFamilyStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterOpFamilyStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opfamilyname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isDrop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>items</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreatedbStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreatedbStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatedbStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterDatabaseStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterDatabaseStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterDatabaseStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterDatabaseSetStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterDatabaseSetStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterDatabaseSetStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropdbStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropdbStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropdbStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalVacuumStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VacuumStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VacuumStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalVacuumRelation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VacuumRelation</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VacuumRelation</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>va_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalExplainStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExplainStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExplainStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateTableAsStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTableAsStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_select_into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRefreshMatViewStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RefreshMatViewStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RefreshMatViewStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>concurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>skipData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalReplicaIdentityStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ReplicaIdentityStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>identity_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * POLAR: DMA Command Statement 
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPolarDMACommandStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PolarDMACommandStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PolarDMACommandStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>weight</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>matchindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>purgeindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>clusterid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* POLAR end */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterSystemStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterSystemStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterSystemStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR: DMA Command Statement */</comment>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>dma_stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* POLAR end */</comment>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateSeqStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateSeqStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateSeqStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ownerId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>for_identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterSeqStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterSeqStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterSeqStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>sequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>for_identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalVariableSetStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableSetStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VariableSetStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalVariableShowStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>VariableShowStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>VariableShowStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDiscardStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DiscardStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DiscardStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateTableSpaceStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateTableSpaceStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTableSpaceStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>owner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropTableSpaceStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropTableSpaceStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropTableSpaceStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterTableSpaceOptionsStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterTableSpaceOptionsStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
								 <parameter><decl><type><specifier>const</specifier> <name>AlterTableSpaceOptionsStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isReset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterTableMoveAllStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>AlterTableMoveAllStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>orig_tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>new_tablespacename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateExtensionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateExtensionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterExtensionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterExtensionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterExtensionContentsStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterExtensionContentsStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterExtensionContentsStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>extname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>objtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateFdwStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateFdwStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateFdwStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>func_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterFdwStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterFdwStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterFdwStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>func_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateForeignServerStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateForeignServerStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateForeignServerStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servertype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>fdwname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterForeignServerStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterForeignServerStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterForeignServerStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>has_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateUserMappingStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateUserMappingStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateUserMappingStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterUserMappingStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterUserMappingStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterUserMappingStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropUserMappingStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropUserMappingStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropUserMappingStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateForeignTableStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateForeignTableStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_equalCreateStmt</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>base</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>servername</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalImportForeignSchemaStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ImportForeignSchemaStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ImportForeignSchemaStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>server_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>remote_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>local_schema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>list_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateTransformStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateTransformStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTransformStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fromsql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tosql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateAmStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateAmStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateAmStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>amname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>handler_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>amtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateTrigStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateTrigStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateTrigStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>timing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whenClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isconstraint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>transitionRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>constrrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateEventTrigStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateEventTrigStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateEventTrigStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>eventname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whenclause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterEventTrigStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterEventTrigStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterEventTrigStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>trigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>tgenabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreatePLangStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreatePLangStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatePLangStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>plname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>plhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>plinline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>plvalidator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pltrusted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateRoleStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateRoleStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateRoleStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>stmt_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterRoleStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterRoleStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterRoleStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterRoleSetStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterRoleSetStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>role</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>setstmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropRoleStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropRoleStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropRoleStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalLockStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LockStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>nowait</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalConstraintsSetStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ConstraintsSetStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ConstraintsSetStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>deferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalReindexStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ReindexStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ReindexStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateSchemaStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateSchemaStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>schemaname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>authrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>schemaElts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>if_not_exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateConversionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateConversionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateConversionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>conversion_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>for_encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>to_encoding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateCastStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateCastStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreateCastStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>sourcetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>targettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPrepareStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PrepareStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PrepareStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalExecuteStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ExecuteStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ExecuteStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDeallocateStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DeallocateStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DeallocateStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropOwnedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropOwnedStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DropOwnedStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalReassignOwnedStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ReassignOwnedStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ReassignOwnedStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterTSDictionaryStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterTSDictionaryStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterTSDictionaryStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>dictname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterTSConfigurationStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterTSConfigurationStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>AlterTSConfigurationStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>cfgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tokentype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>dicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>override</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreatePublicationStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreatePublicationStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>CreatePublicationStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>for_all_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterPublicationStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterPublicationStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>AlterPublicationStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>pubname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>for_all_tables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>tableAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreateSubscriptionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreateSubscriptionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>CreateSubscriptionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>publication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterSubscriptionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterSubscriptionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>AlterSubscriptionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conninfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>publication</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDropSubscriptionStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DropSubscriptionStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>DropSubscriptionStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>behavior</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCreatePolicyStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CreatePolicyStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CreatePolicyStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>cmd_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>permissive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>with_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAlterPolicyStmt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>AlterPolicyStmt</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AlterPolicyStmt</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>policy_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>roles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>with_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Expr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>lexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalColumnRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ColumnRef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnRef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalParamRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ParamRef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ParamRef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAConst</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>A_Const</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Const</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>a</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>b</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* hack for in-line Value field */</comment>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalFuncCall</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FuncCall</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FuncCall</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_order</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>agg_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>agg_within_group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>agg_star</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>agg_distinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>func_variadic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>over</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAStar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>A_Star</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Star</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalAIndices</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>A_Indices</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Indices</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>lidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>uidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalA_Indirection</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>A_Indirection</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_Indirection</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalA_ArrayExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>A_ArrayExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalResTarget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResTarget</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>indirection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalMultiAssignRef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MultiAssignRef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MultiAssignRef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>colno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ncolumns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTypeName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeName</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>setof</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pct_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>typemod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arrayBounds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTypeCast</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TypeCast</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TypeCast</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCollateClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CollateClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CollateClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSortBy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortBy</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortBy</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>sortby_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>sortby_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>useOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalWindowDef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WindowDef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowDef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeSubselect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeSubselect</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeSubselect</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeFunction</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeFunction</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_rowsfrom</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldeflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeTableSample</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTableSample</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableSample</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeTableFunc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTableFunc</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableFunc</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>docexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>rowexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>namespaces</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>columns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeTableFuncCol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTableFuncCol</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTableFuncCol</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>for_ordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coldefexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalIndexElem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>IndexElem</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>IndexElem</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexcolname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ordering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>nulls_ordering</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalColumnDef</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ColumnDef</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ColumnDef</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>colname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inhcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_not_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_from_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>storage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>cooked_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>identitySequence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>collClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>collOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>constraints</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fdwoptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalConstraint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Constraint</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Constraint</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>contype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>deferrable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>initdeferred</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_no_inherit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>raw_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>cooked_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>generated_when</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>keys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>including</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>exclusions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>indexspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>access_method</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>where_clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>pktable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>fk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>pk_attrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>fk_matchtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>fk_upd_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>fk_del_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>old_conpfeqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>old_pktable_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>skip_validation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>initially_valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalDefElem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>DefElem</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>defnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>defname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>defaction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalLockingClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LockingClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>LockingClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>lockedRels</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeTblEntry</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblEntry</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>rtekind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablesample</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>security_barrier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>joinaliasvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funcordinality</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>tablefunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>values_lists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ctelevelsup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>self_reference</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>coltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>colcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>enrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>enrtuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>alias</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>eref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>lateral</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inFromCl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>requiredPerms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>checkAsUser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>selectedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>insertedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>updatedCols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>securityQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRangeTblFunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RangeTblFunction</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RangeTblFunction</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funcexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>funccolcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>funccolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_BITMAPSET_FIELD</name><argument_list>(<argument><expr><name>funcparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTableSampleClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TableSampleClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>tsmhandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>repeatable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalWithCheckOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WithCheckOption</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WithCheckOption</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>polname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>cascaded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalSortGroupClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SortGroupClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>tleSortGroupRef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>nulls_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>hashable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalGroupingSet</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GroupingSet</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>GroupingSet</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalWindowClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WindowClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WindowClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>partitionClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>orderClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>frameOptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>startOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>endOffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>startInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>endInRangeFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inRangeColl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inRangeAsc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>inRangeNullsFirst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>winref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>copiedOrder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRowMarkClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RowMarkClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RowMarkClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>strength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>waitPolicy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalWithClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>WithClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>WithClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>recursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalInferClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>InferClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>InferClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>indexElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>conname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalOnConflictClause</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>OnConflictClause</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>OnConflictClause</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>infer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>targetList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>whereClause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalCommonTableExpr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>CommonTableExpr</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>CommonTableExpr</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>ctename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>aliascolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>ctematerialized</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctequery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>cterecursive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>cterefcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecoltypmods</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>ctecolcollations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalXmlSerialize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>XmlSerialize</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>XmlSerialize</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>xmloption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalRoleSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RoleSpec</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RoleSpec</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>roletype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>rolename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalTriggerTransition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TriggerTransition</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TriggerTransition</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isNew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>isTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPartitionElem</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartitionElem</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionElem</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPartitionSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionSpec</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>partParams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPartitionBoundSpec</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>is_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>modulus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>listdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>lowerdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>upperdatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPartitionRangeDatum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionRangeDatum</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_LOCATION_FIELD</name><argument_list>(<argument><expr><name>location</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalPartitionCmd</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PartitionCmd</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PartitionCmd</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_NODE_FIELD</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stuff from pg_list.h
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalList</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>List</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>item_a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ListCell</name> <modifier>*</modifier></type><name>item_b</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Try to reject by simple scalar checks before grovelling through all the
	 * list elements...
	 */</comment>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We place the switch outside the loop for the sake of efficiency; this
	 * may not be worth doing...
	 */</comment>
	<switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_List</name></expr>:</case>
			<macro><name>forboth</name><argument_list>(<argument>item_a</argument>, <argument>a</argument>, <argument>item_b</argument>, <argument>b</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>item_a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>item_b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_IntList</name></expr>:</case>
			<macro><name>forboth</name><argument_list>(<argument>item_a</argument>, <argument>a</argument>, <argument>item_b</argument>, <argument>b</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>lfirst_int</name><argument_list>(<argument><expr><name>item_a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_int</name><argument_list>(<argument><expr><name>item_b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>T_OidList</name></expr>:</case>
			<macro><name>forboth</name><argument_list>(<argument>item_a</argument>, <argument>a</argument>, <argument>item_b</argument>, <argument>b</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>item_a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>item_b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized list node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If we got here, we should have run out of elements of both lists
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_a</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>item_b</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Stuff from value.h
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>_equalValue</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Value</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>Value</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Integer</name></expr>:</case>
			<expr_stmt><expr><call><name>COMPARE_SCALAR_FIELD</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>ival</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Float</name></expr>:</case>
		<case>case <expr><name>T_String</name></expr>:</case>
		<case>case <expr><name>T_BitString</name></expr>:</case>
			<expr_stmt><expr><call><name>COMPARE_STRING_FIELD</name><argument_list>(<argument><expr><name><name>val</name><operator>.</operator><name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Null</name></expr>:</case>
			<comment type="block">/* nothing to do */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * equal
 *	  returns whether two nodes are equal
 */</comment>
<function><type><name>bool</name></type>
<name>equal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>retval</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * note that a!=b, so only one of them can be NULL
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * are they the same type of nodes?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex expressions */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * PRIMITIVE NODES
			 */</comment>
		<case>case <expr><name>T_Alias</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlias</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeVar</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeVar</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TableFunc</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTableFunc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IntoClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalIntoClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Var</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalVar</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Const</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalConst</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Param</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalParam</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Aggref</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAggref</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingFunc</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalGroupingFunc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowFunc</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalWindowFunc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayRef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalArrayRef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFuncExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NamedArgExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalNamedArgExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OpExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalOpExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DistinctExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDistinctExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullIfExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalNullIfExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ScalarArrayOpExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalScalarArrayOpExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BoolExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalBoolExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubLink</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSubLink</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SubPlan</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSubPlan</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlternativeSubPlan</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlternativeSubPlan</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FieldSelect</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFieldSelect</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FieldStore</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFieldStore</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RelabelType</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRelabelType</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceViaIO</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCoerceViaIO</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayCoerceExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalArrayCoerceExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ConvertRowtypeExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalConvertRowtypeExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CollateExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCollateExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCaseExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseWhen</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCaseWhen</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CaseTestExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCaseTestExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalArrayExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRowExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowCompareExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRowCompareExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoalesceExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCoalesceExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MinMaxExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalMinMaxExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SQLValueFunction</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSQLValueFunction</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalXmlExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NullTest</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalNullTest</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_BooleanTest</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalBooleanTest</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomain</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCoerceToDomain</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CoerceToDomainValue</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCoerceToDomainValue</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetToDefault</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSetToDefault</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CurrentOfExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCurrentOfExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NextValueExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalNextValueExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_InferenceElem</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalInferenceElem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TargetEntry</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTargetEntry</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblRef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeTblRef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FromExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFromExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalOnConflictExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_JoinExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalJoinExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * RELATION NODES
			 */</comment>
		<case>case <expr><name>T_PathKey</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPathKey</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RestrictInfo</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRestrictInfo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderVar</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPlaceHolderVar</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SpecialJoinInfo</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSpecialJoinInfo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AppendRelInfo</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAppendRelInfo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PlaceHolderInfo</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPlaceHolderInfo</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_List</name></expr>:</case>
		<case>case <expr><name>T_IntList</name></expr>:</case>
		<case>case <expr><name>T_OidList</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalList</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>T_Integer</name></expr>:</case>
		<case>case <expr><name>T_Float</name></expr>:</case>
		<case>case <expr><name>T_String</name></expr>:</case>
		<case>case <expr><name>T_BitString</name></expr>:</case>
		<case>case <expr><name>T_Null</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalValue</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * EXTENSIBLE NODES
			 */</comment>
		<case>case <expr><name>T_ExtensibleNode</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalExtensibleNode</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * PARSE NODES
			 */</comment>
		<case>case <expr><name>T_Query</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalQuery</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RawStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRawStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_InsertStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalInsertStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDeleteStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalUpdateStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSelectStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SetOperationStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSetOperationStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterTableStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTableCmd</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterTableCmd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterCollationStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterCollationStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterDomainStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GrantStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalGrantStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GrantRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalGrantRoleStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterDefaultPrivilegesStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterDefaultPrivilegesStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDeclareCursorStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ClosePortalStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalClosePortalStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CallStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCallStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ClusterStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalClusterStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CopyStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCopyStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TableLikeClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTableLikeClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DefineStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDefineStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TruncateStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTruncateStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CommentStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCommentStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SecLabelStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSecLabelStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FetchStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFetchStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalIndexStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateStatsStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateStatsStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateFunctionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateFunctionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FunctionParameter</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFunctionParameter</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterFunctionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterFunctionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DoStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDoStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RenameStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRenameStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterObjectDependsStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterObjectDependsStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterObjectSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterObjectSchemaStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterOwnerStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterOwnerStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterOperatorStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterOperatorStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RuleStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRuleStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_NotifyStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalNotifyStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ListenStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalListenStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_UnlistenStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalUnlistenStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TransactionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTransactionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CompositeTypeStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCompositeTypeStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateEnumStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateRangeStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateRangeStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterEnumStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterEnumStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalViewStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LoadStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalLoadStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateDomainStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateDomainStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateOpClassStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateOpClassStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateOpClassItem</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateOpClassItem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateOpFamilyStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterOpFamilyStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterOpFamilyStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreatedbStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreatedbStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterDatabaseStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterDatabaseStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterDatabaseSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterDatabaseSetStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropdbStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropdbStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_VacuumStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalVacuumStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_VacuumRelation</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalVacuumRelation</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ExplainStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalExplainStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateTableAsStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateTableAsStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RefreshMatViewStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRefreshMatViewStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ReplicaIdentityStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalReplicaIdentityStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PolarDMACommandStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPolarDMACommandStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterSystemStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterSystemStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateSeqStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterSeqStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterSeqStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_VariableSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalVariableSetStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_VariableShowStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalVariableShowStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DiscardStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDiscardStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateTableSpaceStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropTableSpaceStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropTableSpaceStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTableSpaceOptionsStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterTableSpaceOptionsStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTableMoveAllStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterTableMoveAllStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateExtensionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateExtensionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterExtensionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterExtensionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterExtensionContentsStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterExtensionContentsStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateFdwStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateFdwStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterFdwStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterFdwStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateForeignServerStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterForeignServerStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterForeignServerStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateUserMappingStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterUserMappingStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropUserMappingStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropUserMappingStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateForeignTableStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateForeignTableStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ImportForeignSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalImportForeignSchemaStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateTransformStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateTransformStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateAmStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateAmStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateTrigStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateEventTrigStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterEventTrigStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterEventTrigStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreatePLangStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreatePLangStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateRoleStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterRoleStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterRoleSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterRoleSetStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropRoleStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropRoleStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LockStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalLockStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ConstraintsSetStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalConstraintsSetStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ReindexStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalReindexStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CheckPointStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateSchemaStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateSchemaStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateConversionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateConversionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateCastStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateCastStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PrepareStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPrepareStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ExecuteStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalExecuteStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DeallocateStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDeallocateStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropOwnedStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ReassignOwnedStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalReassignOwnedStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTSDictionaryStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterTSDictionaryStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterTSConfigurationStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterTSConfigurationStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreatePolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreatePolicyStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterPolicyStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterPolicyStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreatePublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreatePublicationStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterPublicationStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterPublicationStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CreateSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCreateSubscriptionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AlterSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAlterSubscriptionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DropSubscriptionStmt</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDropSubscriptionStmt</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_Expr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ColumnRef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalColumnRef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ParamRef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalParamRef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_Const</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAConst</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_FuncCall</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalFuncCall</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_Star</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAStar</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_Indices</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAIndices</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_Indirection</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalA_Indirection</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_A_ArrayExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalA_ArrayExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ResTarget</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalResTarget</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_MultiAssignRef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalMultiAssignRef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TypeCast</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTypeCast</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CollateClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCollateClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortBy</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSortBy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowDef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalWindowDef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeSubselect</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeSubselect</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeFunction</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeFunction</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableSample</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeTableSample</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableFunc</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeTableFunc</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTableFuncCol</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeTableFuncCol</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TypeName</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTypeName</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_IndexElem</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalIndexElem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ColumnDef</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalColumnDef</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_Constraint</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalConstraint</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_DefElem</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalDefElem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_LockingClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalLockingClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblEntry</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeTblEntry</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RangeTblFunction</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRangeTblFunction</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TableSampleClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTableSampleClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WithCheckOption</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalWithCheckOption</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_SortGroupClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalSortGroupClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_GroupingSet</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalGroupingSet</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WindowClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalWindowClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RowMarkClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRowMarkClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_WithClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalWithClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_InferClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalInferClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_OnConflictClause</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalOnConflictClause</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_CommonTableExpr</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalCommonTableExpr</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_ObjectWithArgs</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalObjectWithArgs</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_AccessPriv</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalAccessPriv</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_XmlSerialize</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalXmlSerialize</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_RoleSpec</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalRoleSpec</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_TriggerTransition</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalTriggerTransition</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionElem</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPartitionElem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionSpec</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPartitionSpec</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionBoundSpec</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPartitionBoundSpec</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionRangeDatum</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPartitionRangeDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>T_PartitionCmd</name></expr>:</case>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>_equalPartitionCmd</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>
</unit>
