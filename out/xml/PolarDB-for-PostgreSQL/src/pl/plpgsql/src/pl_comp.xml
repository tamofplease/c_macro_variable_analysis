<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/pl/plpgsql/src/pl_comp.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pl_comp.c		- Compiler part of the PL/pgSQL
 *			  procedural language
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/pl/plpgsql/src/pl_comp.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpgsql.h"</cpp:file></cpp:include>


<comment type="block">/* ----------
 * Our own local and global variables
 * ----------
 */</comment>
<decl_stmt><decl><type><name>PLpgSQL_stmt_block</name> <modifier>*</modifier></type><name>plpgsql_parse_result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>datums_alloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>plpgsql_nDatums</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier><modifier>*</modifier></type><name>plpgsql_Datums</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>datums_last</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>plpgsql_error_funcname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>plpgsql_DumpExecTree</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>plpgsql_check_syntax</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>plpgsql_curr_compile</name></decl>;</decl_stmt>

<comment type="block">/* A context appropriate for short-term allocs during compilation */</comment>
<decl_stmt><decl><type><name>MemoryContext</name></type> <name>plpgsql_compile_tmp_cxt</name></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Hash table for compiled functions
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>plpgsql_HashTable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <name>plpgsql_hashent</name>
<block>{
	<decl_stmt><decl><type><name>PLpgSQL_func_hashkey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl>;</decl_stmt>
}</block></struct></type> <name>plpgsql_HashEnt</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNCS_PER_USER</name></cpp:macro>		<cpp:value>128</cpp:value></cpp:define> <comment type="block">/* initial table size */</comment>

<comment type="block">/* ----------
 * Lookup table for EXCEPTION condition names
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>sqlerrstate</name></decl>;</decl_stmt>
}</block></struct></type> <name>ExceptionLabelMap</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ExceptionLabelMap</name></type> <name><name>exception_label_map</name><index>[]</index></name> <init>= <expr><block>{
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plerrcodes.h"</cpp:file></cpp:include>			<comment type="block">/* pgrminclude ignore */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------
 * static prototypes
 * ----------
 */</comment>
<function_decl><type><specifier>static</specifier> <name>PLpgSQL_function</name> <modifier>*</modifier></type><name>do_compile</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>procTup</name></decl></parameter>,
		   <parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>,
		   <parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>hashkey</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_compile_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_parameter_name</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_nsitem_type</name></type> <name>itemtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_dummy_return</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>plpgsql_pre_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>plpgsql_post_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>plpgsql_param_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>resolve_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				   <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error_if_no_field</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>make_datum_param</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PLpgSQL_row</name> <modifier>*</modifier></type><name>build_row_from_vars</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier><modifier>*</modifier></type><name>vars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numvars</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PLpgSQL_type</name> <modifier>*</modifier></type><name>build_datatype</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typeTup</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>origtypname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_start_datums</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_finish_datums</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>compute_function_hashkey</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
						 <parameter><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl></parameter>,
						 <parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>hashkey</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_resolve_polymorphic_argtypes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numargs</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
									 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PLpgSQL_function</name> <modifier>*</modifier></type><name>plpgsql_HashTableLookup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>func_key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_HashTableInsert</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>,
						<parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>func_key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpgsql_HashTableDelete</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>delete_function</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ----------
 * plpgsql_compile		Make an execution tree for a PL/pgSQL function.
 *
 * If forValidator is true, we're only compiling for validation purposes,
 * and so some checks are skipped.
 *
 * Note: it's important for this to fall through quickly if the function
 * has already been compiled.
 * ----------
 */</comment>
<function><type><name>PLpgSQL_function</name> <modifier>*</modifier></type>
<name>plpgsql_compile</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>funcOid</name> <init>= <expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>procTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_func_hashkey</name></type> <name>hashkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>function_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>hashkey_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Lookup the pg_proc tuple by Oid; we'll need it in any case
	 */</comment>
	<expr_stmt><expr><name>procTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>procStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * See if there's already a cache entry for the current FmgrInfo. If not,
	 * try to find one in the hash table.
	 */</comment>
	<expr_stmt><expr><name>function</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_function</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name></expr>;</expr_stmt>

<label><name>recheck</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>function</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Compute hashkey using function signature and actual arg types */</comment>
		<expr_stmt><expr><call><name>compute_function_hashkey</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>procStruct</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashkey</name></expr></argument>, <argument><expr><name>forValidator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashkey_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* And do the lookup */</comment>
		<expr_stmt><expr><name>function</name> <operator>=</operator> <call><name>plpgsql_HashTableLookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hashkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>function</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have a compiled function, but is it still valid? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>==</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>ItemPointerEquals</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>function</name><operator>-&gt;</operator><name>fn_tid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>procTup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>function_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Nope, so remove it from hashtable and try to drop associated
			 * storage (if not done already).
			 */</comment>
			<expr_stmt><expr><call><name>delete_function</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the function isn't in active use then we can overwrite the
			 * func struct with new data, allowing any other existing fn_extra
			 * pointers to make use of the new definition on their next use.
			 * If it is in use then just leave it alone and make a new one.
			 * (The active invocations will run to completion using the
			 * previous definition, and then the cache entry will just be
			 * leaked; doesn't seem worth adding code to clean it up, given
			 * what a corner case this is.)
			 *
			 * If we found the function struct via fn_extra then it's possible
			 * a replacement has already been made, so go back and recheck the
			 * hashtable.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>use_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>function</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hashkey_valid</name></expr>)</condition><block type="pseudo"><block_content>
					<goto>goto <name>recheck</name>;</goto></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the function wasn't found or was out-of-date, we have to compile it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>function_valid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Calculate hashkey if we didn't already; we'll need it to store the
		 * completed function.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hashkey_valid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>compute_function_hashkey</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>procStruct</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hashkey</name></expr></argument>,
									 <argument><expr><name>forValidator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Do the hard part.
		 */</comment>
		<expr_stmt><expr><name>function</name> <operator>=</operator> <call><name>do_compile</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>, <argument><expr><name>function</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>hashkey</name></expr></argument>, <argument><expr><name>forValidator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Save pointer in FmgrInfo to avoid search on subsequent calls
	 */</comment>
	<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_extra</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>function</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Finally return the compiled function
	 */</comment>
	<return>return <expr><name>function</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is the slow part of plpgsql_compile().
 *
 * The passed-in "function" pointer is either NULL or an already-allocated
 * function struct to overwrite.
 *
 * While compiling a function, the CurrentMemoryContext is the
 * per-function memory context of the function we are compiling. That
 * means a palloc() will allocate storage with the same lifetime as
 * the function itself.
 *
 * Because palloc()'d storage will not be immediately freed, temporary
 * allocations should either be performed in a short-lived memory
 * context or explicitly pfree'd. Since not all backend functions are
 * careful about pfree'ing their allocations, it is also wise to
 * switch into a short-term context before calling into the
 * backend. An appropriate context for performing short-term
 * allocations is the plpgsql_compile_tmp_cxt.
 *
 * NB: this code is not re-entrant.  We assume that nothing we do here could
 * result in the invocation of another plpgsql function.
 */</comment>
<function><type><specifier>static</specifier> <name>PLpgSQL_function</name> <modifier>*</modifier></type>
<name>do_compile</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
		   <parameter><decl><type><name>HeapTuple</name></type> <name>procTup</name></decl></parameter>,
		   <parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>,
		   <parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>hashkey</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_dml_trigger</name> <init>= <expr><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_event_trigger</name> <init>= <expr><call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>prosrcdatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>proc_source</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parse_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rettypeid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_in_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_out_args</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>in_arg_varnos</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_arg_variables</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>func_cxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup the scanner input and error info.  We assume that this function
	 * cannot be invoked recursively, so there's no need to save and restore
	 * the static variables used here.
	 */</comment>
	<expr_stmt><expr><name>prosrcdatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>procTup</name></expr></argument>,
								  <argument><expr><name>Anum_pg_proc_prosrc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null prosrc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>proc_source</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>prosrcdatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_scanner_init</name><argument_list>(<argument><expr><name>proc_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plpgsql_error_funcname</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_compile_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <ternary><condition><expr><name>forValidator</name></expr> ?</condition><then> <expr><name>proc_source</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do extra syntax checks when validating the function definition. We skip
	 * this when actually compiling functions for execution, for performance
	 * reasons.
	 */</comment>
	<expr_stmt><expr><name>plpgsql_check_syntax</name> <operator>=</operator> <name>forValidator</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the new function struct, if not done already.  The function
	 * structs are never thrown away, so keep them in TopMemoryContext.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>function</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>function</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_function</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_function</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* re-using a previously existing struct, so clear it out */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_function</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>plpgsql_curr_compile</name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * All the permanent output of compilation (e.g. parse tree) is kept in a
	 * per-function memory context, so it can be reclaimed easily.
	 */</comment>
	<expr_stmt><expr><name>func_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"PL/pgSQL function"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_compile_tmp_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>func_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_signature</name></name> <operator>=</operator> <call><name>format_procedure</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>func_cxt</name></expr></argument>, <argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_signature</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_oid</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_xmin</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name><name>procTup</name><operator>-&gt;</operator><name>t_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_tid</name></name> <operator>=</operator> <name><name>procTup</name><operator>-&gt;</operator><name>t_self</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_cxt</name></name> <operator>=</operator> <name>func_cxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>out_param_varno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* set up for no OUT param */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>resolve_option</name></name> <operator>=</operator> <name>plpgsql_variable_conflict</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>print_strict_params</name></name> <operator>=</operator> <name>plpgsql_print_strict_params</name></expr>;</expr_stmt>
	<comment type="block">/* only promote extra warnings and errors at CREATE FUNCTION time */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>extra_warnings</name></name> <operator>=</operator> <ternary><condition><expr><name>forValidator</name></expr> ?</condition><then> <expr><name>plpgsql_extra_warnings</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>extra_errors</name></name> <operator>=</operator> <ternary><condition><expr><name>forValidator</name></expr> ?</condition><then> <expr><name>plpgsql_extra_errors</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_dml_trigger</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_is_trigger</name></name> <operator>=</operator> <name>PLPGSQL_DML_TRIGGER</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>is_event_trigger</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_is_trigger</name></name> <operator>=</operator> <name>PLPGSQL_EVENT_TRIGGER</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_is_trigger</name></name> <operator>=</operator> <name>PLPGSQL_NOT_TRIGGER</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_prokind</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>prokind</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize the compiler, particularly the namespace stack.  The
	 * outermost namespace contains function parameters and other special
	 * variables (such as FOUND), and is named after the function itself.
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_ns_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_ns_push</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PLPGSQL_LABEL_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_DumpExecTree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_start_datums</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>fn_is_trigger</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_NOT_TRIGGER</name></expr>:</case>

			<comment type="block">/*
			 * Fetch info about the procedure's parameters. Allocations aren't
			 * needed permanently, so make them in tmp cxt.
			 *
			 * We also need to resolve any polymorphic input or output
			 * argument types.  In validation mode we won't be able to, so we
			 * arbitrarily assume we are dealing with integers.
			 */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>procTup</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>plpgsql_resolve_polymorphic_argtypes</name><argument_list>(<argument><expr><name>numargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>argmodes</name></expr></argument>,
												 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>,
												 <argument><expr><name>forValidator</name></expr></argument>,
												 <argument><expr><name>plpgsql_error_funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>in_arg_varnos</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>out_arg_variables</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_variable</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>func_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Create the variables for the procedure's parameters.
			 */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>argtypeid</name> <init>= <expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name></type>		<name>argmode</name> <init>= <expr><ternary><condition><expr><name>argmodes</name></expr> ?</condition><then> <expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>PROARGMODE_IN</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>argdtype</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>argvariable</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>PLpgSQL_nsitem_type</name></type> <name>argitemtype</name></decl>;</decl_stmt>

				<comment type="block">/* Create $n name for variable */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Create datatype info */</comment>
				<expr_stmt><expr><name>argdtype</name> <operator>=</operator> <call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>argtypeid</name></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												  <argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Disallow pseudotype argument */</comment>
				<comment type="block">/* (note we already replaced polymorphic types) */</comment>
				<comment type="block">/* (build_variable would do this, but wrong message) */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>argdtype</name><operator>-&gt;</operator><name>ttype</name></name> <operator>==</operator> <name>PLPGSQL_TTYPE_PSEUDO</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL functions cannot accept type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>argtypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * Build variable and add to datum list.  If there's a name
				 * for the argument, use that as refname, else use $n name.
				 */</comment>
				<expr_stmt><expr><name>argvariable</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>argnames</name> <operator>&amp;&amp;</operator>
													  <name><name>argnames</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal><operator>)</operator></expr> ?</condition><then>
													 <expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name>buf</name></expr></else></ternary></expr></argument>,
													 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argdtype</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>argvariable</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>argitemtype</name> <operator>=</operator> <name>PLPGSQL_NSTYPE_VAR</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>argvariable</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_REC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>argitemtype</name> <operator>=</operator> <name>PLPGSQL_NSTYPE_REC</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* Remember arguments in appropriate arrays */</comment>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_IN</name> <operator>||</operator>
					<name>argmode</name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator>
					<name>argmode</name> <operator>==</operator> <name>PROARGMODE_VARIADIC</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>in_arg_varnos</name><index>[<expr><name>num_in_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>argvariable</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>argmode</name> <operator>==</operator> <name>PROARGMODE_OUT</name> <operator>||</operator>
					<name>argmode</name> <operator>==</operator> <name>PROARGMODE_INOUT</name> <operator>||</operator>
					<name>argmode</name> <operator>==</operator> <name>PROARGMODE_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out_arg_variables</name><index>[<expr><name>num_out_args</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>argvariable</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Add to namespace under the $n name */</comment>
				<expr_stmt><expr><call><name>add_parameter_name</name><argument_list>(<argument><expr><name>argitemtype</name></expr></argument>, <argument><expr><name><name>argvariable</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* If there's a name for the argument, make an alias */</comment>
				<if_stmt><if>if <condition>(<expr><name>argnames</name> <operator>&amp;&amp;</operator> <name><name>argnames</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>add_parameter_name</name><argument_list>(<argument><expr><name>argitemtype</name></expr></argument>, <argument><expr><name><name>argvariable</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>,
									   <argument><expr><name><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If there's just one OUT parameter, out_param_varno points
			 * directly to it.  If there's more than one, build a row that
			 * holds all of them.  Procedures return a row even for one OUT
			 * parameter.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>num_out_args</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator>
				<operator>(</operator><name>num_out_args</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>function</name><operator>-&gt;</operator><name>fn_prokind</name></name> <operator>==</operator> <name>PROKIND_PROCEDURE</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name> <init>= <expr><call><name>build_row_from_vars</name><argument_list>(<argument><expr><name>out_arg_variables</name></expr></argument>,
													   <argument><expr><name>num_out_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>plpgsql_adddatum</name><argument_list>(<argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>row</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>out_param_varno</name></name> <operator>=</operator> <name><name>row</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>num_out_args</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>out_param_varno</name></name> <operator>=</operator> <name><name>out_arg_variables</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>dno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Check for a polymorphic returntype. If found, use the actual
			 * returntype type from the caller's FuncExpr node, if we have
			 * one.  (In validation mode we arbitrarily assume we are dealing
			 * with integers.)
			 *
			 * Note: errcode is FEATURE_NOT_SUPPORTED because it should always
			 * work; if it doesn't we're in some context that fails to make
			 * the info available.
			 */</comment>
			<expr_stmt><expr><name>rettypeid</name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name>rettypeid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>forValidator</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>rettypeid</name> <operator>==</operator> <name>ANYARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>rettypeid</name> <operator>=</operator> <name>INT4ARRAYOID</name></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>rettypeid</name> <operator>==</operator> <name>ANYRANGEOID</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>rettypeid</name> <operator>=</operator> <name>INT4RANGEOID</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>		<comment type="block">/* ANYELEMENT or ANYNONARRAY */</comment>
						<expr_stmt><expr><name>rettypeid</name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<comment type="block">/* XXX what could we use for ANYENUM? */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>rettypeid</name> <operator>=</operator> <call><name>get_fn_expr_rettype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rettypeid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine actual return type "</literal>
										<literal type="string">"for polymorphic function \"%s\""</literal></expr></argument>,
										<argument><expr><name>plpgsql_error_funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Normal function has a defined returntype
			 */</comment>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>=</operator> <name>rettypeid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>proretset</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Lookup the function's return type
			 */</comment>
			<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rettypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>rettypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Disallow pseudotype result, except VOID or RECORD */</comment>
			<comment type="block">/* (note we already replaced polymorphic types) */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>rettypeid</name> <operator>==</operator> <name>VOIDOID</name> <operator>||</operator>
					<name>rettypeid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
					 <comment type="block">/* okay */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>rettypeid</name> <operator>==</operator> <name>TRIGGEROID</name> <operator>||</operator> <name>rettypeid</name> <operator>==</operator> <name>EVTTRIGGEROID</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger functions can only be called as triggers"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/pgSQL functions cannot return type %s"</literal></expr></argument>,
									<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>rettypeid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retistuple</name></name> <operator>=</operator> <call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>rettypeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retisdomain</name></name> <operator>=</operator> <operator>(</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retbyval</name></name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettyplen</name></name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>

			<comment type="block">/*
			 * install $0 reference, but only for polymorphic return types,
			 * and not when the return is specified through an output
			 * parameter.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsPolymorphicType</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>num_out_args</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"$0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
											  <argument><expr><call><name>build_datatype</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>,
															 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
															 <argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
															 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>PLPGSQL_DML_TRIGGER</name></expr>:</case>
			<comment type="block">/* Trigger procedure's return type is unknown yet */</comment>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retistuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retisdomain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* shouldn't be any declared arguments */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"trigger functions cannot have declared arguments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The arguments of the trigger can be accessed through TG_NARGS and TG_ARGV instead."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Add the record for referencing NEW ROW */</comment>
			<expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>plpgsql_build_record</name><argument_list>(<argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RECORDOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>new_varno</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>

			<comment type="block">/* Add the record for referencing OLD ROW */</comment>
			<expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>plpgsql_build_record</name><argument_list>(<argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>RECORDOID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>old_varno</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_name */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name>InvalidOid</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_NAME</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_when */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_when"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_WHEN</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_level */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_level"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_LEVEL</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_op */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_op"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_OP</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_relid */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_relid"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name>InvalidOid</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_RELID</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_relname */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_relname"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name>InvalidOid</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_TABLE_NAME</name></expr>;</expr_stmt>

			<comment type="block">/* tg_table_name is now preferred to tg_relname */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_table_name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name>InvalidOid</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_TABLE_NAME</name></expr>;</expr_stmt>

			<comment type="block">/* add the variable tg_table_schema */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_table_schema"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>NAMEOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name>InvalidOid</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_TABLE_SCHEMA</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_nargs */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_nargs"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>INT4OID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name>InvalidOid</name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_NARGS</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_argv */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_argv"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>TEXTARRAYOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_ARGV</name></expr>;</expr_stmt>

			<break>break;</break>

		<case>case <expr><name>PLPGSQL_EVENT_TRIGGER</name></expr>:</case>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retbyval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retistuple</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retisdomain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* shouldn't be any declared arguments */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"event trigger functions cannot have declared arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Add the variable tg_event */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_event"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_EVENT</name></expr>;</expr_stmt>

			<comment type="block">/* Add the variable tg_tag */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"tg_tag"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
										 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>TEXTOID</name></expr></argument>,
																<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
																<argument><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
																<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_PROMISE</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>promise</name> <operator>=</operator> <name>PLPGSQL_PROMISE_TG_TAG</name></expr>;</expr_stmt>

			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized function typecode: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>function</name><operator>-&gt;</operator><name>fn_is_trigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Remember if function is STABLE/IMMUTABLE */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_readonly</name></name> <operator>=</operator> <operator>(</operator><name><name>procStruct</name><operator>-&gt;</operator><name>provolatile</name></name> <operator>!=</operator> <name>PROVOLATILE_VOLATILE</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the magic FOUND variable.
	 */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"found"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>BOOLOID</name></expr></argument>,
														<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
														<argument><expr><name>InvalidOid</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>found_varno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now parse the function's text
	 */</comment>
	<expr_stmt><expr><name>parse_rc</name> <operator>=</operator> <call><name>plpgsql_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parse_rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plpgsql parser returned %d"</literal></expr></argument>, <argument><expr><name>parse_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>plpgsql_parse_result</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plpgsql_scanner_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>proc_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it has OUT parameters or returns VOID or returns a set, we allow
	 * control to fall off the end without an explicit RETURN statement. The
	 * easiest way to implement this is to add a RETURN statement to the end
	 * of the statement list during parsing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_out_args</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>function</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>==</operator> <name>VOIDOID</name> <operator>||</operator>
		<name><name>function</name><operator>-&gt;</operator><name>fn_retset</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_dummy_return</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Complete the function's info
	 */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_nargs</name></name> <operator>=</operator> <name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>function</name><operator>-&gt;</operator><name>fn_nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_argvarnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>in_arg_varnos</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>plpgsql_finish_datums</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Debug dump for completed functions */</comment>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_DumpExecTree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>plpgsql_dumptree</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * add it to the hash table
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_HashTableInsert</name><argument_list>(<argument><expr><name>function</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_error_funcname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>plpgsql_check_syntax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_compile_tmp_cxt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>function</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_compile_inline	Make an execution tree for an anonymous code block.
 *
 * Note: this is generally parallel to do_compile(); is it worth trying to
 * merge the two?
 *
 * Note: we assume the block will be thrown away so there is no need to build
 * persistent data structures.
 * ----------
 */</comment>
<function><type><name>PLpgSQL_function</name> <modifier>*</modifier></type>
<name>plpgsql_compile_inline</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>proc_source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>func_name</name> <init>= <expr><literal type="string">"inline_code_block"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>parse_rc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>func_cxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Setup the scanner input and error info.  We assume that this function
	 * cannot be invoked recursively, so there's no need to save and restore
	 * the static variables used here.
	 */</comment>
	<expr_stmt><expr><call><name>plpgsql_scanner_init</name><argument_list>(<argument><expr><name>proc_source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plpgsql_error_funcname</name> <operator>=</operator> <name>func_name</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Setup error traceback support for ereport()
	 */</comment>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpgsql_compile_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>proc_source</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

	<comment type="block">/* Do extra syntax checking if check_function_bodies is on */</comment>
	<expr_stmt><expr><name>plpgsql_check_syntax</name> <operator>=</operator> <name>check_function_bodies</name></expr>;</expr_stmt>

	<comment type="block">/* Function struct does not live past current statement */</comment>
	<expr_stmt><expr><name>function</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_function</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_function</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plpgsql_curr_compile</name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * All the rest of the compile-time storage (e.g. parse tree) is kept in
	 * its own memory context, so it can be reclaimed easily.
	 */</comment>
	<expr_stmt><expr><name>func_cxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
									 <argument><expr><literal type="string">"PL/pgSQL inline code context"</literal></expr></argument>,
									 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_compile_tmp_cxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>func_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_signature</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_is_trigger</name></name> <operator>=</operator> <name>PLPGSQL_NOT_TRIGGER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_input_collation</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_cxt</name></name> <operator>=</operator> <name>func_cxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>out_param_varno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* set up for no OUT param */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>resolve_option</name></name> <operator>=</operator> <name>plpgsql_variable_conflict</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>print_strict_params</name></name> <operator>=</operator> <name>plpgsql_print_strict_params</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * don't do extra validation for inline code as we don't want to add spam
	 * at runtime
	 */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>extra_warnings</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>extra_errors</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plpgsql_ns_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_ns_push</name><argument_list>(<argument><expr><name>func_name</name></expr></argument>, <argument><expr><name>PLPGSQL_LABEL_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_DumpExecTree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_start_datums</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up as though in a function returning VOID */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>=</operator> <name>VOIDOID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retset</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retistuple</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retisdomain</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_prokind</name></name> <operator>=</operator> <name>PROKIND_FUNCTION</name></expr>;</expr_stmt>
	<comment type="block">/* a bit of hardwired knowledge about type VOID here */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_retbyval</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettyplen</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remember if function is STABLE/IMMUTABLE.  XXX would it be better to
	 * set this true inside a read-only transaction?  Not clear.
	 */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_readonly</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the magic FOUND variable.
	 */</comment>
	<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>plpgsql_build_variable</name><argument_list>(<argument><expr><literal type="string">"found"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								 <argument><expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><name>BOOLOID</name></expr></argument>,
														<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
														<argument><expr><name>InvalidOid</name></expr></argument>,
														<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>found_varno</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now parse the function's text
	 */</comment>
	<expr_stmt><expr><name>parse_rc</name> <operator>=</operator> <call><name>plpgsql_yyparse</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parse_rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"plpgsql parser returned %d"</literal></expr></argument>, <argument><expr><name>parse_rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>plpgsql_parse_result</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plpgsql_scanner_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it returns VOID (always true at the moment), we allow control to
	 * fall off the end without an explicit RETURN statement.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>fn_rettype</name></name> <operator>==</operator> <name>VOIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>add_dummy_return</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Complete the function's info
	 */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_nargs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plpgsql_finish_datums</name><argument_list>(<argument><expr><name>function</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Pop the error context stack
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_error_funcname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>plpgsql_check_syntax</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_compile_tmp_cxt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>function</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * error context callback to let us supply a call-stack traceback.
 * If we are validating or executing an anonymous code block, the function
 * source text is passed as an argument.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_compile_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Try to convert syntax error position to reference text of original
		 * CREATE FUNCTION or DO command.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>function_parse_error_transpose</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Done if a syntax error position was reported; otherwise we have to
		 * fall back to a "near line N" report.
		 */</comment>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>plpgsql_error_funcname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"compilation of PL/pgSQL function \"%s\" near line %d"</literal></expr></argument>,
				   <argument><expr><name>plpgsql_error_funcname</name></expr></argument>, <argument><expr><call><name>plpgsql_latest_lineno</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Add a name for a function parameter to the function's namespace
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_parameter_name</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_nsitem_type</name></type> <name>itemtype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Before adding the name, check for duplicates.  We need this even though
	 * functioncmds.c has a similar check, because that code explicitly
	 * doesn't complain about conflicting IN and OUT parameter names.  In
	 * plpgsql, such names are in the same namespace, so there is no way to
	 * disambiguate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><call><name>plpgsql_ns_top</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						  <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
						  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_FUNCTION_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter name \"%s\" used more than once"</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, add the name */</comment>
	<expr_stmt><expr><call><name>plpgsql_ns_additem</name><argument_list>(<argument><expr><name>itemtype</name></expr></argument>, <argument><expr><name>itemno</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a dummy RETURN statement to the given function's body
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_dummy_return</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If the outer block has an EXCEPTION clause, we need to make a new outer
	 * block, since the added RETURN shouldn't act like it is inside the
	 * EXCEPTION clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>action</name><operator>-&gt;</operator><name>exceptions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_stmt_block</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_stmt_block</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>cmd_type</name></name> <operator>=</operator> <name>PLPGSQL_STMT_BLOCK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name><name>function</name><operator>-&gt;</operator><name>action</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>action</name><operator>-&gt;</operator><name>body</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>PLpgSQL_stmt</name> <operator>*</operator><operator>)</operator> <call><name>llast</name><argument_list>(<argument><expr><name><name>function</name><operator>-&gt;</operator><name>action</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>cmd_type</name> <operator>!=</operator> <name>PLPGSQL_STMT_RETURN</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_stmt_return</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_stmt_return</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>cmd_type</name></name> <operator>=</operator> <name>PLPGSQL_STMT_RETURN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>retvarno</name></name> <operator>=</operator> <name><name>function</name><operator>-&gt;</operator><name>out_param_varno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>action</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>function</name><operator>-&gt;</operator><name>action</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * plpgsql_parser_setup		set up parser hooks for dynamic parameters
 *
 * Note: this routine, and the hook functions it prepares for, are logically
 * part of plpgsql parsing.  But they actually run during function execution,
 * when we are ready to evaluate a SQL query or expression that has not
 * previously been parsed and planned.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_parser_setup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ParseState</name></name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_pre_columnref_hook</name></name> <operator>=</operator> <name>plpgsql_pre_column_ref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_post_columnref_hook</name></name> <operator>=</operator> <name>plpgsql_post_column_ref</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_paramref_hook</name></name> <operator>=</operator> <name>plpgsql_param_ref</name></expr>;</expr_stmt>
	<comment type="block">/* no need to use p_coerce_param_hook */</comment>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_pre_column_ref		parser callback before parsing a ColumnRef
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>plpgsql_pre_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>resolve_option</name></name> <operator>==</operator> <name>PLPGSQL_RESOLVE_VARIABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>resolve_column_ref</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_post_column_ref		parser callback after parsing a ColumnRef
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>plpgsql_post_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>myvar</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>resolve_option</name></name> <operator>==</operator> <name>PLPGSQL_RESOLVE_VARIABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* we already found there's no match */</comment>

	<if_stmt><if>if <condition>(<expr><name><name>expr</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>resolve_option</name></name> <operator>==</operator> <name>PLPGSQL_RESOLVE_COLUMN</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* there's a table column, prefer that */</comment>

	<comment type="block">/*
	 * If we find a record/row variable but can't match a field name, throw
	 * error if there was no core resolution for the ColumnRef either.  In
	 * that situation, the reference is inevitably going to fail, and
	 * complaining about the record/row variable is likely to be more on-point
	 * than the core parser's error message.  (It's too bad we don't have
	 * access to transformColumnRef's internal crerr state here, as in case of
	 * a conflict with a table name this could still be less than the most
	 * helpful error message possible.)
	 */</comment>
	<expr_stmt><expr><name>myvar</name> <operator>=</operator> <call><name>resolve_column_ref</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>cref</name></expr></argument>, <argument><expr><operator>(</operator><name>var</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>myvar</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We could leave it to the core parser to throw this error, but we
		 * can add a more useful detail message than the core could.
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_AMBIGUOUS_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column reference \"%s\" is ambiguous"</literal></expr></argument>,
						<argument><expr><call><name>NameListToString</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"It could refer to either a PL/pgSQL variable or a table column."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>myvar</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_param_ref		parser callback for ParamRefs ($n symbols)
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>plpgsql_param_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>ParamRef</name> <modifier>*</modifier></type><name>pref</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><operator>(</operator><name>PLpgSQL_expr</name> <operator>*</operator><operator>)</operator> <name><name>pstate</name><operator>-&gt;</operator><name>p_ref_hook_state</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pname</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>nse</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nse</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>ns</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>pname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nse</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* name not known to plpgsql */</comment>

	<return>return <expr><call><name>make_datum_param</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr></argument>, <argument><expr><name><name>pref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * resolve_column_ref		attempt to resolve a ColumnRef as a plpgsql var
 *
 * Returns the translated node structure, or NULL if name not found
 *
 * error_if_no_field tells whether to throw error or quietly return NULL if
 * we are able to match a record/row name but don't find a field name match.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>resolve_column_ref</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				   <parameter><decl><type><name>ColumnRef</name> <modifier>*</modifier></type><name>cref</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>error_if_no_field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>nse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>colname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames_scalar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames_wholerow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames_field</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We use the function's current estate to resolve parameter data types.
	 * This is really pretty bogus because there is no provision for updating
	 * plans when those types change ...
	 */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>cur_estate</name></name></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * The allowed syntaxes are:
	 *
	 * A		Scalar variable reference, or whole-row record reference.
	 * A.B		Qualified scalar or whole-row reference, or field reference.
	 * A.B.C	Qualified record field reference.
	 * A.*		Whole-row record reference.
	 * A.B.*	Qualified whole-row record reference.
	 *----------
	 */</comment>
	<switch>switch <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>nnames_scalar</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>nnames_wholerow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Whole-row reference? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set name2 to prevent matches to scalar variables */</comment>
					<expr_stmt><expr><name>name2</name> <operator>=</operator> <literal type="string">"*"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>nnames_wholerow</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name2</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>name2</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nnames_scalar</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>nnames_wholerow</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>nnames_field</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field1</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field2</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>field3</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lthird</name><argument_list>(<argument><expr><name><name>cref</name><operator>-&gt;</operator><name>fields</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field1</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name1</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field2</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name2</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Whole-row reference? */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>field3</name></expr></argument>, <argument><expr><name>A_Star</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Set name3 to prevent matches to scalar variables */</comment>
					<expr_stmt><expr><name>name3</name> <operator>=</operator> <literal type="string">"*"</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>nnames_wholerow</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>field3</name></expr></argument>, <argument><expr><name>String</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>name3</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><name>field3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>name3</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>nnames_field</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<comment type="block">/* too many names, ignore */</comment>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>nse</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>ns</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>name1</name></expr></argument>, <argument><expr><name>name2</name></expr></argument>, <argument><expr><name>name3</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>nnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nse</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* name not known to plpgsql */</comment>

	<switch>switch <condition>(<expr><name><name>nse</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_NSTYPE_VAR</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>==</operator> <name>nnames_scalar</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>make_datum_param</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PLPGSQL_NSTYPE_REC</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>==</operator> <name>nnames_wholerow</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>make_datum_param</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>==</operator> <name>nnames_field</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* colname could be a field in this record */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name> <init>= <expr><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

				<comment type="block">/* search for a datum referencing this field */</comment>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>firstfield</name></name></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>fld</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fld</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_RECFIELD</name> <operator>&amp;&amp;</operator>
						   <name><name>fld</name><operator>-&gt;</operator><name>recparentno</name></name> <operator>==</operator> <name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fld</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>, <argument><expr><name>colname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<return>return <expr><call><name>make_datum_param</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>fld</name><operator>-&gt;</operator><name>nextfield</name></name></expr>;</expr_stmt>
				</block_content>}</block></while>

				<comment type="block">/*
				 * We should not get here, because a RECFIELD datum should
				 * have been built at parse time for every possible qualified
				 * reference to fields of this record.  But if we do, handle
				 * it like field-not-found: throw error or return NULL.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>error_if_no_field</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"record \"%s\" has no field \"%s\""</literal></expr></argument>,
									<argument><expr><ternary><condition><expr><operator>(</operator><name>nnames_field</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><name>name1</name></expr> </then><else>: <expr><name>name2</name></expr></else></ternary></expr></argument>,
									<argument><expr><name>colname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cref</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized plpgsql itemtype: %d"</literal></expr></argument>, <argument><expr><name><name>nse</name><operator>-&gt;</operator><name>itemtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<comment type="block">/* Name format doesn't match the plpgsql variable type */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Helper for columnref parsing: build a Param referencing a plpgsql datum,
 * and make sure that that datum is listed in the expression's paramnos.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>make_datum_param</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_expr</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dno</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_execstate</name> <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Param</name>	   <modifier>*</modifier></type><name>param</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* see comment in resolve_column_ref */</comment>
	<expr_stmt><expr><name>estate</name> <operator>=</operator> <name><name>expr</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>cur_estate</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dno</name> <operator>&lt;</operator> <name><name>estate</name><operator>-&gt;</operator><name>ndatums</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <name><name>estate</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>dno</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Bitmapset must be allocated in function's permanent memory context
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>func</name><operator>-&gt;</operator><name>fn_cxt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>expr</name><operator>-&gt;</operator><name>paramnos</name></name></expr></argument>, <argument><expr><name>dno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>param</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>Param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramkind</name></name> <operator>=</operator> <name>PARAM_EXTERN</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>paramid</name></name> <operator>=</operator> <name>dno</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_exec_get_datum_type_info</name><argument_list>(<argument><expr><name>estate</name></expr></argument>,
									 <argument><expr><name>datum</name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>paramtype</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>paramtypmod</name></name></expr></argument>,
									 <argument><expr><operator>&amp;</operator><name><name>param</name><operator>-&gt;</operator><name>paramcollid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>location</name></name> <operator>=</operator> <name>location</name></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>param</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_parse_word		The scanner calls this to postparse
 *				any single word that is not a reserved keyword.
 *
 * word1 is the downcased/dequoted identifier; it must be palloc'd in the
 * function's long-term memory context.
 *
 * yytxt is the original token text; we need this to check for quoting,
 * so that later checks for unreserved keywords work properly.
 *
 * If recognized as a variable, fill in *wdatum and return true;
 * if not recognized, fill in *word and return false.
 * (Note: those two pointers actually point to members of the same union,
 * but for notational reasons we pass them separately.)
 * ----------
 */</comment>
<function><type><name>bool</name></type>
<name>plpgsql_parse_word</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yytxt</name></decl></parameter>,
				   <parameter><decl><type><name>PLwdatum</name> <modifier>*</modifier></type><name>wdatum</name></decl></parameter>, <parameter><decl><type><name>PLword</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We should do nothing in DECLARE sections.  In SQL expressions, there's
	 * no need to do anything either --- lookup will happen when the
	 * expression is compiled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_IdentifierLookup</name> <operator>==</operator> <name>IDENTIFIER_LOOKUP_NORMAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do a lookup in the current namespace stack
		 */</comment>
		<expr_stmt><expr><name>ns</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><call><name>plpgsql_ns_top</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>word1</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ns</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PLPGSQL_NSTYPE_VAR</name></expr>:</case>
				<case>case <expr><name>PLPGSQL_NSTYPE_REC</name></expr>:</case>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <name><name>plpgsql_Datums</name><index>[<expr><name><name>ns</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>word1</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>quoted</name></name> <operator>=</operator> <operator>(</operator><name><name>yytxt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>idents</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>

				<default>default:</default>
					<comment type="block">/* plpgsql_ns_lookup should never return anything else */</comment>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized plpgsql itemtype: %d"</literal></expr></argument>,
						 <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>itemtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Nothing found - up to now it's a word without any special meaning for
	 * us.
	 */</comment>
	<expr_stmt><expr><name><name>word</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>word1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>word</name><operator>-&gt;</operator><name>quoted</name></name> <operator>=</operator> <operator>(</operator><name><name>yytxt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_parse_dblword		Same lookup for two words
 *					separated by a dot.
 * ----------
 */</comment>
<function><type><name>bool</name></type>
<name>plpgsql_parse_dblword</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word2</name></decl></parameter>,
					  <parameter><decl><type><name>PLwdatum</name> <modifier>*</modifier></type><name>wdatum</name></decl></parameter>, <parameter><decl><type><name>PLcword</name> <modifier>*</modifier></type><name>cword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>idents</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>word1</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>word2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should do nothing in DECLARE sections.  In SQL expressions, we
	 * really only need to make sure that RECFIELD datums are created when
	 * needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_IdentifierLookup</name> <operator>!=</operator> <name>IDENTIFIER_LOOKUP_DECLARE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do a lookup in the current namespace stack
		 */</comment>
		<expr_stmt><expr><name>ns</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><call><name>plpgsql_ns_top</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>word1</name></expr></argument>, <argument><expr><name>word2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>nnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ns</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PLPGSQL_NSTYPE_VAR</name></expr>:</case>
					<comment type="block">/* Block-qualified reference to scalar variable. */</comment>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <name><name>plpgsql_Datums</name><index>[<expr><name><name>ns</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>quoted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* not used */</comment>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>idents</name></name> <operator>=</operator> <name>idents</name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>

				<case>case <expr><name>PLPGSQL_NSTYPE_REC</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name>nnames</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * First word is a record name, so second word could
						 * be a field in this record.  We build a RECFIELD
						 * datum whether it is or not --- any error will be
						 * detected later.
						 */</comment>
						<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plpgsql_Datums</name><index>[<expr><name><name>ns</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>plpgsql_build_recfield</name><argument_list>(<argument><expr><name>rec</name></expr></argument>, <argument><expr><name>word2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>new</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* Block-qualified reference to record variable. */</comment>
						<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <name><name>plpgsql_Datums</name><index>[<expr><name><name>ns</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>quoted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* not used */</comment>
					<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>idents</name></name> <operator>=</operator> <name>idents</name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>

				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Nothing found */</comment>
	<expr_stmt><expr><name><name>cword</name><operator>-&gt;</operator><name>idents</name></name> <operator>=</operator> <name>idents</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_parse_tripword		Same lookup for three words
 *					separated by dots.
 * ----------
 */</comment>
<function><type><name>bool</name></type>
<name>plpgsql_parse_tripword</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word2</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>word3</name></decl></parameter>,
					   <parameter><decl><type><name>PLwdatum</name> <modifier>*</modifier></type><name>wdatum</name></decl></parameter>, <parameter><decl><type><name>PLcword</name> <modifier>*</modifier></type><name>cword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>idents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nnames</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>idents</name> <operator>=</operator> <call><name>list_make3</name><argument_list>(<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>word1</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>word2</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>makeString</name><argument_list>(<argument><expr><name>word3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should do nothing in DECLARE sections.  In SQL expressions, we
	 * really only need to make sure that RECFIELD datums are created when
	 * needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_IdentifierLookup</name> <operator>!=</operator> <name>IDENTIFIER_LOOKUP_DECLARE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do a lookup in the current namespace stack. Must find a qualified
		 * reference, else ignore.
		 */</comment>
		<expr_stmt><expr><name>ns</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><call><name>plpgsql_ns_top</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>word1</name></expr></argument>, <argument><expr><name>word2</name></expr></argument>, <argument><expr><name>word3</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>nnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ns</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nnames</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>ns</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>PLPGSQL_NSTYPE_REC</name></expr>:</case>
					<block>{<block_content>
						<comment type="block">/*
						 * words 1/2 are a record name, so third word could be
						 * a field in this record.
						 */</comment>
						<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>

						<expr_stmt><expr><name>rec</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plpgsql_Datums</name><index>[<expr><name><name>ns</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>plpgsql_build_recfield</name><argument_list>(<argument><expr><name>rec</name></expr></argument>, <argument><expr><name>word3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>datum</name></name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>new</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>ident</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>quoted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* not used */</comment>
						<expr_stmt><expr><name><name>wdatum</name><operator>-&gt;</operator><name>idents</name></name> <operator>=</operator> <name>idents</name></expr>;</expr_stmt>
						<return>return <expr><name>true</name></expr>;</return>
					</block_content>}</block>

				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Nothing found */</comment>
	<expr_stmt><expr><name><name>cword</name><operator>-&gt;</operator><name>idents</name></name> <operator>=</operator> <name>idents</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_parse_wordtype	The scanner found word%TYPE. word can be
 *				a variable name or a basetype.
 *
 * Returns datatype struct, or NULL if no match found for word.
 * ----------
 */</comment>
<function><type><name>PLpgSQL_type</name> <modifier>*</modifier></type>
<name>plpgsql_parse_wordtype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>dtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>nse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do a lookup in the current namespace stack
	 */</comment>
	<expr_stmt><expr><name>nse</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><call><name>plpgsql_ns_top</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							<argument><expr><name>ident</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nse</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>nse</name><operator>-&gt;</operator><name>itemtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_NSTYPE_VAR</name></expr>:</case>
				<return>return <expr><operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plpgsql_Datums</name><index>[<expr><name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>datatype</name></expr>;</return>

				<comment type="block">/* XXX perhaps allow REC/ROW here? */</comment>

			<default>default:</default>
				<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Word wasn't found in the namespace stack. Try to find a data type with
	 * that name, but ignore shell types and complex types.
	 */</comment>
	<expr_stmt><expr><name>typeName</name> <operator>=</operator> <call><name>makeTypeName</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>LookupTypeName</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typeTup</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typisdefined</name></name> <operator>||</operator>
			<name><name>typeStruct</name><operator>-&gt;</operator><name>typrelid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>dtype</name> <operator>=</operator> <call><name>build_datatype</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
							   <argument><expr><name><name>plpgsql_curr_compile</name><operator>-&gt;</operator><name>fn_input_collation</name></name></expr></argument>,
							   <argument><expr><name>typeName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>dtype</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Nothing found - up to now it's a word without any special meaning for
	 * us.
	 */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_parse_cwordtype		Same lookup for compositeword%TYPE
 * ----------
 */</comment>
<function><type><name>PLpgSQL_type</name> <modifier>*</modifier></type>
<name>plpgsql_parse_cwordtype</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>idents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>dtype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_nsitem</name> <modifier>*</modifier></type><name>nse</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fldname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classtup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>attrtup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typetup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>

	<comment type="block">/* Avoid memory leaks in the long-term function context */</comment>
	<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do a lookup in the current namespace stack. We don't need to check
		 * number of names matched, because we will only consider scalar
		 * variables.
		 */</comment>
		<expr_stmt><expr><name>nse</name> <operator>=</operator> <call><name>plpgsql_ns_lookup</name><argument_list>(<argument><expr><call><name>plpgsql_ns_top</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>,
								<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>nse</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>nse</name><operator>-&gt;</operator><name>itemtype</name></name> <operator>==</operator> <name>PLPGSQL_NSTYPE_VAR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dtype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>plpgsql_Datums</name><index>[<expr><name><name>nse</name><operator>-&gt;</operator><name>itemno</name></name></expr>]</index></name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>datatype</name></expr>;</expr_stmt>
			<goto>goto <name>done</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * First word could also be a table name
		 */</comment>
		<expr_stmt><expr><name>classOid</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fldname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relvar</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relvar</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Can't lock relation - we might not have privileges. */</comment>
		<expr_stmt><expr><name>classOid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>fldname</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><call><name>lthird</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<goto>goto <name>done</name>;</goto></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>classtup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It must be a relation, sequence, view, materialized view, composite
	 * type, or foreign table
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		<name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_SEQUENCE</name> <operator>&amp;&amp;</operator>
		<name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
		<name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>classStruct</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch the named table field and its type
	 */</comment>
	<expr_stmt><expr><name>attrtup</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>, <argument><expr><name>fldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attrtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>done</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attrStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>attrtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>typetup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
							  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>attrStruct</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name><name>attrStruct</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Found that - build a compiler type struct in the caller's cxt and
	 * return it.  Note that we treat the type as being found-by-OID; no
	 * attempt to re-look-up the type name will happen during invalidations.
	 */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dtype</name> <operator>=</operator> <call><name>build_datatype</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>,
						   <argument><expr><name><name>attrStruct</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
						   <argument><expr><name><name>attrStruct</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>attrtup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>attrtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typetup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dtype</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_parse_wordrowtype		Scanner found word%ROWTYPE.
 *					So word must be a table name.
 * ----------
 */</comment>
<function><type><name>PLpgSQL_type</name> <modifier>*</modifier></type>
<name>plpgsql_parse_wordrowtype</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Look up the relation.  Note that because relation rowtypes have the
	 * same names as their relations, this could be handled as a type lookup
	 * equally well; we use the relation lookup code path only because the
	 * errors thrown here have traditionally referred to relations not types.
	 * But we'll make a TypeName in case we have to do re-look-up of the type.
	 */</comment>
	<expr_stmt><expr><name>classOid</name> <operator>=</operator> <call><name>RelnameGetRelid</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Build and return the row type struct */</comment>
	<return>return <expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><call><name>get_rel_type_id</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><call><name>makeTypeName</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_parse_cwordrowtype		Scanner found compositeword%ROWTYPE.
 *			So word must be a namespace qualified table name.
 * ----------
 */</comment>
<function><type><name>PLpgSQL_type</name> <modifier>*</modifier></type>
<name>plpgsql_parse_cwordrowtype</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>idents</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>classOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>relvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldCxt</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As above, this is a relation lookup but could be a type lookup if we
	 * weren't being backwards-compatible about error wording.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Avoid memory leaks in long-term function context */</comment>
	<expr_stmt><expr><name>oldCxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up relation name.  Can't lock it - we might not have privileges. */</comment>
	<expr_stmt><expr><name>relvar</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>classOid</name> <operator>=</operator> <call><name>RangeVarGetRelid</name><argument_list>(<argument><expr><name>relvar</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build and return the row type struct */</comment>
	<return>return <expr><call><name>plpgsql_build_datatype</name><argument_list>(<argument><expr><call><name>get_rel_type_id</name><argument_list>(<argument><expr><name>classOid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
								  <argument><expr><call><name>makeTypeNameFromNameList</name><argument_list>(<argument><expr><name>idents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_build_variable - build a datum-array entry of a given
 * datatype
 *
 * The returned struct may be a PLpgSQL_var or PLpgSQL_rec
 * depending on the given datatype, and is allocated via
 * palloc.  The struct is automatically added to the current datum
 * array, and optionally to the current namespace.
 */</comment>
<function><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type>
<name>plpgsql_build_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>,
					   <parameter><decl><type><name>bool</name></type> <name>add2namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>dtype</name><operator>-&gt;</operator><name>ttype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PLPGSQL_TTYPE_SCALAR</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Ordinary scalar datatype */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_var</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_VAR</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>datatype</name></name> <operator>=</operator> <name>dtype</name></expr>;</expr_stmt>
				<comment type="block">/* other fields are left as 0, might be changed by caller */</comment>

				<comment type="block">/* preset to NULL */</comment>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>freeval</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>plpgsql_adddatum</name><argument_list>(<argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>add2namespace</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>plpgsql_ns_additem</name><argument_list>(<argument><expr><name>PLPGSQL_NSTYPE_VAR</name></expr></argument>,
									   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>,
									   <argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>var</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PLPGSQL_TTYPE_REC</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* Composite type -- build a record variable */</comment>
				<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>plpgsql_build_record</name><argument_list>(<argument><expr><name>refname</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>,
										   <argument><expr><name>dtype</name></expr></argument>, <argument><expr><name><name>dtype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
										   <argument><expr><name>add2namespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_variable</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PLPGSQL_TTYPE_PSEUDO</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"variable \"%s\" has pseudo-type %s"</literal></expr></argument>,
							<argument><expr><name>refname</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>dtype</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized ttype: %d"</literal></expr></argument>, <argument><expr><name><name>dtype</name><operator>-&gt;</operator><name>ttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build empty named record variable, and optionally add it to namespace
 */</comment>
<function><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type>
<name>plpgsql_build_record</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>refname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>,
					 <parameter><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>dtype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rectypeid</name></decl></parameter>,
					 <parameter><decl><type><name>bool</name></type> <name>add2namespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rec</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_REC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>refname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<comment type="block">/* other fields are left as 0, might be changed by caller */</comment>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>datatype</name></name> <operator>=</operator> <name>dtype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>rectypeid</name></name> <operator>=</operator> <name>rectypeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>firstfield</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>erh</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>plpgsql_adddatum</name><argument_list>(<argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>rec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>add2namespace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>plpgsql_ns_additem</name><argument_list>(<argument><expr><name>PLPGSQL_NSTYPE_REC</name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>, <argument><expr><name><name>rec</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a row-variable data structure given the component variables.
 * Include a rowtupdesc, since we will need to materialize the row result.
 */</comment>
<function><type><specifier>static</specifier> <name>PLpgSQL_row</name> <modifier>*</modifier></type>
<name>build_row_from_vars</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier><modifier>*</modifier></type><name>vars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numvars</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_row</name> <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>row</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_row</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_ROW</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>refname</name></name> <operator>=</operator> <literal type="string">"(unnamed row)"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>numvars</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>nfields</name></name> <operator>=</operator> <name>numvars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>fieldnames</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numvars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numvars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numvars</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_variable</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>vars</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typcoll</name></decl>;</decl_stmt>

		<comment type="block">/* Member vars of a row should never be const */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>isconst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
				<expr_stmt><expr><name>typoid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>typoid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typcoll</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PLpgSQL_var</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name><name>datatype</name><operator>-&gt;</operator><name>collation</name></name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<comment type="block">/* shouldn't need to revalidate rectypeid already... */</comment>
				<expr_stmt><expr><name>typoid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>PLpgSQL_rec</name> <operator>*</operator><operator>)</operator> <name>var</name><operator>)</operator><operator>-&gt;</operator><name>rectypeid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* don't know typmod, if it's used at all */</comment>
				<expr_stmt><expr><name>typcoll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* composite types have no collation */</comment>
				<break>break;</break>

			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dtype: %d"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>dtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>typoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<expr_stmt><expr><name>typmod</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>typcoll</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>fieldnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>refname</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>row</name><operator>-&gt;</operator><name>varnos</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
						   <argument><expr><name><name>var</name><operator>-&gt;</operator><name>refname</name></name></expr></argument>,
						   <argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>,
						   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntryCollation</name><argument_list>(<argument><expr><name><name>row</name><operator>-&gt;</operator><name>rowtupdesc</name></name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>typcoll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>row</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Build a RECFIELD datum for the named field of the specified record variable
 *
 * If there's already such a datum, just return it; we don't need duplicates.
 */</comment>
<function><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type>
<name>plpgsql_build_recfield</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_rec</name> <modifier>*</modifier></type><name>rec</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fldname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>recfield</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* search for an existing datum referencing this field */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>firstfield</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLpgSQL_recfield</name> <modifier>*</modifier></type><name>fld</name> <init>= <expr><operator>(</operator><name>PLpgSQL_recfield</name> <operator>*</operator><operator>)</operator> <name><name>plpgsql_Datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fld</name><operator>-&gt;</operator><name>dtype</name></name> <operator>==</operator> <name>PLPGSQL_DTYPE_RECFIELD</name> <operator>&amp;&amp;</operator>
			   <name><name>fld</name><operator>-&gt;</operator><name>recparentno</name></name> <operator>==</operator> <name><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fld</name><operator>-&gt;</operator><name>fieldname</name></name></expr></argument>, <argument><expr><name>fldname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>fld</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>fld</name><operator>-&gt;</operator><name>nextfield</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* nope, so make a new one */</comment>
	<expr_stmt><expr><name>recfield</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_recfield</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>dtype</name></name> <operator>=</operator> <name>PLPGSQL_DTYPE_RECFIELD</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>fieldname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>fldname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>recparentno</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>rectupledescid</name></name> <operator>=</operator> <name>INVALID_TUPLEDESC_IDENTIFIER</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>plpgsql_adddatum</name><argument_list>(<argument><expr><operator>(</operator><name>PLpgSQL_datum</name> <operator>*</operator><operator>)</operator> <name>recfield</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now we can link it into the parent's chain */</comment>
	<expr_stmt><expr><name><name>recfield</name><operator>-&gt;</operator><name>nextfield</name></name> <operator>=</operator> <name><name>rec</name><operator>-&gt;</operator><name>firstfield</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rec</name><operator>-&gt;</operator><name>firstfield</name></name> <operator>=</operator> <name><name>recfield</name><operator>-&gt;</operator><name>dno</name></name></expr>;</expr_stmt>

	<return>return <expr><name>recfield</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_build_datatype
 *		Build PLpgSQL_type struct given type OID, typmod, collation,
 *		and type's parsed name.
 *
 * If collation is not InvalidOid then it overrides the type's default
 * collation.  But collation is ignored if the datatype is non-collatable.
 *
 * origtypname is the parsed form of what the user wrote as the type name.
 * It can be NULL if the type could not be a composite type, or if it was
 * identified by OID to begin with (e.g., it's a function argument type).
 */</comment>
<function><type><name>PLpgSQL_type</name> <modifier>*</modifier></type>
<name>plpgsql_build_datatype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typeOid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
					   <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>origtypname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>typ</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typeOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typ</name> <operator>=</operator> <call><name>build_datatype</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>origtypname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>typ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Utility subroutine to make a PLpgSQL_type struct given a pg_type entry
 * and additional details (see comments for plpgsql_build_datatype).
 */</comment>
<function><type><specifier>static</specifier> <name>PLpgSQL_type</name> <modifier>*</modifier></type>
<name>build_datatype</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typeTup</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>, <parameter><decl><type><name>TypeName</name> <modifier>*</modifier></type><name>origtypname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_type</name> <modifier>*</modifier></type><name>typ</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" is only a shell"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>typ</name> <operator>=</operator> <operator>(</operator><name>PLpgSQL_type</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_type</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name> <operator>=</operator> <call><name>HeapTupleGetOid</name><argument_list>(<argument><expr><name>typeTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPTYPE_BASE</name></expr>:</case>
		<case>case <expr><name>TYPTYPE_ENUM</name></expr>:</case>
		<case>case <expr><name>TYPTYPE_RANGE</name></expr>:</case>
			<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>PLPGSQL_TTYPE_SCALAR</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TYPTYPE_COMPOSITE</name></expr>:</case>
			<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>PLPGSQL_TTYPE_REC</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TYPTYPE_DOMAIN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typbasetype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>PLPGSQL_TTYPE_REC</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>PLPGSQL_TTYPE_SCALAR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>TYPTYPE_PSEUDO</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>PLPGSQL_TTYPE_REC</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>=</operator> <name>PLPGSQL_TTYPE_PSEUDO</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized typtype: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typlen</name></name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typbyval</name></name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typtype</name></name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typcollation</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>collation</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* Detect if type is true array, or domain thereof */</comment>
	<comment type="block">/* NB: this is only used to decide whether to apply expand_array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_BASE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This test should include what get_element_type() checks.  We also
		 * disallow non-toastable array types (i.e. oidvector and int2vector).
		 */</comment>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typisarray</name></name> <operator>=</operator> <operator>(</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
						   <call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						   <name><name>typeStruct</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we can short-circuit looking up base types if it's not varlena */</comment>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typisarray</name></name> <operator>=</operator> <operator>(</operator><name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>
						   <name><name>typeStruct</name><operator>-&gt;</operator><name>typstorage</name></name> <operator>!=</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator>
						   <call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_base_element_type</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typbasetype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>typisarray</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name>typmod</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If it's a named composite type (or domain over one), find the typcache
	 * entry and record the current tupdesc ID, so we can detect changes
	 * (including drops).  We don't currently support on-the-fly replacement
	 * of non-composite types, else we might want to do this for them too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>typ</name><operator>-&gt;</operator><name>ttype</name></name> <operator>==</operator> <name>PLPGSQL_TTYPE_REC</name> <operator>&amp;&amp;</operator> <name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name> <operator>!=</operator> <name>RECORDOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>,
									 <argument><expr><name>TYPECACHE_TUPDESC</name> <operator>|</operator>
									 <name>TYPECACHE_DOMAIN_BASE_INFO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>typtype</name></name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>domainBaseType</name></name></expr></argument>,
										 <argument><expr><name>TYPECACHE_TUPDESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>tupDesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_WRONG_OBJECT_TYPE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is not composite"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>typ</name><operator>-&gt;</operator><name>typoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>origtypname</name></name> <operator>=</operator> <name>origtypname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>tcache</name></name> <operator>=</operator> <name>typentry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>=</operator> <name><name>typentry</name><operator>-&gt;</operator><name>tupDesc_identifier</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>origtypname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>tcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>typ</name><operator>-&gt;</operator><name>tupdesc_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>typ</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	plpgsql_recognize_err_condition
 *		Check condition name and translate it to SQLSTATE.
 *
 * Note: there are some cases where the same condition name has multiple
 * entries in the table.  We arbitrarily return the first match.
 */</comment>
<function><type><name>int</name></type>
<name>plpgsql_recognize_err_condition</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>condname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_sqlstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>allow_sqlstate</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>condname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator>
			<call><name>strspn</name><argument_list>(<argument><expr><name>condname</name></expr></argument>, <argument><expr><literal type="string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>condname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>condname</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>condname</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>condname</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
								 <argument><expr><name><name>condname</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>exception_label_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>condname</name></expr></argument>, <argument><expr><name><name>exception_label_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>exception_label_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sqlerrstate</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized exception condition \"%s\""</literal></expr></argument>,
					<argument><expr><name>condname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_parse_err_condition
 *		Generate PLpgSQL_condition entry(s) for an exception condition name
 *
 * This has to be able to return a list because there are some duplicate
 * names in the table of error code names.
 */</comment>
<function><type><name>PLpgSQL_condition</name> <modifier>*</modifier></type>
<name>plpgsql_parse_err_condition</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>condname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_condition</name> <modifier>*</modifier></type><name>new</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLpgSQL_condition</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX Eventually we will want to look for user-defined exception names
	 * here.
	 */</comment>

	<comment type="block">/*
	 * OTHERS is represented as code 0 (which would map to '00000', but we
	 * have no need to represent that as an exception condition).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>condname</name></expr></argument>, <argument><expr><literal type="string">"others"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_condition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>sqlerrstate</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>condname</name></name> <operator>=</operator> <name>condname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>new</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>exception_label_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>condname</name></expr></argument>, <argument><expr><name><name>exception_label_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>label</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>new</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_condition</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>sqlerrstate</name></name> <operator>=</operator> <name><name>exception_label_map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sqlerrstate</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>condname</name></name> <operator>=</operator> <name>condname</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>new</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized exception condition \"%s\""</literal></expr></argument>,
						<argument><expr><name>condname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>prev</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_start_datums			Initialize datum list at compile startup.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_start_datums</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>datums_alloc</name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_nDatums</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* This is short-lived, so needn't allocate in function's cxt */</comment>
	<expr_stmt><expr><name>plpgsql_Datums</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>plpgsql_compile_tmp_cxt</name></expr></argument>,
										<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>datums_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* datums_last tracks what's been seen by plpgsql_add_initdatums() */</comment>
	<expr_stmt><expr><name>datums_last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_adddatum			Add a variable, record or row
 *					to the compiler's datum list.
 * ----------
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_adddatum</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_datum</name> <modifier>*</modifier></type><name>newdatum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>plpgsql_nDatums</name> <operator>==</operator> <name>datums_alloc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>datums_alloc</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>plpgsql_Datums</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>plpgsql_Datums</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>datums_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>newdatum</name><operator>-&gt;</operator><name>dno</name></name> <operator>=</operator> <name>plpgsql_nDatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plpgsql_Datums</name><index>[<expr><name>plpgsql_nDatums</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>newdatum</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * plpgsql_finish_datums	Copy completed datum info into function struct.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_finish_datums</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>copiable_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>ndatums</name></name> <operator>=</operator> <name>plpgsql_nDatums</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>datums</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_datum</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>plpgsql_nDatums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>plpgsql_nDatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>plpgsql_Datums</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* This must agree with copy_plpgsql_datums on what is copiable */</comment>
		<switch>switch <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>datums</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_PROMISE</name></expr>:</case>
				<expr_stmt><expr><name>copiable_size</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_var</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<expr_stmt><expr><name>copiable_size</name> <operator>+=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>copiable_size</name></name> <operator>=</operator> <name>copiable_size</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * plpgsql_add_initdatums		Make an array of the datum numbers of
 *					all the initializable datums created since the last call
 *					to this function.
 *
 * If varnos is NULL, we just forget any datum entries created since the
 * last call.
 *
 * This is used around a DECLARE section to create a list of the datums
 * that have to be initialized at block entry.  Note that datums can also
 * be created elsewhere than DECLARE, eg by a FOR-loop, but it is then
 * the responsibility of special-purpose code to initialize them.
 * ----------
 */</comment>
<function><type><name>int</name></type>
<name>plpgsql_add_initdatums</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>varnos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The set of dtypes recognized here must match what exec_stmt_block()
	 * cares about (re)initializing at block entry.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>datums_last</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>plpgsql_nDatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>plpgsql_Datums</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
			<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>varnos</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>varnos</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>datums_last</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>plpgsql_nDatums</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<switch>switch <condition>(<expr><name><name>plpgsql_Datums</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dtype</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PLPGSQL_DTYPE_VAR</name></expr>:</case>
					<case>case <expr><name>PLPGSQL_DTYPE_REC</name></expr>:</case>
						<expr_stmt><expr><operator>(</operator><operator>*</operator><name>varnos</name><operator>)</operator><index>[<expr><name>n</name><operator>++</operator></expr>]</index> <operator>=</operator> <name><name>plpgsql_Datums</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>dno</name></expr>;</expr_stmt>

					<default>default:</default>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>varnos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>datums_last</name> <operator>=</operator> <name>plpgsql_nDatums</name></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Compute the hashkey for a given function invocation
 *
 * The hashkey is returned into the caller-provided storage at *hashkey.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_function_hashkey</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>,
						 <parameter><decl><type><name>Form_pg_proc</name></type> <name>procStruct</name></decl></parameter>,
						 <parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>hashkey</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Make sure any unused bytes of the struct are zero */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>hashkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_func_hashkey</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get function OID */</comment>
	<expr_stmt><expr><name><name>hashkey</name><operator>-&gt;</operator><name>funcOid</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_oid</name></name></expr>;</expr_stmt>

	<comment type="block">/* get call context */</comment>
	<expr_stmt><expr><name><name>hashkey</name><operator>-&gt;</operator><name>isTrigger</name></name> <operator>=</operator> <call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hashkey</name><operator>-&gt;</operator><name>isEventTrigger</name></name> <operator>=</operator> <call><name>CALLED_AS_EVENT_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If DML trigger, include trigger's OID in the hash, so that each trigger
	 * usage gets a different hash entry, allowing for e.g. different relation
	 * rowtypes or transition table names.  In validation mode we do not know
	 * what relation or transition table names are intended to be used, so we
	 * leave trigOid zero; the hash entry built in this case will never be
	 * used for any actual calls.
	 *
	 * We don't currently need to distinguish different event trigger usages
	 * in the same way, since the special parameter variables don't vary in
	 * type in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hashkey</name><operator>-&gt;</operator><name>isTrigger</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>forValidator</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>hashkey</name><operator>-&gt;</operator><name>trigOid</name></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgoid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get input collation, if known */</comment>
	<expr_stmt><expr><name><name>hashkey</name><operator>-&gt;</operator><name>inputCollation</name></name> <operator>=</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>fncollation</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get the argument types */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hashkey</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>, <argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>,
			   <argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* resolve any polymorphic argument types */</comment>
		<expr_stmt><expr><call><name>plpgsql_resolve_polymorphic_argtypes</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr></argument>,
											 <argument><expr><name><name>hashkey</name><operator>-&gt;</operator><name>argtypes</name></name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name><operator>-&gt;</operator><name>fn_expr</name></name></expr></argument>,
											 <argument><expr><name>forValidator</name></expr></argument>,
											 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>procStruct</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This is the same as the standard resolve_polymorphic_argtypes() function,
 * but with a special case for validation: assume that polymorphic arguments
 * are integer, integer-array or integer-range.  Also, we go ahead and report
 * the error if we can't resolve the types.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_resolve_polymorphic_argtypes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numargs</name></decl></parameter>,
									 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>argmodes</name></decl></parameter>,
									 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>call_expr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forValidator</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>proname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>forValidator</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* normal case, pass to standard routine */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>resolve_polymorphic_argtypes</name><argument_list>(<argument><expr><name>numargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>argmodes</name></expr></argument>,
										  <argument><expr><name>call_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine actual argument "</literal>
							<literal type="string">"type for polymorphic function \"%s\""</literal></expr></argument>,
							<argument><expr><name>proname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* special validation case */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>ANYELEMENTOID</name></expr>:</case>
				<case>case <expr><name>ANYNONARRAYOID</name></expr>:</case>
				<case>case <expr><name>ANYENUMOID</name></expr>:</case>	<comment type="block">/* XXX dubious */</comment>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT4OID</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>ANYARRAYOID</name></expr>:</case>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT4ARRAYOID</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>ANYRANGEOID</name></expr>:</case>
					<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>INT4RANGEOID</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * delete_function - clean up as much as possible of a stale function cache
 *
 * We can't release the PLpgSQL_function struct itself, because of the
 * possibility that there are fn_extra pointers to it.  We can release
 * the subsidiary storage, but only if there are no active evaluations
 * in progress.  Otherwise we'll just leak that storage.  Since the
 * case would only occur if a pg_proc update is detected during a nested
 * recursive call on the function, a leak seems acceptable.
 *
 * Note that this can be called more than once if there are multiple fn_extra
 * pointers to the same function cache.  Hence be careful not to do things
 * twice.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>delete_function</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* remove function from hash table (might be done already) */</comment>
	<expr_stmt><expr><call><name>plpgsql_HashTableDelete</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* release the function's storage if safe and not done already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>func</name><operator>-&gt;</operator><name>use_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>plpgsql_free_function_memory</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* exported so we can call it from plpgsql_init() */</comment>
<function><type><name>void</name></type>
<name>plpgsql_HashTableInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<comment type="block">/* don't allow double-initialization */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plpgsql_HashTable</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PLpgSQL_func_hashkey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>plpgsql_HashEnt</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_HashTable</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"PLpgSQL function hash"</literal></expr></argument>,
									<argument><expr><name>FUNCS_PER_USER</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
									<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PLpgSQL_function</name> <modifier>*</modifier></type>
<name>plpgsql_HashTableLookup</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>func_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plpgsql_HashEnt</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>plpgsql_HashEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plpgsql_HashTable</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func_key</name></expr></argument>,
											 <argument><expr><name>HASH_FIND</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hentry</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>hentry</name><operator>-&gt;</operator><name>function</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_HashTableInsert</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>,
						<parameter><decl><type><name>PLpgSQL_func_hashkey</name> <modifier>*</modifier></type><name>func_key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plpgsql_HashEnt</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>plpgsql_HashEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plpgsql_HashTable</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>func_key</name></expr></argument>,
											 <argument><expr><name>HASH_ENTER</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"trying to insert a function that already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>function</name></name> <operator>=</operator> <name>function</name></expr>;</expr_stmt>
	<comment type="block">/* prepare back link from function to hashtable key */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_hashkey</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>hentry</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpgsql_HashTableDelete</name><parameter_list>(<parameter><decl><type><name>PLpgSQL_function</name> <modifier>*</modifier></type><name>function</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>plpgsql_HashEnt</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>

	<comment type="block">/* do nothing if not in table */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>function</name><operator>-&gt;</operator><name>fn_hashkey</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>hentry</name> <operator>=</operator> <operator>(</operator><name>plpgsql_HashEnt</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>plpgsql_HashTable</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>function</name><operator>-&gt;</operator><name>fn_hashkey</name></name></expr></argument>,
											 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>hentry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"trying to delete function that does not exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* remove back link, which no longer points to allocated storage */</comment>
	<expr_stmt><expr><name><name>function</name><operator>-&gt;</operator><name>fn_hashkey</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
