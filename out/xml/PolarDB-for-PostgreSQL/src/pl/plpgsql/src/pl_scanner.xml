<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/pl/plpgsql/src/pl_scanner.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pl_scanner.c
 *	  lexical scanning for PL/pgSQL
 *
 *
 * Portions Copyright (c) 1996-2018, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/pl/plpgsql/src/pl_scanner.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scanner.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpgsql.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pl_gram.h"</cpp:file></cpp:include>			<comment type="block">/* must be after parser/scanner.h */</comment>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_KEYWORD</name><parameter_list>(<parameter><type><name>a</name></type></parameter>,<parameter><type><name>b</name></type></parameter>,<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{a,b,c},</cpp:value></cpp:define>


<comment type="block">/* Klugy flag to tell scanner how to look up identifiers */</comment>
<decl_stmt><decl><type><name>IdentifierLookup</name></type> <name>plpgsql_IdentifierLookup</name> <init>= <expr><name>IDENTIFIER_LOOKUP_NORMAL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * A word about keywords:
 *
 * We keep reserved and unreserved keywords in separate arrays.  The
 * reserved keywords are passed to the core scanner, so they will be
 * recognized before (and instead of) any variable name.  Unreserved words
 * are checked for separately, usually after determining that the identifier
 * isn't a known variable name.  If plpgsql_IdentifierLookup is DECLARE then
 * no variable names will be recognized, so the unreserved words always work.
 * (Note in particular that this helps us avoid reserving keywords that are
 * only needed in DECLARE sections.)
 *
 * In certain contexts it is desirable to prefer recognizing an unreserved
 * keyword over recognizing a variable name.  In particular, at the start
 * of a statement we should prefer unreserved keywords unless the statement
 * looks like an assignment (i.e., first token is followed by ':=' or '[').
 * This rule allows most statement-introducing keywords to be kept unreserved.
 * (We still have to reserve initial keywords that might follow a block
 * label, unfortunately, since the method used to determine if we are at
 * start of statement doesn't recognize such cases.  We'd also have to
 * reserve any keyword that could legitimately be followed by ':=' or '['.)
 * Some additional cases are handled in pl_gram.y using tok_is_keyword().
 *
 * We try to avoid reserving more keywords than we have to; but there's
 * little point in not reserving a word if it's reserved in the core grammar.
 * Currently, the following words are reserved here but not in the core:
 * BEGIN BY DECLARE EXECUTE FOREACH IF LOOP STRICT WHILE
 */</comment>

<comment type="block">/*
 * Lists of keyword (name, token-value, category) entries.
 *
 * !!WARNING!!: These lists must be sorted by ASCII name, because binary
 *		 search is used to locate entries.
 *
 * Be careful not to put the same word in both lists.  Also be sure that
 * pl_gram.y's unreserved_keyword production agrees with the second list.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ScanKeyword</name></type> <name><name>reserved_keywords</name><index>[]</index></name> <init>= <expr><block>{
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"all"</literal></argument>, <argument>K_ALL</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"begin"</literal></argument>, <argument>K_BEGIN</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"by"</literal></argument>, <argument>K_BY</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"case"</literal></argument>, <argument>K_CASE</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"declare"</literal></argument>, <argument>K_DECLARE</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"else"</literal></argument>, <argument>K_ELSE</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"end"</literal></argument>, <argument>K_END</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"execute"</literal></argument>, <argument>K_EXECUTE</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"for"</literal></argument>, <argument>K_FOR</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"foreach"</literal></argument>, <argument>K_FOREACH</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"from"</literal></argument>, <argument>K_FROM</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"if"</literal></argument>, <argument>K_IF</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"in"</literal></argument>, <argument>K_IN</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"into"</literal></argument>, <argument>K_INTO</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"loop"</literal></argument>, <argument>K_LOOP</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"not"</literal></argument>, <argument>K_NOT</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"null"</literal></argument>, <argument>K_NULL</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"or"</literal></argument>, <argument>K_OR</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"strict"</literal></argument>, <argument>K_STRICT</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"then"</literal></argument>, <argument>K_THEN</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"to"</literal></argument>, <argument>K_TO</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"using"</literal></argument>, <argument>K_USING</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"when"</literal></argument>, <argument>K_WHEN</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"while"</literal></argument>, <argument>K_WHILE</argument>, <argument>RESERVED_KEYWORD</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>num_reserved_keywords</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>reserved_keywords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ScanKeyword</name></type> <name><name>unreserved_keywords</name><index>[]</index></name> <init>= <expr><block>{
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"absolute"</literal></argument>, <argument>K_ABSOLUTE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"alias"</literal></argument>, <argument>K_ALIAS</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"array"</literal></argument>, <argument>K_ARRAY</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"assert"</literal></argument>, <argument>K_ASSERT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"backward"</literal></argument>, <argument>K_BACKWARD</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"call"</literal></argument>, <argument>K_CALL</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"close"</literal></argument>, <argument>K_CLOSE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"collate"</literal></argument>, <argument>K_COLLATE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"column"</literal></argument>, <argument>K_COLUMN</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"column_name"</literal></argument>, <argument>K_COLUMN_NAME</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"commit"</literal></argument>, <argument>K_COMMIT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"constant"</literal></argument>, <argument>K_CONSTANT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"constraint"</literal></argument>, <argument>K_CONSTRAINT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"constraint_name"</literal></argument>, <argument>K_CONSTRAINT_NAME</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"continue"</literal></argument>, <argument>K_CONTINUE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"current"</literal></argument>, <argument>K_CURRENT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"cursor"</literal></argument>, <argument>K_CURSOR</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"datatype"</literal></argument>, <argument>K_DATATYPE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"debug"</literal></argument>, <argument>K_DEBUG</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"default"</literal></argument>, <argument>K_DEFAULT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"detail"</literal></argument>, <argument>K_DETAIL</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"diagnostics"</literal></argument>, <argument>K_DIAGNOSTICS</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"do"</literal></argument>, <argument>K_DO</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"dump"</literal></argument>, <argument>K_DUMP</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"elseif"</literal></argument>, <argument>K_ELSIF</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"elsif"</literal></argument>, <argument>K_ELSIF</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"errcode"</literal></argument>, <argument>K_ERRCODE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"error"</literal></argument>, <argument>K_ERROR</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"exception"</literal></argument>, <argument>K_EXCEPTION</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"exit"</literal></argument>, <argument>K_EXIT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"fetch"</literal></argument>, <argument>K_FETCH</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"first"</literal></argument>, <argument>K_FIRST</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"forward"</literal></argument>, <argument>K_FORWARD</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"get"</literal></argument>, <argument>K_GET</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"hint"</literal></argument>, <argument>K_HINT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"import"</literal></argument>, <argument>K_IMPORT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"info"</literal></argument>, <argument>K_INFO</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"insert"</literal></argument>, <argument>K_INSERT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"is"</literal></argument>, <argument>K_IS</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"last"</literal></argument>, <argument>K_LAST</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"log"</literal></argument>, <argument>K_LOG</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"message"</literal></argument>, <argument>K_MESSAGE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"message_text"</literal></argument>, <argument>K_MESSAGE_TEXT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"move"</literal></argument>, <argument>K_MOVE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"next"</literal></argument>, <argument>K_NEXT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"no"</literal></argument>, <argument>K_NO</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"notice"</literal></argument>, <argument>K_NOTICE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"open"</literal></argument>, <argument>K_OPEN</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"option"</literal></argument>, <argument>K_OPTION</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"perform"</literal></argument>, <argument>K_PERFORM</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"pg_context"</literal></argument>, <argument>K_PG_CONTEXT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"pg_datatype_name"</literal></argument>, <argument>K_PG_DATATYPE_NAME</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"pg_exception_context"</literal></argument>, <argument>K_PG_EXCEPTION_CONTEXT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"pg_exception_detail"</literal></argument>, <argument>K_PG_EXCEPTION_DETAIL</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"pg_exception_hint"</literal></argument>, <argument>K_PG_EXCEPTION_HINT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"print_strict_params"</literal></argument>, <argument>K_PRINT_STRICT_PARAMS</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"prior"</literal></argument>, <argument>K_PRIOR</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"query"</literal></argument>, <argument>K_QUERY</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"raise"</literal></argument>, <argument>K_RAISE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"relative"</literal></argument>, <argument>K_RELATIVE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"reset"</literal></argument>, <argument>K_RESET</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"result_oid"</literal></argument>, <argument>K_RESULT_OID</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"return"</literal></argument>, <argument>K_RETURN</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"returned_sqlstate"</literal></argument>, <argument>K_RETURNED_SQLSTATE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"reverse"</literal></argument>, <argument>K_REVERSE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"rollback"</literal></argument>, <argument>K_ROLLBACK</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"row_count"</literal></argument>, <argument>K_ROW_COUNT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"rowtype"</literal></argument>, <argument>K_ROWTYPE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"schema"</literal></argument>, <argument>K_SCHEMA</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"schema_name"</literal></argument>, <argument>K_SCHEMA_NAME</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"scroll"</literal></argument>, <argument>K_SCROLL</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"set"</literal></argument>, <argument>K_SET</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"slice"</literal></argument>, <argument>K_SLICE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"sqlstate"</literal></argument>, <argument>K_SQLSTATE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"stacked"</literal></argument>, <argument>K_STACKED</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"table"</literal></argument>, <argument>K_TABLE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"table_name"</literal></argument>, <argument>K_TABLE_NAME</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"type"</literal></argument>, <argument>K_TYPE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"use_column"</literal></argument>, <argument>K_USE_COLUMN</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"use_variable"</literal></argument>, <argument>K_USE_VARIABLE</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"variable_conflict"</literal></argument>, <argument>K_VARIABLE_CONFLICT</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
	<macro><name>PG_KEYWORD</name><argument_list>(<argument><literal type="string">"warning"</literal></argument>, <argument>K_WARNING</argument>, <argument>UNRESERVED_KEYWORD</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>num_unreserved_keywords</name> <init>= <expr><call><name>lengthof</name><argument_list>(<argument><expr><name>unreserved_keywords</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This macro must recognize all tokens that can immediately precede a
 * PL/pgSQL executable statement (that is, proc_sect or proc_stmt in the
 * grammar).  Fortunately, there are not very many, so hard-coding in this
 * fashion seems sufficient.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AT_STMT_START</name><parameter_list>(<parameter><type><name>prev_token</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((prev_token) == ';' || \
	 (prev_token) == K_BEGIN || \
	 (prev_token) == K_THEN || \
	 (prev_token) == K_ELSE || \
	 (prev_token) == K_LOOP)</cpp:value></cpp:define>


<comment type="block">/* Auxiliary data about a token (other than the token type) */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>YYSTYPE</name></type>		<name>lval</name></decl>;</decl_stmt>			<comment type="block">/* semantic information */</comment>
	<decl_stmt><decl><type><name>YYLTYPE</name></type>		<name>lloc</name></decl>;</decl_stmt>			<comment type="block">/* offset in scanbuf */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>leng</name></decl>;</decl_stmt>			<comment type="block">/* length in bytes */</comment>
}</block></struct></type> <name>TokenAuxData</name>;</typedef>

<comment type="block">/*
 * Scanner working state.  At some point we might wish to fold all this
 * into a YY_EXTRA struct.  For the moment, there is no need for plpgsql's
 * lexer to be re-entrant, and the notational burden of passing a yyscanner
 * pointer around is great enough to not want to do it without need.
 */</comment>

<comment type="block">/* The stuff the core lexer needs */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>core_yyscan_t</name></type> <name>yyscanner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>core_yy_extra_type</name></type> <name>core_yy</name></decl>;</decl_stmt>

<comment type="block">/* The original input string */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>scanorig</name></decl>;</decl_stmt>

<comment type="block">/* Current token's length (corresponds to plpgsql_yylval and plpgsql_yylloc) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>plpgsql_yyleng</name></decl>;</decl_stmt>

<comment type="block">/* Current token's code (corresponds to plpgsql_yylval and plpgsql_yylloc) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>plpgsql_yytoken</name></decl>;</decl_stmt>

<comment type="block">/* Token pushback stack */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_PUSHBACKS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_pushbacks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name><name>pushback_token</name><index>[<expr><name>MAX_PUSHBACKS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TokenAuxData</name></type> <name><name>pushback_auxdata</name><index>[<expr><name>MAX_PUSHBACKS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* State for plpgsql_location_to_lineno() */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_line_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_line_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>cur_line_num</name></decl>;</decl_stmt>

<comment type="block">/* Internal functions */</comment>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>internal_yylex</name><parameter_list>(<parameter><decl><type><name>TokenAuxData</name> <modifier>*</modifier></type><name>auxdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_back_token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>TokenAuxData</name> <modifier>*</modifier></type><name>auxdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>location_lineno_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * This is the yylex routine called from the PL/pgSQL grammar.
 * It is a wrapper around the core lexer, with the ability to recognize
 * PL/pgSQL variables and return them as special T_DATUM tokens.  If a
 * word or compound word does not match any variable name, or if matching
 * is turned off by plpgsql_IdentifierLookup, it is returned as
 * T_WORD or T_CWORD respectively, or as an unreserved keyword if it
 * matches one of those.
 */</comment>
<function><type><name>int</name></type>
<name>plpgsql_yylex</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tok1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ScanKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tok1</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tok1</name> <operator>==</operator> <name>IDENT</name> <operator>||</operator> <name>tok1</name> <operator>==</operator> <name>PARAM</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>tok2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tok2</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tok2</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>tok3</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux3</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tok3</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>tok3</name> <operator>==</operator> <name>IDENT</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>tok4</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux4</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tok4</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>tok4</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>tok5</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux5</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>tok5</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>tok5</name> <operator>==</operator> <name>IDENT</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>plpgsql_parse_tripword</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
												   <argument><expr><name><name>aux3</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
												   <argument><expr><name><name>aux5</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>wdatum</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>cword</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_DATUM</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_CWORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* not A.B.C, so just process A.B */</comment>
						<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok5</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>plpgsql_parse_dblword</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
												  <argument><expr><name><name>aux3</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>wdatum</name></name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>cword</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_DATUM</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_CWORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* not A.B.C, so just process A.B */</comment>
					<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>plpgsql_parse_dblword</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
											  <argument><expr><name><name>aux3</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>wdatum</name></name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>cword</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_DATUM</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_CWORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* not A.B, so just process A */</comment>
				<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>plpgsql_parse_word</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
									   <argument><expr><name><name>core_yy</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name><name>aux1</name><operator>.</operator><name>lloc</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>wdatum</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_DATUM</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name><operator>.</operator><name>quoted</name></name> <operator>&amp;&amp;</operator>
						 <operator>(</operator><name>kw</name> <operator>=</operator> <call><name>ScanKeywordLookup</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name><operator>.</operator><name>ident</name></name></expr></argument>,
												 <argument><expr><name>unreserved_keywords</name></expr></argument>,
												 <argument><expr><name>num_unreserved_keywords</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name><name>kw</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name><name>kw</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_WORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* not A.B, so just process A */</comment>
			<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we are at start of statement, prefer unreserved keywords
			 * over variable names, unless the next token is assignment or
			 * '[', in which case prefer variable names.  (Note we need not
			 * consider '.' as the next token; that case was handled above,
			 * and we always prefer variable names in that case.)  If we are
			 * not at start of statement, always prefer variable names over
			 * unreserved keywords.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>AT_STMT_START</name><argument_list>(<argument><expr><name>plpgsql_yytoken</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><operator>(</operator><name>tok2</name> <operator>==</operator> <literal type="char">'='</literal> <operator>||</operator> <name>tok2</name> <operator>==</operator> <name>COLON_EQUALS</name> <operator>||</operator> <name>tok2</name> <operator>==</operator> <literal type="char">'['</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try for unreserved keyword, then for variable name */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>core_yy</name><operator>.</operator><name>scanbuf</name><index>[<expr><name><name>aux1</name><operator>.</operator><name>lloc</name></name></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator>
					<operator>(</operator><name>kw</name> <operator>=</operator> <call><name>ScanKeywordLookup</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
											<argument><expr><name>unreserved_keywords</name></expr></argument>,
											<argument><expr><name>num_unreserved_keywords</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name><name>kw</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name><name>kw</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>plpgsql_parse_word</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
											<argument><expr><name><name>core_yy</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name><name>aux1</name><operator>.</operator><name>lloc</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>wdatum</name></name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_DATUM</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_WORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* try for variable name, then for unreserved keyword */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>plpgsql_parse_word</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>,
									   <argument><expr><name><name>core_yy</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name><name>aux1</name><operator>.</operator><name>lloc</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>wdatum</name></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_DATUM</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name><operator>.</operator><name>quoted</name></name> <operator>&amp;&amp;</operator>
						 <operator>(</operator><name>kw</name> <operator>=</operator> <call><name>ScanKeywordLookup</name><argument_list>(<argument><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>word</name><operator>.</operator><name>ident</name></name></expr></argument>,
												 <argument><expr><name>unreserved_keywords</name></expr></argument>,
												 <argument><expr><name>num_unreserved_keywords</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>aux1</name><operator>.</operator><name>lval</name><operator>.</operator><name>keyword</name></name> <operator>=</operator> <name><name>kw</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name><name>kw</name><operator>-&gt;</operator><name>value</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>tok1</name> <operator>=</operator> <name>T_WORD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Not a potential plpgsql variable name, just return the data.
		 *
		 * Note that we also come through here if the grammar pushed back a
		 * T_DATUM, T_CWORD, T_WORD, or unreserved-keyword token returned by a
		 * previous lookup cycle; thus, pushbacks do not incur extra lookup
		 * work, since we'll never do the above code twice for the same token.
		 * This property also makes it safe to rely on the old value of
		 * plpgsql_yytoken in the is-this-start-of-statement test above.
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>plpgsql_yylval</name> <operator>=</operator> <name><name>aux1</name><operator>.</operator><name>lval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_yylloc</name> <operator>=</operator> <name><name>aux1</name><operator>.</operator><name>lloc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_yyleng</name> <operator>=</operator> <name><name>aux1</name><operator>.</operator><name>leng</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_yytoken</name> <operator>=</operator> <name>tok1</name></expr>;</expr_stmt>
	<return>return <expr><name>tok1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Internal yylex function.  This wraps the core lexer and adds one feature:
 * a token pushback stack.  We also make a couple of trivial single-token
 * translations from what the core lexer does to what we want, in particular
 * interfacing from the core_YYSTYPE to YYSTYPE union.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>internal_yylex</name><parameter_list>(<parameter><decl><type><name>TokenAuxData</name> <modifier>*</modifier></type><name>auxdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>yytext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_pushbacks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>num_pushbacks</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <name><name>pushback_token</name><index>[<expr><name>num_pushbacks</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>auxdata</name> <operator>=</operator> <name><name>pushback_auxdata</name><index>[<expr><name>num_pushbacks</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>core_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>auxdata</name><operator>-&gt;</operator><name>lval</name><operator>.</operator><name>core_yystype</name></name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><name><name>auxdata</name><operator>-&gt;</operator><name>lloc</name></name></expr></argument>,
						   <argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* remember the length of yytext before it gets changed */</comment>
		<expr_stmt><expr><name>yytext</name> <operator>=</operator> <name><name>core_yy</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name><name>auxdata</name><operator>-&gt;</operator><name>lloc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>auxdata</name><operator>-&gt;</operator><name>leng</name></name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check for &lt;&lt; &gt;&gt; and #, which the core considers operators */</comment>
		<if_stmt><if>if <condition>(<expr><name>token</name> <operator>==</operator> <name>Op</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>auxdata</name><operator>-&gt;</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"&lt;&lt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>token</name> <operator>=</operator> <name>LESS_LESS</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>auxdata</name><operator>-&gt;</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"&gt;&gt;"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>token</name> <operator>=</operator> <name>GREATER_GREATER</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>auxdata</name><operator>-&gt;</operator><name>lval</name><operator>.</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"#"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>token</name> <operator>=</operator> <literal type="char">'#'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/* The core returns PARAM as ival, but we treat it like IDENT */</comment>
		<if type="elseif">else if <condition>(<expr><name>token</name> <operator>==</operator> <name>PARAM</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>auxdata</name><operator>-&gt;</operator><name>lval</name><operator>.</operator><name>str</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>yytext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>token</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Push back a token to be re-read by next internal_yylex() call.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_back_token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>TokenAuxData</name> <modifier>*</modifier></type><name>auxdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>num_pushbacks</name> <operator>&gt;=</operator> <name>MAX_PUSHBACKS</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many tokens pushed back"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>pushback_token</name><index>[<expr><name>num_pushbacks</name></expr>]</index></name> <operator>=</operator> <name>token</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pushback_auxdata</name><index>[<expr><name>num_pushbacks</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>auxdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_pushbacks</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Push back a single token to be re-read by next plpgsql_yylex() call.
 *
 * NOTE: this does not cause yylval or yylloc to "back up".  Also, it
 * is not a good idea to push back a token code other than what you read.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_push_back_token</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>auxdata</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>auxdata</name><operator>.</operator><name>lval</name></name> <operator>=</operator> <name>plpgsql_yylval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>auxdata</name><operator>.</operator><name>lloc</name></name> <operator>=</operator> <name>plpgsql_yylloc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>auxdata</name><operator>.</operator><name>leng</name></name> <operator>=</operator> <name>plpgsql_yyleng</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>auxdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Tell whether a token is an unreserved keyword.
 *
 * (If it is, its lowercased form was returned as the token value, so we
 * do not need to offer that data here.)
 */</comment>
<function><type><name>bool</name></type>
<name>plpgsql_token_is_unreserved_keyword</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_unreserved_keywords</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>unreserved_keywords</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>==</operator> <name>token</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append the function text starting at startlocation and extending to
 * (not including) endlocation onto the existing contents of "buf".
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_append_source_text</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>startlocation</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endlocation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>startlocation</name> <operator>&lt;=</operator> <name>endlocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>scanorig</name> <operator>+</operator> <name>startlocation</name></expr></argument>,
						   <argument><expr><name>endlocation</name> <operator>-</operator> <name>startlocation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Peek one token ahead in the input stream.  Only the token code is
 * made available, not any of the auxiliary info such as location.
 *
 * NB: no variable or unreserved keyword lookup is performed here, they will
 * be returned as IDENT. Reserved keywords are resolved as usual.
 */</comment>
<function><type><name>int</name></type>
<name>plpgsql_peek</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tok1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux1</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tok1</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>tok1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Peek two tokens ahead in the input stream. The first token and its
 * location in the query are returned in *tok1_p and *tok1_loc, second token
 * and its location in *tok2_p and *tok2_loc.
 *
 * NB: no variable or unreserved keyword lookup is performed here, they will
 * be returned as IDENT. Reserved keywords are resolved as usual.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_peek2</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tok1_p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tok2_p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tok1_loc</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tok2_loc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>tok1</name></decl>,
				<decl><type ref="prev"/><name>tok2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TokenAuxData</name></type> <name>aux1</name></decl>,
				<decl><type ref="prev"/><name>aux2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tok1</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tok2</name> <operator>=</operator> <call><name>internal_yylex</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aux2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>tok1_p</name> <operator>=</operator> <name>tok1</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tok1_loc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tok1_loc</name> <operator>=</operator> <name><name>aux1</name><operator>.</operator><name>lloc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tok2_p</name> <operator>=</operator> <name>tok2</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tok2_loc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>tok2_loc</name> <operator>=</operator> <name><name>aux2</name><operator>.</operator><name>lloc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>push_back_token</name><argument_list>(<argument><expr><name>tok1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aux1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_scanner_errposition
 *		Report an error cursor position, if possible.
 *
 * This is expected to be used within an ereport() call.  The return value
 * is a dummy (always 0, in fact).
 *
 * Note that this can only be used for messages emitted during initial
 * parsing of a plpgsql function, since it requires the scanorig string
 * to still be available.
 */</comment>
<function><type><name>int</name></type>
<name>plpgsql_scanner_errposition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>scanorig</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* no-op if location is unknown */</comment>

	<comment type="block">/* Convert byte offset to character number */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>pg_mbstrlen_with_len</name><argument_list>(<argument><expr><name>scanorig</name></expr></argument>, <argument><expr><name>location</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* And pass it to the ereport mechanism */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>internalerrposition</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Also pass the function body string */</comment>
	<return>return <expr><call><name>internalerrquery</name><argument_list>(<argument><expr><name>scanorig</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * plpgsql_yyerror
 *		Report a lexer or grammar error.
 *
 * The message's cursor position refers to the current token (the one
 * last returned by plpgsql_yylex()).
 * This is OK for syntax error messages from the Bison parser, because Bison
 * parsers report error as soon as the first unparsable token is reached.
 * Beware of using yyerror for other purposes, as the cursor position might
 * be misleading!
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_yyerror</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>yytext</name> <init>= <expr><name><name>core_yy</name><operator>.</operator><name>scanbuf</name></name> <operator>+</operator> <name>plpgsql_yylloc</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>yytext</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is typically the translation of "syntax error" */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s at end of input"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>plpgsql_scanner_errposition</name><argument_list>(<argument><expr><name>plpgsql_yylloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we have done any lookahead then flex will have restored the
		 * character after the end-of-token.  Zap it again so that we report
		 * only the single token here.  This modifies scanbuf but we no longer
		 * care about that.
		 */</comment>
		<expr_stmt><expr><name><name>yytext</name><index>[<expr><name>plpgsql_yyleng</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: first %s is typically the translation of "syntax error" */</comment>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s at or near \"%s\""</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>yytext</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>plpgsql_scanner_errposition</name><argument_list>(<argument><expr><name>plpgsql_yylloc</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a location (a byte offset in the function source text),
 * return a line number.
 *
 * We expect that this is typically called for a sequence of increasing
 * location values, so optimize accordingly by tracking the endpoints
 * of the "current" line.
 */</comment>
<function><type><name>int</name></type>
<name>plpgsql_location_to_lineno</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>location</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>loc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>location</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>scanorig</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* garbage in, garbage out */</comment>
	<expr_stmt><expr><name>loc</name> <operator>=</operator> <name>scanorig</name> <operator>+</operator> <name>location</name></expr>;</expr_stmt>

	<comment type="block">/* be correct, but not fast, if input location goes backwards */</comment>
	<if_stmt><if>if <condition>(<expr><name>loc</name> <operator>&lt;</operator> <name>cur_line_start</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>location_lineno_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>cur_line_end</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>loc</name> <operator>&gt;</operator> <name>cur_line_end</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cur_line_start</name> <operator>=</operator> <name>cur_line_end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_line_num</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>cur_line_end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cur_line_start</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>cur_line_num</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* initialize or reset the state for plpgsql_location_to_lineno */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>location_lineno_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>cur_line_start</name> <operator>=</operator> <name>scanorig</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_line_num</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur_line_end</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>cur_line_start</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return the most recently computed lineno */</comment>
<function><type><name>int</name></type>
<name>plpgsql_latest_lineno</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>cur_line_num</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Called before any actual parsing is done
 *
 * Note: the passed "str" must remain valid until plpgsql_scanner_finish().
 * Although it is not fed directly to flex, we need the original string
 * to cite in error messages.
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_scanner_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Start up the core scanner */</comment>
	<expr_stmt><expr><name>yyscanner</name> <operator>=</operator> <call><name>scanner_init</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>core_yy</name></expr></argument>,
							 <argument><expr><name>reserved_keywords</name></expr></argument>, <argument><expr><name>num_reserved_keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * scanorig points to the original string, which unlike the scanner's
	 * scanbuf won't be modified on-the-fly by flex.  Notice that although
	 * yytext points into scanbuf, we rely on being able to apply locations
	 * (offsets from string start) to scanorig as well.
	 */</comment>
	<expr_stmt><expr><name>scanorig</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

	<comment type="block">/* Other setup */</comment>
	<expr_stmt><expr><name>plpgsql_IdentifierLookup</name> <operator>=</operator> <name>IDENTIFIER_LOOKUP_NORMAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plpgsql_yytoken</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_pushbacks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>location_lineno_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called after parsing is done to clean up after plpgsql_scanner_init()
 */</comment>
<function><type><name>void</name></type>
<name>plpgsql_scanner_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* release storage */</comment>
	<expr_stmt><expr><call><name>scanner_finish</name><argument_list>(<argument><expr><name>yyscanner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* avoid leaving any dangling pointers */</comment>
	<expr_stmt><expr><name>yyscanner</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>scanorig</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
