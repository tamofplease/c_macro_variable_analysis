<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/PolarDB-for-PostgreSQL/src/pl/plpython/plpy_exec.c"><comment type="block">/*
 * executing Python code
 *
 * src/pl/plpython/plpy_exec.c
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpython.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpy_exec.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpy_elog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpy_main.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpy_procedure.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"plpy_subxactobject.h"</cpp:file></cpp:include>


<comment type="block">/* saved state for a set-returning function */</comment>
<typedef>typedef <type><struct>struct <name>PLySRFState</name>
<block>{
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>			<comment type="block">/* Python iterator producing results */</comment>
	<decl_stmt><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>savedargs</name></decl>;</decl_stmt>	<comment type="block">/* function argument values */</comment>
	<decl_stmt><decl><type><name>MemoryContextCallback</name></type> <name>callback</name></decl>;</decl_stmt> <comment type="block">/* for releasing refcounts when done */</comment>
}</block></struct></type> <name>PLySRFState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type><name>PLy_function_build_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PLySavedArgs</name> <modifier>*</modifier></type><name>PLy_function_save_args</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PLy_function_restore_args</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>savedargs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PLy_function_drop_args</name><parameter_list>(<parameter><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>savedargs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PLy_global_args_push</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PLy_global_args_pop</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpython_srf_cleanup_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpython_return_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type><name>PLy_trigger_build_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>,
					   <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>HeapTuple</name></type> <name>PLy_modify_tuple</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>pltd</name></decl></parameter>,
				 <parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>otup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>plpython_trigger_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type><name>PLy_procedure_call</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kargs</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>vargs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>PLy_abort_open_subtransactions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>save_subxact_level</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* function subhandler */</comment>
<function><type><name>Datum</name></type>
<name>PLy_exec_function</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_setof</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>is_setof</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plrv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PLySRFState</name> <modifier>*</modifier><specifier>volatile</specifier></type> <name>srfstate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the function is called recursively, we must push outer-level
	 * arguments into the stack.  This must be immediately before the PG_TRY
	 * to ensure that the corresponding pop happens.
	 */</comment>
	<expr_stmt><expr><call><name>PLy_global_args_push</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_setof</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* First Call setup */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>srfstate</name> <operator>=</operator> <operator>(</operator><name>PLySRFState</name> <operator>*</operator><operator>)</operator>
					<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>,
										   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PLySRFState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Immediately register cleanup callback */</comment>
				<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>callback</name><operator>.</operator><name>func</name></name> <operator>=</operator> <name>plpython_srf_cleanup_callback</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>callback</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>srfstate</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextRegisterResetCallback</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name><name>srfstate</name><operator>-&gt;</operator><name>callback</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>srfstate</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Every call setup */</comment>
			<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>funcctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>srfstate</name> <operator>=</operator> <operator>(</operator><name>PLySRFState</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>srfstate</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>srfstate</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Non-SETOF function or first time for SETOF function: build
			 * args, then actually execute the function.
			 */</comment>
			<expr_stmt><expr><name>plargs</name> <operator>=</operator> <call><name>PLy_function_build_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plrv</name> <operator>=</operator> <call><name>PLy_procedure_call</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><name>plargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plrv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Second or later call for a SETOF function: restore arguments in
			 * globals dict to what they were when we left off.  We must do
			 * this in case multiple evaluations of the same SETOF function
			 * are interleaved.  It's a bit annoying, since the iterator may
			 * not look at the arguments at all, but we have no way to know
			 * that.  Fortunately this isn't terribly expensive.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PLy_function_restore_args</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> <comment type="block">/* deleted by restore_args */</comment>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If it returns a set, call the iterator to get the next return item.
		 * We stay in the SPI context while doing this, because PyIter_Next()
		 * calls back into Python code which might contain SPI calls.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_setof</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* first time -- do checks and setup */</comment>
				<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsi</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rsi</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsi</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
					<operator>(</operator><name><name>rsi</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_ValuePerCall</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported set function return mode"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"PL/Python set-returning functions only support returning one value per call."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>rsi</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_ValuePerCall</name></expr>;</expr_stmt>

				<comment type="block">/* Make iterator out of returned object */</comment>
				<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plrv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"returned object cannot be iterated"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"PL/Python set-returning functions must return an iterable object."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Fetch next from iterator */</comment>
			<expr_stmt><expr><name>plrv</name> <operator>=</operator> <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>plrv</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Iterator is exhausted or error happened */</comment>
				<decl_stmt><decl><type><name>bool</name></type>		<name>has_error</name> <init>= <expr><operator>(</operator><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>has_error</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>PLy_elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"error fetching next item from iterator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Pass a null through the data-returning steps below */</comment>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plrv</name> <operator>=</operator> <name>Py_None</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * This won't be last call, so save argument values.  We do
				 * this again each time in case the iterator is changing those
				 * values.
				 */</comment>
				<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name> <operator>=</operator> <call><name>PLy_function_save_args</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Disconnect from SPI manager and then create the return values datum
		 * (if the input function does a palloc for it this must not be
		 * allocated in the SPI memory context because SPI_finish would free
		 * it).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpython_return_error_callback</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * For a procedure or function declared to return void, the Python
		 * return value must be None. For void-returning functions, we also
		 * treat a None return value as a special "void datum" rather than
		 * NULL (as is the case for non-void-returning functions).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>typoid</name></name> <operator>==</operator> <name>VOIDOID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>plrv</name> <operator>!=</operator> <name>Py_None</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>is_procedure</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Python procedure did not return None"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Python function with return type \"void\" did not return None"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>plrv</name> <operator>==</operator> <name>Py_None</name> <operator>&amp;&amp;</operator>
				 <name>srfstate</name> <operator>&amp;&amp;</operator> <name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * In a SETOF function, the iteration-ending null isn't a real
			 * value; don't pass it through the input function, which might
			 * complain.
			 */</comment>
			<expr_stmt><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Normal conversion of result */</comment>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>PLy_output_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>plrv</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Pop old arguments from the stack if they were pushed above */</comment>
		<expr_stmt><expr><call><name>PLy_global_args_pop</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If there was an error within a SRF, the iterator might not have
		 * been exhausted yet.  Clear it so the next invocation of the
		 * function will start the iteration again.  (This code is probably
		 * unnecessary now; plpython_srf_cleanup_callback should take care of
		 * cleanup.  But it doesn't hurt anything to do it here.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>srfstate</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<comment type="block">/* And drop any saved args; we won't need them */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PLy_function_drop_args</name><argument_list>(<argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<comment type="block">/* Pop old arguments from the stack if they were pushed above */</comment>
	<expr_stmt><expr><call><name>PLy_global_args_pop</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>srfstate</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We're in a SRF, exit appropriately */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Iterator exhausted, so we're done */</comment>
			<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>isnull</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SRF_RETURN_NEXT_NULL</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Plain function, just return the Datum value (possibly null) */</comment>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* trigger subhandler
 *
 * the python function is expected to return Py_None if the tuple is
 * acceptable and unmodified.  Otherwise it should return a PyString
 * object who's value is SKIP, or MODIFY.  SKIP means don't perform
 * this action.  MODIFY means the tuple has been modified, so update
 * tuple and perform action.  SKIP and MODIFY assume the trigger fires
 * BEFORE the event and is ROW level.  postgres expects the function
 * to take no arguments and return an argument of type trigger.
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>PLy_exec_trigger</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plargs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plrv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rel_descr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tdata</name> <operator>=</operator> <operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Input/output conversion for trigger tuples.  We use the result and
	 * result_in fields to store the tuple conversion info.  We do this over
	 * again on each call to cover the possibility that the relation's tupdesc
	 * changed since the trigger was last called.  The PLy_xxx_setup_func
	 * calls should only happen once, but PLy_input_setup_tuple and
	 * PLy_output_setup_tuple are responsible for not doing repetitive work.
	 */</comment>
	<expr_stmt><expr><name>rel_descr</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>typoid</name></name> <operator>!=</operator> <name><name>rel_descr</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PLy_output_setup_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
							  <argument><expr><name><name>rel_descr</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>,
							  <argument><expr><name><name>rel_descr</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>,
							  <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>result_in</name><operator>.</operator><name>typoid</name></name> <operator>!=</operator> <name><name>rel_descr</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PLy_input_setup_func</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result_in</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
							 <argument><expr><name><name>rel_descr</name><operator>-&gt;</operator><name>tdtypeid</name></name></expr></argument>,
							 <argument><expr><name><name>rel_descr</name><operator>-&gt;</operator><name>tdtypmod</name></name></expr></argument>,
							 <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>PLy_output_setup_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>rel_descr</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PLy_input_setup_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result_in</name></name></expr></argument>, <argument><expr><name>rel_descr</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name>			<name>rc</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>SPI_register_trigger_data</name><argument_list>(<argument><expr><name>tdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rc</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>plargs</name> <operator>=</operator> <call><name>PLy_trigger_build_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plrv</name> <operator>=</operator> <call><name>PLy_procedure_call</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="string">"TD"</literal></expr></argument>, <argument><expr><name>plargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>plrv</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Disconnect from SPI manager
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * return of None means we're happy with the tuple
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>plrv</name> <operator>!=</operator> <name>Py_None</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srv</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>srv</name> <operator>=</operator> <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>srv</name> <operator>=</operator> <call><name>PLyUnicode_AsString</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected return value from trigger procedure"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected None or a string."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>srv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>srv</name></expr></argument>, <argument><expr><literal type="string">"SKIP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>srv</name></expr></argument>, <argument><expr><literal type="string">"MODIFY"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
					<call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>PLy_modify_tuple</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>plargs</name></expr></argument>, <argument><expr><name>tdata</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"PL/Python trigger function returned \"MODIFY\" in a DELETE trigger -- ignored"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>srv</name></expr></argument>, <argument><expr><literal type="string">"OK"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * accept "OK" as an alternative to None; otherwise, raise an
				 * error
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_EXCEPTION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected return value from trigger procedure"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected None, \"OK\", \"SKIP\", or \"MODIFY\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plrv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* helper functions for Python code execution */</comment>

<function><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type>
<name>PLy_function_build_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>PyList_New</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>nargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>args</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PLyDatumToOb</name> <modifier>*</modifier></type><name>arginfo</name> <init>= <expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fcinfo</name><operator>-&gt;</operator><name>argnull</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>PLy_input_convert</name><argument_list>(<argument><expr><name>arginfo</name></expr></argument>, <argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>arg</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>Py_None</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PLy_elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PyList_SetItem() failed, while setting up arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name></name> <operator>&amp;&amp;</operator> <name><name>proc</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator>
				<call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>PLy_elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"PyDict_SetItemString() failed, while setting up arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Set up output conversion for functions returning RECORD */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>typoid</name></name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>desc</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>get_call_result_type</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>desc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TYPEFUNC_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function returning record called in context "</literal>
								<literal type="string">"that cannot accept type record"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* cache the output conversion functions */</comment>
			<expr_stmt><expr><call><name>PLy_output_setup_record</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>args</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Construct a PLySavedArgs struct representing the current values of the
 * procedure's arguments in its globals dict.  This can be used to restore
 * those values when exiting a recursive call level or returning control to a
 * set-returning function.
 *
 * This would not be necessary except for an ancient decision to make args
 * available via the proc's globals :-( ... but we're stuck with that now.
 */</comment>
<function><type><specifier>static</specifier> <name>PLySavedArgs</name> <modifier>*</modifier></type>
<name>PLy_function_save_args</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<comment type="block">/* saved args are always allocated in procedure's context */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>PLySavedArgs</name> <operator>*</operator><operator>)</operator>
		<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>mcxt</name></name></expr></argument>,
							   <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PLySavedArgs</name></expr></argument>, <argument><expr><name>namedargs</name></expr></argument>)</argument_list></call> <operator>+</operator>
							   <name><name>proc</name><operator>-&gt;</operator><name>nargs</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>nargs</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</expr_stmt>

	<comment type="block">/* Fetch the "args" list */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>args</name></name> <operator>=</operator> <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fetch all the named arguments */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>result</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>namedargs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>,
															<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>namedargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Restore procedure's arguments from a PLySavedArgs struct,
 * then free the struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PLy_function_restore_args</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>savedargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Restore named arguments into their slots in the globals dict */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>savedargs</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>savedargs</name><operator>-&gt;</operator><name>namedargs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>argnames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>savedargs</name><operator>-&gt;</operator><name>namedargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>savedargs</name><operator>-&gt;</operator><name>namedargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore the "args" object, too */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>savedargs</name><operator>-&gt;</operator><name>args</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><name><name>savedargs</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>savedargs</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And free the PLySavedArgs struct */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>savedargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Free a PLySavedArgs struct without restoring the values.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PLy_function_drop_args</name><parameter_list>(<parameter><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>savedargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Drop references for named args */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>savedargs</name><operator>-&gt;</operator><name>nargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>savedargs</name><operator>-&gt;</operator><name>namedargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Drop ref to the "args" object, too */</comment>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>savedargs</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* And free the PLySavedArgs struct */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>savedargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Save away any existing arguments for the given procedure, so that we can
 * install new values for a recursive call.  This should be invoked before
 * doing PLy_function_build_args().
 *
 * NB: caller must ensure that PLy_global_args_pop gets invoked once, and
 * only once, per successful completion of PLy_global_args_push.  Otherwise
 * we'll end up out-of-sync between the actual call stack and the contents
 * of proc-&gt;argstack.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PLy_global_args_push</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We only need to push if we are already inside some active call */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>calldepth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>

		<comment type="block">/* Build a struct containing current argument values */</comment>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>PLy_function_save_args</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Push the saved argument values into the procedure's stack.  Once we
		 * modify either proc-&gt;argstack or proc-&gt;calldepth, we had better
		 * return without the possibility of error.
		 */</comment>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>argstack</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>argstack</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>calldepth</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Pop old arguments when exiting a recursive call.
 *
 * Note: the idea here is to adjust the proc's callstack state before doing
 * anything that could possibly fail.  In event of any error, we want the
 * callstack to look like we've done the pop.  Leaking a bit of memory is
 * tolerable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PLy_global_args_pop</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>calldepth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We only need to pop if we were already inside some active call */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>calldepth</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLySavedArgs</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>argstack</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Pop the callstack */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>argstack</name></name> <operator>=</operator> <name><name>ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>calldepth</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/* Restore argument values, then free ptr */</comment>
		<expr_stmt><expr><call><name>PLy_function_restore_args</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Exiting call depth 1 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>argstack</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>calldepth</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * We used to delete the named arguments (but not "args") from the
		 * proc's globals dict when exiting the outermost call level for a
		 * function.  This seems rather pointless though: nothing can see the
		 * dict until the function is called again, at which time we'll
		 * overwrite those dict entries.  So don't bother with that.
		 */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Memory context deletion callback for cleaning up a PLySRFState.
 * We need this in case execution of the SRF is terminated early,
 * due to error or the caller simply not running it to completion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpython_srf_cleanup_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLySRFState</name> <modifier>*</modifier></type><name>srfstate</name> <init>= <expr><operator>(</operator><name>PLySRFState</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Release refcount on the iter, if we still have one */</comment>
	<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>iter</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<comment type="block">/* And drop any saved args; we won't need them */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PLy_function_drop_args</name><argument_list>(<argument><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>srfstate</name><operator>-&gt;</operator><name>savedargs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpython_return_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLyExecutionContext</name> <modifier>*</modifier></type><name>exec_ctx</name> <init>= <expr><call><name>PLy_current_execution_context</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>curr_proc</name></name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>exec_ctx</name><operator>-&gt;</operator><name>curr_proc</name><operator>-&gt;</operator><name>is_procedure</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while creating return value"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type>
<name>PLy_trigger_build_args</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name> <modifier>*</modifier></type><name>rv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rel_descr</name> <init>= <expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier></type><name>pltname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pltevent</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pltwhen</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pltlevel</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pltrelid</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>plttablename</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>plttableschema</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier></type><name>pltargs</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pytnew</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>pytold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>pltdata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>stroid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>pltdata</name> <operator>=</operator> <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pltdata</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>pltname</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>pltname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stroid</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>oidout</name></expr></argument>,
													 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pltrelid</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"relid"</literal></expr></argument>, <argument><expr><name>pltrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stroid</name> <operator>=</operator> <call><name>SPI_getrelname</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plttablename</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"table_name"</literal></expr></argument>, <argument><expr><name>plttablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plttablename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>stroid</name> <operator>=</operator> <call><name>SPI_getnspname</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>plttableschema</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"table_schema"</literal></expr></argument>, <argument><expr><name>plttableschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plttableschema</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stroid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BEFORE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pltwhen</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"BEFORE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pltwhen</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"AFTER"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_INSTEAD</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pltwhen</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"INSTEAD OF"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized WHEN tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pltwhen</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"when"</literal></expr></argument>, <argument><expr><name>pltwhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltwhen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pltlevel</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"ROW"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"level"</literal></expr></argument>, <argument><expr><name>pltlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pytnew</name> <operator>=</operator> <call><name>PLy_input_from_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result_in</name></name></expr></argument>,
											  <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
											  <argument><expr><name>rel_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>pytnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pytnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rv</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pytold</name> <operator>=</operator> <call><name>PLy_input_from_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result_in</name></name></expr></argument>,
											  <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
											  <argument><expr><name>rel_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>pytold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pytold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rv</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>pytnew</name> <operator>=</operator> <call><name>PLy_input_from_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result_in</name></name></expr></argument>,
											  <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr></argument>,
											  <argument><expr><name>rel_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>pytnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pytnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pytold</name> <operator>=</operator> <call><name>PLy_input_from_tuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result_in</name></name></expr></argument>,
											  <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>,
											  <argument><expr><name>rel_descr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>pytold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pytold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>rv</name> <operator>=</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OP tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"event"</literal></expr></argument>, <argument><expr><name>pltevent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltevent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_FOR_STATEMENT</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pltlevel</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"STATEMENT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"level"</literal></expr></argument>, <argument><expr><name>pltlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"old"</literal></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"INSERT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"DELETE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"UPDATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_TRUNCATE</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><literal type="string">"TRUNCATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized OP tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>pltevent</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"event"</literal></expr></argument>, <argument><expr><name>pltevent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltevent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized LEVEL tg_event: %u"</literal></expr></argument>, <argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * all strings...
			 */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier></type><name>pltarg</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>pltargs</name> <operator>=</operator> <call><name>PyList_New</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pltargs</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>pltarg</name> <operator>=</operator> <call><name>PyString_FromString</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * stolen, don't Py_DECREF
				 */</comment>
				<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>pltargs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pltarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>pltargs</name> <operator>=</operator> <name>Py_None</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>, <argument><expr><name>pltargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pltargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pltdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>pltdata</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Apply changes requested by a MODIFY return from a trigger function.
 */</comment>
<function><type><specifier>static</specifier> <name>HeapTuple</name></type>
<name>PLy_modify_tuple</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>pltd</name></decl></parameter>, <parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>tdata</name></decl></parameter>,
				 <parameter><decl><type><name>HeapTuple</name></type> <name>otup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>rtup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plntup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>plval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>modvalues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>modnulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier><specifier>volatile</specifier></type> <name>modrepls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name></type> <name>plerrcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>callback</name></name> <operator>=</operator> <name>plpython_trigger_error_callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>plerrcontext</name><operator>.</operator><name>previous</name></name> <operator>=</operator> <name>error_context_stack</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <operator>&amp;</operator><name>plerrcontext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>plntup</name> <operator>=</operator> <name>plkeys</name> <operator>=</operator> <name>plval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>modvalues</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>modnulls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>modrepls</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>,
					<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plntup</name> <operator>=</operator> <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>pltd</name></expr></argument>, <argument><expr><literal type="string">"new"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TD[\"new\"] deleted, cannot modify row"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>plntup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>plntup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TD[\"new\"] is not a dictionary"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>plkeys</name> <operator>=</operator> <call><name>PyDict_Keys</name><argument_list>(<argument><expr><name>plntup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <call><name>PyList_Size</name><argument_list>(<argument><expr><name>plkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>tdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>modvalues</name> <operator>=</operator> <operator>(</operator><name>Datum</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>modnulls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>modrepls</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nkeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier></type><name>platt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>plattstr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attn</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PLyObToDatum</name> <modifier>*</modifier></type><name>att</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>platt</name> <operator>=</operator> <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>plkeys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>platt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>plattstr</name> <operator>=</operator> <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>platt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>platt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>plattstr</name> <operator>=</operator> <call><name>PLyUnicode_AsString</name><argument_list>(<argument><expr><name>platt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"TD[\"new\"] dictionary key at ordinal position %d is not a string"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>plattstr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><name>attn</name> <operator>=</operator> <call><name>SPI_fnumber</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>plattstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>==</operator> <name>SPI_ERROR_NOATTRIBUTE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key \"%s\" found in TD[\"new\"] does not exist as a column in the triggering row"</literal></expr></argument>,
								<argument><expr><name>plattstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>attn</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set system attribute \"%s\""</literal></expr></argument>,
								<argument><expr><name>plattstr</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>plval</name> <operator>=</operator> <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>plntup</name></expr></argument>, <argument><expr><name>platt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>plval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"Python interpreter is probably corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>plval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We assume proc-&gt;result is set up to convert tuples properly */</comment>
			<expr_stmt><expr><name>att</name> <operator>=</operator> <operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>result</name><operator>.</operator><name>u</name><operator>.</operator><name>tuple</name><operator>.</operator><name>atts</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>modvalues</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PLy_output_convert</name><argument_list>(<argument><expr><name>att</name></expr></argument>,
													 <argument><expr><name>plval</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>modnulls</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>modrepls</name><index>[<expr><name>attn</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>plval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>rtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>otup</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>modvalues</name></expr></argument>, <argument><expr><name>modnulls</name></expr></argument>, <argument><expr><name>modrepls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plntup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>plval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>modvalues</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>modnulls</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>modrepls</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modrepls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plntup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>plkeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modvalues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>modrepls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name><name>plerrcontext</name><operator>.</operator><name>previous</name></name></expr>;</expr_stmt>

	<return>return <expr><name>rtup</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>plpython_trigger_error_callback</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PLyExecutionContext</name> <modifier>*</modifier></type><name>exec_ctx</name> <init>= <expr><call><name>PLy_current_execution_context</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>exec_ctx</name><operator>-&gt;</operator><name>curr_proc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"while modifying trigger row"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* execute Python code, propagate Python errors to the backend */</comment>
<function><type><specifier>static</specifier> <name>PyObject</name> <modifier>*</modifier></type>
<name>PLy_procedure_call</name><parameter_list>(<parameter><decl><type><name>PLyProcedure</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kargs</name></decl></parameter>, <parameter><decl><type><name>PyObject</name> <modifier>*</modifier></type><name>vargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PyObject</name>   <modifier>*</modifier></type><name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name> <specifier>volatile</specifier></type> <name>save_subxact_level</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>explicit_subtransactions</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name>kargs</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PY_VERSION_HEX</name> <operator>&gt;=</operator> <literal type="number">0x03020000</literal></expr></cpp:if>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,
							 <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr><operator>(</operator><name>PyCodeObject</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,
							 <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * Since plpy will only let you close subtransactions that you
		 * started, you cannot *unnest* subtransactions, only *nest* them
		 * without closing.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>explicit_subtransactions</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>save_subxact_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PLy_abort_open_subtransactions</name><argument_list>(<argument><expr><name>save_subxact_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PLy_abort_open_subtransactions</name><argument_list>(<argument><expr><name>save_subxact_level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the Python code returned an error, propagate it */</comment>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PLy_elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Abort lingering subtransactions that have been explicitly started
 * by plpy.subtransaction().start() and not properly closed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>PLy_abort_open_subtransactions</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>save_subxact_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>save_subxact_level</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>explicit_subtransactions</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>save_subxact_level</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PLySubtransactionData</name> <modifier>*</modifier></type><name>subtransactiondata</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>explicit_subtransactions</name> <operator>!=</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"forcibly aborting a subtransaction that has not been exited"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>RollbackAndReleaseCurrentSubTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>subtransactiondata</name> <operator>=</operator> <operator>(</operator><name>PLySubtransactionData</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>explicit_subtransactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>explicit_subtransactions</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>explicit_subtransactions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>subtransactiondata</name><operator>-&gt;</operator><name>oldcontext</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>subtransactiondata</name><operator>-&gt;</operator><name>oldowner</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>subtransactiondata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>
</unit>
