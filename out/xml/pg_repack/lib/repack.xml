<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pg_repack/lib/repack.c"><comment type="block">/*
 * pg_repack: lib/repack.c
 *
 * Portions Copyright (c) 2008-2011, NIPPON TELEGRAPH AND TELEPHONE CORPORATION
 * Portions Copyright (c) 2011, Itagaki Takahiro
 * Portions Copyright (c) 2012-2020, The Reorg Development Team
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>

<comment type="block">/*
 * heap_open/heap_close was moved to table_open/table_close in 12.0
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * utils/rel.h no longer includes pg_am.h as of 9.6, so need to include
 * it explicitly.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * catalog/pg_foo_fn.h headers was merged back into pg_foo.h headers
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits_fn.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgut/pgut-spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgut/pgut-be.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>

<comment type="block">/* builtins.h was reorganized for 9.5, so now we need this header */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90500</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>PG_MODULE_MAGIC</name></expr>;</expr_stmt>

<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_version</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_trigger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_apply</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_get_order_by</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_indexdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_swap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_drop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_disable_autovacuum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_index_swap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name> <name>PGUT_EXPORT</name></type> <name>repack_get_table_and_inheritors</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_trigger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_apply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_get_order_by</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_indexdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_disable_autovacuum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_index_swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>repack_get_table_and_inheritors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type>	<name>repack_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>repack_prepare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_quoted_relname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_quoted_nspname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>swap_heap_or_index_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>r2</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>copy_tuple</name><parameter_list>(<parameter><type><name>tuple</name></type></parameter>, <parameter><type><name>desc</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>PointerGetDatum(SPI_returntuple((tuple), (desc)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IsToken</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(IS_HIGHBIT_SET((c)) || isalnum((unsigned char) (c)) || (c) == '_')</cpp:value></cpp:define>

<comment type="block">/* check access authority */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>must_be_superuser</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"must be superuser to use %s function"</literal></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* The API of RenameRelationInternal() was changed in 9.2.
 * Use the RENAME_REL macro for compatibility across versions.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RENAME_REL</name><parameter_list>(<parameter><type><name>relid</name></type></parameter>, <parameter><type><name>newrelname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RenameRelationInternal(relid, newrelname, true);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RENAME_REL</name><parameter_list>(<parameter><type><name>relid</name></type></parameter>, <parameter><type><name>newrelname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RenameRelationInternal(relid, newrelname, true, false);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<comment type="block">/*
 * is_index flag was added in 12.0, prefer separate macro for relation and index
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">120000</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RENAME_INDEX</name><parameter_list>(<parameter><type><name>relid</name></type></parameter>, <parameter><type><name>newrelname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RENAME_REL(relid, newrelname);</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RENAME_INDEX</name><parameter_list>(<parameter><type><name>relid</name></type></parameter>, <parameter><type><name>newrelname</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>RenameRelationInternal(relid, newrelname, true, true);</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REPACK_VERSION</name></cpp:ifdef>
<comment type="block">/* macro trick to stringify a macro expansion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xstr</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str(s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#s</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIBRARY_VERSION</name></cpp:macro> <cpp:value>xstr(REPACK_VERSION)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIBRARY_VERSION</name></cpp:macro> <cpp:value>"unknown"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>Datum</name></type>
<name>repack_version</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"pg_repack "</literal> <name>LIBRARY_VERSION</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_trigger(PG_FUNCTION_ARGS)
 * @brief   Insert a operation log into log-table.
 *
 * repack_trigger(sql)
 *
 * @param	sql	SQL to insert a operation log into log-table.
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_trigger</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerData</name>	   <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>			<name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name><name>argtypes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>sql</name></decl>;</decl_stmt>

	<comment type="block">/* authority check */</comment>
	<expr_stmt><expr><call><name>must_be_superuser</name><argument_list>(<argument><expr><literal type="string">"repack_trigger"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* make sure it's called as a trigger at all */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgnargs</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"repack_trigger: invalid trigger call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* retrieve parameters */</comment>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name><operator>-&gt;</operator><name>tgargs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>

	<comment type="block">/* connect to SPI manager */</comment>
	<expr_stmt><expr><call><name>repack_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* INSERT: (NULL, newtup) */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>copy_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* DELETE: (oldtup, NULL) */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>copy_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* UPDATE: (oldtup, newtup) */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newtuple</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>copy_tuple</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigtuple</name></name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>copy_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* INSERT INTO repack.log VALUES ($1, $2) */</comment>
	<expr_stmt><expr><call><name>execute_with_args</name><argument_list>(<argument><expr><name>SPI_OK_INSERT</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_apply(PG_FUNCTION_ARGS)
 * @brief   Apply operations in log table into temp table.
 *
 * repack_apply(sql_peek, sql_insert, sql_delete, sql_update, sql_pop,  count)
 *
 * @param	sql_peek	SQL to pop tuple from log table.
 * @param	sql_insert	SQL to insert into temp table.
 * @param	sql_delete	SQL to delete from temp table.
 * @param	sql_update	SQL to update temp table.
 * @param	sql_pop	SQL to bulk-delete tuples from log table.
 * @param	count		Max number of operations, or no count iff &lt;=0.
 * @retval				Number of performed operations.
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_apply</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_PEEK_COUNT</name></cpp:macro>	<cpp:value>1000</cpp:value></cpp:define>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_peek</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_insert</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_delete</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sql_update</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* sql_pop, the fourth arg, will be used in the loop below */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>count</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>		<name>plan_peek</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>		<name>plan_insert</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>		<name>plan_delete</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>		<name>plan_update</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>			<name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name><name>argtypes_peek</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>INT4OID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>			<name><name>values_peek</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type>			<name><name>nulls_peek</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>		<name>sql_pop</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* authority check */</comment>
	<expr_stmt><expr><call><name>must_be_superuser</name><argument_list>(<argument><expr><literal type="string">"repack_apply"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to SPI manager */</comment>
	<expr_stmt><expr><call><name>repack_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* peek tuple in log */</comment>
	<expr_stmt><expr><name>plan_peek</name> <operator>=</operator> <call><name>repack_prepare</name><argument_list>(<argument><expr><name>sql_peek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes_peek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>				<name>ntuples</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SPITupleTable</name>  <modifier>*</modifier></type><name>tuptable</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>desc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>				<name><name>argtypes</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* id, pk, row */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>			<name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* id, pk, row */</comment>
		<decl_stmt><decl><type><name>bool</name></type>			<name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* id, pk, row */</comment>

		<comment type="block">/* peek tuple in log */</comment>
		<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values_peek</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>DEFAULT_PEEK_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values_peek</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>count</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>DEFAULT_PEEK_COUNT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>execute_plan</name><argument_list>(<argument><expr><name>SPI_OK_SELECT</name></expr></argument>, <argument><expr><name>plan_peek</name></expr></argument>, <argument><expr><name>values_peek</name></expr></argument>, <argument><expr><name>nulls_peek</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* copy tuptable because we will call other sqls. */</comment>
		<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tuptable</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* id */</comment>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* pk */</comment>
		<expr_stmt><expr><name><name>argtypes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* row */</comment>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_pop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_pop</name></expr></argument>, <argument><expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntuples</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>n</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pkid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>pkid</name> <operator>=</operator> <call><name>SPI_getvalue</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pkid</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* INSERT */</comment>
				<if_stmt><if>if <condition>(<expr><name>plan_insert</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>plan_insert</name> <operator>=</operator> <call><name>repack_prepare</name><argument_list>(<argument><expr><name>sql_insert</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argtypes</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>execute_plan</name><argument_list>(<argument><expr><name>SPI_OK_INSERT</name></expr></argument>, <argument><expr><name>plan_insert</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"n"</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* DELETE */</comment>
				<if_stmt><if>if <condition>(<expr><name>plan_delete</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>plan_delete</name> <operator>=</operator> <call><name>repack_prepare</name><argument_list>(<argument><expr><name>sql_delete</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>execute_plan</name><argument_list>(<argument><expr><name>SPI_OK_DELETE</name></expr></argument>, <argument><expr><name>plan_delete</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"n"</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* UPDATE */</comment>
				<if_stmt><if>if <condition>(<expr><name>plan_update</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>plan_update</name> <operator>=</operator> <call><name>repack_prepare</name><argument_list>(<argument><expr><name>sql_update</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>execute_plan</name><argument_list>(<argument><expr><name>SPI_OK_UPDATE</name></expr></argument>, <argument><expr><name>plan_update</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"n"</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Add the primary key ID of each row from the log
			 * table we have processed so far to this
			 * DELETE ... IN (...) query string, so we
			 * can delete all the rows we have processed at-once.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_pop</name></expr></argument>, <argument><expr><name>pkid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_pop</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>, <argument><expr><name>pkid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>pkid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<comment type="block">/* i must be &gt; 0 (and hence we must have some rows to delete)
		 * since SPI_processed &gt; 0
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_pop</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Bulk delete of processed rows from the log table */</comment>
		<expr_stmt><expr><call><name>execute</name><argument_list>(<argument><expr><name>SPI_OK_DELETE</name></expr></argument>, <argument><expr><name><name>sql_pop</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parsed CREATE INDEX statement. You can rebuild sql using
 * sprintf(buf, "%s %s ON %s USING %s (%s)%s",
 *		create, index, table type, columns, options)
 */</comment>
<typedef>typedef <type><struct>struct <name>IndexDef</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>create</name></decl>;</decl_stmt>	<comment type="block">/* CREATE INDEX or CREATE UNIQUE INDEX */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>	<comment type="block">/* index name including schema */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>	<comment type="block">/* table name including schema */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>		<comment type="block">/* btree, hash, gist or gin */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>columns</name></decl>;</decl_stmt>	<comment type="block">/* column definition */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>options</name></decl>;</decl_stmt>	<comment type="block">/* options after columns, before TABLESPACE (e.g. COLLATE) */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tablespace</name></decl>;</decl_stmt> <comment type="block">/* tablespace if specified */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>where</name></decl>;</decl_stmt>	<comment type="block">/* WHERE content if specified */</comment>
}</block></struct></type> <name>IndexDef</name>;</typedef>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_relation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>nsp</name> <init>= <expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>strver</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ver</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table name not found for OID %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the version of the running server (PG_VERSION_NUM would return
	 * the version we compiled the extension with) */</comment>
	<expr_stmt><expr><name>strver</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><literal type="string">"server_version_num"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">90600</literal></expr></cpp:if>
		, <argument><expr><name>false</name></expr></argument>	    <comment type="block">/* missing_ok */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ver</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><name>strver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Relation names given by PostgreSQL core are always
	 * qualified since some minor releases. Note that this change
	 * wasn't introduced in PostgreSQL 9.2 and 9.1 releases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">100000</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">100003</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">90600</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">90608</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">90500</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">90512</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">90400</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">90417</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">90300</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">90322</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">90200</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">90300</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>ver</name> <operator>&gt;=</operator> <literal type="number">90100</literal> <operator>&amp;&amp;</operator> <name>ver</name> <operator>&lt;</operator> <literal type="number">90200</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Qualify the name if not visible in search path */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsVisible</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Always qualify the name */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nsp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nspname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>, <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>parse_error</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected index definition: %s"</literal></expr></argument>, <argument><expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_const</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>arg1</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>arg1</name></expr></argument>, <argument><expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg1</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>arg2</name> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>arg2</name></expr></argument>, <argument><expr><operator>(</operator><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>arg2</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>sql</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>sql</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* error */</comment>
	<return>return <expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_until_const</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>	<name>len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pos</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>pos</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* error */</comment>
	<return>return <expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_ident</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><operator>*</operator><name>sql</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sql</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sql</name><operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'"'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>end</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<return>return <expr><name>end</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>	<comment type="block">/* escaped quote ("") */</comment>
				<expr_stmt><expr><name>sql</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<while>while <condition>(<expr><operator>*</operator><name>sql</name> <operator>&amp;&amp;</operator> <call><name>IsToken</name><argument_list>(<argument><expr><operator>*</operator><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><operator>*</operator><name>sql</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name>sql</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* error */</comment>
	<return>return <expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Skip until 'end' character found. The 'end' character is replaced with \0.
 * Returns the next character of the 'end', or NULL if 'end' is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_until</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	<name>instr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>nopen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>sql</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>nopen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>instr</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>sql</name> <operator>!=</operator> <name>end</name><operator>)</operator></expr>;</condition> <incr><expr><name>sql</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>instr</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>instr</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>sql</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>instr</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>sql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>instr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>sql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sql</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* next char is always string */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>sql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><literal type="char">'('</literal></expr>:</case>
					<expr_stmt><expr><name>nopen</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">')'</literal></expr>:</case>
					<expr_stmt><expr><name>nopen</name><operator>--</operator></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><literal type="char">'\''</literal></expr>:</case>
				<case>case <expr><literal type="char">'"'</literal></expr>:</case>
					<expr_stmt><expr><name>instr</name> <operator>=</operator> <name><name>sql</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>nopen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>instr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sql</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>sql</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<return>return <expr><name>sql</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* error */</comment>
	<return>return <expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_indexdef</name><parameter_list>(<parameter><decl><type><name>IndexDef</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sql</name> <init>= <expr><call><name>pg_get_indexdef_string</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>idxname</name> <init>= <expr><call><name>get_quoted_relname</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tblname</name> <init>= <expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>limit</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* CREATE [UNIQUE] INDEX */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>create</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"CREATE INDEX"</literal></expr></argument>, <argument><expr><literal type="string">"CREATE UNIQUE INDEX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* index */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>idxname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ON */</comment>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"ON"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* table */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><name>tblname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* USING */</comment>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"USING"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* type */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_ident</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* (columns) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sql</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>sql</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>columns</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sql</name> <operator>=</operator> <call><name>skip_until</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>parse_error</name><argument_list>(<argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* options */</comment>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Is there a tablespace? Note that apparently there is never, but
	 * if there was one it would appear here. */</comment>
	<if_stmt><if>if <condition>(<expr><name>sql</name> <operator>&lt;</operator> <name>limit</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_until_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"TABLESPACE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespace</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_ident</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Note: assuming WHERE is the only clause allowed after TABLESPACE */</comment>
	<if_stmt><if>if <condition>(<expr><name>sql</name> <operator>&lt;</operator> <name>limit</name> <operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sql</name> <operator>=</operator> <call><name>skip_until_const</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"WHERE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>stmt</name><operator>-&gt;</operator><name>where</name></name> <operator>=</operator> <name>sql</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.create  = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>create</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.index   = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.table   = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.type    = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.columns = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>columns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.options = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.tspace  = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>tablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"indexdef.where   = %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>where</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse the trailing ... [ COLLATE X ] [ DESC ] [ NULLS { FIRST | LAST } ] from an index
 * definition column.
 * Returned values point to token. \0's are inserted to separate parsed parts.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_indexdef_col</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>token</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>desc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>collate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* easier to walk backwards than to parse quotes and escapes... */</comment>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <operator>(</operator><name>pos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">" NULLS FIRST"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nulls</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pos</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>NULL</name> <operator>!=</operator> <operator>(</operator><name>pos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">" NULLS LAST"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>nulls</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pos</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <operator>(</operator><name>pos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">" DESC"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>desc</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pos</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <operator>(</operator><name>pos</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="string">" COLLATE "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>collate</name> <operator>=</operator> <name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>pos</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_get_order_by(PG_FUNCTION_ARGS)
 * @brief   Get key definition of the index.
 *
 * repack_get_order_by(index, table)
 *
 * @param	index	Oid of target index.
 * @param	table	Oid of table of the index.
 * @retval			Create index DDL for temp table.
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_get_order_by</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>index</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>table</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexDef</name></type>		<name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>		<name>indexRel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>nattr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>parse_indexdef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * FIXME: this is very unreliable implementation but I don't want to
	 * re-implement customized versions of pg_get_indexdef_string...
	 */</comment>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>nattr</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>next</name> <operator>=</operator> <name><name>stmt</name><operator>.</operator><name>columns</name></name></expr>;</init> <condition><expr><name>next</name></expr>;</condition> <incr><expr><name>nattr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opcname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>coldesc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colnulls</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>colcollate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>token</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>token</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>token</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>skip_until</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>parse_indexdef_col</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>coldesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colnulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>opcname</name> <operator>=</operator> <call><name>skip_until</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>colcollate</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>colcollate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>coldesc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>coldesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>opcname</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* lookup default operator name from operator class */</comment>

			<decl_stmt><decl><type><name>Oid</name></type>				<name>opclass</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>				<name>oprid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>			<name>strategy</name> <init>= <expr><name>BTLessStrategyNumber</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>				<name>opcintype</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>				<name>opfamily</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>HeapTuple</name></type>		<name>tp</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_opclass</name></type>	<name>opclassTup</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>opclass</name> <operator>=</operator> <call><name>OpclassnameGetOpcid</name><argument_list>(<argument><expr><name>BTREE_AM_OID</name></expr></argument>, <argument><expr><name>opcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Retrieve operator information. */</comment>
			<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>opclassTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name><name>opclassTup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <name><name>opclassTup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opcintype</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>indexRel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">110000</literal></expr></cpp:if>
				<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>nattr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><name>opcintype</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>attrs</name><index>[<expr><name>nattr</name></expr>]</index></name><operator>-&gt;</operator><name>atttypid</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>oprid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing operator %d(%u,%u) in opfamily %u"</literal></expr></argument>,
					 <argument><expr><name>strategy</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>opcname</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" USING %s"</literal></expr></argument>, <argument><expr><call><name>get_opname</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>colnulls</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>colnulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>next</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>indexRel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_indexdef(PG_FUNCTION_ARGS)
 * @brief   Reproduce DDL that create index at the temp table.
 *
 * repack_indexdef(index, table)
 *
 * @param	index		Oid of target index.
 * @param	table		Oid of table of the index.
 * @param	tablespace	Namespace for the index. If NULL keep the original.
 * @param   boolean		Whether to use CONCURRENTLY when creating the index.
 * @retval			Create index DDL for temp table.
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_indexdef</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type>			<name>tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>IndexDef</name></type>		<name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>concurrent_index</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>parse_indexdef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>concurrent_index</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s CONCURRENTLY index_%u ON %s USING %s (%s)%s"</literal></expr></argument>,
			<argument><expr><name><name>stmt</name><operator>.</operator><name>create</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>table</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>columns</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"%s index_%u ON repack.table_%u USING %s (%s)%s"</literal></expr></argument>,
			<argument><expr><name><name>stmt</name><operator>.</operator><name>create</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>columns</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* specify the new tablespace or the original one if any */</comment>
	<if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>||</operator> <name><name>stmt</name><operator>.</operator><name>tablespace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" TABLESPACE %s"</literal></expr></argument>,
			<argument><expr><operator>(</operator><ternary><condition><expr><name>tablespace</name></expr> ?</condition><then> <expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>tablespace</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>stmt</name><operator>.</operator><name>tablespace</name></name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>.</operator><name>where</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">" WHERE %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>.</operator><name>where</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>getoid</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>desc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>column</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>	<name>datum</name> <init>= <expr><call><name>SPI_getbinval</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>column</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_swap(PG_FUNCTION_ARGS)
 * @brief   Swapping relfilenode of tables and relation ids of toast tables
 *          and toast indexes.
 *
 * repack_swap(oid, relname)
 *
 * TODO: remove useless CommandCounterIncrement().
 *
 * @param	oid		Oid of table of target.
 * @retval			None.
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_swap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_quoted_relname</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>get_quoted_nspname</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> 			<name><name>argtypes</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><name>OIDOID</name></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	 		<name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>	 		<name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name>  <modifier>*</modifier></type><name>tuptable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>		<name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>		<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>			<name>records</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>			<name>i</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Oid</name></type>				<name>reltoastrelid1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>reltoastidxid1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>oid2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>reltoastrelid2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>reltoastidxid2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>owner1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>owner2</name></decl>;</decl_stmt>

	<comment type="block">/* authority check */</comment>
	<expr_stmt><expr><call><name>must_be_superuser</name><argument_list>(<argument><expr><literal type="string">"repack_swap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to SPI manager */</comment>
	<expr_stmt><expr><call><name>repack_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* swap relfilenode and dependencies for tables. */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>execute_with_args</name><argument_list>(<argument><expr><name>SPI_OK_SELECT</name></expr></argument>,
		<argument><expr><literal type="string">"SELECT X.reltoastrelid, TX.indexrelid, X.relowner,"</literal>
		<literal type="string">"       Y.oid, Y.reltoastrelid, TY.indexrelid, Y.relowner"</literal>
		<literal type="string">"  FROM pg_catalog.pg_class X LEFT JOIN pg_catalog.pg_index TX"</literal>
		<literal type="string">"         ON X.reltoastrelid = TX.indrelid AND TX.indisvalid,"</literal>
		<literal type="string">"       pg_catalog.pg_class Y LEFT JOIN pg_catalog.pg_index TY"</literal>
		<literal type="string">"         ON Y.reltoastrelid = TY.indrelid AND TY.indisvalid"</literal>
		<literal type="string">" WHERE X.oid = $1"</literal>
		<literal type="string">"   AND Y.oid = ('repack.table_' || X.oid)::regclass"</literal></expr></argument>,
		<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuptable</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>records</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>records</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"repack_swap : no swap target"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltoastrelid1</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltoastidxid1</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>owner1</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oid2</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltoastrelid2</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltoastidxid2</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>owner2</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* change owner of new relation to original owner */</comment>
	<if_stmt><if>if <condition>(<expr><name>owner1</name> <operator>!=</operator> <name>owner2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name>oid2</name></expr></argument>, <argument><expr><name>owner1</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* swap tables. */</comment>
	<expr_stmt><expr><call><name>swap_heap_or_index_files</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>oid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* swap indexes. */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>execute_with_args</name><argument_list>(<argument><expr><name>SPI_OK_SELECT</name></expr></argument>,
		<argument><expr><literal type="string">"SELECT X.oid, Y.oid"</literal>
		<literal type="string">"  FROM pg_catalog.pg_index I,"</literal>
		<literal type="string">"       pg_catalog.pg_class X,"</literal>
		<literal type="string">"       pg_catalog.pg_class Y"</literal>
		<literal type="string">" WHERE I.indrelid = $1"</literal>
		<literal type="string">"   AND I.indexrelid = X.oid"</literal>
		<literal type="string">"   AND I.indisvalid"</literal>
		<literal type="string">"   AND Y.oid = ('repack.index_' || X.oid)::regclass"</literal></expr></argument>,
		<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuptable</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>records</name> <operator>=</operator> <name>SPI_processed</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>records</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>		<name>idx1</name></decl>, <decl><type ref="prev"/><name>idx2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx1</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx2</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>swap_heap_or_index_files</name><argument_list>(<argument><expr><name>idx1</name></expr></argument>, <argument><expr><name>idx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* swap names for toast tables and toast indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>reltoastrelid1</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>reltoastidxid1</name> <operator>!=</operator> <name>InvalidOid</name> <operator>||</operator>
			<name>reltoastrelid2</name> <operator>!=</operator> <name>InvalidOid</name> <operator>||</operator>
			<name>reltoastidxid2</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"repack_swap : unexpected toast relations (T1=%u, I1=%u, T2=%u, I2=%u"</literal></expr></argument>,
				<argument><expr><name>reltoastrelid1</name></expr></argument>, <argument><expr><name>reltoastidxid1</name></expr></argument>, <argument><expr><name>reltoastrelid2</name></expr></argument>, <argument><expr><name>reltoastidxid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* do nothing */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>reltoastrelid2</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>	<name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>reltoastidxid1</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
			<name>reltoastidxid2</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"repack_swap : unexpected toast relations (T1=%u, I1=%u, T2=%u, I2=%u"</literal></expr></argument>,
				<argument><expr><name>reltoastrelid1</name></expr></argument>, <argument><expr><name>reltoastidxid1</name></expr></argument>, <argument><expr><name>reltoastrelid2</name></expr></argument>, <argument><expr><name>reltoastidxid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* rename X to Y */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u"</literal></expr></argument>, <argument><expr><name>oid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_REL</name><argument_list>(<argument><expr><name>reltoastrelid1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u_index"</literal></expr></argument>, <argument><expr><name>oid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_INDEX</name><argument_list>(<argument><expr><name>reltoastidxid1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>reltoastrelid1</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>	<name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>pid</name> <init>= <expr><call><name>getpid</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* rename X to TEMP */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_pid%d"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_REL</name><argument_list>(<argument><expr><name>reltoastrelid1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_pid%d_index"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_INDEX</name><argument_list>(<argument><expr><name>reltoastidxid1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* rename Y to X */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_REL</name><argument_list>(<argument><expr><name>reltoastrelid2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u_index"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_INDEX</name><argument_list>(<argument><expr><name>reltoastidxid2</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* rename TEMP to Y */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u"</literal></expr></argument>, <argument><expr><name>oid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_REL</name><argument_list>(<argument><expr><name>reltoastrelid1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NAMEDATALEN</name></expr></argument>, <argument><expr><literal type="string">"pg_toast_%u_index"</literal></expr></argument>, <argument><expr><name>oid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RENAME_INDEX</name><argument_list>(<argument><expr><name>reltoastidxid1</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* drop repack trigger */</comment>
	<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
		<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
		<argument><expr><literal type="string">"DROP TRIGGER IF EXISTS repack_trigger ON %s.%s CASCADE"</literal></expr></argument>,
		<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_drop(PG_FUNCTION_ARGS)
 * @brief   Delete temporarily objects.
 *
 * repack_drop(oid, relname)
 *
 * @param	oid		Oid of target table.
 * @retval			None.
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_drop</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numobj</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_quoted_relname</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>get_quoted_nspname</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>relname</name> <operator>&amp;&amp;</operator> <name>nspname</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table name not found for OID %u"</literal></expr></argument>, <argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* authority check */</comment>
	<expr_stmt><expr><call><name>must_be_superuser</name><argument_list>(<argument><expr><literal type="string">"repack_drop"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to SPI manager */</comment>
	<expr_stmt><expr><call><name>repack_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To prevent concurrent lockers of the repack target table from causing
	 * deadlocks, take an exclusive lock on it. Consider that the following
	 * commands take exclusive lock on tables log_xxx and the target table
	 * itself when deleting the repack_trigger on it, while concurrent
	 * updaters require row exclusive lock on the target table and in
	 * addition, on the log_xxx table, because of the trigger.
	 *
	 * Consider how a deadlock could occur - if the DROP TABLE repack.log_%u
	 * gets a lock on log_%u table before a concurrent updater could get it
	 * but after the updater has obtained a lock on the target table, the
	 * subsequent DROP TRIGGER ... ON target-table would report a deadlock as
	 * it finds itself waiting for a lock on target-table held by the updater,
	 * which in turn, is waiting for lock on log_%u table.
	 *
	 * Fixes deadlock mentioned in the Github issue #55.
	 *
	 * Skip the lock if we are not going to do anything.
	 * Otherwise, if repack gets accidentally run twice for the same table
	 * at the same time, the second repack, in order to perform
	 * a pointless cleanup, has to wait until the first one completes.
	 * This adds an ACCESS EXCLUSIVE lock request into the queue
	 * making the table effectively inaccessible for any other backend.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numobj</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
			<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
			<argument><expr><literal type="string">"LOCK TABLE %s.%s IN ACCESS EXCLUSIVE MODE"</literal></expr></argument>,
			<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* drop log table: must be done before dropping the pk type,
	 * since the log table is dependent on the pk type. (That's
	 * why we check numobj &gt; 1 here.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numobj</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
			<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
			<argument><expr><literal type="string">"DROP TABLE IF EXISTS repack.log_%u CASCADE"</literal></expr></argument>,
			<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>numobj</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* drop type for pk type */</comment>
	<if_stmt><if>if <condition>(<expr><name>numobj</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
			<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
			<argument><expr><literal type="string">"DROP TYPE IF EXISTS repack.pk_%u"</literal></expr></argument>,
			<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>numobj</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * drop repack trigger: We have already dropped the trigger in normal
	 * cases, but it can be left on error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numobj</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
			<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
			<argument><expr><literal type="string">"DROP TRIGGER IF EXISTS repack_trigger ON %s.%s CASCADE"</literal></expr></argument>,
			<argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>numobj</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* drop temp table */</comment>
	<if_stmt><if>if <condition>(<expr><name>numobj</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
			<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
			<argument><expr><literal type="string">"DROP TABLE IF EXISTS repack.table_%u CASCADE"</literal></expr></argument>,
			<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>numobj</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>repack_disable_autovacuum</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* connect to SPI manager */</comment>
	<expr_stmt><expr><call><name>repack_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>execute_with_format</name><argument_list>(
		<argument><expr><name>SPI_OK_UTILITY</name></expr></argument>,
		<argument><expr><literal type="string">"ALTER TABLE %s SET (autovacuum_enabled = off)"</literal></expr></argument>,
		<argument><expr><call><name>get_relation_name</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* init SPI */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repack_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>ret</name> <init>= <expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_repack: SPI_connect returned %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* prepare plan */</comment>
<function><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>
<name>repack_prepare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name> <init>= <expr><call><name>SPI_prepare</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_repack: repack_prepare failed (code=%d, query=%s)"</literal></expr></argument>, <argument><expr><name>SPI_result</name></expr></argument>, <argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>plan</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_quoted_relname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>relname</name></expr> ?</condition><then> <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_quoted_nspname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name> <init>= <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>nspname</name></expr> ?</condition><then> <expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>nspname</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This is a copy of swap_relation_files in cluster.c, but it also swaps
 * relfrozenxid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>swap_heap_or_index_files</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>r1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>r2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup1</name></decl>,
				<decl><type ref="prev"/><name>reltup2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relform1</name></decl>,
				<decl><type ref="prev"/><name>relform2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>swaptemp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>

	<comment type="block">/* We need writable copies of both pg_class tuples. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
	<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>relRelation</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>reltup1</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform1</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>reltup2</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relform2</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Actually swap the fields in the two tuples
	 */</comment>
	<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relfilenode</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltablespace</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>swaptemp</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>=</operator> <name>swaptemp</name></expr>;</expr_stmt>

	<comment type="block">/* set rel1's frozen Xid to larger one */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>,
								 <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* swap size statistics too, since new rel has freshly-updated stats */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int32</name></type>		<name>swap_pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>		<name>swap_tuples</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>swap_pages</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>relpages</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <name>swap_pages</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>swap_tuples</name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <name>swap_tuples</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>indstate</name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>

	<comment type="block">/* Update the tuples in pg_class */</comment>
	<expr_stmt><expr><call><name>simple_heap_update</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup1</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple_heap_update</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup2</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep system catalogs current */</comment>
	<expr_stmt><expr><call><name>CatalogIndexInsert</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>, <argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogIndexInsert</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>, <argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup1</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup1</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdateWithInfo</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup2</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup2</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have toast tables associated with the relations being swapped,
	 * change their dependency links to re-associate them with their new
	 * owning relations.  Otherwise the wrong one will get dropped ...
	 *
	 * NOTE: it is possible that only one table has a toast table; this can
	 * happen in CLUSTER if there were dropped columns in the old table, and
	 * in ALTER TABLE when adding or changing type of columns.
	 *
	 * NOTE: at present, a TOAST table's only dependency is the one on its
	 * owning table.  If more are ever created, we'd need to use something
	 * more selective than deleteDependencyRecordsFor() to get rid of only the
	 * link we want.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name> <operator>||</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>baseobject</name></decl>,
					<decl><type ref="prev"/><name>toastobject</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>count</name></decl>;</decl_stmt>

		<comment type="block">/* Delete old dependencies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
											   <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for TOAST table, found %ld"</literal></expr></argument>,
					 <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
											   <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for TOAST table, found %ld"</literal></expr></argument>,
					 <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Register new dependencies */</comment>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>r1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>relform1</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>r2</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>toastobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>relform2</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>toastobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Blow away the old relcache entries now.	We need this kluge because
	 * relcache.c keeps a link to the smgr relation for the physical file, and
	 * that will be out of date as soon as we do CommandCounterIncrement.
	 * Whichever of the rels is the second to be cleared during cache
	 * invalidation will have a dangling reference to an already-deleted smgr
	 * relation.  Rather than trying to avoid this by ordering operations just
	 * so, it's easiest to not have the relcache entries there at all.
	 * (Fortunately, since one of the entries is local in our transaction,
	 * it's sufficient to clear out our own relcache this way; the problem
	 * cannot arise for other backends when they see our update on the
	 * non-local relation.)
	 */</comment>
	<expr_stmt><expr><call><name>RelationForgetRelation</name><argument_list>(<argument><expr><name>r1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RelationForgetRelation</name><argument_list>(<argument><expr><name>r2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Clean up. */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">120000</literal></expr></cpp:if>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum repack_index_swap(PG_FUNCTION_ARGS)
 * @brief   Swap out an original index on a table with the newly-created one.
 *
 * repack_index_swap(index)
 *
 * @param	index	Oid of the *original* index.
 * @retval	void
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_index_swap</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>                <name>orig_idx_oid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>                <name>repacked_idx_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>     <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPITupleTable</name>      <modifier>*</modifier></type><name>tuptable</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>          <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>          <name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/* authority check */</comment>
	<expr_stmt><expr><call><name>must_be_superuser</name><argument_list>(<argument><expr><literal type="string">"repack_index_swap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* connect to SPI manager */</comment>
	<expr_stmt><expr><call><name>repack_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the OID of our new index. */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"SELECT oid FROM pg_class "</literal>
					 <literal type="string">"WHERE relname = 'index_%u' AND relkind = 'i'"</literal></expr></argument>,
					 <argument><expr><name>orig_idx_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>execute</name><argument_list>(<argument><expr><name>SPI_OK_SELECT</name></expr></argument>, <argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Could not find index 'index_%u', found "</literal> <name>UINT64_FORMAT</name> <literal type="string">" matches"</literal></expr></argument>,
			 <argument><expr><name>orig_idx_oid</name></expr></argument>, <argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>SPI_processed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tuptable</name> <operator>=</operator> <name>SPI_tuptable</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>desc</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <name><name>tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>repacked_idx_oid</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>swap_heap_or_index_files</name><argument_list>(<argument><expr><name>orig_idx_oid</name></expr></argument>, <argument><expr><name>repacked_idx_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_VOID</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * @fn      Datum get_table_and_inheritors(PG_FUNCTION_ARGS)
 * @brief   Return array containing Oids of parent table and its children.
 *          Note that this function does not release relation locks.
 *
 * get_table_and_inheritors(table)
 *
 * @param	table	parent table.
 * @retval	regclass[]
 */</comment>
<function><type><name>Datum</name></type>
<name>repack_get_table_and_inheritors</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parent</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>relations_array</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>relations_array_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that parent table exists */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also check that children exist */</comment>
	<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relations_array_size</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>relations_array_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><call><name>construct_empty_array</name><argument_list>(<argument><expr><name>OIDOID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>relations_array</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>relations_array_size</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>relations</argument>)</argument_list></macro>
		<expr_stmt><expr><name><name>relations_array</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><name>relations_array</name></expr></argument>,
							 <argument><expr><name>relations_array_size</name></expr></argument>,
							 <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relations_array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_ARRAYTYPE_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
