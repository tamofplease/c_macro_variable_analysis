<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pg_repack/bin/pg_repack.c"><comment type="block">/*
 * pg_repack.c: bin/pg_repack.c
 *
 * Portions Copyright (c) 2008-2011, NIPPON TELEGRAPH AND TELEPHONE CORPORATION
 * Portions Copyright (c) 2011, Itagaki Takahiro
 * Portions Copyright (c) 2012-2020, The Reorg Development Team
 */</comment>

<comment type="block" format="doxygen">/**
 * @brief Client Modules
 */</comment>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>PROGRAM_URL</name>		<init>= <expr><literal type="string">"https://reorg.github.io/pg_repack/"</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>PROGRAM_ISSUES</name>	<init>= <expr><literal type="string">"https://github.com/reorg/pg_repack/issues"</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>REPACK_VERSION</name></cpp:ifdef>
<comment type="block">/* macro trick to stringify a macro expansion */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xstr</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str(s)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>str</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#s</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>PROGRAM_VERSION</name> <init>= <expr><call><name>xstr</name><argument_list>(<argument><expr><name>REPACK_VERSION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>PROGRAM_VERSION</name> <init>= <expr><literal type="string">"unknown"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgut/pgut-fe.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYS_SELECT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/select.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/*
 * APPLY_COUNT: Number of applied logs per transaction. Larger values
 * could be faster, but will be long transactions in the REDO phase.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPLY_COUNT</name></cpp:macro>		<cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/* Once we get down to seeing fewer than this many tuples in the
 * log table, we'll say that we're ready to perform the switch.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_TUPLES_BEFORE_SWITCH</name></cpp:macro>	<cpp:value>20</cpp:value></cpp:define>

<comment type="block">/* poll() or select() timeout, in seconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLL_TIMEOUT</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Compile an array of existing transactions which are active during
 * pg_repack's setup. Some transactions we can safely ignore:
 *  a. The '1/1, -1/0' lock skipped is from the bgwriter on newly promoted
 *     servers. See https://github.com/reorg/pg_reorg/issues/1
 *  b. Our own database connections
 *  c. Other pg_repack clients, as distinguished by application_name, which
 *     may be operating on other tables at the same time. See
 *     https://github.com/reorg/pg_repack/issues/1
 *  d. open transactions/locks existing on other databases than the actual
 *     processing relation (except for locks on shared objects)
 *  e. VACUUMs which are always executed outside transaction blocks.
 *
 * Note, there is some redundancy in how the filtering is done (e.g. excluding
 * based on pg_backend_pid() and application_name), but that shouldn't hurt
 * anything. Also, the test of application_name is not bulletproof -- for
 * instance, the application name when running installcheck will be
 * pg_regress.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_XID_SNAPSHOT_90200</name></cpp:macro> \
	<cpp:value>"SELECT coalesce(array_agg(l.virtualtransaction), '{}') " \
	"  FROM pg_locks AS l " \
	"  LEFT JOIN pg_stat_activity AS a " \
	"    ON l.pid = a.pid " \
	"  LEFT JOIN pg_database AS d " \
	"    ON a.datid = d.oid " \
	"  WHERE l.locktype = 'virtualxid' " \
	"  AND l.pid NOT IN (pg_backend_pid(), $1) " \
	"  AND (l.virtualxid, l.virtualtransaction) &lt;&gt; ('1/1', '-1/0') " \
	"  AND (a.application_name IS NULL OR a.application_name &lt;&gt; $2)" \
	"  AND a.query !~* E'^\\\\s*vacuum\\\\s+' " \
	"  AND a.query !~ E'^autovacuum: ' " \
	"  AND ((d.datname IS NULL OR d.datname = current_database()) OR l.database = 0)"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_XID_SNAPSHOT_90000</name></cpp:macro> \
	<cpp:value>"SELECT coalesce(array_agg(l.virtualtransaction), '{}') " \
	"  FROM pg_locks AS l " \
	"  LEFT JOIN pg_stat_activity AS a " \
	"    ON l.pid = a.procpid " \
	"  LEFT JOIN pg_database AS d " \
	"    ON a.datid = d.oid " \
	"  WHERE l.locktype = 'virtualxid' " \
	"  AND l.pid NOT IN (pg_backend_pid(), $1) " \
	"  AND (l.virtualxid, l.virtualtransaction) &lt;&gt; ('1/1', '-1/0') " \
	"  AND (a.application_name IS NULL OR a.application_name &lt;&gt; $2)" \
	"  AND a.current_query !~* E'^\\\\s*vacuum\\\\s+' " \
	"  AND a.current_query !~ E'^autovacuum: ' " \
	"  AND ((d.datname IS NULL OR d.datname = current_database()) OR l.database = 0)"</cpp:value></cpp:define>

<comment type="block">/* application_name is not available before 9.0. The last clause of
 * the WHERE clause is just to eat the $2 parameter (application name).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_XID_SNAPSHOT_80300</name></cpp:macro> \
	<cpp:value>"SELECT coalesce(array_agg(l.virtualtransaction), '{}') " \
	"  FROM pg_locks AS l" \
	"  LEFT JOIN pg_stat_activity AS a " \
	"    ON l.pid = a.procpid " \
	"  LEFT JOIN pg_database AS d " \
	"    ON a.datid = d.oid " \
	" WHERE l.locktype = 'virtualxid' AND l.pid NOT IN (pg_backend_pid(), $1)" \
	" AND (l.virtualxid, l.virtualtransaction) &lt;&gt; ('1/1', '-1/0') " \
	" AND a.current_query !~* E'^\\\\s*vacuum\\\\s+' " \
	" AND a.current_query !~ E'^autovacuum: ' " \
	" AND ((d.datname IS NULL OR d.datname = current_database()) OR l.database = 0)" \
	" AND ($2::text IS NOT NULL)"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_XID_SNAPSHOT</name></cpp:macro> \
	<cpp:value>(PQserverVersion(connection) &gt;= 90200 ? SQL_XID_SNAPSHOT_90200 : \
	 (PQserverVersion(connection) &gt;= 90000 ? SQL_XID_SNAPSHOT_90000 : \
	  SQL_XID_SNAPSHOT_80300))</cpp:value></cpp:define>


<comment type="block">/* Later, check whether any of the transactions we saw before are still
 * alive, and wait for them to go away.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQL_XID_ALIVE</name></cpp:macro> \
	<cpp:value>"SELECT pid FROM pg_locks WHERE locktype = 'virtualxid'"\
	" AND pid &lt;&gt; pg_backend_pid() AND virtualtransaction = ANY($1)"</cpp:value></cpp:define>

<comment type="block">/* To be run while our main connection holds an AccessExclusive lock on the
 * target table, and our secondary conn is attempting to grab an AccessShare
 * lock. We know that "granted" must be false for these queries because
 * we already hold the AccessExclusive lock. Also, we only care about other
 * transactions trying to grab an ACCESS EXCLUSIVE lock, because we are only
 * trying to kill off disallowed DDL commands, e.g. ALTER TABLE or TRUNCATE.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CANCEL_COMPETING_LOCKS</name></cpp:macro> \
	<cpp:value>"SELECT pg_cancel_backend(pid) FROM pg_locks WHERE locktype = 'relation'"\
	" AND granted = false AND relation = %u"\
	" AND mode = 'AccessExclusiveLock' AND pid &lt;&gt; pg_backend_pid()"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KILL_COMPETING_LOCKS</name></cpp:macro> \
	<cpp:value>"SELECT pg_terminate_backend(pid) "\
	"FROM pg_locks WHERE locktype = 'relation'"\
	" AND granted = false AND relation = %u"\
	" AND mode = 'AccessExclusiveLock' AND pid &lt;&gt; pg_backend_pid()"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COUNT_COMPETING_LOCKS</name></cpp:macro> \
	<cpp:value>"SELECT pid FROM pg_locks WHERE locktype = 'relation'" \
	" AND granted = false AND relation = %u" \
	" AND mode = 'AccessExclusiveLock' AND pid &lt;&gt; pg_backend_pid()"</cpp:value></cpp:define>

<comment type="block">/* Will be used as a unique prefix for advisory locks. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REPACK_LOCK_PREFIX_STR</name></cpp:macro> <cpp:value>"16185446"</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>UNPROCESSED</name></decl>,
	<decl><name>INPROGRESS</name></decl>,
	<decl><name>FINISHED</name></decl>
}</block></enum></type> <name>index_status_t</name>;</typedef>

<comment type="block">/*
 * per-index information
 */</comment>
<typedef>typedef <type><struct>struct <name>repack_index</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>				<name>target_oid</name></decl>;</decl_stmt>		<comment type="block">/* target: OID */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>create_index</name></decl>;</decl_stmt>	<comment type="block">/* CREATE INDEX */</comment>
	<decl_stmt><decl><type><name>index_status_t</name></type>  <name>status</name></decl>;</decl_stmt> 		<comment type="block">/* Track parallel build statuses. */</comment>
	<decl_stmt><decl><type><name>int</name></type>             <name>worker_idx</name></decl>;</decl_stmt>		<comment type="block">/* which worker conn is handling */</comment>
}</block></struct></type> <name>repack_index</name>;</typedef>

<comment type="block">/*
 * per-table information
 */</comment>
<typedef>typedef <type><struct>struct <name>repack_table</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>target_name</name></decl>;</decl_stmt>	<comment type="block">/* target: relname */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>target_oid</name></decl>;</decl_stmt>		<comment type="block">/* target: OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>target_toast</name></decl>;</decl_stmt>	<comment type="block">/* target: toast OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>target_tidx</name></decl>;</decl_stmt>	<comment type="block">/* target: toast index OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>pkid</name></decl>;</decl_stmt>			<comment type="block">/* target: PK OID */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>ckid</name></decl>;</decl_stmt>			<comment type="block">/* target: CK OID */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>create_pktype</name></decl>;</decl_stmt>	<comment type="block">/* CREATE TYPE pk */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>create_log</name></decl>;</decl_stmt>		<comment type="block">/* CREATE TABLE log */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>create_trigger</name></decl>;</decl_stmt>	<comment type="block">/* CREATE TRIGGER repack_trigger */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>enable_trigger</name></decl>;</decl_stmt>	<comment type="block">/* ALTER TABLE ENABLE ALWAYS TRIGGER repack_trigger */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>create_table</name></decl>;</decl_stmt>	<comment type="block">/* CREATE TABLE table AS SELECT WITH NO DATA*/</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>copy_data</name></decl>;</decl_stmt>		<comment type="block">/* INSERT INTO */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>alter_col_storage</name></decl>;</decl_stmt>	<comment type="block">/* ALTER TABLE ALTER COLUMN SET STORAGE */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>drop_columns</name></decl>;</decl_stmt>	<comment type="block">/* ALTER TABLE DROP COLUMNs */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>delete_log</name></decl>;</decl_stmt>		<comment type="block">/* DELETE FROM log */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>lock_table</name></decl>;</decl_stmt>		<comment type="block">/* LOCK TABLE table */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>sql_peek</name></decl>;</decl_stmt>		<comment type="block">/* SQL used in flush */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>sql_insert</name></decl>;</decl_stmt>		<comment type="block">/* SQL used in flush */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>sql_delete</name></decl>;</decl_stmt>		<comment type="block">/* SQL used in flush */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>sql_update</name></decl>;</decl_stmt>		<comment type="block">/* SQL used in flush */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>sql_pop</name></decl>;</decl_stmt>		<comment type="block">/* SQL used in flush */</comment>
	<decl_stmt><decl><type><name>int</name></type>             <name>n_indexes</name></decl>;</decl_stmt>      <comment type="block">/* number of indexes */</comment>
	<decl_stmt><decl><type><name>repack_index</name>   <modifier>*</modifier></type><name>indexes</name></decl>;</decl_stmt>        <comment type="block">/* info on each index */</comment>
}</block></struct></type> <name>repack_table</name>;</typedef>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_superuser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_tablespace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>preliminary_checks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_requested_relation_exists</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repack_all_databases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>order_by</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>repack_one_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>order_by</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repack_one_table</name><parameter_list>(<parameter><decl><type><name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>order_by</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>repack_table_indexes</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>index_details</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>repack_all_indexes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repack_cleanup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fatal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>repack_cleanup_callback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fatal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userdata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>rebuild_indexes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getstr</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>getoid</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>advisory_lock</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lock_exclusive</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lock_query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>start_xact</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>kill_ddl</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>terminate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>lock_access_share</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_name</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLSTATE_INVALID_SCHEMA_NAME</name></cpp:macro>	<cpp:value>"3F000"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLSTATE_UNDEFINED_FUNCTION</name></cpp:macro>		<cpp:value>"42883"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SQLSTATE_QUERY_CANCELED</name></cpp:macro>			<cpp:value>"57014"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>sqlstate_equals</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>PQresultErrorField</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>analyze</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>alldb</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>noorder</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type>	<name>parent_table_list</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type>	<name>table_list</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type>	<name>schema_list</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				<modifier>*</modifier></type><name>orderby</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>				<modifier>*</modifier></type><name>tablespace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>moveidx</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type>	<name>r_index</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>only_indexes</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>				<name>wait_timeout</name> <init>= <expr><literal type="number">60</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* in seconds */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>				<name>jobs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* number of concurrent worker conns. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>dryrun</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>		<name>temp_obj_num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* temporary objects counter */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>no_kill_backend</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* abandon when timed-out */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>				<name>no_superuser_check</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>SimpleStringList</name></type>	<name>exclude_extension_list</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* don't repack tables of these extensions */</comment>

<comment type="block">/* buffer should have at least 11 bytes */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>utoa</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buffer</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>pgut_option</name></type> <name><name>options</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="string">"all"</literal></expr>, <expr><operator>&amp;</operator><name>alldb</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'t'</literal></expr>, <expr><literal type="string">"table"</literal></expr>, <expr><operator>&amp;</operator><name>table_list</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'I'</literal></expr>, <expr><literal type="string">"parent-table"</literal></expr>, <expr><operator>&amp;</operator><name>parent_table_list</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="string">"schema"</literal></expr>, <expr><operator>&amp;</operator><name>schema_list</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'n'</literal></expr>, <expr><literal type="string">"no-order"</literal></expr>, <expr><operator>&amp;</operator><name>noorder</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'N'</literal></expr>, <expr><literal type="string">"dry-run"</literal></expr>, <expr><operator>&amp;</operator><name>dryrun</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'o'</literal></expr>, <expr><literal type="string">"order-by"</literal></expr>, <expr><operator>&amp;</operator><name>orderby</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'s'</literal></expr>, <expr><literal type="string">"tablespace"</literal></expr>, <expr><operator>&amp;</operator><name>tablespace</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'S'</literal></expr>, <expr><literal type="string">"moveidx"</literal></expr>, <expr><operator>&amp;</operator><name>moveidx</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="string">"index"</literal></expr>, <expr><operator>&amp;</operator><name>r_index</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'x'</literal></expr>, <expr><literal type="string">"only-indexes"</literal></expr>, <expr><operator>&amp;</operator><name>only_indexes</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'T'</literal></expr>, <expr><literal type="string">"wait-timeout"</literal></expr>, <expr><operator>&amp;</operator><name>wait_timeout</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'B'</literal></expr>, <expr><literal type="char">'Z'</literal></expr>, <expr><literal type="string">"no-analyze"</literal></expr>, <expr><operator>&amp;</operator><name>analyze</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'j'</literal></expr>, <expr><literal type="string">"jobs"</literal></expr>, <expr><operator>&amp;</operator><name>jobs</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'D'</literal></expr>, <expr><literal type="string">"no-kill-backend"</literal></expr>, <expr><operator>&amp;</operator><name>no_kill_backend</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="string">"no-superuser-check"</literal></expr>, <expr><operator>&amp;</operator><name>no_superuser_check</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'l'</literal></expr>, <expr><literal type="char">'C'</literal></expr>, <expr><literal type="string">"exclude-extension"</literal></expr>, <expr><operator>&amp;</operator><name>exclude_extension_list</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>						<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>						<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>pgut_getopt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"too many arguments"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>check_tablespace</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dryrun</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Dry run enabled, not executing repack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name>only_indexes</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name><name>table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --index (-i) and --table (-t)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --index (-i) and --parent-table (-I)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name>only_indexes</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --index (-i) and --only-indexes (-x)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name><name>exclude_extension_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --index (-i) and --exclude-extension (-C)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>only_indexes</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>table_list</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot repack all indexes of database, specify the table(s)"</literal>
					   <literal type="string">"via --table (-t) or --parent-table (-I)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>only_indexes</name> <operator>&amp;&amp;</operator> <name><name>exclude_extension_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --only-indexes (-x) and --exclude-extension (-C)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>alldb</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot repack specific index(es) in all databases"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>orderby</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option -o (--order-by) has no effect while repacking indexes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>noorder</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option -n (--no-order) has no effect while repacking indexes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><operator>!</operator><name>analyze</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ANALYZE is not performed after repacking indexes, -z (--no-analyze) has no effect"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>jobs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option -j (--jobs) has no effect, repacking indexes does not use parallel jobs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>repack_all_indexes</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>schema_list</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>table_list</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot repack specific table(s) in schema, use schema.table notation instead"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>exclude_extension_list</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name><name>table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --table (-t) and --exclude-extension (-C)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>exclude_extension_list</name><operator>.</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --parent-table (-I) and --exclude-extension (-C)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>noorder</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>orderby</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>alldb</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>table_list</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot repack specific table(s) in all databases"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>schema_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot repack specific schema(s) in all databases"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>repack_all_databases</name><argument_list>(<argument><expr><name>orderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>repack_one_database</name><argument_list>(<argument><expr><name>orderby</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s failed with error: %s"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Test if the current user is a database superuser.
 * Borrowed from psql/common.c
 *
 * Note: this will correctly detect superuserness only with a protocol-3.0
 * or newer backend; otherwise it will always say "false".
 */</comment>
<function><type><name>bool</name></type>
<name>is_superuser</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>no_superuser_check</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>connection</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PQparameterStatus</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"is_superuser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if the tablespace requested exists.
 *
 * Raise an exception on error.
 */</comment>
<function><type><name>void</name></type>
<name>check_tablespace</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>		<modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* nothing to check, but let's see the options */</comment>
		<if_stmt><if>if <condition>(<expr><name>moveidx</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot specify --moveidx (-S) without --tablespace (-s)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check if the tablespace exists */</comment>
	<expr_stmt><expr><call><name>reconnect</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tablespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(
		<argument><expr><literal type="string">"select spcname from pg_tablespace where spcname = $1"</literal></expr></argument>,
		<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the tablespace \"%s\" doesn't exist"</literal></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"error checking the namespace: %s"</literal></expr></argument>,
				 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Perform sanity checks before beginning work. Make sure pg_repack is
 * installed in the database, the user is a superuser, etc.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>preliminary_checks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list><block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>		<modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_superuser</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>, <argument><expr><literal type="string">"You must be a superuser to use %s"</literal></expr></argument>,
					 <argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Query the extension version. Exit if no match */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(<argument><expr><literal type="string">"select repack.version(), repack.version_sql()"</literal></expr></argument>,
		<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>libver</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>			<name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* the string is something like "pg_repack 1.1.7" */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s %s"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>, <argument><expr><name>PROGRAM_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* check the version of the C library */</comment>
		<expr_stmt><expr><name>libver</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>libver</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
					<argument><expr><literal type="string">"program '%s' does not match database library '%s'"</literal></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>libver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check the version of the SQL extension */</comment>
		<expr_stmt><expr><name>libver</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>libver</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
					<argument><expr><literal type="string">"extension '%s' required, found '%s';"</literal>
					<literal type="string">" please drop and re-create the extension"</literal></expr></argument>,
					<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>libver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>sqlstate_equals</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>SQLSTATE_INVALID_SCHEMA_NAME</name></expr></argument>)</argument_list></call>
			<operator>||</operator> <call><name>sqlstate_equals</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>SQLSTATE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Schema repack does not exist, or version too old (version
			 * functions not found). Skip the database.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
					<argument><expr><literal type="string">"%s %s is not installed in the database"</literal></expr></argument>,
					<argument><expr><name>PROGRAM_NAME</name></expr></argument>, <argument><expr><name>PROGRAM_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Return the error message otherwise */</comment>
			<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Disable statement timeout. */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SET statement_timeout = 0"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restrict search_path to system catalog. */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SET search_path = pg_catalog, pg_temp, public"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* To avoid annoying "create implicit ..." messages. */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SET client_min_messages = warning"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the presence of tables specified by --parent-table and --table
 * otherwise format user-friendly message
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_requested_relation_exists</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list><block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>		<modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	    <modifier>*</modifier><modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>iparam</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>num_relations</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_relations</name> <operator>=</operator> <call><name>simple_string_list_size</name><argument_list>(<argument><expr><name>parent_table_list</name></expr></argument>)</argument_list></call> <operator>+</operator>
					<call><name>simple_string_list_size</name><argument_list>(<argument><expr><name>table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nothing was implicitly requested, so nothing to do here */</comment>
	<if_stmt><if>if <condition>(<expr><name>num_relations</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* has no suitable to_regclass(text) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call><operator>&lt;</operator><literal type="number">90600</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>num_relations</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT r FROM (VALUES "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>table_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"($%d, 'r')"</literal></expr></argument>, <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>iparam</name> <operator>&lt;</operator> <name>num_relations</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"($%d, 'p')"</literal></expr></argument>, <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>iparam</name> <operator>&lt;</operator> <name>num_relations</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
		<argument><expr><literal type="string">") AS given_t(r,kind) WHERE"</literal>
		<comment type="block">/* regular --table relation or inherited --parent-table */</comment>
		<literal type="string">" NOT EXISTS("</literal>
		<literal type="string">"  SELECT FROM repack.tables WHERE relid=to_regclass(given_t.r))"</literal>
		<comment type="block">/* declarative partitioned --parent-table */</comment>
		<literal type="string">" AND NOT EXISTS("</literal>
		<literal type="string">"  SELECT FROM pg_catalog.pg_class c WHERE c.oid=to_regclass(given_t.r) AND c.relkind = given_t.kind AND given_t.kind = 'p')"</literal></expr></argument>
	)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* double check the parameters array is sane */</comment>
	<if_stmt><if>if <condition>(<expr><name>iparam</name> <operator>!=</operator> <name>num_relations</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
				<argument><expr><literal type="string">"internal error: bad parameters count: %i instead of %i"</literal></expr></argument>,
				 <argument><expr><name>iparam</name></expr></argument>, <argument><expr><name>num_relations</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>iparam</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> 	<name>num</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>rel_names</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_names</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_names</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
							<argument><expr><literal type="string">"relations do not exist: %s"</literal></expr></argument>, <argument><expr><name><name>rel_names</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
							<argument><expr><literal type="string">"ERROR:  relation %s does not exist"</literal></expr></argument>, <argument><expr><name><name>rel_names</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rel_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call repack_one_database for each database.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repack_all_databases</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orderby</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dbname</name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reconnect</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"You must be a superuser to use %s"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>execute</name><argument_list>(<argument><expr><literal type="string">"SELECT datname FROM pg_database WHERE datallowconn ORDER BY 1;"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>disconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>	<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>	<name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>PQgetvalue</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"repacking database \"%s\""</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dryrun</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>repack_one_database</name><argument_list>(<argument><expr><name>orderby</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"database \"%s\" skipped: %s"</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* result is not copied */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getstr</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>getoid</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>row</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Oid</name><operator>)</operator><call><name>strtoul</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>row</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Call repack_one_table for the target tables or each table in a database.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>repack_one_database</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orderby</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>					<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>			   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>			<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>			  <modifier>*</modifier><modifier>*</modifier></type><name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>iparam</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>					<name>num_parent_tables</name></decl>,
							<decl><type ref="prev"/><name>num_tables</name></decl>,
							<decl><type ref="prev"/><name>num_schemas</name></decl>,
							<decl><type ref="prev"/><name>num_params</name></decl>,
							<decl><type ref="prev"/><name>num_excluded_extensions</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>num_parent_tables</name> <operator>=</operator> <call><name>simple_string_list_size</name><argument_list>(<argument><expr><name>parent_table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_tables</name> <operator>=</operator> <call><name>simple_string_list_size</name><argument_list>(<argument><expr><name>table_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_schemas</name> <operator>=</operator> <call><name>simple_string_list_size</name><argument_list>(<argument><expr><name>schema_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_excluded_extensions</name> <operator>=</operator> <call><name>simple_string_list_size</name><argument_list>(<argument><expr><name>exclude_extension_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 1st param is the user-specified tablespace */</comment>
	<expr_stmt><expr><name>num_params</name> <operator>=</operator> <name>num_excluded_extensions</name> <operator>+</operator>
				 <name>num_parent_tables</name> <operator>+</operator>
				 <name>num_tables</name> <operator>+</operator>
				 <name>num_schemas</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>params</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>num_params</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>reconnect</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No sense in setting up concurrent workers if --jobs=1 */</comment>
	<if_stmt><if>if <condition>(<expr><name>jobs</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setup_workers</name><argument_list>(<argument><expr><name>jobs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>preliminary_checks</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_requested_relation_exists</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* acquire target tables */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
		<argument><expr><literal type="string">"SELECT t.*,"</literal>
		<literal type="string">" coalesce(v.tablespace, t.tablespace_orig) as tablespace_dest"</literal>
		<literal type="string">" FROM repack.tables t, "</literal>
		<literal type="string">" (VALUES (quote_ident($1::text))) as v (tablespace)"</literal>
		<literal type="string">" WHERE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tablespace</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>num_tables</name> <operator>||</operator> <name>num_parent_tables</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* standalone tables */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_tables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>table_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* Construct table name placeholders to be used by PQexecParams */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"relid = $%d::regclass"</literal></expr></argument>, <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_tables</name> <operator>&amp;&amp;</operator> <name>num_parent_tables</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* parent tables + inherited children */</comment>
		<if_stmt><if>if <condition>(<expr><name>num_parent_tables</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* Construct table name placeholders to be used by PQexecParams */</comment>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
								 <argument><expr><literal type="string">"relid = ANY(repack.get_table_and_inheritors($%d::regclass))"</literal></expr></argument>,
								 <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" OR "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>num_schemas</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"schemaname IN ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>schema_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* Construct schema name placeholders to be used by PQexecParams */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"pkid IS NOT NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Exclude tables which belong to extensions */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>exclude_extension_list</name><operator>.</operator><name>head</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" AND t.relid NOT IN"</literal>
									 <literal type="string">"  (SELECT d.objid::regclass"</literal>
									 <literal type="string">"   FROM pg_depend d JOIN pg_extension e"</literal>
									 <literal type="string">"   ON d.refobjid = e.oid"</literal>
									 <literal type="string">"   WHERE d.classid = 'pg_class'::regclass AND ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* List all excluded extensions */</comment>
		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>exclude_extension_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"e.extname = $%d"</literal></expr></argument>, <argument><expr><name>iparam</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><index>[<expr><name>iparam</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><literal type="string">" OR "</literal></expr> </then><else>: <expr><literal type="string">")"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Close subquery */</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ensure the regression tests get a consistent ordering of tables */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY t.relname, t.schemaname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* double check the parameters array is sane */</comment>
	<if_stmt><if>if <condition>(<expr><name>iparam</name> <operator>!=</operator> <name>num_params</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>,
				<argument><expr><literal type="string">"internal error: bad parameters count: %i instead of %zi"</literal></expr></argument>,
				 <argument><expr><name>iparam</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>num_params</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* on error skip the database */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Return the error message otherwise */</comment>
		<if_stmt><if>if <condition>(<expr><name>errbuf</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>repack_table</name></type>	<name>table</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>copy_sql</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>create_table_1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>create_table_2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tablespace</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ckey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>target_name</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>target_oid</name></name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>target_toast</name></name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>target_tidx</name></name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt> <comment type="line">// Skip schemaname</comment>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>pkid</name></name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>ckid</name></name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>.</operator><name>pkid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" must have a primary key or not-null unique keys"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>.</operator><name>target_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>create_pktype</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>create_log</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>create_trigger</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>enable_trigger</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>create_table_1</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* to be clobbered */</comment>
		<expr_stmt><expr><name>create_table_2</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>copy_data</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument> , <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>alter_col_storage</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>drop_columns</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>delete_log</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>lock_table</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ckey</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>sql_peek</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>sql_insert</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>sql_delete</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>sql_update</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>sql_pop</name></name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tablespace</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>c</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Craft CREATE TABLE SQL */</comment>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>create_table_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>create_table_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Always append WITH NO DATA to CREATE TABLE SQL*/</comment>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">" WITH NO DATA"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>create_table</name></name> <operator>=</operator> <name><name>sql</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<comment type="block">/* Craft Copy SQL */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_sql</name></expr></argument>, <argument><expr><name><name>table</name><operator>.</operator><name>copy_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orderby</name></expr>)</condition>

		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ckey</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* CLUSTER mode */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_sql</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_sql</name></expr></argument>, <argument><expr><name>ckey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* else, VACUUM FULL mode (non-clustered tables) */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>orderby</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* VACUUM FULL mode (for clustered tables too), do nothing */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* User specified ORDER BY */</comment>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_sql</name></expr></argument>, <argument><expr><literal type="string">" ORDER BY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copy_sql</name></expr></argument>, <argument><expr><name>orderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>table</name><operator>.</operator><name>copy_data</name></name> <operator>=</operator> <name><name>copy_sql</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>repack_one_table</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table</name></expr></argument>, <argument><expr><name>orderby</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>disconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>apply_log</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>sql_peek</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>sql_insert</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>sql_delete</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>sql_update</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>sql_pop</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>,
					   <argument><expr><literal type="string">"SELECT repack.repack_apply($1, $2, $3, $4, $5, $6)"</literal></expr></argument>,
					   <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create indexes on temp table, possibly using multiple worker connections
 * concurrently if the user asked for --jobs=...
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rebuild_indexes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			    <name>num_indexes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>num_active_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>num_workers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>repack_index</name>   <modifier>*</modifier></type><name>index_jobs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name>have_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- create indexes ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_indexes</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>n_indexes</name></name></expr>;</expr_stmt>

	<comment type="block">/* We might have more actual worker connections than we need,
	 * if the number of workers exceeds the number of indexes to be
	 * built. In that case, ignore the extra workers.
	 */</comment>
	<expr_stmt><expr><name>num_workers</name> <operator>=</operator> <ternary><condition><expr><name>num_indexes</name> <operator>&gt;</operator> <name><name>workers</name><operator>.</operator><name>num_workers</name></name></expr> ?</condition><then> <expr><name><name>workers</name><operator>.</operator><name>num_workers</name></name></expr> </then><else>: <expr><name>num_indexes</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_active_workers</name> <operator>=</operator> <name>num_workers</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Have %d indexes and num_workers=%d"</literal></expr></argument>, <argument><expr><name>num_indexes</name></expr></argument>,
		 <argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>index_jobs</name> <operator>=</operator> <name><name>table</name><operator>-&gt;</operator><name>indexes</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"set up index_jobs [%d]"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"target_oid   : %u"</literal></expr></argument>, <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>target_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"create_index : %s"</literal></expr></argument>, <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>num_workers</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Use primary connection if we are not setting up parallel
			 * index building, or if we only have one worker.
			 */</comment>
			<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* This bookkeeping isn't actually important in this no-workers
			 * case, but just for clarity.
			 */</comment>
			<expr_stmt><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>FINISHED</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Assign available worker to build an index. */</comment>
			<expr_stmt><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>INPROGRESS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Initial worker %d to build index: %s"</literal></expr></argument>,
				 <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error sending async query: %s\n%s"</literal></expr></argument>,
					 <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>have_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<goto>goto <name>cleanup</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Else we have more indexes to be built than workers
		 * available. That's OK, we'll get to them later.
		 */</comment>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>num_workers</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>freed_worker</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<comment type="block">/* Prefer poll() over select(), following PostgreSQL custom. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL</name></cpp:ifdef>
		<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>input_fds</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>input_fds</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>input_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>input_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name> <operator>|</operator> <name>POLLERR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>input_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<decl_stmt><decl><type><name>fd_set</name></type> <name>input_mask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>timeout</name></decl>;</decl_stmt>
		<comment type="block">/* select() needs the highest-numbered socket descriptor */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>max_fd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Now go through our index builds, and look for any which is
		 * reported complete. Reassign that worker to the next index to
		 * be built, if any.
		 */</comment>
		<while>while <condition>(<expr><name>num_active_workers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"polling %d active workers"</literal></expr></argument>, <argument><expr><name>num_active_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL</name></cpp:ifdef>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>poll</name><argument_list>(<argument><expr><name>input_fds</name></expr></argument>, <argument><expr><name>num_workers</name></expr></argument>, <argument><expr><name>POLL_TIMEOUT</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<comment type="block">/* re-initialize timeout and input_mask before each
			 * invocation of select(). I think this isn't
			 * necessary on many Unixen, but just in case.
			 */</comment>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>POLL_TIMEOUT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>timeout</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>max_fd</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>max_fd</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>max_fd</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>max_fd</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>input_mask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* XXX: the errno != EINTR check means we won't bail
			 * out on SIGINT. We should probably just remove this
			 * check, though it seems we also need to fix up
			 * the on_interrupt handling for workers' index
			 * builds (those PGconns don't seem to have c-&gt;cancel
			 * set, so we don't cancel the in-progress builds).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"poll() failed: %d, %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Poll returned: %d"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>INPROGRESS</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Must call PQconsumeInput before we can check PQisBusy */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error fetching async query status: %s"</literal></expr></argument>,
							 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>have_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
						<goto>goto <name>cleanup</name>;</goto>
					</block_content>}</block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Command finished in worker %d: %s"</literal></expr></argument>,
							 <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr></argument>,
							 <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<while>while <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
							<block>{<block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error with create index: %s"</literal></expr></argument>,
									 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>have_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
								<goto>goto <name>cleanup</name>;</goto>
							</block_content>}</block></if></if_stmt>
							<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></while>

						<comment type="block">/* We are only going to re-queue one worker, even
						 * though more than one index build might be finished.
						 * Any other jobs which may be finished will
						 * just have to wait for the next pass through the
						 * poll()/select() loop.
						 */</comment>
						<expr_stmt><expr><name>freed_worker</name> <operator>=</operator> <name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>FINISHED</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>num_active_workers</name><operator>--</operator></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name>freed_worker</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_indexes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>==</operator> <name>UNPROCESSED</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>INPROGRESS</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>worker_idx</name> <operator>=</operator> <name>freed_worker</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Assigning worker %d to build index #%d: "</literal>
							 <literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>freed_worker</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
							 <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>freed_worker</name></expr>]</index></name></expr></argument>,
										  <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error sending async query: %s\n%s"</literal></expr></argument>,
								 <argument><expr><name><name>index_jobs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>,
								 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>freed_worker</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>have_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							<goto>goto <name>cleanup</name>;</goto>
						</block_content>}</block></if></if_stmt>
						<expr_stmt><expr><name>num_active_workers</name><operator>++</operator></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name>freed_worker</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>

	</block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>!</operator><name>have_error</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Re-organize one table.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repack_one_table</name><parameter_list>(<parameter><decl><type><name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>orderby</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>vxid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>			<name><name>buffer</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>            <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>       <modifier>*</modifier></type><name>indexres</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>     <modifier>*</modifier></type><name><name>indexparams</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		    <name><name>indexbuffer</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>             <name>j</name></decl>;</decl_stmt>

	<comment type="block">/* appname will be "pg_repack" in normal use on 9.0+, or
	 * "pg_regress" when run under `make installcheck`
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>     <modifier>*</modifier></type><name>appname</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGAPPNAME"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Keep track of whether we have gotten through setup to install
	 * the repack_trigger, log table, etc. ourselves. We don't want to
	 * go through repack_cleanup() if we didn't actually set up the
	 * trigger ourselves, lest we be cleaning up another pg_repack's mess,
	 * or worse, interfering with a still-running pg_repack.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>            <name>table_init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"repacking table \"%s\""</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- repack_one_table ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"target_name       : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"target_oid        : %u"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"target_toast      : %u"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_toast</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"target_tidx       : %u"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_tidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"pkid              : %u"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>pkid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"ckid              : %u"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>ckid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"create_pktype     : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_pktype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"create_log        : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"create_trigger    : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_trigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"enable_trigger    : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>enable_trigger</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"create_table      : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"copy_data         : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>copy_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"alter_col_storage : %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>table</name><operator>-&gt;</operator><name>alter_col_storage</name></name></expr> ?</condition><then>
		 <expr><name><name>table</name><operator>-&gt;</operator><name>alter_col_storage</name></name></expr> </then><else>: <expr><literal type="string">"(skipped)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"drop_columns      : %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>table</name><operator>-&gt;</operator><name>drop_columns</name></name></expr> ?</condition><then> <expr><name><name>table</name><operator>-&gt;</operator><name>drop_columns</name></name></expr> </then><else>: <expr><literal type="string">"(skipped)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"delete_log        : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>delete_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"lock_table        : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>lock_table</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sql_peek          : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>sql_peek</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sql_insert        : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>sql_insert</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sql_delete        : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>sql_delete</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sql_update        : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>sql_update</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"sql_pop           : %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>sql_pop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dryrun</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* push repack_cleanup_callback() on stack to clean temporary objects */</comment>
	<expr_stmt><expr><call><name>pgut_atexit_push</name><argument_list>(<argument><expr><name>repack_cleanup_callback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 1. Setup advisory lock and trigger on main table.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- setup ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>advisory_lock</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>lock_exclusive</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>lock_table</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>no_kill_backend</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Skipping repack %s due to timeout"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"lock_exclusive() failed for %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * pg_get_indexdef requires an access share lock, so do those calls while
	 * we have an access exclusive lock anyway, so we know they won't block.
	 */</comment>

	<expr_stmt><expr><name><name>indexparams</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>indexbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>indexparams</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>moveidx</name></expr> ?</condition><then> <expr><name>tablespace</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* First, just display a warning message for any invalid indexes
	 * which may be on the table (mostly to match the behavior of 1.1.8).
	 */</comment>
	<expr_stmt><expr><name>indexres</name> <operator>=</operator> <call><name>execute</name><argument_list>(
		<argument><expr><literal type="string">"SELECT pg_get_indexdef(indexrelid)"</literal>
		<literal type="string">" FROM pg_index WHERE indrelid = $1 AND NOT indisvalid"</literal></expr></argument>,
		<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>indexparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>indexres</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>indexdef</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>indexdef</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>indexres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"skipping invalid index: %s"</literal></expr></argument>, <argument><expr><name>indexdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>indexres</name> <operator>=</operator> <call><name>execute</name><argument_list>(
		<argument><expr><literal type="string">"SELECT indexrelid,"</literal>
		<literal type="string">" repack.repack_indexdef(indexrelid, indrelid, $2, FALSE) "</literal>
		<literal type="string">" FROM pg_index WHERE indrelid = $1 AND indisvalid"</literal></expr></argument>,
		<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>indexparams</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>n_indexes</name></name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>indexres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name></name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>n_indexes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>repack_index</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>n_indexes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>target_oid</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>indexres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>create_index</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>indexres</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>status</name> <operator>=</operator> <name>UNPROCESSED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>worker_idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* Unassigned */</comment>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>table</name><operator>-&gt;</operator><name>n_indexes</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"index[%d].target_oid      : %u"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>target_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"index[%d].create_index    : %s"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>indexes</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>create_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>


	<comment type="block">/*
	 * Check if repack_trigger is not conflict with existing trigger. We can
	 * find it out later but we check it in advance and go to cleanup if needed.
	 * In AFTER trigger context, since triggered tuple is not changed by other
	 * trigger we don't care about the fire order.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute</name><argument_list>(<argument><expr><literal type="string">"SELECT repack.conflicted_triggers($1)"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"the table \"%s\" already has a trigger called \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>, <argument><expr><literal type="string">"repack_trigger"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(
					 <argument><expr><literal type="string">"The trigger was probably installed during a previous"</literal>
					 <literal type="string">" attempt to run pg_repack on the table which was"</literal>
					 <literal type="string">" interrupted and for some reason failed to clean up"</literal>
					 <literal type="string">" the temporary objects.  Please drop the trigger or drop"</literal>
					<literal type="string">" and recreate the pg_repack extension altogether"</literal>
					 <literal type="string">" to remove all the temporary objects left over."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_pktype</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_obj_num</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_log</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_obj_num</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_trigger</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_obj_num</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>enable_trigger</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT repack.disable_autovacuum('repack.log_%u')"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* While we are still holding an AccessExclusive lock on the table, submit
	 * the request for an AccessShare lock asynchronously from conn2.
	 * We want to submit this query in conn2 while connection's
	 * transaction still holds its lock, so that no DDL may sneak in
	 * between the time that connection commits and conn2 gets its lock.
	 */</comment>
	<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><literal type="string">"BEGIN ISOLATION LEVEL READ COMMITTED"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* grab the backend PID of conn2; we'll need this when querying
	 * pg_locks momentarily.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_backend_pid()"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not using lock_access_share() here since we know that
	 * it's not possible to obtain the ACCESS SHARE lock right now
	 * in conn2, since the primary connection holds ACCESS EXCLUSIVE.
	 */</comment>
	<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE %s IN ACCESS SHARE MODE"</literal></expr></argument>,
					 <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE %s IN ACCESS SHARE MODE"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unable to set conn2 nonblocking."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error sending async query: %s\n%s"</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>,
			 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now that we've submitted the LOCK TABLE request through conn2,
	 * look for and cancel any (potentially dangerous) DDL commands which
	 * might also be waiting on our table lock at this point --
	 * it's not safe to let them wait, because they may grab their
	 * AccessExclusive lock before conn2 gets its AccessShare lock,
	 * and perform unsafe DDL on the table.
	 *
	 * Normally, lock_access_share() would take care of this for us,
	 * but we're not able to use it here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>kill_ddl</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>no_kill_backend</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Skipping repack %s due to timeout."</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"kill_ddl() failed."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We're finished killing off any unsafe DDL. COMMIT in our main
	 * connection, so that conn2 may get its AccessShare lock.
	 */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The main connection has now committed its repack_trigger,
	 * log table, and temp. table. If any error occurs from this point
	 * on and we bail out, we should try to clean those up.
	 */</comment>
	<expr_stmt><expr><name>table_init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Keep looping PQgetResult() calls until it returns NULL, indicating the
	 * command is done and we have obtained our lock.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>res</name> <operator>=</operator> <call><name>PQgetResult</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Waiting on ACCESS SHARE lock..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error with LOCK TABLE: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>cleanup</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Turn conn2 back into blocking mode for further non-async use. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unable to set conn2 blocking."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * 2. Copy tuples into temp table.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- copy tuples ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Must use SERIALIZABLE (or at least not READ COMMITTED) to avoid race
	 * condition between the create_table statement and rows subsequently
	 * being added to the log.
	 */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"BEGIN ISOLATION LEVEL SERIALIZABLE"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* SET work_mem = maintenance_work_mem */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SELECT set_config('work_mem', current_setting('maintenance_work_mem'), true)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>orderby</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>orderby</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SET LOCAL synchronize_seqscans = off"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch an array of Virtual IDs of all transactions active right now.
	 */</comment>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt> <comment type="block">/* backend PID of conn2 */</comment>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>PROGRAM_NAME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute</name><argument_list>(<argument><expr><name>SQL_XID_SNAPSHOT</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vxid</name> <operator>=</operator> <call><name>pgut_strdup</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete any existing entries in the log table now, since we have not
	 * yet run the CREATE TABLE ... AS SELECT, which will take in all existing
	 * rows from the target table; if we also included prior rows from the
	 * log we could wind up with duplicates.
	 */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>delete_log</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We need to be able to obtain an AccessShare lock on the target table
	 * for the create_table command to go through, so go ahead and obtain
	 * the lock explicitly.
	 *
	 * Since conn2 has been diligently holding its AccessShare lock, it
	 * is possible that another transaction has been waiting to acquire
	 * an AccessExclusive lock on the table (e.g. a concurrent ALTER TABLE
	 * or TRUNCATE which we must not allow). If there are any such
	 * transactions, lock_access_share() will kill them so that our
	 * CREATE TABLE ... AS SELECT does not deadlock waiting for an
	 * AccessShare lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>lock_access_share</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Before copying data to the target table, we need to set the column storage
	 * type if its storage type has been changed from the type default.
	 */</comment>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>create_table</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>alter_col_storage</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>alter_col_storage</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>copy_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_obj_num</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT repack.disable_autovacuum('repack.table_%u')"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>table</name><operator>-&gt;</operator><name>drop_columns</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>drop_columns</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 3. Create indexes on temp table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rebuild_indexes</name><argument_list>(<argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* don't clear indexres until after rebuild_indexes or bad things happen */</comment>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>indexres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 4. Apply log to temp table until no tuples are left in the log
	 * and all of the old transactions are finished.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>apply_log</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>APPLY_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We'll keep applying tuples from the log table in batches
		 * of APPLY_COUNT, until applying a batch of tuples
		 * (via LIMIT) results in our having applied
		 * MIN_TUPLES_BEFORE_SWITCH or fewer tuples. We don't want to
		 * get stuck repetitively applying some small number of tuples
		 * from the log table as inserts/updates/deletes may be
		 * constantly coming into the original table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <name>MIN_TUPLES_BEFORE_SWITCH</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>	<comment type="block">/* there might be still some tuples, repeat. */</comment>

		<comment type="block">/* old transactions still alive ? */</comment>
		<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>vxid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute</name><argument_list>(<argument><expr><name>SQL_XID_ALIVE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Wait for old transactions.
			 * Only display this message if we are NOT
			 * running under pg_regress, so as not to cause
			 * noise which would trip up pg_regress.
			 */</comment>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>appname</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>appname</name></expr></argument>, <argument><expr><literal type="string">"pg_regress"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Waiting for %d transactions to finish. First PID: %s"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sleep</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* All old transactions are finished;
			 * go to next step. */</comment>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * 5. Swap: will be done with conn2, since it already holds an
	 *    AccessShare lock.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- swap ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Bump our existing AccessShare lock to AccessExclusive */</comment>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>lock_exclusive</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>table</name><operator>-&gt;</operator><name>lock_table</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"lock_exclusive() failed in conn2 for %s"</literal></expr></argument>,
			 <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>apply_log</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><literal type="string">"SELECT repack.repack_swap($1)"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * 6. Drop.
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- drop ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"BEGIN ISOLATION LEVEL READ COMMITTED"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>lock_exclusive</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>table</name><operator>-&gt;</operator><name>lock_table</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"lock_exclusive() failed in connection for %s"</literal></expr></argument>,
			 <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>cleanup</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>temp_obj_num</name></expr></argument>, <argument><expr><name>indexbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SELECT repack.repack_drop($1, $2)"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>temp_obj_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* reset temporary object counter after cleanup */</comment>

	<comment type="block">/*
	 * 7. Analyze.
	 * Note that cleanup hook has been already uninstalled here because analyze
	 * is not an important operation; No clean up even if failed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>analyze</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"---- analyze ----"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"BEGIN ISOLATION LEVEL READ COMMITTED"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"ANALYZE %s"</literal></expr></argument>, <argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Release advisory lock on table. */</comment>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REPACK_LOCK_PREFIX_STR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_advisory_unlock($1, CAST(-2147483648 + $2::bigint AS integer))"</literal></expr></argument>,
			   <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>vxid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>vxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Rollback current transactions */</comment>
	<expr_stmt><expr><call><name>pgut_rollback</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgut_rollback</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX: distinguish between fatal and non-fatal errors via the first
	 * arg to repack_cleanup().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>ret</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>table_init</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>repack_cleanup</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><name>table</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Kill off any concurrent DDL (or any transaction attempting to take
 * an AccessExclusive lock) trying to run against our table if we want to
 * do. Note, we're killing these queries off *before* they are granted
 * an AccessExclusive lock on our table.
 *
 * Returns true if no problems encountered, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>kill_ddl</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>terminate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>n_tuples</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check the number of backends competing AccessExclusiveLock */</comment>
	<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>COUNT_COMPETING_LOCKS</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n_tuples</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n_tuples</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Competing backend is exsits, but if we do not want to calcel/terminate
		 * any backend, do nothing.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>no_kill_backend</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%d unsafe queries remain but do not cancel them and skip to repack it"</literal></expr></argument>,
				 <argument><expr><name>n_tuples</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>CANCEL_COMPETING_LOCKS</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error canceling unsafe queries: %s"</literal></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>terminate</name> <operator>&amp;&amp;</operator> <call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">80400</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					 <argument><expr><literal type="string">"Canceled %d unsafe queries. Terminating any remaining PIDs."</literal></expr></argument>,
					 <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><name>KILL_COMPETING_LOCKS</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Error killing unsafe queries: %s"</literal></expr></argument>,
						 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Canceled %d unsafe queries"</literal></expr></argument>, <argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"No competing DDL to cancel."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Try to acquire an ACCESS SHARE table lock, avoiding deadlocks and long
 * waits by killing off other sessions which may be stuck trying to obtain
 * an ACCESS EXCLUSIVE lock.
 *
 * Arguments:
 *
 *  conn: connection to use
 *  relid: OID of relation
 *  target_name: name of table
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lock_access_share</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>target_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>time_t</name></type>			<name>start</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>duration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wait_msec</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>duration</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start</name></expr>;</expr_stmt>

		<comment type="block">/* Cancel queries unconditionally, i.e. don't bother waiting
		 * wait_timeout as lock_exclusive() does -- the only queries we
		 * should be killing are disallowed DDL commands hanging around
		 * for an AccessExclusive lock, which must be deadlocked at
		 * this point anyway since conn2 holds its AccessShare lock
		 * already.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <operator>(</operator><name>wait_timeout</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>kill_ddl</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>kill_ddl</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* wait for a while to lock the table. */</comment>
		<expr_stmt><expr><name>wait_msec</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SET LOCAL statement_timeout = %d"</literal></expr></argument>, <argument><expr><name>wait_msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>printfStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE %s IN ACCESS SHARE MODE"</literal></expr></argument>, <argument><expr><name>target_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute_elevel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>sqlstate_equals</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>SQLSTATE_QUERY_CANCELED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* retry if lock conflicted */</comment>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgut_rollback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* exit otherwise */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RESET statement_timeout"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Obtain an advisory lock on the table's OID, to make sure no other
 * pg_repack is working on the table. This is not so much a concern with
 * full-table repacks, but mainly so that index-only repacks don't interfere
 * with each other or a full-table repack.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>advisory_lock</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>	   <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>REPACK_LOCK_PREFIX_STR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>

	<comment type="block">/* For the 2-argument form of pg_try_advisory_lock, we need to
	 * pass in two signed 4-byte integers. But a table OID is an
	 * *unsigned* 4-byte integer. Add -2147483648 to that OID to make
	 * it fit reliably into signed int space.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_try_advisory_lock($1, CAST(-2147483648 + $2::bigint AS integer))"</literal></expr></argument>,
			   <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,  <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"t"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Another pg_repack command may be running on the table. Please try again later."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try acquire an ACCESS EXCLUSIVE table lock, avoiding deadlocks and long
 * waits by killing off other sessions.
 * Arguments:
 *
 *  conn: connection to use
 *  relid: OID of relation
 *  lock_query: LOCK TABLE ... IN ACCESS EXCLUSIVE query to be executed
 *  start_xact: whether we will issue a BEGIN ourselves. If not, we will
 *              use a SAVEPOINT and ROLLBACK TO SAVEPOINT if our query
 *              times out, to avoid leaving the transaction in error state.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>lock_exclusive</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lock_query</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>start_xact</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>time_t</name></type>		<name>start</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>time_t</name></type>		<name>duration</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>sql</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>wait_msec</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>start_xact</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"BEGIN ISOLATION LEVEL READ COMMITTED"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SAVEPOINT repack_sp1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>duration</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>start</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>duration</name> <operator>&gt;</operator> <name>wait_timeout</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>no_kill_backend</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"timed out, do not cancel conflicting backends"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

				<comment type="block">/* Before exit the loop reset the transaction */</comment>
				<if_stmt><if>if <condition>(<expr><name>start_xact</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pgut_rollback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT repack_sp1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cancel_query</name></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQserverVersion</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">80400</literal> <operator>&amp;&amp;</operator>
					<name>duration</name> <operator>&gt;</operator> <name>wait_timeout</name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"terminating conflicted backends"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cancel_query</name> <operator>=</operator>
						<literal type="string">"SELECT pg_terminate_backend(pid) FROM pg_locks"</literal>
						<literal type="string">" WHERE locktype = 'relation'"</literal>
						<literal type="string">"   AND relation = $1 AND pid &lt;&gt; pg_backend_pid()"</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"canceling conflicted backends"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>cancel_query</name> <operator>=</operator>
						<literal type="string">"SELECT pg_cancel_backend(pid) FROM pg_locks"</literal>
						<literal type="string">" WHERE locktype = 'relation'"</literal>
						<literal type="string">"   AND relation = $1 AND pid &lt;&gt; pg_backend_pid()"</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>cancel_query</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* wait for a while to lock the table. */</comment>
		<expr_stmt><expr><name>wait_msec</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>, <argument><expr><name>i</name> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"SET LOCAL statement_timeout = %d"</literal></expr></argument>, <argument><expr><name>wait_msec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute_elevel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>lock_query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>sqlstate_equals</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>SQLSTATE_QUERY_CANCELED</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* retry if lock conflicted */</comment>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>start_xact</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pgut_rollback</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK TO SAVEPOINT repack_sp1"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* exit otherwise */</comment>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"RESET statement_timeout"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* This function calls to repack_drop() to clean temporary objects on error
 * in creation of temporary objects.
 */</comment>
<function><type><name>void</name></type>
<name>repack_cleanup_callback</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fatal</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>target_table</name> <init>= <expr><operator>*</operator><operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <name>userdata</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>num_buff</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name>fatal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>target_table</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>temp_obj_num</name></expr></argument>, <argument><expr><name>num_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* testing PQstatus() of connection and conn2, as we do
		 * in repack_cleanup(), doesn't seem to work here,
		 * so just use an unconditional reconnect().
		 */</comment>
		<expr_stmt><expr><call><name>reconnect</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SELECT repack.repack_drop($1, $2)"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>temp_obj_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* reset temporary object counter after cleanup */</comment>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The userdata pointing a table being re-organized. We need to cleanup temp
 * objects before the program exits.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repack_cleanup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fatal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>repack_table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fatal</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"!!!FATAL ERROR!!! Please refer to the manual.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>num_buff</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Try reconnection if not available. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name> <operator>||</operator>
			<call><name>PQstatus</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>CONNECTION_OK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>reconnect</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* do cleanup */</comment>
		<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name><name>table</name><operator>-&gt;</operator><name>target_oid</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator>  <call><name>utoa</name><argument_list>(<argument><expr><name>temp_obj_num</name></expr></argument>, <argument><expr><name>num_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><literal type="string">"SELECT repack.repack_drop($1, $2)"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>temp_obj_num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> <comment type="block">/* reset temporary object counter after cleanup */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Indexes of a table are repacked.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>repack_table_indexes</name><parameter_list>(<parameter><decl><type><name>PGresult</name> <modifier>*</modifier></type><name>index_details</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>				<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>			<modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>		<name>sql</name></decl>, <decl><type ref="prev"/><name>sql_drop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>				<name><name>buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>			<modifier>*</modifier></type><name>create_idx</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>schema_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>table_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>					<name>table</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>i</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"/><name>num_repacked</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>                <modifier>*</modifier></type><name>repacked_indexes</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>table</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>tablespace</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>schema_name</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* table_name is schema-qualified */</comment>
	<expr_stmt><expr><name>table_name</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep track of which of the table's indexes we have successfully
	 * repacked, so that we may DROP only those indexes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>repacked_indexes</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ENOMEM</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unable to calloc repacked_indexes"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Check if any concurrent pg_repack command is being run on the same
	 * table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>advisory_lock</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Unable to obtain advisory lock on \"%s\""</literal></expr></argument>, <argument><expr><name>table_name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>isvalid</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>idx_name</name> <init>= <expr><call><name>getstr</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>isvalid</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"SELECT pgc.relname, nsp.nspname "</literal>
							 <literal type="string">"FROM pg_class pgc INNER JOIN pg_namespace nsp "</literal>
							 <literal type="string">"ON nsp.oid = pgc.relnamespace "</literal>
							 <literal type="string">"WHERE pgc.relname = 'index_%u' "</literal>
							 <literal type="string">"AND nsp.nspname = $1"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>schema_name</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"repacking index \"%s\""</literal></expr></argument>, <argument><expr><name>idx_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Cannot create index \"%s\".\"index_%u\", "</literal>
								<literal type="string">"already exists"</literal></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"An invalid index may have been left behind"</literal>
								   <literal type="string">" by a previous pg_repack on the table"</literal>
								   <literal type="string">" which was interrupted. Please use DROP "</literal>
								   <literal type="string">"INDEX \"%s\".\"index_%u\""</literal>
								   <literal type="string">" to remove this index and try again."</literal></expr></argument>,
								   <argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>dryrun</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute</name><argument_list>(<argument><expr><literal type="string">"SELECT repack.repack_indexdef($1, $2, $3, true)"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>,
						  <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><literal type="string">"unable to generate SQL to CREATE work index for %s"</literal></expr></argument>,
					<argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>create_idx</name> <operator>=</operator> <call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Use a separate PGresult to avoid stomping on create_idx */</comment>
			<expr_stmt><expr><name>res2</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(<argument><expr><name>create_idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res2</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_COMMAND_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Error creating index \"%s\".\"index_%u\": %s"</literal></expr></argument>,
								<argument><expr><name>schema_name</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>
							 )</argument_list></call> <operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>repacked_indexes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>num_repacked</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"skipping invalid index: %s.%s"</literal></expr></argument>, <argument><expr><name>schema_name</name></expr></argument>,
				 <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>dryrun</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we did not successfully repack any indexes, e.g. because of some
	 * error affecting every CREATE INDEX attempt, don't waste time with
	 * the ACCESS EXCLUSIVE lock on the table, and return false.
	 * N.B. none of the DROP INDEXes should be performed since
	 * repacked_indexes[] flags should all be false.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num_repacked</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
			 <argument><expr><literal type="string">"Skipping index swapping for \"%s\", since no new indexes built"</literal></expr></argument>,
			 <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>drop_idx</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* take an exclusive lock on table before calling repack_index_swap() */</comment>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"LOCK TABLE %s IN ACCESS EXCLUSIVE MODE"</literal></expr></argument>,
					 <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>lock_exclusive</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"lock_exclusive() failed in connection for %s"</literal></expr></argument>,
			 <argument><expr><name>table_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>drop_idx</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>repacked_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>utoa</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name><name>buffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"SELECT repack.repack_index_swap($1)"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Skipping index swap for index_%u"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>drop_idx</name>:</label>
	<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"DROP INDEX CONCURRENTLY "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>, <argument><expr><literal type="string">"\"%s\"."</literal></expr></argument>,  <argument><expr><name>schema_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>getoid</name><argument_list>(<argument><expr><name>index_details</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>repacked_indexes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_drop</name></expr></argument>, <argument><expr><literal type="string">"%s\"index_%u\""</literal></expr></argument>, <argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>command</name><argument_list>(<argument><expr><name><name>sql_drop</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"Skipping drop of index_%u"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql_drop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>done</name>:</label>
	<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>repacked_indexes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call repack_table_indexes for each of the tables
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>repack_all_indexes</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>errbuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>errsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>					<name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGresult</name>				<modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>			<name>sql</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name>	<modifier>*</modifier></type><name>cell</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>				<modifier>*</modifier></type><name><name>params</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>reconnect</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>r_index</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name><name>table_list</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>preliminary_checks</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_requested_relation_exists</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>errsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
			<argument><expr><literal type="string">"SELECT repack.oid2text(i.oid), idx.indexrelid, idx.indisvalid, idx.indrelid, repack.oid2text(idx.indrelid), n.nspname"</literal>
			<literal type="string">" FROM pg_index idx JOIN pg_class i ON i.oid = idx.indexrelid"</literal>
			<literal type="string">" JOIN pg_namespace n ON n.oid = i.relnamespace"</literal>
			<literal type="string">" WHERE idx.indexrelid = $1::regclass ORDER BY indisvalid DESC, i.relname, n.nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cell</name> <operator>=</operator> <name><name>r_index</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>table_list</name><operator>.</operator><name>head</name></name> <operator>||</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>,
			<argument><expr><literal type="string">"SELECT repack.oid2text(i.oid), idx.indexrelid, idx.indisvalid, idx.indrelid, $1::text, n.nspname"</literal>
			<literal type="string">" FROM pg_index idx JOIN pg_class i ON i.oid = idx.indexrelid"</literal>
			<literal type="string">" JOIN pg_namespace n ON n.oid = i.relnamespace"</literal>
			<literal type="string">" WHERE idx.indrelid = $1::regclass ORDER BY indisvalid DESC, i.relname, n.nspname"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>parent_table_list</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>nchildren</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>

			<comment type="block">/* find children of this parent table */</comment>
			<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(<argument><expr><literal type="string">"SELECT quote_ident(n.nspname) || '.' || quote_ident(c.relname)"</literal>
								 <literal type="string">" FROM pg_class c JOIN pg_namespace n on n.oid = c.relnamespace"</literal>
								 <literal type="string">" WHERE c.oid = ANY (repack.get_table_and_inheritors($1::regclass))"</literal>
								 <literal type="string">" ORDER BY n.nspname, c.relname"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>nchildren</name> <operator>=</operator> <call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>nchildren</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"relation \"%s\" does not exist"</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* append new tables to 'table_list' */</comment>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nchildren</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name>table_list</name></expr></argument>, <argument><expr><call><name>getstr</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cell</name> <operator>=</operator> <name><name>table_list</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>params</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>execute_elevel</name><argument_list>(<argument><expr><name><name>sql</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>DEBUG2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if<condition>(<expr><name><name>table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" does not have any indexes"</literal></expr></argument>,
					<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if<condition>(<expr><name><name>r_index</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"\"%s\" is not a valid index"</literal></expr></argument>,
					<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if<condition>(<expr><name><name>table_list</name><operator>.</operator><name>head</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>INFO</name></expr></argument>, <argument><expr><literal type="string">"repacking indexes of \"%s\""</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>repack_table_indexes</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"repack failed for \"%s\""</literal></expr></argument>, <argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CLEARPGRES</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>
	<expr_stmt><expr><call><name>disconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_help</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>details</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s re-organizes a PostgreSQL database.\n\n"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Usage:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  %s [OPTION]... [DBNAME]\n"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>details</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -a, --all                 repack all databases\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -t, --table=TABLE         repack specific table only\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -I, --parent-table=TABLE  repack specific parent table and its inheritors\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -c, --schema=SCHEMA       repack tables in specific schema only\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -s, --tablespace=TBLSPC   move repacked tables to a new tablespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -S, --moveidx             move repacked indexes to TBLSPC too\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -o, --order-by=COLUMNS    order by columns instead of cluster keys\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -n, --no-order            do vacuum full instead of cluster\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -N, --dry-run             print what would have been repacked\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -j, --jobs=NUM            Use this many parallel jobs for each table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -i, --index=INDEX         move only the specified index\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -x, --only-indexes        move only indexes of the specified table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -T, --wait-timeout=SECS   timeout to cancel other backends on conflict\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -D, --no-kill-backend     don't kill other backends when timed out\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -Z, --no-analyze          don't analyze at end\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -k, --no-superuser-check  skip superuser checks in client\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -C, --exclude-extension   don't repack tables which belong to specific extension\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
