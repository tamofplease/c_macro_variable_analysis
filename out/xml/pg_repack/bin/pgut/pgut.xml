<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pg_repack/bin/pgut/pgut.c"><comment type="block">/*-------------------------------------------------------------------------
 * pgut.c
 *
 * Portions Copyright (c) 2008-2011, NIPPON TELEGRAPH AND TELEPHONE CORPORATION
 * Portions Copyright (c) 2011, Itagaki Takahiro
 * Portions Copyright (c) 2012-2020, The Reorg Development Team
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres_fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&gt;=</operator> <literal type="number">140000</literal></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include> <comment type="block">/* for simple_prompt */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgut.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGUT_MULTI_THREADED</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgut-pthread.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_key_t</name></type>		<name>pgut_edata_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pthread_mutex_t</name></type>		<name>pgut_conn_mutex</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pgut_conn_lock</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>pthread_mutex_lock(&amp;pgut_conn_mutex)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pgut_conn_unlock</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>pthread_mutex_unlock(&amp;pgut_conn_mutex)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pgut_conn_lock</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pgut_conn_unlock</name><parameter_list>()</parameter_list></cpp:macro>	<cpp:value>((void) 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* old gcc doesn't have LLONG_MAX. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LLONG_MAX</name></cpp:ifndef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_INT_64</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLONG_MAX</name></cpp:macro>		<cpp:value>LONG_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LLONG_MAX</name></cpp:macro>		<cpp:value>INT64CONST(0x7FFFFFFFFFFFFFFF)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>PROGRAM_NAME</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Interrupted by SIGINT (Ctrl+C) ? */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>interrupted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>	<name>in_cleanup</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* log min messages */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>pgut_log_level</name> <init>= <expr><name>INFO</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>pgut_abort_level</name> <init>= <expr><name>ERROR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>pgut_echo</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Database connections */</comment>
<typedef>typedef <type><name><name>struct</name> <name>pgutConn</name></name></type>	<name>pgutConn</name>;</typedef>
<struct>struct <name>pgutConn</name>
<block>{
	<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>cancel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgutConn</name>   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>pgutConn</name> <modifier>*</modifier></type><name>pgut_connections</name></decl>;</decl_stmt>

<comment type="block">/* Connection routines */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>on_before_exec</name><parameter_list>(<parameter><decl><type><name>pgutConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>on_after_exec</name><parameter_list>(<parameter><decl><type><name>pgutConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>on_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>on_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>exit_or_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exitcode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>void</name></type>
<name>pgut_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>PROGRAM_NAME</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>PROGRAM_NAME</name> <operator>=</operator> <call><name>get_progname</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_pglocale_pgservice</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"pgscripts"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGUT_MULTI_THREADED</name></cpp:ifdef>
		<expr_stmt><expr><call><name>pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pgut_edata_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_mutex_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pgut_conn_mutex</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* application_name for 9.0 or newer versions */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGAPPNAME"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgut_putenv</name><argument_list>(<argument><expr><literal type="string">"PGAPPNAME"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>init_cancel_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>on_cleanup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_putenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>putenv</name><argument_list>(<argument><expr><call><name>pgut_strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* putenv requires malloc'ed buffer */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Try to interpret value as boolean value.  Valid values are: true,
 * false, yes, no, on, off, 1, 0; as well as unique prefixes thereof.
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_bool</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>parse_bool_with_len</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>parse_bool_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><operator>*</operator><name>value</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'t'</literal></expr>:</case>
		<case>case <expr><literal type="char">'T'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'f'</literal></expr>:</case>
		<case>case <expr><literal type="char">'F'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'y'</literal></expr>:</case>
		<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'n'</literal></expr>:</case>
		<case>case <expr><literal type="char">'N'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'o'</literal></expr>:</case>
		<case>case <expr><literal type="char">'O'</literal></expr>:</case>
			<comment type="block">/* 'o' is not unique enough */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'1'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><literal type="char">'0'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>		<comment type="block">/* suppress compiler warning */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse string as 32bit signed int.
 * valid range: -2147483648 ~ 2147483647
 */</comment>
<function><type><name>bool</name></type>
<name>parse_int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>	<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>INFINITE_STR</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val</name> <operator>!=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <name>val</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse string as 32bit unsigned int.
 * valid range: 0 ~ 4294967295 (2^32-1)
 */</comment>
<function><type><name>bool</name></type>
<name>parse_uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>uint32</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>INFINITE_STR</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>UINT_MAX</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name>val</name> <operator>!=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>uint32</name><operator>)</operator> <name>val</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <name>val</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse string as int64
 * valid range: -9223372036854775808 ~ 9223372036854775807
 */</comment>
<function><type><name>bool</name></type>
<name>parse_int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>	<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>INFINITE_STR</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>LLONG_MAX</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_strtoi64</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoll</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse string as uint64
 * valid range: 0 ~ (2^64-1)
 */</comment>
<function><type><name>bool</name></type>
<name>parse_uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>	<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>INFINITE_STR</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>ULONG_MAX</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>ULLONG_MAX</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>ULONG_MAX</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>_strtoui64</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG_INT_64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoull</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <operator>*</operator><name>endptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert ISO-8601 format string to time_t value.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>time_t</name> <modifier>*</modifier></type><name>time</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tm</name></name></type>	<name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>junk</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* tmp = replace( value, !isalnum, ' ' ) */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><call><name>IsAlnum</name><argument_list>(<argument><expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name><name>value</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>tmp</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* parse for "YYYY-MM-DD HH:MI:SS" */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* tm_year is year - 1900 */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* tm_mon is 0 - 11 */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>		<comment type="block">/* tm_mday is 1 - 31 */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_min</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="string">"%04d %02d %02d %02d %02d %02d%1s"</literal></expr></argument>,
		<argument><expr><operator>&amp;</operator><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name><name>tm</name><operator>.</operator><name>tm_hour</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>.</operator><name>tm_min</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>.</operator><name>tm_sec</name></name></expr></argument>, <argument><expr><name>junk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <literal type="number">6</literal> <operator>&lt;</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* adjust year */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>+=</operator> <literal type="number">2000</literal> <operator>-</operator> <literal type="number">1900</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>&gt;=</operator> <literal type="number">1900</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name> <operator>-=</operator> <literal type="number">1900</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* adjust month */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* determine whether Daylight Saving Time is in effect */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>.</operator><name>tm_isdst</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>time</name> <operator>=</operator> <call><name>mktime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append the given string `val` to the `list` */</comment>
<function><type><name>void</name></type>
<name>simple_string_list_append</name><parameter_list>(<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* this calculation correctly accounts for the null trailing byte */</comment>
	<expr_stmt><expr><name>cell</name> <operator>=</operator> <operator>(</operator><name>SimpleStringListCell</name> <operator>*</operator><operator>)</operator>
		<call><name>pgut_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SimpleStringListCell</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cell</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>cell</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Test whether `val` is in the given `list` */</comment>
<function><type><name>bool</name></type>
<name>simple_string_list_member</name><parameter_list>(<parameter><decl><type><name>SimpleStringList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SimpleStringListCell</name> <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>cell</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>cell</name></expr>;</condition> <incr><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cell</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the number of elements in the given SimpleStringList */</comment>
<function><type><name>size_t</name></type>
<name>simple_string_list_size</name><parameter_list>(<parameter><decl><type><name>SimpleStringList</name></type> <name>list</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> 					<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SimpleStringListCell</name>   <modifier>*</modifier></type><name>cell</name> <init>= <expr><name><name>list</name><operator>.</operator><name>head</name></name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>cell</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cell</name> <operator>=</operator> <name><name>cell</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>prompt_for_password</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>passwdbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>have_passwd</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFSIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">100000</literal></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name>have_passwd</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>passwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>BUFSIZE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_passwd</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>passwdbuf</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>passwdbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PG_VERSION_NUM</name> <operator>&lt;</operator> <literal type="number">140000</literal></expr></cpp:elif>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>have_passwd</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>passwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>BUFSIZE</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>have_passwd</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>passwdbuf</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>passwdbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name>have_passwd</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>passwdbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>simple_prompt</name><argument_list>(<argument><expr><literal type="string">"Password: "</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>have_passwd</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>passwdbuf</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>passwdbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof><operator>*</operator><name>BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not allocate memory ("</literal> <name>UINT64_FORMAT</name> <literal type="string">" bytes): "</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>BUFSIZE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>BUFSIZE</name></cpp:undef>
</block_content>}</block></function>


<function><type><name>PGconn</name> <modifier>*</modifier></type>
<name>pgut_connect</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>info</name></decl></parameter>, <parameter><decl><type><name>YesNo</name></type> <name>prompt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>passwd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>add_pass</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prompt</name> <operator>==</operator> <name>YES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>prompt_for_password</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>, <argument><expr><literal type="string">" password=%s "</literal></expr></argument>, <argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>passwd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>add_pass</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Start the connection. Loop until we have a password if requested by backend. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>passwd</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name><name>add_pass</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pgutConn</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>pgut_new</name><argument_list>(<argument><expr><name>pgutConn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>cancel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pgut_conn_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pgut_connections</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pgut_connections</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgut_conn_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>add_pass</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Hardcode a search path to avoid injections into public or pg_temp */</comment>
			<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET search_path TO pg_catalog, pg_temp, public"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>conn</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <call><name>PQconnectionNeedsPassword</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>prompt</name> <operator>!=</operator> <name>NO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>passwd</name> <operator>=</operator> <call><name>prompt_for_password</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>add_pass</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
	 			<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
	 			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>, <argument><expr><literal type="string">" password=%s "</literal></expr></argument>, <argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>add_pass</name><operator>.</operator><name>data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>add_pass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>passwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_CONNECT</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not connect to database: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_disconnect</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgutConn</name>	   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pgutConn</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pgut_conn_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name>pgut_connections</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>pgut_connections</name></expr>;</init> <condition><expr><name>c</name></expr>;</condition> <incr><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>conn</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>pgut_conn_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_disconnect_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pgut_conn_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>pgut_connections</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>pgut_connections</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgut_connections</name> <operator>=</operator> <name><name>pgut_connections</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>pgut_conn_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>echo_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"(query)\n%s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"(query) %s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nParams</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"\t(param:%d) = %s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>params</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><literal type="string">"(null)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pgut_execute</name><parameter_list>(<parameter><decl><type><name>PGconn</name><modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pgut_execute_elevel</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>pgut_execute_elevel</name><parameter_list>(<parameter><decl><type><name>PGconn</name><modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgutConn</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* write query to elog if debug */</comment>
	<if_stmt><if>if <condition>(<expr><name>pgut_echo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>echo_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not connected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* find connection */</comment>
	<expr_stmt><expr><call><name>pgut_conn_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>pgut_connections</name></expr>;</init> <condition><expr><name>c</name></expr>;</condition> <incr><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>conn</name></name> <operator>==</operator> <name>conn</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>pgut_conn_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_before_exec</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nParams</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexec</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQexecParams</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>c</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>on_after_exec</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGRES_TUPLES_OK</name></expr>:</case>
		<case>case <expr><name>PGRES_COMMAND_OK</name></expr>:</case>
		<case>case <expr><name>PGRES_COPY_IN</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query failed: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"query was: %s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ExecStatusType</name></type>
<name>pgut_command</name><parameter_list>(<parameter><decl><type><name>PGconn</name><modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGresult</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ExecStatusType</name></type>	<name>code</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pgut_execute</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>PQresultStatus</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PQclear</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>code</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* commit if needed */</comment>
<function><type><name>bool</name></type>
<name>pgut_commit</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PQTRANS_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PGRES_COMMAND_OK</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>	<comment type="block">/* nothing to do */</comment>
</block_content>}</block></function>

<comment type="block">/* rollback if needed */</comment>
<function><type><name>void</name></type>
<name>pgut_rollback</name><parameter_list>(<parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <call><name>PQtransactionStatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PQTRANS_IDLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>pgut_send</name><parameter_list>(<parameter><decl><type><name>PGconn</name><modifier>*</modifier></type> <name>conn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* write query to elog if debug */</comment>
	<if_stmt><if>if <condition>(<expr><name>pgut_echo</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>echo_query</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>conn</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not connected"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nParams</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQsendQuery</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>PQsendQueryParams</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>E_PG_COMMAND</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"query failed: %s"</literal></expr></argument>, <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"query was: %s"</literal></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgut_wait</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>PGconn</name> <modifier>*</modifier></type><name><name>connections</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* all connections are busy. wait for finish */</comment>
	<while>while <condition>(<expr><operator>!</operator><name>interrupted</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>fd_set</name></type>	<name>mask</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>maxsock</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>maxsock</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>	<name>sock</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sock</name> <operator>=</operator> <call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>sock</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>maxsock</name> <operator>&lt;</operator> <name>sock</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>maxsock</name> <operator>=</operator> <name>sock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<if_stmt><if>if <condition>(<expr><name>maxsock</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>wait_for_sockets</name><argument_list>(<argument><expr><name>maxsock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>	<comment type="block">/* timeout */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>FD_ISSET</name><argument_list>(<argument><expr><call><name>PQsocket</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>mask</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>PQconsumeInput</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>PQisBusy</name><argument_list>(<argument><expr><name><name>connections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<return>return <expr><name>i</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CHECK_FOR_INTERRUPTS - Ctrl+C pressed?
 */</comment>
<function><type><name>void</name></type>
<name>CHECK_FOR_INTERRUPTS</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>interrupted</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>in_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINTR</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"interrupted"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * elog staffs
 */</comment>
<typedef>typedef <type><struct>struct <name>pgutErrorData</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>				<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>save_errno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>msg</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>detail</name></decl>;</decl_stmt>
}</block></struct></type> <name>pgutErrorData</name>;</typedef>

<comment type="block">/* FIXME: support recursive error */</comment>
<function><type><specifier>static</specifier> <name>pgutErrorData</name> <modifier>*</modifier></type>
<name>getErrorData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>PGUT_MULTI_THREADED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>pgutErrorData</name> <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>pthread_getspecific</name><argument_list>(<argument><expr><name>pgut_edata_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>edata</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>pgut_new</name><argument_list>(<argument><expr><name>pgutErrorData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgutErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pthread_setspecific</name><argument_list>(<argument><expr><name>pgut_edata_key</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>edata</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><specifier>static</specifier> <name>pgutErrorData</name></type>	<name>edata</name></decl>;</decl_stmt>

	<return>return <expr><operator>&amp;</operator><name>edata</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pgutErrorData</name> <modifier>*</modifier></type>
<name>pgut_errinit</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>getErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>save_errno</name></name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* reset msg */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* reset detail */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name><operator>.</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>edata</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* remove white spaces and line breaks from the end of buffer */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>trimStringBuffer</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsSpace</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><operator>--</operator><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>elog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>			<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&lt;</operator> <name>pgut_abort_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>log_required</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>pgut_log_level</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edata</name> <operator>=</operator> <call><name>pgut_errinit</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>pgut_appendStringInfoVA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>;</do>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>save_errno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>trimStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgut_errfinish</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>pgut_errstart</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&lt;</operator> <name>pgut_abort_level</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>log_required</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>pgut_log_level</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgut_errinit</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_errfinish</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>getErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>log_required</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name>pgut_log_level</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pgut_error</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>code</name></name></expr></argument>,
			<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>data</name></name></expr> ?</condition><then> <expr><name><name>edata</name><operator>-&gt;</operator><name>msg</name><operator>.</operator><name>data</name></name></expr> </then><else>: <expr><literal type="string">"unknown"</literal></expr></else></ternary></expr></argument>,
			<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgut_abort_level</name> <operator>&lt;=</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&lt;=</operator> <name>PANIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>in_cleanup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> <comment type="block">/* need to be set for cleaning temporary objects on error */</comment>
		<expr_stmt><expr><call><name>exit_or_abort</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PGUT_OVERRIDE_ELOG</name></cpp:ifndef>
<function><type><name>void</name></type>
<name>pgut_error</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>detail</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><call><name>format_elevel</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>detail</name> <operator>&amp;&amp;</operator> <name><name>detail</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\nDETAIL: %s\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s: %s\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * log_required -- is elevel logically &gt;= log_min_level?
 *
 * physical order:
 *   DEBUG &lt; LOG &lt; INFO &lt; NOTICE &lt; WARNING &lt; ERROR &lt; FATAL &lt; PANIC
 * log_min_messages order:
 *   DEBUG &lt; INFO &lt; NOTICE &lt; WARNING &lt; ERROR &lt; LOG &lt; FATAL &lt; PANIC
 */</comment>
<function><type><name>bool</name></type>
<name>log_required</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_min_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>LOG</name> <operator>||</operator> <name>elevel</name> <operator>==</operator> <name>COMMERROR</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>log_min_level</name> <operator>==</operator> <name>LOG</name> <operator>||</operator> <name>log_min_level</name> <operator>&lt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>log_min_level</name> <operator>==</operator> <name>LOG</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* elevel != LOG */</comment>
		<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>FATAL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Neither is LOG */</comment>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>log_min_level</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>format_elevel</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
	<block>{<block_content>
	<case>case <expr><name>DEBUG5</name></expr>:</case>
	<case>case <expr><name>DEBUG4</name></expr>:</case>
	<case>case <expr><name>DEBUG3</name></expr>:</case>
	<case>case <expr><name>DEBUG2</name></expr>:</case>
	<case>case <expr><name>DEBUG1</name></expr>:</case>
		<return>return <expr><literal type="string">"DEBUG"</literal></expr>;</return>
	<case>case <expr><name>LOG</name></expr>:</case>
		<return>return <expr><literal type="string">"LOG"</literal></expr>;</return>
	<case>case <expr><name>INFO</name></expr>:</case>
		<return>return <expr><literal type="string">"INFO"</literal></expr>;</return>
	<case>case <expr><name>NOTICE</name></expr>:</case>
		<return>return <expr><literal type="string">"NOTICE"</literal></expr>;</return>
	<case>case <expr><name>WARNING</name></expr>:</case>
		<return>return <expr><literal type="string">"WARNING"</literal></expr>;</return>
	<case>case <expr><name>COMMERROR</name></expr>:</case>
	<case>case <expr><name>ERROR</name></expr>:</case>
		<return>return <expr><literal type="string">"ERROR"</literal></expr>;</return>
	<case>case <expr><name>FATAL</name></expr>:</case>
		<return>return <expr><literal type="string">"FATAL"</literal></expr>;</return>
	<case>case <expr><name>PANIC</name></expr>:</case>
		<return>return <expr><literal type="string">"PANIC"</literal></expr>;</return>
	<default>default:</default>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid elevel: %d"</literal></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="string">""</literal></expr>;</return>		<comment type="block">/* unknown value; just return an empty string */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>parse_elevel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"DEBUG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DEBUG2</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>INFO</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NOTICE</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"LOG"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>LOG</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>WARNING</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"ERROR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ERROR</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>FATAL</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="string">"PANIC"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PANIC</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
		 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid elevel: %s"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ERROR</name></expr>;</return>		<comment type="block">/* unknown value; just return ERROR */</comment>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>errcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlerrcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>getErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name>sqlerrcode</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>errcode_errno</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>getErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>code</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>save_errno</name></name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>errmsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>getErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>			<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ok</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>pgut_appendStringInfoVA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>;</do>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>fmt</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">": "</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>save_errno</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>trimStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>	<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>errdetail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgutErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><call><name>getErrorData</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>va_list</name></type>			<name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>ok</name></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ok</name> <operator>=</operator> <call><name>pgut_appendStringInfoVA</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>ok</name></expr>)</condition>;</do>
	<expr_stmt><expr><call><name>trimStringBuffer</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>	<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>CRITICAL_SECTION</name></type> <name>cancelConnLock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * on_before_exec
 *
 * Set cancel to point to the current database connection.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>on_before_exec</name><parameter_list>(<parameter><decl><type><name>pgutConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>old</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>in_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>	<comment type="block">/* forbid cancel during cleanup */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Free the old one if we have one */</comment>
	<expr_stmt><expr><name>old</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>cancel</name></name></expr>;</expr_stmt>

	<comment type="block">/* be sure handle_sigint doesn't use pointer while freeing */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>cancel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>old</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>cancel</name></name> <operator>=</operator> <call><name>PQgetCancel</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * on_after_exec
 *
 * Free the current cancel connection, if any, and set to NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>on_after_exec</name><parameter_list>(<parameter><decl><type><name>pgutConn</name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGcancel</name>   <modifier>*</modifier></type><name>old</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>in_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>	<comment type="block">/* forbid cancel during cleanup */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>old</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>cancel</name></name></expr>;</expr_stmt>

	<comment type="block">/* be sure handle_sigint doesn't use pointer while freeing */</comment>
	<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>cancel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>old</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PQfreeCancel</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Handle interrupt signals by cancelling the current command.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>on_interrupt</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgutConn</name>   <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Set interrupted flag */</comment>
	<expr_stmt><expr><name>interrupted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>in_cleanup</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Send QueryCancel if we are processing a database query */</comment>
	<expr_stmt><expr><call><name>pgut_conn_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>pgut_connections</name></expr>;</init> <condition><expr><name>c</name></expr>;</condition> <incr><expr><name>c</name> <operator>=</operator> <name><name>c</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>cancel</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>PQcancel</name><argument_list>(<argument><expr><name><name>c</name><operator>-&gt;</operator><name>cancel</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Cancel request sent"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pgut_conn_unlock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>			<comment type="block">/* just in case the write changed it */</comment>
</block_content>}</block></function>

<typedef>typedef <type><name><name>struct</name> <name>pgut_atexit_item</name></name></type> <name>pgut_atexit_item</name>;</typedef>
<struct>struct <name>pgut_atexit_item</name>
<block>{
	<decl_stmt><decl><type><name>pgut_atexit_callback</name></type>	<name>callback</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>				   <modifier>*</modifier></type><name>userdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgut_atexit_item</name>	   <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>pgut_atexit_item</name> <modifier>*</modifier></type><name>pgut_atexit_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>pgut_atexit_push</name><parameter_list>(<parameter><decl><type><name>pgut_atexit_callback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgut_atexit_item</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>callback</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>pgut_new</name><argument_list>(<argument><expr><name>pgut_atexit_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>callback</name></name> <operator>=</operator> <name>callback</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>userdata</name></name> <operator>=</operator> <name>userdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>pgut_atexit_stack</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pgut_atexit_stack</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_atexit_pop</name><parameter_list>(<parameter><decl><type><name>pgut_atexit_callback</name></type> <name>callback</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>userdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgut_atexit_item</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgut_atexit_item</name> <modifier>*</modifier><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>pgut_atexit_stack</name></expr><operator>,</operator> <expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name>pgut_atexit_stack</name></expr>;</init>
		 <condition><expr><name>item</name></expr>;</condition>
		 <incr><expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>callback</name></name> <operator>==</operator> <name>callback</name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>userdata</name></name> <operator>==</operator> <name>userdata</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>call_atexit_callbacks</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fatal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pgut_atexit_item</name>  <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>pgut_atexit_stack</name></expr>;</init> <condition><expr><name>item</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name><name>item</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name>fatal</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>userdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>on_cleanup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>in_cleanup</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>interrupted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>call_atexit_callbacks</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgut_disconnect_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>exit_or_abort</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>exitcode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>in_cleanup</name> <operator>&amp;&amp;</operator> <name>FATAL</name> <operator>&gt;</operator> <name>elevel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* oops, error in cleanup*/</comment>
		<expr_stmt><expr><call><name>call_atexit_callbacks</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>FATAL</name> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>&lt;=</operator> <name>PANIC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* on FATAL or PANIC */</comment>
		<expr_stmt><expr><call><name>call_atexit_callbacks</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* normal exit */</comment>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>exitcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * unlike the server code, this function automatically extend the buffer.
 */</comment>
<function><type><name>bool</name></type>
<name>pgut_appendStringInfoVA</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>avail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nprinted</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>avail</name> <operator>=</operator> <name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>nprinted</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>avail</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nprinted</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nprinted</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>avail</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>nprinted</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Double the buffer size and try again. */</comment>
	<expr_stmt><expr><call><name>enlargePQExpBuffer</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>appendStringInfoFile</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>		<name>rc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>rc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>appendStringInfoFd</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>		<name>rc</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>enlargeStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>errno</name> <operator>=</operator> <name>ENOMEM</name></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>str</name><operator>-&gt;</operator><name>maxlen</name></name> <operator>-</operator> <name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>rc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name> <operator>+=</operator> <name>rc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>str</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>str</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>errno</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>pgut_malloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not allocate memory ("</literal> <name>UINT64_FORMAT</name> <literal type="string">" bytes): "</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>
<name>pgut_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not re-allocate memory ("</literal> <name>UINT64_FORMAT</name> <literal type="string">" bytes): "</literal></expr></argument>,
				<argument><expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>size</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>pgut_strdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not duplicate string \"%s\": "</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>strdup_with_len</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>r</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* strdup but trim whitespaces at head and tail */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>strdup_trim</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsSpace</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt> </block_content>}</block></while>

	<return>return <expr><call><name>strdup_with_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try open file. Also create parent directries if open for writes.
 *
 * mode can contain 'R', that is same as 'r' but missing ok.
 */</comment>
<function><type><name>FILE</name> <modifier>*</modifier></type>
<name>pgut_fopen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>omode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>missing_ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>mode</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><name>omode</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'R'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'r'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>missing_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>retry</name>:</label>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal> <operator>||</operator> <name><name>mode</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>	<name><name>dir</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_parent_directory</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pgut_mkdir</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<goto>goto <name>retry</name>;</goto>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": "</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fp</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * this tries to build all the elements of a path to a directory a la mkdir -p
 * we assume the path is in canonical form, i.e. uses / as the separator.
 */</comment>
<function><type><name>bool</name></type>
<name>pgut_mkdir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dirpath</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>first</name></decl>,
				<decl><type ref="prev"/><name>last</name></decl>,
				<decl><type ref="prev"/><name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dirpath</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>p</name> <operator>=</operator> <name>path</name> <operator>=</operator> <call><name>pgut_strdup</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* skip network and drive specifiers for win32 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* network drive */</comment>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid path \"%s\""</literal></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator>
				 <operator>(</operator><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
				  <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* local drive */</comment>
			<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* Skip leading '/'. */</comment>
		<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>first</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name>last</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>retry</name>:</label>
		<comment type="block">/* check for pre-existing directory; ok if it's a parent */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sb</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>last</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EEXIST</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOTDIR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>S_IRWXU</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>retry</name>;</goto></block_content></block></if></if_stmt>	<comment type="block">/* another thread might create the directory. */</comment>
			<expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create directory \"%s\": "</literal></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>select_win32</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>readfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>writefds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>exceptfds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type> <name>timeout</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>select</name></cpp:macro>		<cpp:value>select_win32</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>
<name>wait_for_socket</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sock</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>fds</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>sock</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>wait_for_sockets</name><argument_list>(<argument><expr><name>sock</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fds</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>wait_for_sockets</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>fds</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>fds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_errno</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"select failed: "</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>handle_sigint</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>on_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>handle_sigint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Console control handler for Win32. Note that the control handler will
 * execute on a *different thread* than the main one, so we need to do
 * proper locking around those structures.
 */</comment>
<function><type><specifier>static</specifier> <name>BOOL</name> <name>WINAPI</name></type>
<name>consoleHandler</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>dwCtrlType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dwCtrlType</name> <operator>==</operator> <name>CTRL_C_EVENT</name> <operator>||</operator>
		<name>dwCtrlType</name> <operator>==</operator> <name>CTRL_BREAK_EVENT</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>on_interrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>TRUE</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* Return FALSE for any signals not being handled */</comment>
		<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_cancel_handler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cancelConnLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetConsoleCtrlHandler</name><argument_list>(<argument><expr><name>consoleHandler</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>sleep</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>seconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><name>seconds</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>usleep</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>usec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Sleep</name><argument_list>(<argument><expr><operator>(</operator><name>usec</name> <operator>+</operator> <literal type="number">999</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* rounded up */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>select</name></cpp:undef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>select_win32</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>readfds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>writefds</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>exceptfds</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>	<name>remain</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>remain</name> <operator>=</operator> <operator>*</operator><name>timeout</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>remain</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>remain</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name>LONG_MAX</name></expr>;</expr_stmt>	<comment type="block">/* infinite */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* sleep only one second because Ctrl+C doesn't interrupt select. */</comment>
	<while>while <condition>(<expr><name><name>remain</name><operator>.</operator><name>tv_sec</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>remain</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>				<name>ret</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type>	<name>onesec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>fd_set</name></type>			<name>save_readfds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>fd_set</name></type>			<name>save_writefds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>fd_set</name></type>			<name>save_exceptfds</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>remain</name><operator>.</operator><name>tv_sec</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>onesec</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>onesec</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>remain</name><operator>.</operator><name>tv_sec</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>onesec</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>onesec</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <name><name>remain</name><operator>.</operator><name>tv_usec</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>remain</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* save fds */</comment>
		<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_readfds</name></expr></argument>, <argument><expr><name>readfds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>writefds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_writefds</name></expr></argument>, <argument><expr><name>writefds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>exceptfds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_exceptfds</name></expr></argument>, <argument><expr><name>exceptfds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>readfds</name></expr></argument>, <argument><expr><name>writefds</name></expr></argument>, <argument><expr><name>exceptfds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>onesec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>ret</name></expr>;</return></block_content></block></if>	<comment type="block">/* succeeded */</comment>
		<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* error */</comment>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>interrupted</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>EINTR</name></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* restore fds */</comment>
		<if_stmt><if>if <condition>(<expr><name>readfds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>readfds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_readfds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>writefds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>writefds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_writefds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>exceptfds</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>exceptfds</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_exceptfds</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fd_set</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><literal type="number">0</literal></expr>;</return>	<comment type="block">/* timeout */</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* WIN32 */</comment>
</unit>
