<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/pg_repack/bin/pgut/pgut-fe.c"><comment type="block">/*-------------------------------------------------------------------------
 * pgut-fe.c
 *
 * Portions Copyright (c) 2008-2011, NIPPON TELEGRAPH AND TELEPHONE CORPORATION
 * Portions Copyright (c) 2011, Itagaki Takahiro
 * Portions Copyright (c) 2012-2020, The Reorg Development Team
 *-------------------------------------------------------------------------
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FRONTEND</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgut-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/username.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_GETOPT_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;getopt_long.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>host</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>port</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>username</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>password</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>YesNo</name></type>		<name>prompt_password</name> <init>= <expr><name>DEFAULT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PGconn</name>	   <modifier>*</modifier></type><name>connection</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PGconn</name>     <modifier>*</modifier></type><name>conn2</name>      <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>worker_conns</name></type> <name>workers</name>   <init>= <expr><block>{
	<expr><operator>.</operator><name>num_workers</name>     <operator>=</operator> <literal type="number">0</literal></expr>,
	<expr><operator>.</operator><name>conns</name>           <operator>=</operator> <name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>parse_pair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>buffer</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>key</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>value</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Set up worker conns which will be used for concurrent index rebuilds.
 * 'num_workers' is the desired number of worker connections, i.e. from
 * --jobs flag. Due to max_connections we might not actually be able to
 * set up that many workers, but don't treat that as a fatal error.
 */</comment>
<function><type><name>void</name></type>
<name>setup_workers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_workers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
 	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>
 	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
 	<decl_stmt><decl><type><name>PGconn</name> <modifier>*</modifier></type><name>conn</name></decl>;</decl_stmt>

 	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"In setup_workers(), target num_workers = %d"</literal></expr></argument>, <argument><expr><name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 	<if_stmt><if>if <condition>(<expr><name>num_workers</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>num_workers</name> <operator>&gt;</operator> <name><name>workers</name><operator>.</operator><name>num_workers</name></name></expr>)</condition>
 	<block>{<block_content>
 		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>&amp;&amp;</operator> <name><name>dbname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
 			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dbname=%s "</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
 		<if_stmt><if>if <condition>(<expr><name>host</name> <operator>&amp;&amp;</operator> <name><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
 			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"host=%s "</literal></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
 		<if_stmt><if>if <condition>(<expr><name>port</name> <operator>&amp;&amp;</operator> <name><name>port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
 			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"port=%s "</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
 		<if_stmt><if>if <condition>(<expr><name>username</name> <operator>&amp;&amp;</operator> <name><name>username</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
 			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"user=%s "</literal></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
 		<if_stmt><if>if <condition>(<expr><name>password</name> <operator>&amp;&amp;</operator> <name><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
 			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"password=%s "</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

 		<if_stmt><if>if <condition>(<expr><name><name>workers</name><operator>.</operator><name>conns</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
 		<block>{<block_content>
 			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Setting up workers.conns"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 			<expr_stmt><expr><name><name>workers</name><operator>.</operator><name>conns</name></name> <operator>=</operator> <operator>(</operator><name>PGconn</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PGconn</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_workers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		</block_content>}</block></if>
 		<else>else
 		<block>{<block_content>
 			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"TODO: Implement pool resizing."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 		</block_content>}</block></else></if_stmt>

 		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
 		<block>{<block_content>
 			<comment type="block">/* Don't prompt for password again; we should have gotten
 			 * it already from reconnect().
 			 */</comment>
 			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Setting up worker conn %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

 			<comment type="block">/* Don't confuse pgut_connections by using pgut_connect()
			 *
			 * XXX: could use PQconnectStart() and PQconnectPoll() to
			 * open these connections in non-blocking manner.
			 */</comment>
 			<expr_stmt><expr><name>conn</name> <operator>=</operator> <call><name>PQconnectdb</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 			<if_stmt><if>if <condition>(<expr><call><name>PQstatus</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CONNECTION_OK</name></expr>)</condition>
 			<block>{<block_content>
 				<expr_stmt><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
 			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"Unable to set up worker conn #%d: %s"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
					 <argument><expr><call><name>PQerrorMessage</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Hardcode a search path to avoid injections into public or pg_temp */</comment>
			<expr_stmt><expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"SET search_path TO pg_catalog, pg_temp, public"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <comment type="block">/* Make sure each worker connection can work in non-blocking
             * mode.
             */</comment>
            <if_stmt><if>if <condition>(<expr><call><name>PQsetnonblocking</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unable to set worker connection %d "</literal>
					 <literal type="string">"non-blocking."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
 		</block_content>}</block></for>
		<comment type="block">/* In case we bailed out of setting up all workers, record
		 * how many successful worker conns we actually have.
		 */</comment>
 		<expr_stmt><expr><name><name>workers</name><operator>.</operator><name>num_workers</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

 		<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Disconnect all our worker conns. */</comment>
<function><type><name>void</name></type> <name>disconnect_workers</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
 	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

 	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>workers</name><operator>.</operator><name>num_workers</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
 		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"No workers to disconnect."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
 	<else>else
 	<block>{<block_content>
 		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>workers</name><operator>.</operator><name>num_workers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
 		<block>{<block_content>
 			<if_stmt><if>if <condition>(<expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
 			<block>{<block_content>
 				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"Disconnecting worker %d."</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 				<expr_stmt><expr><call><name>PQfinish</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 				<expr_stmt><expr><name><name>workers</name><operator>.</operator><name>conns</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
 			</block_content>}</block></if>
 			<else>else
 			<block>{<block_content>
 				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"Worker %d already disconnected?"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
 			</block_content>}</block></else></if_stmt>
 		</block_content>}</block></for>
 		<expr_stmt><expr><name><name>workers</name><operator>.</operator><name>num_workers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
 		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>workers</name><operator>.</operator><name>conns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workers</name><operator>.</operator><name>conns</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
 	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * the result is also available with the global variable 'connection'.
 */</comment>
<function><type><name>void</name></type>
<name>reconnect</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>new_password</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>disconnect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>&amp;&amp;</operator> <name><name>dbname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dbname=%s "</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>host</name> <operator>&amp;&amp;</operator> <name><name>host</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"host=%s "</literal></expr></argument>, <argument><expr><name>host</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>port</name> <operator>&amp;&amp;</operator> <name><name>port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"port=%s "</literal></expr></argument>, <argument><expr><name>port</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>username</name> <operator>&amp;&amp;</operator> <name><name>username</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"user=%s "</literal></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>password</name> <operator>&amp;&amp;</operator> <name><name>password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"password=%s "</literal></expr></argument>, <argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>connection</name> <operator>=</operator> <call><name>pgut_connect</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conn2</name>      <operator>=</operator> <call><name>pgut_connect</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>prompt_password</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update password */</comment>
	<if_stmt><if>if <condition>(<expr><name>connection</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_password</name> <operator>=</operator> <call><name>PQpass</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>new_password</name> <operator>&amp;&amp;</operator> <name><name>new_password</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>password</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>new_password</name></expr></argument>, <argument><expr><name>password</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>password</name> <operator>=</operator> <call><name>pgut_strdup</name><argument_list>(<argument><expr><name>new_password</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>termStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>disconnect</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>connection</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgut_disconnect</name><argument_list>(<argument><expr><name>connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>connection</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>conn2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pgut_disconnect</name><argument_list>(<argument><expr><name>conn2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>conn2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>disconnect_workers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>option_from_env</name><parameter_list>(<parameter><decl><type><name>pgut_option</name></type> <name><name>options</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>options</name> <operator>&amp;&amp;</operator> <name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>pgut_option</name>	   <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>&amp;</operator><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>			<name><name>name</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>source</name></name> <operator>&gt;</operator> <name>SOURCE_ENV</name> <operator>||</operator>
			<name><name>opt</name><operator>-&gt;</operator><name>allowed</name></name> <operator>==</operator> <name>SOURCE_DEFAULT</name> <operator>||</operator> <name><name>opt</name><operator>-&gt;</operator><name>allowed</name></name> <operator>&gt;</operator> <name>SOURCE_ENV</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>opt</name><operator>-&gt;</operator><name>lname</name></name></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"-_ "</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* - to _ */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>toupper</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pgut_setopt</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>SOURCE_ENV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* compare two strings ignore cases and ignore -_ */</comment>
<function><type><name>bool</name></type>
<name>pgut_keyeq</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lhs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rhs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>lhs</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>rhs</name></expr>;</condition> <incr><expr><name>lhs</name><operator>++</operator></expr><operator>,</operator> <expr><name>rhs</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"-_ "</literal></expr></argument>, <argument><expr><operator>*</operator><name>lhs</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"-_ "</literal></expr></argument>, <argument><expr><operator>*</operator><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>ToLower</name><argument_list>(<argument><expr><operator>*</operator><name>lhs</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>ToLower</name><argument_list>(<argument><expr><operator>*</operator><name>rhs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><operator>*</operator><name>lhs</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>rhs</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>pgut_setopt</name><parameter_list>(<parameter><decl><type><name>pgut_option</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>optarg</name></decl></parameter>, <parameter><decl><type><name>pgut_optsrc</name></type> <name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	  <modifier>*</modifier></type><name>message</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>opt</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"Try \"%s --help\" for more information.\n"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>source</name></name> <operator>&gt;</operator> <name>src</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* high prior value has been set already. */</comment>
		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>src</name> <operator>&gt;=</operator> <name>SOURCE_CMDLINE</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>source</name></name> <operator>&gt;=</operator> <name>src</name> <operator>&amp;&amp;</operator> <name><name>opt</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <literal type="char">'l'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* duplicated option in command line -- don't worry if the option
		 * type is 'l' i.e. SimpleStringList, since we are allowed to have
		 * multiples of these.
		 */</comment>
		<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"specified only once"</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* can be overwritten if non-command line source */</comment>
		<expr_stmt><expr><name><name>opt</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'b'</literal></expr>:</case>
			<case>case <expr><literal type="char">'B'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>optarg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name><operator>)</operator> <operator>=</operator> <operator>(</operator><name><name>opt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'b'</literal><operator>)</operator></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><call><name>parse_bool</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<return>return;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a boolean"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'f'</literal></expr>:</case>
				<expr_stmt><expr><operator>(</operator><operator>(</operator><name>pgut_optfn</name><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name><operator>)</operator><operator>(</operator><name>opt</name><operator>,</operator> <name>optarg</name><operator>)</operator></expr>;</expr_stmt>
				<return>return;</return>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>parse_int32</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a 32bit signed integer"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a List"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>simple_string_list_append</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			<case>case <expr><literal type="char">'u'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>parse_uint32</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a 32bit unsigned integer"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'I'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>parse_int64</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a 64bit signed integer"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'U'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>parse_uint64</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a 64bit unsigned integer"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>source</name></name> <operator>!=</operator> <name>SOURCE_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <call><name>pgut_strdup</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>parse_time</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a time"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'y'</literal></expr>:</case>
			<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>optarg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><operator>(</operator><name>YesNo</name> <operator>*</operator><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>opt</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <literal type="char">'y'</literal></expr> ?</condition><then> <expr><name>YES</name></expr> </then><else>: <expr><name>NO</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>bool</name></type>	<name>value</name></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>parse_bool</name><argument_list>(<argument><expr><name>optarg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><operator>(</operator><name>YesNo</name> <operator>*</operator><operator>)</operator> <name><name>opt</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>value</name></expr> ?</condition><then> <expr><name>YES</name></expr> </then><else>: <expr><name>NO</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
						<return>return;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>message</name> <operator>=</operator> <literal type="string">"a boolean"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid option type: %c"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isprint</name><argument_list>(<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option -%c, --%s should be %s: '%s'"</literal></expr></argument>,
				<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>sname</name></name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>lname</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>EINVAL</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"option --%s should be %s: '%s'"</literal></expr></argument>,
				<argument><expr><name><name>opt</name><operator>-&gt;</operator><name>lname</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get configuration from configuration file.
 */</comment>
<function><type><name>void</name></type>
<name>pgut_readopt</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>pgut_option</name></type> <name><name>options</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>key</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>	<name><name>value</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>options</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fp</name> <operator>=</operator> <call><name>pgut_fopen</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="string">"Rt"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>lengthof</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>IsSpace</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></for>

		<if_stmt><if>if <condition>(<expr><call><name>parse_pair</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>pgut_option</name> <modifier>*</modifier></type><name>opt</name> <init>= <expr><operator>&amp;</operator><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>pgut_keyeq</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>lname</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>allowed</name></name> <operator>==</operator> <name>SOURCE_DEFAULT</name> <operator>||</operator>
						<name><name>opt</name><operator>-&gt;</operator><name>allowed</name></name> <operator>&gt;</operator> <name>SOURCE_FILE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"option %s cannot specified in file"</literal></expr></argument>, <argument><expr><name><name>opt</name><operator>-&gt;</operator><name>lname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name><name>opt</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>SOURCE_FILE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pgut_setopt</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>SOURCE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>options</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><literal type="string">"invalid option \"%s\""</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>skip_space</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><call><name>IsSpace</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt> </block_content>}</block></while>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_next_token</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>s</name> <operator>=</operator> <call><name>skip_space</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* parse quoted string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				<switch>switch <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'b'</literal></expr>:</case>
						<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\b'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'f'</literal></expr>:</case>
						<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\f'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'n'</literal></expr>:</case>
						<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'r'</literal></expr>:</case>
						<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'t'</literal></expr>:</case>
						<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\t'</literal></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'0'</literal></expr>:</case>
					<case>case <expr><literal type="char">'1'</literal></expr>:</case>
					<case>case <expr><literal type="char">'2'</literal></expr>:</case>
					<case>case <expr><literal type="char">'3'</literal></expr>:</case>
					<case>case <expr><literal type="char">'4'</literal></expr>:</case>
					<case>case <expr><literal type="char">'5'</literal></expr>:</case>
					<case>case <expr><literal type="char">'6'</literal></expr>:</case>
					<case>case <expr><literal type="char">'7'</literal></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>long</name></type>		<name>octVal</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

							<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init>
								 <condition><expr><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'7'</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition>
									 <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
								<expr_stmt><expr><name>octVal</name> <operator>=</operator> <operator>(</operator><name>octVal</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>s</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></for>
							<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char</name><operator>)</operator> <name>octVal</name><operator>)</operator></expr>;</expr_stmt>
						</block_content>}</block>
						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				<comment type="block">/* doubled quote becomes just one quote */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<break>break;</break></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"# \n\r\t\v"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>dst</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>s</name> <operator>+</operator> <name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_pair</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>buffer</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>key</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>value</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>value</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * parse key
	 */</comment>
	<expr_stmt><expr><name>start</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>start</name> <operator>=</operator> <call><name>skip_space</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="string">"=# \n\r\t\v"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* skip blank buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>end</name> <operator>-</operator> <name>start</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>start</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"syntax error in \"%s\""</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* key found */</comment>
	<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><index>[<expr><name>end</name> <operator>-</operator> <name>start</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* find key and value split char */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>start</name> <operator>=</operator> <call><name>skip_space</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"syntax error in \"%s\""</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>start</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * parse value
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>end</name> <operator>=</operator> <call><name>get_next_token</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>start</name> <operator>=</operator> <call><name>skip_space</name><argument_list>(<argument><expr><name>end</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>start</name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"syntax error in \"%s\""</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * execute - Execute a SQL and return the result.
 */</comment>
<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>execute</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pgut_execute</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>PGresult</name> <modifier>*</modifier></type>
<name>execute_elevel</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pgut_execute_elevel</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * command - Execute a SQL and discard the result.
 */</comment>
<function><type><name>ExecStatusType</name></type>
<name>command</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nParams</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>pgut_command</name><argument_list>(<argument><expr><name>connection</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>nParams</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_elevel</name><parameter_list>(<parameter><decl><type><name>pgut_option</name> <modifier>*</modifier></type><name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>pgut_log_level</name> <operator>=</operator> <call><name>parse_elevel</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>pgut_option</name></type> <name><name>default_options</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="string">"echo"</literal></expr>			, <expr><operator>&amp;</operator><name>pgut_echo</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">'E'</literal></expr>, <expr><literal type="string">"elevel"</literal></expr>		, <expr><name>set_elevel</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="string">"dbname"</literal></expr>		, <expr><operator>&amp;</operator><name>dbname</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'h'</literal></expr>, <expr><literal type="string">"host"</literal></expr>			, <expr><operator>&amp;</operator><name>host</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'p'</literal></expr>, <expr><literal type="string">"port"</literal></expr>			, <expr><operator>&amp;</operator><name>port</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'s'</literal></expr>, <expr><literal type="char">'U'</literal></expr>, <expr><literal type="string">"username"</literal></expr>		, <expr><operator>&amp;</operator><name>username</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'Y'</literal></expr>, <expr><literal type="char">'w'</literal></expr>, <expr><literal type="string">"no-password"</literal></expr>	, <expr><operator>&amp;</operator><name>prompt_password</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="char">'y'</literal></expr>, <expr><literal type="char">'W'</literal></expr>, <expr><literal type="string">"password"</literal></expr>		, <expr><operator>&amp;</operator><name>prompt_password</name></expr> }</block></expr>,
	<expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>option_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pgut_option</name></type> <name><name>opts</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>len</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>opts</name> <operator>&amp;&amp;</operator> <name><name>opts</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> </block_content>}</block></for>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>pgut_option</name> <modifier>*</modifier></type>
<name>option_find</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>pgut_option</name></type> <name><name>opts1</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>pgut_option</name></type> <name><name>opts2</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>opts1</name> <operator>&amp;&amp;</operator> <name><name>opts1</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>opts1</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>opts1</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>opts2</name> <operator>&amp;&amp;</operator> <name><name>opts2</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>opts2</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>opts2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>NULL</name></expr>;</return>	<comment type="block">/* not found */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>option_has_arg</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'b'</literal></expr>:</case>
		<case>case <expr><literal type="char">'B'</literal></expr>:</case>
		<case>case <expr><literal type="char">'y'</literal></expr>:</case>
		<case>case <expr><literal type="char">'Y'</literal></expr>:</case>
			<return>return <expr><name>no_argument</name></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>required_argument</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>option_copy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>option</name></name></type> <name><name>dst</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pgut_option</name></type> <name><name>opts</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>has_arg</name> <operator>=</operator> <call><name>option_has_arg</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flag</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>val</name> <operator>=</operator> <name><name>opts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sname</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type>
<name>option_merge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>pgut_option</name></type> <name><name>opts1</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>pgut_option</name></type> <name><name>opts2</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>len1</name> <init>= <expr><call><name>option_length</name><argument_list>(<argument><expr><name>opts1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>len2</name> <init>= <expr><call><name>option_length</name><argument_list>(<argument><expr><name>opts2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>n</name> <init>= <expr><name>len1</name> <operator>+</operator> <name>len2</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgut_newarray</name><argument_list>(<argument><expr>struct <name>option</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>option_copy</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>opts1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>option_copy</name><argument_list>(<argument><expr><name>result</name> <operator>+</operator> <name>len1</name></expr></argument>, <argument><expr><name>opts2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>result</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>pgut_option</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>longopts_to_optstring</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>option</name></name></type> <name><name>opts</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>	<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>opts</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control> <block>{<block_content> </block_content>}</block></for>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pgut_malloc</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>opts</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</condition> <incr><expr><name>len</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isprint</name><argument_list>(<argument><expr><name><name>opts</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <name><name>opts</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>val</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>opts</name><index>[<expr><name>len</name></expr>]</index></name><operator>.</operator><name>has_arg</name> <operator>!=</operator> <name>no_argument</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="char">':'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>pgut_getopt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>pgut_option</name></type> <name><name>options</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>					<name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>optindex</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>			   <modifier>*</modifier></type><name>optstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>option</name></name>	   <modifier>*</modifier></type><name>longopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pgut_option</name>		   <modifier>*</modifier></type><name>opt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pgut_init</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Help message and version are handled at first. */</comment>
	<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--help"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-?"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>help</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--version"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-V"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><name>PROGRAM_NAME</name></expr></argument>, <argument><expr><name>PROGRAM_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"--configuration"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>PG_VERSION_STR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Merge default and user options. */</comment>
	<expr_stmt><expr><name>longopts</name> <operator>=</operator> <call><name>option_merge</name><argument_list>(<argument><expr><name>default_options</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>optstring</name> <operator>=</operator> <call><name>longopts_to_optstring</name><argument_list>(<argument><expr><name>longopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assign named options */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <call><name>getopt_long</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>optstring</name></expr></argument>, <argument><expr><name>longopts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>optindex</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>option_find</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>default_options</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgut_setopt</name><argument_list>(<argument><expr><name>opt</name></expr></argument>, <argument><expr><name>optarg</name></expr></argument>, <argument><expr><name>SOURCE_CMDLINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Read environment variables */</comment>
	<expr_stmt><expr><call><name>option_from_env</name><argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <operator>(</operator><name>dbname</name> <operator>||</operator>
	<operator>(</operator><name>dbname</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATABASE"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	<operator>(</operator><name>dbname</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGUSER"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
	<operator>(</operator><name>dbname</name> <operator>=</operator> <call><name>get_user_name_or_exit</name><argument_list>(<argument><expr><name>PROGRAM_NAME</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>optind</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>help</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>details</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pgut_help</name><argument_list>(<argument><expr><name>details</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>details</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nConnection options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -d, --dbname=DBNAME       database to connect\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -h, --host=HOSTNAME       database server host or socket directory\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -p, --port=PORT           database server port\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -U, --username=USERNAME   user name to connect as\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -w, --no-password         never prompt for password\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -W, --password            force password prompt\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\nGeneric options:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>details</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -e, --echo                echo queries\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  -E, --elevel=LEVEL        set output message level\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  --help                    show this help, then exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"  --version                 output version information, then exit\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>details</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>PROGRAM_URL</name> <operator>||</operator> <name>PROGRAM_ISSUES</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>PROGRAM_URL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Read the website for details: &lt;%s&gt;.\n"</literal></expr></argument>, <argument><expr><name>PROGRAM_URL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>PROGRAM_ISSUES</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"Report bugs to &lt;%s&gt;.\n"</literal></expr></argument>, <argument><expr><name>PROGRAM_ISSUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
