<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/build/src/extern_iowow/src/utils/iwavl.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iwavl.h"</cpp:file></cpp:include>

<comment type="block">/*
 * avl_tree.c - intrusive, nonrecursive AVL tree data structure (self-balancing
 *		binary search tree), implementation file
 *
 * Written in 2014-2016 by Eric Biggers &lt;ebiggers3@gmail.com&gt;
 *
 * To the extent possible under law, the author(s) have dedicated all copyright
 * and related and neighboring rights to this software to the public domain
 * worldwide via the Creative Commons Zero 1.0 Universal Public Domain
 * Dedication (the "CC0").
 *
 * This software is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the CC0 for more details.
 *
 * You should have received a copy of the CC0 along with this software; if not
 * see &lt;http://creativecommons.org/publicdomain/zero/1.0/&gt;.
 */</comment>


<comment type="block">/* Returns the left child (sign &lt; 0) or the right child (sign &gt; 0) of the
 * specified AVL tree node.
 * Note: for all calls of this, 'sign' is constant at compilation time,
 * so the compiler can remove the conditional.  */</comment>
<function><type><name>IW_INLINE</name> <name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_get_child</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name><name>parent</name><operator>-&gt;</operator><name>right</name></name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>IW_INLINE</name> <name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_first_or_last_in_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>first</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>first</name> <operator>=</operator> <call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator>struct <name>iwavl_node</name><operator>*</operator><operator>)</operator> <name>first</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Starts an in-order traversal of the tree: returns the least-valued node, or
 * 0 if the tree is empty.  */</comment>
<function><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_first_in_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>iwavl_first_or_last_in_order</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Starts a *reverse* in-order traversal of the tree: returns the
 * greatest-valued node, or 0 if the tree is empty.  */</comment>
<function><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_last_in_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>iwavl_first_or_last_in_order</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>IW_INLINE</name> <name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_next_or_prev_in_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><expr><name>next</name> <operator>=</operator> <call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>next</name> <operator>=</operator> <call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
      <empty_stmt>;</empty_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <for>for <control>(<init><expr><name>next</name> <operator>=</operator> <call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</init>
         <condition><expr><name>next</name> <operator>&amp;&amp;</operator> <name>node</name> <operator>==</operator> <call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>next</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</condition>
         <incr><expr><name>node</name> <operator>=</operator> <name>next</name></expr><operator>,</operator> <expr><name>next</name> <operator>=</operator> <call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
      <empty_stmt>;</empty_stmt>
    </block_content>}</block></for>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><operator>(</operator>struct <name>iwavl_node</name><operator>*</operator><operator>)</operator> <name>next</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Continues an in-order traversal of the tree: returns the next-greatest-valued
 * node, or 0 if there is none.  */</comment>
<function><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_next_in_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>iwavl_next_or_prev_in_order</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Continues a *reverse* in-order traversal of the tree: returns the
 * previous-greatest-valued node, or 0 if there is none.  */</comment>
<function><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_prev_in_order</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>iwavl_next_or_prev_in_order</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Starts a postorder traversal of the tree.  */</comment>
<function><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_first_in_postorder</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>first</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>
    <while>while <condition>(<expr><name><name>first</name><operator>-&gt;</operator><name>left</name></name> <operator>||</operator> <name><name>first</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>first</name> <operator>=</operator> <ternary><condition><expr><name><name>first</name><operator>-&gt;</operator><name>left</name></name></expr> ?</condition><then> <expr><name><name>first</name><operator>-&gt;</operator><name>left</name></name></expr> </then><else>: <expr><name><name>first</name><operator>-&gt;</operator><name>right</name></name></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>(</operator>struct <name>iwavl_node</name><operator>*</operator><operator>)</operator> <name>first</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Continues a postorder traversal of the tree.  @prev will not be deferenced as
 * it's allowed that its memory has been freed; @prev_parent must be its saved
 * parent node.  Returns 0 if there are no more nodes (i.e. @prev was the
 * root of the tree).  */</comment>
<function><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>iwavl_next_in_postorder</name><parameter_list>(
  <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>prev</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>prev_parent</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>prev_parent</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>next</name> <operator>&amp;&amp;</operator> <name>prev</name> <operator>==</operator> <name><name>next</name><operator>-&gt;</operator><name>left</name></name> <operator>&amp;&amp;</operator> <name><name>next</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition> <block>{<block_content>
    <for>for <control>(<init><expr><name>next</name> <operator>=</operator> <name><name>next</name><operator>-&gt;</operator><name>right</name></name></expr>;</init>
         <condition><expr><name><name>next</name><operator>-&gt;</operator><name>left</name></name> <operator>||</operator> <name><name>next</name><operator>-&gt;</operator><name>right</name></name></expr>;</condition>
         <incr><expr><name>next</name> <operator>=</operator> <ternary><condition><expr><name><name>next</name><operator>-&gt;</operator><name>left</name></name></expr> ?</condition><then> <expr><name><name>next</name><operator>-&gt;</operator><name>left</name></name></expr> </then><else>: <expr><name><name>next</name><operator>-&gt;</operator><name>right</name></name></expr></else></ternary></expr></incr>)</control> <block>{<block_content>
      <empty_stmt>;</empty_stmt>
    </block_content>}</block></for>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><operator>(</operator>struct <name>iwavl_node</name><operator>*</operator><operator>)</operator> <name>next</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Sets the left child (sign &lt; 0) or the right child (sign &gt; 0) of the
 * specified AVL tree node.
 * Note: for all calls of this, 'sign' is constant at compilation time,
 * so the compiler can remove the conditional.  */</comment>
<function><type><name>IW_INLINE</name> <name>void</name></type> <name>avl_set_child</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>child</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>sign</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Sets the parent and balance factor of the specified AVL tree node.  */</comment>
<function><type><name>IW_INLINE</name> <name>void</name></type> <name>avl_set_parent_balance</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>balance_factor</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent_balance</name></name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>parent</name> <operator>|</operator> <operator>(</operator><name>balance_factor</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Sets the parent of the specified AVL tree node.  */</comment>
<function><type><name>IW_INLINE</name> <name>void</name></type> <name>avl_set_parent</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>parent</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent_balance</name></name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator> <name>parent</name> <operator>|</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>parent_balance</name></name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Returns the balance factor of the specified AVL tree node --- that is, the
 * height of its right subtree minus the height of its left subtree.  */</comment>
<function><type><name>IW_INLINE</name> <name>int</name></type> <name>avl_get_balance_factor</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>parent_balance</name></name> <operator>&amp;</operator> <literal type="number">3</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Adds @amount to the balance factor of the specified AVL tree node.
 * The caller must ensure this still results in a valid balance factor
 * (-1, 0, or 1).  */</comment>
<function><type><name>IW_INLINE</name> <name>void</name></type> <name>avl_adjust_balance_factor</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parent_balance</name></name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>IW_INLINE</name> <name>void</name></type> <name>avl_replace_child</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name>  <modifier>*</modifier></type><name>parent</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name>  <modifier>*</modifier></type><name>old_child</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name>  <modifier>*</modifier></type><name>new_child</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>old_child</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>new_child</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>new_child</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>root_ptr</name> <operator>=</operator> <name>new_child</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Template for performing a single rotation ---
 *
 * sign &gt; 0:  Rotate clockwise (right) rooted at A:
 *
 *           P?            P?
 *           |             |
 *           A             B
 *          / \           / \
 *         B   C?  =&gt;    D?  A
 *        / \               / \
 *       D?  E?            E?  C?
 *
 * (nodes marked with ? may not exist)
 *
 * sign &lt; 0:  Rotate counterclockwise (left) rooted at A:
 *
 *           P?            P?
 *           |             |
 *           A             B
 *          / \           / \
 *         C?  B   =&gt;    A   D?
 *            / \       / \
 *           E?  D?    C?  E?
 *
 * This updates pointers but not balance factors!
 */</comment>
<function><type><name>IW_INLINE</name> <name>void</name></type> <name>avl_rotate</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier><modifier>*</modifier> <specifier>const</specifier></type> <name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>sign</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>B</name> <init>= <expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>E</name> <init>= <expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>P</name> <init>= <expr><call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>avl_set_child</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>avl_set_child</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>E</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>avl_replace_child</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Template for performing a double rotation ---
 *
 * sign &gt; 0:  Rotate counterclockwise (left) rooted at B, then
 *		     clockwise (right) rooted at A:
 *
 *           P?            P?          P?
 *           |             |           |
 *           A             A           E
 *          / \           / \        /   \
 *         B   C?  =&gt;    E   C? =&gt;  B     A
 *        / \           / \        / \   / \
 *       D?  E         B   G?     D?  F?G?  C?
 *          / \       / \
 *         F?  G?    D?  F?
 *
 * (nodes marked with ? may not exist)
 *
 * sign &lt; 0:  Rotate clockwise (right) rooted at B, then
 *		     counterclockwise (left) rooted at A:
 *
 *         P?          P?              P?
 *         |           |               |
 *         A           A               E
 *        / \         / \            /   \
 *       C?  B   =&gt;  C?  E    =&gt;    A     B
 *          / \         / \        / \   / \
 *         E   D?      G?  B      C?  G?F?  D?
 *        / \             / \
 *       G?  F?          F?  D?
 *
 * Returns a pointer to E and updates balance factors.  Except for those
 * two things, this function is equivalent to:
 *	avl_rotate(root_ptr, B, -sign);
 *	avl_rotate(root_ptr, A, +sign);
 *
 * See comment in avl_handle_subtree_growth() for explanation of balance
 * factor updates.
 */</comment>
<function><type><name>IW_INLINE</name> <name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>avl_do_double_rotate</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier><modifier>*</modifier> <specifier>const</specifier></type> <name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>B</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>sign</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>E</name> <init>= <expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>F</name> <init>= <expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>G</name> <init>= <expr><call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type> <name>P</name> <init>= <expr><call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>e</name> <init>= <expr><call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>E</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>avl_set_child</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>, <argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_parent_balance</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>sign</name> <operator>*</operator> <name>e</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><name>e</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>avl_set_child</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>, <argument><expr><name>F</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_parent_balance</name><argument_list>(<argument><expr><name>B</name></expr></argument>, <argument><expr><name>E</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>sign</name> <operator>*</operator> <name>e</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><name>e</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>avl_set_child</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><operator>+</operator><name>sign</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_child</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_parent_balance</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>G</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>F</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>F</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>avl_replace_child</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>E</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function handles the growth of a subtree due to an insertion.
 *
 * @root_ptr
 *	Location of the tree's root pointer.
 *
 * @node
 *	A subtree that has increased in height by 1 due to an insertion.
 *
 * @parent
 *	Parent of @node; must not be 0.
 *
 * @sign
 *	-1 if @node is the left child of @parent;
 *	+1 if @node is the right child of @parent.
 *
 * This function will adjust @parent's balance factor, then do a (single
 * or double) rotation if necessary.  The return value will be %true if
 * the full AVL tree is now adequately balanced, or %false if the subtree
 * rooted at @parent is now adequately balanced but has increased in
 * height by 1, so the caller should continue up the tree.
 *
 * Note that if %false is returned, no rotation will have been done.
 * Indeed, a single node insertion cannot require that more than one
 * (single or double) rotation be done.
 */</comment>
<function><type><name>IW_INLINE</name> <name>bool</name></type> <name>avl_handle_subtree_growth</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier><modifier>*</modifier> <specifier>const</specifier></type> <name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type>  <name>node</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier> <specifier>const</specifier></type>  <name>parent</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>int</name></type>                 <name>sign</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>old_balance_factor</name></decl>, <decl><type ref="prev"/><name>new_balance_factor</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>old_balance_factor</name> <operator>=</operator> <call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>old_balance_factor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* @parent is still sufficiently balanced (-1 or +1
     * balance factor), but must have increased in height.
     * Continue up the tree.  */</comment>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>new_balance_factor</name> <operator>=</operator> <name>old_balance_factor</name> <operator>+</operator> <name>sign</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>new_balance_factor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* @parent is now perfectly balanced (0 balance factor).
     * It cannot have increased in height, so there is
     * nothing more to do.  */</comment>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* @parent is too left-heavy (new_balance_factor == -2) or
   * too right-heavy (new_balance_factor == +2).  */</comment>

  <comment type="block">/* Test whether @node is left-heavy (-1 balance factor) or
   * right-heavy (+1 balance factor).
   * Note that it cannot be perfectly balanced (0 balance factor)
   * because here we are under the invariant that @node has
   * increased in height due to the insertion.  */</comment>
  <if_stmt><if>if <condition>(<expr><name>sign</name> <operator>*</operator> <call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* @node (B below) is heavy in the same direction @parent
     * (A below) is heavy.
     *
     * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     * The comment, diagram, and equations below assume sign &lt; 0.
     * The other case is symmetric!
     * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     *
     * Do a clockwise rotation rooted at @parent (A below):
     *
     *           A              B
     *          / \           /   \
     *         B   C?  =&gt;    D     A
     *        / \           / \   / \
     *       D   E?        F?  G?E?  C?
     *      / \
     *     F?  G?
     *
     * Before the rotation:
     *	balance(A) = -2
     *	balance(B) = -1
     * Let x = height(C).  Then:
     *	height(B) = x + 2
     *	height(D) = x + 1
     *	height(E) = x
     *	max(height(F), height(G)) = x.
     *
     * After the rotation:
     *	height(D) = max(height(F), height(G)) + 1
     *		  = x + 1
     *	height(A) = max(height(E), height(C)) + 1
     *		  = max(x, x) + 1 = x + 1
     *	balance(B) = 0
     *	balance(A) = 0
     */</comment>
    <expr_stmt><expr><call><name>avl_rotate</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Equivalent to setting @parent's balance factor to 0.  */</comment>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* A */</comment>

    <comment type="block">/* Equivalent to setting @node's balance factor to 0.  */</comment>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>   <comment type="block">/* B */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* @node (B below) is heavy in the direction opposite
     * from the direction @parent (A below) is heavy.
     *
     * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     * The comment, diagram, and equations below assume sign &lt; 0.
     * The other case is symmetric!
     * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
     *
     * Do a counterblockwise rotation rooted at @node (B below),
     * then a clockwise rotation rooted at @parent (A below):
     *
     *           A             A           E
     *          / \           / \        /   \
     *         B   C?  =&gt;    E   C? =&gt;  B     A
     *        / \           / \        / \   / \
     *       D?  E         B   G?     D?  F?G?  C?
     *          / \       / \
     *         F?  G?    D?  F?
     *
     * Before the rotation:
     *	balance(A) = -2
     *	balance(B) = +1
     * Let x = height(C).  Then:
     *	height(B) = x + 2
     *	height(E) = x + 1
     *	height(D) = x
     *	max(height(F), height(G)) = x
     *
     * After both rotations:
     *	height(A) = max(height(G), height(C)) + 1
     *		  = x + 1
     *	balance(A) = balance(E{orig}) &gt;= 0 ? 0 : -balance(E{orig})
     *	height(B) = max(height(D), height(F)) + 1
     *		  = x + 1
     *	balance(B) = balance(E{orig} &lt;= 0) ? 0 : -balance(E{orig})
     *
     *	height(E) = x + 2
     *	balance(E) = 0
     */</comment>
    <expr_stmt><expr><call><name>avl_do_double_rotate</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Height after rotation is unchanged; nothing more to do.  */</comment>
  <return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Rebalance the tree after insertion of the specified node.  */</comment>
<function><type><name>void</name></type> <name>iwavl_rebalance_after_insert</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name>  <modifier>*</modifier></type><name>inserted</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>done</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>inserted</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>inserted</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>node</name> <operator>=</operator> <name>inserted</name></expr>;</expr_stmt>

  <comment type="block">/* Adjust balance factor of new node's parent.
   * No rotation will need to be done at this level.  */</comment>

  <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* @parent did not change in height.  Nothing more to do.  */</comment>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="block">/* The subtree rooted at @parent increased in height by 1.  */</comment>

  <do>do <block>{<block_content>
    <comment type="block">/* Adjust balance factor of next ancestor.  */</comment>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>parent</name></expr>)</condition> <block>{<block_content>
      <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* The subtree rooted at @node has increased in height by 1.  */</comment>
    <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>avl_handle_subtree_growth</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                       <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>done</name> <operator>=</operator> <call><name>avl_handle_subtree_growth</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                       <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>!</operator><name>done</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/*
 * This function handles the shrinkage of a subtree due to a deletion.
 *
 * @root_ptr
 *	Location of the tree's root pointer.
 *
 * @parent
 *	A node in the tree, exactly one of whose subtrees has decreased
 *	in height by 1 due to a deletion.  (This includes the case where
 *	one of the child pointers has become 0, since we can consider
 *	the "0" subtree to have a height of 0.)
 *
 * @sign
 *	+1 if the left subtree of @parent has decreased in height by 1;
 *	-1 if the right subtree of @parent has decreased in height by 1.
 *
 * @left_deleted_ret
 *	If the return value is not 0, this will be set to %true if the
 *	left subtree of the returned node has decreased in height by 1,
 *	or %false if the right subtree of the returned node has decreased
 *	in height by 1.
 *
 * This function will adjust @parent's balance factor, then do a (single
 * or double) rotation if necessary.  The return value will be 0 if
 * the full AVL tree is now adequately balanced, or a pointer to the
 * parent of @parent if @parent is now adequately balanced but has
 * decreased in height by 1.  Also in the latter case, *left_deleted_ret
 * will be set.
 */</comment>
<function><type><name>IW_INLINE</name> <name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>avl_handle_subtree_shrink</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier><modifier>*</modifier> <specifier>const</specifier></type> <name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name>        <modifier>*</modifier></type><name>parent</name></decl></parameter>,
  <parameter><decl><type><specifier>const</specifier> <name>int</name></type>                 <name>sign</name></decl></parameter>,
  <parameter><decl><type><name>bool</name><modifier>*</modifier> <specifier>const</specifier></type>               <name>left_deleted_ret</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>old_balance_factor</name></decl>, <decl><type ref="prev"/><name>new_balance_factor</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>old_balance_factor</name> <operator>=</operator> <call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>old_balance_factor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* Prior to the deletion, the subtree rooted at
     * @parent was perfectly balanced.  It's now
     * unbalanced by 1, but that's okay and its height
     * hasn't changed.  Nothing more to do.  */</comment>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>new_balance_factor</name> <operator>=</operator> <name>old_balance_factor</name> <operator>+</operator> <name>sign</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>new_balance_factor</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <comment type="block">/* The subtree rooted at @parent is now perfectly
     * balanced, whereas before the deletion it was
     * unbalanced by 1.  Its height must have decreased
     * by 1.  No rotation is needed at this location,
     * but continue up the tree.  */</comment>
    <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>node</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <comment type="block">/* @parent is too left-heavy (new_balance_factor == -2) or
     * too right-heavy (new_balance_factor == +2).  */</comment>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>iwavl_get_child</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* The rotations below are similar to those done during
     * insertion (see avl_handle_subtree_growth()), so full
     * comments are not provided.  The only new case is the
     * one where @node has a balance factor of 0, and that is
     * commented.  */</comment>

    <if_stmt><if>if <condition>(<expr><name>sign</name> <operator>*</operator> <call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>avl_rotate</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>avl_get_balance_factor</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <comment type="block">/*
         * @node (B below) is perfectly balanced.
         *
         * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         * The comment, diagram, and equations
         * below assume sign &lt; 0.  The other case
         * is symmetric!
         * @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
         *
         * Do a clockwise rotation rooted at
         * @parent (A below):
         *
         *           A              B
         *          / \           /   \
         *         B   C?  =&gt;    D     A
         *        / \           / \   / \
         *       D   E         F?  G?E   C?
         *      / \
         *     F?  G?
         *
         * Before the rotation:
         *	balance(A) = -2
         *	balance(B) =  0
         * Let x = height(C).  Then:
         *	height(B) = x + 2
         *	height(D) = x + 1
         *	height(E) = x + 1
         *	max(height(F), height(G)) = x.
         *
         * After the rotation:
         *	height(D) = max(height(F), height(G)) + 1
         *		  = x + 1
         *	height(A) = max(height(E), height(C)) + 1
         *		  = max(x + 1, x) + 1 = x + 2
         *	balance(A) = -1
         *	balance(B) = +1
         */</comment>

        <comment type="block">/* A: -2 =&gt; -1 (sign &lt; 0)
        * or +2 =&gt; +1 (sign &gt; 0)
        * No change needed --- that's the same as
        * old_balance_factor.  */</comment>

        <comment type="block">/* B: 0 =&gt; +1 (sign &lt; 0)
         * or 0 =&gt; -1 (sign &gt; 0)  */</comment>
        <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Height is unchanged; nothing more to do.  */</comment>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>avl_adjust_balance_factor</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>avl_do_double_rotate</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                  <argument><expr><name>parent</name></expr></argument>, <argument><expr><operator>-</operator><name>sign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>left_deleted_ret</name> <operator>=</operator> <operator>(</operator><name>node</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>left</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>parent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Swaps node X, which must have 2 children, with its in-order successor, then
 * unlinks node X.  Returns the parent of X just before unlinking, without its
 * balance factor having been updated to account for the unlink.  */</comment>
<function><type><name>IW_INLINE</name> <name><name>struct</name> <name>iwavl_node</name></name><modifier>*</modifier></type> <name>avl_tree_swap_with_successor</name><parameter_list>(
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>root_ptr</name></decl></parameter>,
  <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name>  <modifier>*</modifier></type><name>X</name></decl></parameter>,
  <parameter><decl><type><name>bool</name>               <modifier>*</modifier></type><name>left_deleted_ret</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>Y</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>Y</name> <operator>=</operator> <name><name>X</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Y</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/*
     *     P?           P?           P?
     *     |            |            |
     *     X            Y            Y
     *    / \          / \          / \
     *   A   Y    =&gt;  A   X    =&gt;  A   B?
     *      / \          / \
     *    (0)  B?      (0)  B?
     *
     * [ X unlinked, Y returned ]
     */</comment>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Y</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>left_deleted_ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>Q</name></decl>;</decl_stmt>

    <do>do <block>{<block_content>
      <expr_stmt><expr><name>Q</name> <operator>=</operator> <name>Y</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>Y</name> <operator>=</operator> <name><name>Y</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
    </block_content>}</block> while <condition>(<expr><name><name>Y</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition>;</do>

    <comment type="block">/*
     *     P?           P?           P?
     *     |            |            |
     *     X            Y            Y
     *    / \          / \          / \
     *   A   ...  =&gt;  A  ...   =&gt;  A  ...
     *       |            |            |
     *       Q            Q            Q
     *      /            /            /
     *     Y            X            B?
     *    / \          / \
     *  (0)  B?      (0)  B?
     *
     *
     * [ X unlinked, Q returned ]
     */</comment>

    <expr_stmt><expr><name><name>Q</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name><name>Y</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>Q</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name><name>Q</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>Y</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name><name>X</name><operator>-&gt;</operator><name>right</name></name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name><name>X</name><operator>-&gt;</operator><name>right</name></name></expr></argument>, <argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>Q</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>left_deleted_ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>Y</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name><name>X</name><operator>-&gt;</operator><name>left</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name><name>X</name><operator>-&gt;</operator><name>left</name></name></expr></argument>, <argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>Y</name><operator>-&gt;</operator><name>parent_balance</name></name> <operator>=</operator> <name><name>X</name><operator>-&gt;</operator><name>parent_balance</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>avl_replace_child</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>X</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>X</name></expr></argument>, <argument><expr><name>Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Removes an item from the specified AVL tree.
 *
 * @root_ptr
 *	Location of the AVL tree's root pointer.  Indirection is needed
 *	because the root node may change if the tree needed to be rebalanced
 *	because of the deletion or if @node was the root node.
 *
 * @node
 *	Pointer to the `struct iwavl_node' embedded in the item to
 *	remove from the tree.
 *
 * Note: This function *only* removes the node and rebalances the tree.
 * It does not free any memory, nor does it do the equivalent of
 * iwavl_node_set_unlinked().
 */</comment>
<function><type><name>void</name></type> <name>iwavl_remove</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>root_ptr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>left_deleted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* @node is fully internal, with two children.  Swap it
     * with its in-order successor (which must exist in the
     * right subtree of @node and can have, at most, a right
     * child), then unlink @node.  */</comment>
    <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>avl_tree_swap_with_successor</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                          <argument><expr><operator>&amp;</operator><name>left_deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <comment type="block">/* @parent is now the parent of what was @node's in-order
     * successor.  It cannot be 0, since @node itself was
     * an ancestor of its in-order successor.
     * @left_deleted has been set to %true if @node's
     * in-order successor was the left child of @parent,
     * otherwise %false.  */</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>iwavl_node</name></name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

    <comment type="block">/* @node is missing at least one child.  Unlink it.  Set
     * @parent to @node's parent, and set @left_deleted to
     * reflect which child of @parent @node was.  Or, if
     * @node was the root node, simply update the root node
     * and return.  */</comment>
    <expr_stmt><expr><name>child</name> <operator>=</operator> <ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>left</name></name></expr> </then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>right</name></name></expr></else></ternary></expr>;</expr_stmt>
    <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>iwavl_get_parent</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>parent</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>left</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>left</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>left_deleted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>right</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>left_deleted</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>child</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>avl_set_parent</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>root_ptr</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
      <return>return;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="block">/* Rebalance the tree.  */</comment>
  <do>do <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>left_deleted</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>avl_handle_subtree_shrink</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                         <argument><expr><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>avl_handle_subtree_shrink</name><argument_list>(<argument><expr><name>root_ptr</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                         <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>left_deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><name>parent</name></expr>)</condition>;</do>
</block_content>}</block></function>
</unit>
