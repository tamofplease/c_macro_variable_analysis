<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/build/src/extern_iwnet/src/bearssl/ec/ec_prime_i15.c"><comment type="block">/*
 * Copyright (c) 2017 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Parameters for supported curves:
 *   - field modulus p
 *   - R^2 mod p (R = 2^(15k) for the smallest k such that R &gt;= p)
 *   - b*R mod p (b is the second curve equation parameter)
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P256_P</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0111</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x003F</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x1000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x4000</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x0001</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P256_R2</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0111</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x6000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x7FFC</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FBF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FBF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x77FF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x4FFF</literal></expr>, <expr><literal type="number">0x0000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P256_B</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0111</literal></expr>,
	<expr><literal type="number">0x770C</literal></expr>, <expr><literal type="number">0x5EEF</literal></expr>, <expr><literal type="number">0x29C4</literal></expr>, <expr><literal type="number">0x3EC4</literal></expr>, <expr><literal type="number">0x6273</literal></expr>, <expr><literal type="number">0x0486</literal></expr>, <expr><literal type="number">0x4543</literal></expr>, <expr><literal type="number">0x3993</literal></expr>,
	<expr><literal type="number">0x3C01</literal></expr>, <expr><literal type="number">0x6B56</literal></expr>, <expr><literal type="number">0x212E</literal></expr>, <expr><literal type="number">0x57EE</literal></expr>, <expr><literal type="number">0x4882</literal></expr>, <expr><literal type="number">0x204B</literal></expr>, <expr><literal type="number">0x7483</literal></expr>, <expr><literal type="number">0x3C16</literal></expr>,
	<expr><literal type="number">0x0187</literal></expr>, <expr><literal type="number">0x0000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P384_P</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0199</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x0003</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x7FC0</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7EFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x01FF</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P384_R2</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0199</literal></expr>,
	<expr><literal type="number">0x1000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x0001</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0010</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x7F00</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x01FF</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x1000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x2000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P384_B</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0199</literal></expr>,
	<expr><literal type="number">0x7333</literal></expr>, <expr><literal type="number">0x2096</literal></expr>, <expr><literal type="number">0x70D1</literal></expr>, <expr><literal type="number">0x2310</literal></expr>, <expr><literal type="number">0x3020</literal></expr>, <expr><literal type="number">0x6197</literal></expr>, <expr><literal type="number">0x1464</literal></expr>, <expr><literal type="number">0x35BB</literal></expr>,
	<expr><literal type="number">0x70CA</literal></expr>, <expr><literal type="number">0x0117</literal></expr>, <expr><literal type="number">0x1920</literal></expr>, <expr><literal type="number">0x4136</literal></expr>, <expr><literal type="number">0x5FC8</literal></expr>, <expr><literal type="number">0x5713</literal></expr>, <expr><literal type="number">0x4938</literal></expr>, <expr><literal type="number">0x7DD2</literal></expr>,
	<expr><literal type="number">0x4DD2</literal></expr>, <expr><literal type="number">0x4A71</literal></expr>, <expr><literal type="number">0x0220</literal></expr>, <expr><literal type="number">0x683E</literal></expr>, <expr><literal type="number">0x2C87</literal></expr>, <expr><literal type="number">0x4DB1</literal></expr>, <expr><literal type="number">0x7BFF</literal></expr>, <expr><literal type="number">0x6C09</literal></expr>,
	<expr><literal type="number">0x0452</literal></expr>, <expr><literal type="number">0x0084</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P521_P</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x022B</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x07FF</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P521_R2</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x022B</literal></expr>,
	<expr><literal type="number">0x0100</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>P521_B</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x022B</literal></expr>,
	<expr><literal type="number">0x7002</literal></expr>, <expr><literal type="number">0x6A07</literal></expr>, <expr><literal type="number">0x751A</literal></expr>, <expr><literal type="number">0x228F</literal></expr>, <expr><literal type="number">0x71EF</literal></expr>, <expr><literal type="number">0x5869</literal></expr>, <expr><literal type="number">0x20F4</literal></expr>, <expr><literal type="number">0x1EFC</literal></expr>,
	<expr><literal type="number">0x7357</literal></expr>, <expr><literal type="number">0x37E0</literal></expr>, <expr><literal type="number">0x4EEC</literal></expr>, <expr><literal type="number">0x605E</literal></expr>, <expr><literal type="number">0x1652</literal></expr>, <expr><literal type="number">0x26F6</literal></expr>, <expr><literal type="number">0x31FA</literal></expr>, <expr><literal type="number">0x4A8F</literal></expr>,
	<expr><literal type="number">0x6193</literal></expr>, <expr><literal type="number">0x3C2A</literal></expr>, <expr><literal type="number">0x3C42</literal></expr>, <expr><literal type="number">0x48C7</literal></expr>, <expr><literal type="number">0x3489</literal></expr>, <expr><literal type="number">0x6771</literal></expr>, <expr><literal type="number">0x4C57</literal></expr>, <expr><literal type="number">0x5CCD</literal></expr>,
	<expr><literal type="number">0x2725</literal></expr>, <expr><literal type="number">0x545B</literal></expr>, <expr><literal type="number">0x503B</literal></expr>, <expr><literal type="number">0x5B42</literal></expr>, <expr><literal type="number">0x21A0</literal></expr>, <expr><literal type="number">0x2534</literal></expr>, <expr><literal type="number">0x687E</literal></expr>, <expr><literal type="number">0x70E4</literal></expr>,
	<expr><literal type="number">0x1618</literal></expr>, <expr><literal type="number">0x27D7</literal></expr>, <expr><literal type="number">0x0465</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>R2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name>p0i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>point_len</name></decl>;</decl_stmt>
}</block></struct></type> <name>curve_params</name>;</typedef>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type>
<name>id_to_curve</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>curve_params</name></type> <name><name>pp</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{ <expr><name>P256_P</name></expr>, <expr><name>P256_B</name></expr>, <expr><name>P256_R2</name></expr>, <expr><literal type="number">0x0001</literal></expr>,  <expr><literal type="number">65</literal></expr> }</block></expr>,
		<expr><block>{ <expr><name>P384_P</name></expr>, <expr><name>P384_B</name></expr>, <expr><name>P384_R2</name></expr>, <expr><literal type="number">0x0001</literal></expr>,  <expr><literal type="number">97</literal></expr> }</block></expr>,
		<expr><block>{ <expr><name>P521_P</name></expr>, <expr><name>P521_B</name></expr>, <expr><name>P521_R2</name></expr>, <expr><literal type="number">0x0001</literal></expr>, <expr><literal type="number">133</literal></expr> }</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>pp</name><index>[<expr><name>curve</name> <operator>-</operator> <name>BR_EC_secp256r1</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>I15_LEN</name></cpp:macro>   <cpp:value>((BR_MAX_EC_SIZE + 29) / 15)</cpp:value></cpp:define>

<comment type="block">/*
 * Type for a point in Jacobian coordinates:
 * -- three values, x, y and z, in Montgomery representation
 * -- affine coordinates are X = x / z^2 and Y = y / z^3
 * -- for the point at infinity, z = 0
 */</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>c</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><name>I15_LEN</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>jacobian</name>;</typedef>

<comment type="block">/*
 * We use a custom interpreter that uses a dozen registers, and
 * only six operations:
 *    MSET(d, a)       copy a into d
 *    MADD(d, a)       d = d+a (modular)
 *    MSUB(d, a)       d = d-a (modular)
 *    MMUL(d, a, b)    d = a*b (Montgomery multiplication)
 *    MINV(d, a, b)    invert d modulo p; a and b are used as scratch registers
 *    MTZ(d)           clear return value if d = 0
 * Destination of MMUL (d) must be distinct from operands (a and b).
 * There is no such constraint for MSUB and MADD.
 *
 * Registers include the operand coordinates, and temporaries.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSET</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(0x0000 + ((d) &lt;&lt; 8) + ((a) &lt;&lt; 4))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MADD</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(0x1000 + ((d) &lt;&lt; 8) + ((a) &lt;&lt; 4))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSUB</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro>      <cpp:value>(0x2000 + ((d) &lt;&lt; 8) + ((a) &lt;&lt; 4))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MMUL</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(0x3000 + ((d) &lt;&lt; 8) + ((a) &lt;&lt; 4) + (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINV</name><parameter_list>(<parameter><type><name>d</name></type></parameter>, <parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>(0x4000 + ((d) &lt;&lt; 8) + ((a) &lt;&lt; 4) + (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MTZ</name><parameter_list>(<parameter><type><name>d</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>(0x5000 + ((d) &lt;&lt; 8))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENDCODE</name></cpp:macro>         <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/*
 * Registers for the input operands.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P1x</name></cpp:macro>    <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P1y</name></cpp:macro>    <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P1z</name></cpp:macro>    <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P2x</name></cpp:macro>    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P2y</name></cpp:macro>    <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P2z</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * Alternate names for the first input operand.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Px</name></cpp:macro>     <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Py</name></cpp:macro>     <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Pz</name></cpp:macro>     <cpp:value>2</cpp:value></cpp:define>

<comment type="block">/*
 * Temporaries.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t1</name></cpp:macro>     <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t2</name></cpp:macro>     <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t3</name></cpp:macro>     <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t4</name></cpp:macro>     <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t5</name></cpp:macro>    <cpp:value>10</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t6</name></cpp:macro>    <cpp:value>11</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t7</name></cpp:macro>    <cpp:value>12</cpp:value></cpp:define>

<comment type="block">/*
 * Extra scratch registers available when there is no second operand (e.g.
 * for "double" and "affine").
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t8</name></cpp:macro>     <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t9</name></cpp:macro>     <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>t10</name></cpp:macro>    <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * Doubling formulas are:
 *
 *   s = 4*x*y^2
 *   m = 3*(x + z^2)*(x - z^2)
 *   x' = m^2 - 2*s
 *   y' = m*(s - x') - 8*y^4
 *   z' = 2*y*z
 *
 * If y = 0 (P has order 2) then this yields infinity (z' = 0), as it
 * should. This case should not happen anyway, because our curves have
 * prime order, and thus do not contain any point of order 2.
 *
 * If P is infinity (z = 0), then again the formulas yield infinity,
 * which is correct. Thus, this code works for all points.
 *
 * Cost: 8 multiplications
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>code_double</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/*
	 * Compute z^2 (in t1).
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>Pz</name></expr></argument>, <argument><expr><name>Pz</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute x-z^2 (in t2) and then x+z^2 (in t1).
	 */</comment>
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>Px</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>Px</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute m = 3*(x+z^2)*(x-z^2) (in t1).
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute s = 4*x*y^2 (in t2) and 2*y^2 (in t3).
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>Py</name></expr></argument>, <argument><expr><name>Py</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>Px</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute x' = m^2 - 2*s.
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>Px</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>Px</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>Px</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute z' = 2*y*z.
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>Py</name></expr></argument>, <argument><expr><name>Pz</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>Pz</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>Pz</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute y' = m*(s - x') - 8*y^4. Note that we already have
	 * 2*y^2 in t3.
	 */</comment>
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>Px</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>Py</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>Py</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>Py</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,

	<expr><name>ENDCODE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Addtions formulas are:
 *
 *   u1 = x1 * z2^2
 *   u2 = x2 * z1^2
 *   s1 = y1 * z2^3
 *   s2 = y2 * z1^3
 *   h = u2 - u1
 *   r = s2 - s1
 *   x3 = r^2 - h^3 - 2 * u1 * h^2
 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
 *   z3 = h * z1 * z2
 *
 * If both P1 and P2 are infinity, then z1 == 0 and z2 == 0, implying that
 * z3 == 0, so the result is correct.
 * If either of P1 or P2 is infinity, but not both, then z3 == 0, which is
 * not correct.
 * h == 0 only if u1 == u2; this happens in two cases:
 * -- if s1 == s2 then P1 and/or P2 is infinity, or P1 == P2
 * -- if s1 != s2 then P1 + P2 == infinity (but neither P1 or P2 is infinity)
 *
 * Thus, the following situations are not handled correctly:
 * -- P1 = 0 and P2 != 0
 * -- P1 != 0 and P2 = 0
 * -- P1 = P2
 * All other cases are properly computed. However, even in "incorrect"
 * situations, the three coordinates still are properly formed field
 * elements.
 *
 * The returned flag is cleared if r == 0. This happens in the following
 * cases:
 * -- Both points are on the same horizontal line (same Y coordinate).
 * -- Both points are infinity.
 * -- One point is infinity and the other is on line Y = 0.
 * The third case cannot happen with our curves (there is no valid point
 * on line Y = 0 since that would be a point of order 2). If the two
 * source points are non-infinity, then remains only the case where the
 * two points are on the same horizontal line.
 *
 * This allows us to detect the "P1 == P2" case, assuming that P1 != 0 and
 * P2 != 0:
 * -- If the returned value is not the point at infinity, then it was properly
 * computed.
 * -- Otherwise, if the returned flag is 1, then P1+P2 = 0, and the result
 * is indeed the point at infinity.
 * -- Otherwise (result is infinity, flag is 0), then P1 = P2 and we should
 * use the 'double' code.
 *
 * Cost: 16 multiplications
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>code_add</name><index>[]</index></name> <init>= <expr><block>{
	<comment type="block">/*
	 * Compute u1 = x1*z2^2 (in t1) and s1 = y1*z2^3 (in t3).
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>P2z</name></expr></argument>, <argument><expr><name>P2z</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>P2z</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>P2x</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>P2y</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute h = u2 - u1 (in t2) and r = s2 - s1 (in t4).
	 */</comment>
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Report cases where r = 0 through the returned flag.
	 */</comment>
	<expr><call><name>MTZ</name><argument_list>(<argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5).
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 * t1 and t7 can be used as scratch registers.
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/*
	 * Compute z3 = h*z1*z2.
	 */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>P2z</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,

	<expr><name>ENDCODE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Check that the point is on the curve. This code snippet assumes the
 * following conventions:
 * -- Coordinates x and y have been freshly decoded in P1 (but not
 * converted to Montgomery coordinates yet).
 * -- P2x, P2y and P2z are set to, respectively, R^2, b*R and 1.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>code_check</name><index>[]</index></name> <init>= <expr><block>{

	<comment type="block">/* Convert x and y to Montgomery representation. */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>P2x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>P2x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compute x^3 in t1. */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Subtract 3*x from t1. */</comment>
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Add b. */</comment>
	<expr><call><name>MADD</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P2y</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compute y^2 in t2. */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>P1y</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compare y^2 with x^3 - 3*x + b; they must match. */</comment>
	<expr><call><name>MSUB</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MTZ</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Set z to 1 (in Montgomery representation). */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>P2x</name></expr></argument>, <argument><expr><name>P2z</name></expr></argument>)</argument_list></call></expr>,

	<expr><name>ENDCODE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Conversion back to affine coordinates. This code snippet assumes that
 * the z coordinate of P2 is set to 1 (not in Montgomery representation).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>code_affine</name><index>[]</index></name> <init>= <expr><block>{

	<comment type="block">/* Save z*R in t1. */</comment>
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compute z^3 in t2. */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>P1z</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>P2z</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Invert to (1/z^3) in t2. */</comment>
	<expr><call><name>MINV</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compute y. */</comment>
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>P1y</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>P1y</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compute (1/z^2) in t3. */</comment>
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* Compute x. */</comment>
	<expr><call><name>MSET</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>P1x</name></expr></argument>)</argument_list></call></expr>,
	<expr><call><name>MMUL</name><argument_list>(<argument><expr><name>P1x</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>,

	<expr><name>ENDCODE</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>run_code</name><parameter_list>(<parameter><decl><type><name>jacobian</name> <modifier>*</modifier></type><name>P1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>jacobian</name> <modifier>*</modifier></type><name>P2</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>code</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>t</name><index>[<expr><literal type="number">13</literal></expr>]</index><index>[<expr><name>I15_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>r</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the two operands in the dedicated registers.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>P1x</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <name>I15_LEN</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>P2x</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <name>I15_LEN</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Run formulas.
	 */</comment>
	<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>u</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>op</name></decl>, <decl><type ref="prev"/><name>d</name></decl>, <decl><type ref="prev"/><name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>op</name> <operator>=</operator> <name><name>code</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>op</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>(</operator><name>op</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>op</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <name>op</name> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>op</name> <operator>&gt;&gt;=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>ctl</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>plen</name></decl>;</decl_stmt>
			<expr_stmt><expr><name>unsigned</name> <name>char</name> <name><name>tp</name><index>[<expr><operator>(</operator><name>BR_MAX_EC_SIZE</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>a</name></expr>]</index></name></expr></argument>, <argument><expr><name>I15_LEN</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><name>ctl</name> <operator>=</operator> <call><name>br_i15_add</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>a</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ctl</name> <operator>|=</operator> <call><name>NOT</name><argument_list>(<argument><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<expr_stmt><expr><call><name>br_i15_add</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>a</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
			<expr_stmt><expr><call><name>br_i15_montymul</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>a</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>b</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p0i</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">4</literal></expr>:</case>
			<expr_stmt><expr><name>plen</name> <operator>=</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>br_i15_encode</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tp</name><index>[<expr><name>plen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>br_i15_modpow</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>,
				<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p0i</name></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>a</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>b</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <operator>~</operator><call><name>br_i15_iszero</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><name>d</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Copy back result.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>c</name></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><name>P1x</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">3</literal> <operator>*</operator> <name>I15_LEN</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_one</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>plen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>plen</name> <operator>=</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">31</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>plen</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x0001</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>point_zero</name><parameter_list>(<parameter><decl><type><name>jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>P</name><operator>-&gt;</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>point_double</name><parameter_list>(<parameter><decl><type><name>jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>run_code</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>code_double</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type>
<name>point_add</name><parameter_list>(<parameter><decl><type><name>jacobian</name> <modifier>*</modifier></type><name>P1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>jacobian</name> <modifier>*</modifier></type><name>P2</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>run_code</name><argument_list>(<argument><expr><name>P1</name></expr></argument>, <argument><expr><name>P2</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>code_add</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>point_mul</name><parameter_list>(<parameter><decl><type><name>jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We do a simple double-and-add ladder with a 2-bit window
	 * to make only one add every two doublings. We thus first
	 * precompute 2P and 3P in some local buffers.
	 *
	 * We always perform two doublings and one addition; the
	 * addition is with P, 2P and 3P and is done in a temporary
	 * array.
	 *
	 * The addition code cannot handle cases where one of the
	 * operands is infinity, which is the case at the start of the
	 * ladder. We therefore need to maintain a flag that controls
	 * this situation.
	 */</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>qz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jacobian</name></type> <name>P2</name></decl>, <decl><type ref="prev"/><name>P3</name></decl>, <decl><type ref="prev"/><name>Q</name></decl>, <decl><type ref="prev"/><name>T</name></decl>, <decl><type ref="prev"/><name>U</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P2</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><sizeof>sizeof <name>P2</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P2</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P3</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><sizeof>sizeof <name>P3</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P2</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>point_zero</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>xlen</name> <operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">6</literal></expr>;</init> <condition><expr><name>k</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>k</name> <operator>-=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>bnz</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>point_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>point_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><sizeof>sizeof <name>T</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><sizeof>sizeof <name>U</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><operator>*</operator><name>x</name> <operator>&gt;&gt;</operator> <name>k</name><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">3</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>bnz</name> <operator>=</operator> <call><name>NEQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><call><name>EQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P2</name></expr></argument>, <argument><expr><sizeof>sizeof <name>T</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><call><name>EQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P3</name></expr></argument>, <argument><expr><sizeof>sizeof <name>T</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>point_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>bnz</name> <operator>&amp;</operator> <name>qz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>bnz</name> <operator>&amp;</operator> <operator>~</operator><name>qz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qz</name> <operator>&amp;=</operator> <operator>~</operator><name>bnz</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>x</name> <operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decode point into Jacobian coordinates. This function does not support
 * the point at infinity. If the point is invalid then this returns 0, but
 * the coordinates are still set to properly formed field elements.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>point_decode</name><parameter_list>(<parameter><decl><type><name>jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Points must use uncompressed format:
	 * -- first byte is 0x04;
	 * -- coordinates X and Y use unsigned big-endian, with the same
	 *    length as the field modulus.
	 *
	 * We don't support hybrid format (uncompressed, but first byte
	 * has value 0x06 or 0x07, depending on the least significant bit
	 * of Y) because it is rather useless, and explicitly forbidden
	 * by PKIX (RFC 5480, section 2.2).
	 *
	 * We don't support compressed format either, because it is not
	 * much used in practice (there are or were patent-related
	 * concerns about point compression, which explains the lack of
	 * generalised support). Also, point compression support would
	 * need a bit more code.
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>plen</name></decl>, <decl><type ref="prev"/><name>zlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jacobian</name></type> <name>Q</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_zero</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>plen</name> <operator>=</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>plen</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>br_i15_decode_mod</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>br_i15_decode_mod</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>plen</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check first byte.
	 */</comment>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>EQ</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0x04</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* obsolete
	r &amp;= EQ(buf[0], 0x04) | (EQ(buf[0] &amp; 0xFE, 0x06)
		&amp; ~(uint32_t)(buf[0] ^ buf[plen &lt;&lt; 1]));
	*/</comment>

	<comment type="block">/*
	 * Convert coordinates and check that the point is valid.
	 */</comment>
	<expr_stmt><expr><name>zlen</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">31</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint16_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>Q</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>R2</name></name></expr></argument>, <argument><expr><name>zlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>Q</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>zlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_one</name><argument_list>(<argument><expr><name><name>Q</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <operator>~</operator><call><name>run_code</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>code_check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Encode a point. This method assumes that the point is correct and is
 * not the point at infinity. Encoded size is always 1+2*plen, where
 * plen is the field modulus length, in bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>point_encode</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>plen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jacobian</name></type> <name>Q</name></decl>, <decl><type ref="prev"/><name>T</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>dst</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>plen</name> <operator>=</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>+</operator> <literal type="number">7</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_one</name><argument_list>(<argument><expr><name><name>T</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>run_code</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>code_affine</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_encode</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name><name>Q</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_encode</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>plen</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>, <argument><expr><name><name>Q</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>br_ec_curve_def</name> <modifier>*</modifier></type>
<name>id_to_curve_def</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>curve</name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>BR_EC_secp256r1</name></expr>:</case>
		<return>return <expr><operator>&amp;</operator><name>br_secp256r1</name></expr>;</return>
	<case>case <expr><name>BR_EC_secp384r1</name></expr>:</case>
		<return>return <expr><operator>&amp;</operator><name>br_secp384r1</name></expr>;</return>
	<case>case <expr><name>BR_EC_secp521r1</name></expr>:</case>
		<return>return <expr><operator>&amp;</operator><name>br_secp521r1</name></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_generator</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_curve_def</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>id_to_curve_def</name><argument_list>(<argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>generator_len</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>cd</name><operator>-&gt;</operator><name>generator</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_order</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_curve_def</name> <modifier>*</modifier></type><name>cd</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cd</name> <operator>=</operator> <call><name>id_to_curve_def</name><argument_list>(<argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>cd</name><operator>-&gt;</operator><name>order_len</name></name></expr>;</expr_stmt>
	<return>return <expr><name><name>cd</name><operator>-&gt;</operator><name>order</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_xoff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>api_generator</name><argument_list>(<argument><expr><name>curve</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_mul</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>Glen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jacobian</name></type> <name>P</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>id_to_curve</name><argument_list>(<argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Glen</name> <operator>!=</operator> <name><name>cc</name><operator>-&gt;</operator><name>point_len</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_encode</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_mulgen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>Glen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>G</name> <operator>=</operator> <call><name>api_generator</name><argument_list>(<argument><expr><name>curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>api_mul</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Glen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_muladd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>B</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>t</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>curve_params</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>jacobian</name></type> <name>P</name></decl>, <decl><type ref="prev"/><name>Q</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * TODO: see about merging the two ladders. Right now, we do
	 * two independent point multiplications, which is a bit
	 * wasteful of CPU resources (but yields short code).
	 */</comment>

	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>id_to_curve</name><argument_list>(<argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name><name>cc</name><operator>-&gt;</operator><name>point_len</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>A</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>B</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>Glen</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>B</name> <operator>=</operator> <call><name>api_generator</name><argument_list>(<argument><expr><name>curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>B</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ylen</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We want to compute P+Q. Since the base points A and B are distinct
	 * from infinity, and the multipliers are non-zero and lower than the
	 * curve order, then we know that P and Q are non-infinity. This
	 * leaves two special situations to test for:
	 * -- If P = Q then we must use point_double().
	 * -- If P+Q = 0 then we must report an error.
	 */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>point_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>br_i15_iszero</name><argument_list>(<argument><expr><name><name>P</name><operator>.</operator><name>c</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If z is 1 then either P+Q = 0 (t = 1) or P = Q (t = 0). So we
	 * have the following:
	 *
	 *   z = 0, t = 0   return P (normal addition)
	 *   z = 0, t = 1   return P (normal addition)
	 *   z = 1, t = 0   return Q (a 'double' case)
	 *   z = 1, t = 1   report an error (P+Q = 0)
	 */</comment>
	<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>z</name> <operator>&amp;</operator> <operator>~</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_encode</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>z</name> <operator>&amp;</operator> <name>t</name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ec.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_impl</name></type> <name>br_ec_prime_i15</name> <init>= <expr><block>{
	<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0x03800000</literal></expr>,
	<expr><operator>&amp;</operator><name>api_generator</name></expr>,
	<expr><operator>&amp;</operator><name>api_order</name></expr>,
	<expr><operator>&amp;</operator><name>api_xoff</name></expr>,
	<expr><operator>&amp;</operator><name>api_mul</name></expr>,
	<expr><operator>&amp;</operator><name>api_mulgen</name></expr>,
	<expr><operator>&amp;</operator><name>api_muladd</name></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
