<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/ssl/ssl_lru.c"><comment type="block">/*
 * Copyright (c) 2016 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Each entry consists in a fixed number of bytes. Entries are concatenated
 * in the store block. "Addresses" are really offsets in the block,
 * expressed over 32 bits (so the cache may have size at most 4 GB, which
 * "ought to be enough for everyone"). The "null address" is 0xFFFFFFFF.
 * Note that since the storage block alignment is in no way guaranteed, we
 * perform only accesses that can handle unaligned data.
 *
 * Two concurrent data structures are maintained:
 *
 * -- Entries are organised in a doubly-linked list; saved entries are added
 * at the head, and loaded entries are moved to the head. Eviction uses
 * the list tail (this is the LRU algorithm).
 *
 * -- Entries are indexed with a binary tree: all left descendants of a
 * node have a lower session ID (in lexicographic order), while all
 * right descendants have a higher session ID. The tree is heuristically
 * balanced.
 *
 * Entry format:
 *
 *   session ID          32 bytes
 *   master secret       48 bytes
 *   protocol version    2 bytes (big endian)
 *   cipher suite        2 bytes (big endian)
 *   list prev           4 bytes (big endian)
 *   list next           4 bytes (big endian)
 *   tree left child     4 bytes (big endian)
 *   tree right child    4 bytes (big endian)
 *
 * If an entry has a protocol version set to 0, then it is "disabled":
 * it was a session pushed to the cache at some point, but it has
 * been explicitly removed.
 *
 * We need to keep the tree balanced because an attacker could make
 * handshakes, selecting some specific sessions (by reusing them) to
 * try to make us make an imbalanced tree that makes lookups expensive
 * (a denial-of-service attack that would persist as long as the cache
 * remains, i.e. even after the attacker made all his connections).
 * To do that, we replace the session ID (or the start of the session ID)
 * with a HMAC value computed over the replaced part; the hash function
 * implementation and the key are obtained from the server context upon
 * first save() call.
 *
 * Theoretically, an attacker could use the exact timing of the lookup
 * to infer the current tree topology, and try to revive entries to make
 * it as unbalanced as possible. However, since the session ID are
 * chosen randomly by the server, and the attacker cannot see the
 * indexing values and must thus rely on blind selection, it should be
 * exponentially difficult for the attacker to maintain a large
 * imbalance.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SESSION_ID_LEN</name></cpp:macro>       <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASTER_SECRET_LEN</name></cpp:macro>    <cpp:value>48</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SESSION_ID_OFF</name></cpp:macro>        <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASTER_SECRET_OFF</name></cpp:macro>    <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION_OFF</name></cpp:macro>          <cpp:value>80</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIPHER_SUITE_OFF</name></cpp:macro>     <cpp:value>82</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_PREV_OFF</name></cpp:macro>        <cpp:value>84</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LIST_NEXT_OFF</name></cpp:macro>        <cpp:value>88</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_LEFT_OFF</name></cpp:macro>        <cpp:value>92</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TREE_RIGHT_OFF</name></cpp:macro>       <cpp:value>96</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LRU_ENTRY_LEN</name></cpp:macro>       <cpp:value>100</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDR_NULL</name></cpp:macro>   <cpp:value>((uint32_t)-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETSET</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>off</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>static inline uint32_t get_ ## name(br_ssl_session_cache_lru *cc, uint32_t x) \
{ \
	return br_dec32be(cc-&gt;store + x + (off)); \
} \
static inline void set_ ## name(br_ssl_session_cache_lru *cc, \
	uint32_t x, uint32_t val) \
{ \
	br_enc32be(cc-&gt;store + x + (off), val); \
}</cpp:value></cpp:define>

<macro><name>GETSET</name><argument_list>(<argument>prev</argument>, <argument>LIST_PREV_OFF</argument>)</argument_list></macro>
<macro><name>GETSET</name><argument_list>(<argument>next</argument>, <argument>LIST_NEXT_OFF</argument>)</argument_list></macro>
<macro><name>GETSET</name><argument_list>(<argument>left</argument>, <argument>TREE_LEFT_OFF</argument>)</argument_list></macro>
<macro><name>GETSET</name><argument_list>(<argument>right</argument>, <argument>TREE_RIGHT_OFF</argument>)</argument_list></macro>

<comment type="block">/*
 * Transform the session ID by replacing the first N bytes with a HMAC
 * value computed over these bytes, using the random key K (the HMAC
 * value is truncated if needed). HMAC will use the same hash function
 * as the DRBG in the SSL server context, so with SHA-256, SHA-384,
 * or SHA-1, depending on what is available.
 *
 * The risk of collision is considered too small to be a concern; and
 * the impact of a collision is low (the handshake won't succeed). This
 * risk is much lower than any transmission error, which would lead to
 * the same consequences.
 *
 * Source and destination arrays msut be disjoint.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mask_id</name><parameter_list>(<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>br_hmac_key_context</name></type> <name>hkc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>br_hmac_context</name></type> <name>hc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>SESSION_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_hmac_key_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hkc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>index_key</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>index_key</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_hmac_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hkc</name></expr></argument>, <argument><expr><name>SESSION_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_hmac_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hc</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>SESSION_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_hmac_out</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hc</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find a node by ID. Returned value is the node address, or ADDR_NULL if
 * the node is not found.
 *
 * If addr_link is not NULL, then '*addr_link' is set to the address of the
 * last followed link. If the found node is the root, or if the tree is
 * empty, then '*addr_link' is set to ADDR_NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>find_node</name><parameter_list>(<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>,
	<parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>addr_link</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>root</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <name>ADDR_NULL</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>x</name> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>SESSION_ID_OFF</name></expr></argument>, <argument><expr><name>SESSION_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name> <operator>+</operator> <name>TREE_LEFT_OFF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>r</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>addr_link</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>addr_link</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>x</name></expr>;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>y</name> <operator>=</operator> <name>x</name> <operator>+</operator> <name>TREE_RIGHT_OFF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>get_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>addr_link</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>addr_link</name> <operator>=</operator> <name>y</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ADDR_NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * For node x, find its replacement upon removal.
 *
 *  -- If node x has no child, then this returns ADDR_NULL.
 *  -- Otherwise, if node x has a left child, then the replacement is the
 *     rightmost left-descendent.
 *  -- Otherwise, the replacement is the leftmost right-descendent.
 *
 * If a node is returned, then '*al' is set to the address of the field
 * that points to that node. Otherwise (node x has no child), '*al' is
 * set to ADDR_NULL.
 *
 * Note that the replacement node, when found, is always a descendent
 * of node 'x', so it cannot be the tree root. Thus, '*al' can be set
 * to ADDR_NULL only when no node is found and ADDR_NULL is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>find_replacement_node</name><parameter_list>(<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>al</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>y1</name></decl>, <decl><type ref="prev"/><name>y2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>y1</name> <operator>=</operator> <call><name>get_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>y1</name> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>y2</name> <operator>=</operator> <name>x</name> <operator>+</operator> <name>TREE_LEFT_OFF</name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>z</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>get_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>z</name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>al</name> <operator>=</operator> <name>y2</name></expr>;</expr_stmt>
				<return>return <expr><name>y1</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>y2</name> <operator>=</operator> <name>y1</name> <operator>+</operator> <name>TREE_RIGHT_OFF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y1</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>y1</name> <operator>=</operator> <call><name>get_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>y1</name> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>y2</name> <operator>=</operator> <name>x</name> <operator>+</operator> <name>TREE_RIGHT_OFF</name></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>z</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>get_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>y1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>z</name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>al</name> <operator>=</operator> <name>y2</name></expr>;</expr_stmt>
				<return>return <expr><name>y1</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>y2</name> <operator>=</operator> <name>y1</name> <operator>+</operator> <name>TREE_LEFT_OFF</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>y1</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>al</name> <operator>=</operator> <name>ADDR_NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>ADDR_NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the link at address 'alx' to point to node 'x'. If 'alx' is
 * ADDR_NULL, then this sets the tree root to 'x'.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>set_link</name><parameter_list>(<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>alx</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>alx</name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>br_enc32be</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>alx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove node 'x' from the tree. This function shall not be called if
 * node 'x' is not part of the tree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_node</name><parameter_list>(<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>alx</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>aly</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Removal algorithm:
	 * ------------------
	 *
	 * - If we remove the root, then the tree becomes empty.
	 *
	 * - If the removed node has no child, then we can simply remove
	 *   it, with nothing else to do.
	 *
	 * - Otherwise, the removed node must be replaced by either its
	 *   rightmost left-descendent, or its leftmost right-descendent.
	 *   The replacement node itself must be removed from its current
	 *   place. By definition, that replacement node has either no
	 *   child, or at most a single child that will replace it in the
	 *   tree.
	 */</comment>

	<comment type="block">/*
	 * Find node back and its ancestor link. If the node was the
	 * root, then alx is set to ADDR_NULL.
	 */</comment>
	<expr_stmt><expr><call><name>find_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>SESSION_ID_OFF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find replacement node 'y', and 'aly' is set to the address of
	 * the link to that replacement node. If the removed node has no
	 * child, then both 'y' and 'aly' are set to ADDR_NULL.
	 */</comment>
	<expr_stmt><expr><name>y</name> <operator>=</operator> <call><name>find_replacement_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>y</name> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>z</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The unlinked replacement node may have one child (but
		 * not two) that takes its place.
		 */</comment>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>get_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>z</name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>get_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>set_link</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>aly</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Link the replacement node in its new place, overwriting
		 * the current link to the node 'x' (which removes 'x').
		 */</comment>
		<expr_stmt><expr><call><name>set_link</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>alx</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The replacement node adopts the left and right children
		 * of the removed node. Note that this also works even if
		 * the replacement node was a direct descendent of the
		 * removed node, since we unlinked it previously.
		 */</comment>
		<expr_stmt><expr><call><name>set_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>get_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><call><name>get_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * No replacement, we simply unlink the node 'x'.
		 */</comment>
		<expr_stmt><expr><call><name>set_link</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>alx</name></expr></argument>, <argument><expr><name>ADDR_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lru_save</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_session_cache_class</name> <modifier>*</modifier><modifier>*</modifier></type><name>ctx</name></decl></parameter>,
	<parameter><decl><type><name>br_ssl_server_context</name> <modifier>*</modifier></type><name>server_ctx</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_ssl_session_parameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>id</name><index>[<expr><name>SESSION_ID_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>alx</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>br_ssl_session_cache_lru</name> <operator>*</operator><operator>)</operator><name>ctx</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the buffer is too small, we don't record anything. This
	 * test avoids problems in subsequent code.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>store_len</name></name> <operator>&lt;</operator> <name>LRU_ENTRY_LEN</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Upon the first save in a session cache instance, we obtain
	 * a random key for our indexing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cc</name><operator>-&gt;</operator><name>init_done</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>br_hmac_drbg_generate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server_ctx</name><operator>-&gt;</operator><name>eng</name><operator>.</operator><name>rng</name></name></expr></argument>,
			<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>index_key</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>index_key</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <call><name>br_hmac_drbg_get_hash</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>server_ctx</name><operator>-&gt;</operator><name>eng</name><operator>.</operator><name>rng</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>init_done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>mask_id</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>session_id</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look for the node in the tree. If the same ID is already used,
	 * then reject it. This is a collision event, which should be
	 * exceedingly rare.
	 * Note: we do NOT record the emplacement here, because the
	 * removal of an entry may change the tree topology.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>find_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find some room for the new parameters. If the cache is not
	 * full yet, add it to the end of the area and bump the pointer up.
	 * Otherwise, evict the list tail entry. Note that we already
	 * filtered out the case of a ridiculously small buffer that
	 * cannot hold any entry at all; thus, if there is no room for an
	 * extra entry, then the cache cannot be empty.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>store_ptr</name></name> <operator>&gt;</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>store_len</name></name> <operator>-</operator> <name>LRU_ENTRY_LEN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Evict tail. If the buffer has room for a single entry,
		 * then this may also be the head.
		 */</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>tail</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <call><name>get_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>tail</name></name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>ADDR_NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>set_next</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>ADDR_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Remove the node from the tree.
		 */</comment>
		<expr_stmt><expr><call><name>remove_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * Allocate room for new node.
		 */</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>store_ptr</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>store_ptr</name></name> <operator>+=</operator> <name>LRU_ENTRY_LEN</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Find the emplacement for the new node, and link it.
	 */</comment>
	<expr_stmt><expr><call><name>find_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_link</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>alx</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_left</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>ADDR_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_right</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>ADDR_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * New entry becomes new list head. It may also become the list
	 * tail if the cache was empty at that point.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>set_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>set_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>ADDR_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_next</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Fill data in the entry.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>SESSION_ID_OFF</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>SESSION_ID_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>MASTER_SECRET_OFF</name></expr></argument>,
		<argument><expr><name><name>params</name><operator>-&gt;</operator><name>master_secret</name></name></expr></argument>, <argument><expr><name>MASTER_SECRET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc16be</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>VERSION_OFF</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc16be</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>CIPHER_SUITE_OFF</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>cipher_suite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>lru_load</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_session_cache_class</name> <modifier>*</modifier><modifier>*</modifier></type><name>ctx</name></decl></parameter>,
	<parameter><decl><type><name>br_ssl_server_context</name> <modifier>*</modifier></type><name>server_ctx</name></decl></parameter>,
	<parameter><decl><type><name>br_ssl_session_parameters</name> <modifier>*</modifier></type><name>params</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>id</name><index>[<expr><name>SESSION_ID_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>server_ctx</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>br_ssl_session_cache_lru</name> <operator>*</operator><operator>)</operator><name>ctx</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cc</name><operator>-&gt;</operator><name>init_done</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>mask_id</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>session_id</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>find_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>version</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>br_dec16be</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>VERSION_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>version</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Entry is disabled, we pretend we did not find it.
			 * Notably, we don't move it to the front of the
			 * LRU list.
			 */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>params</name><operator>-&gt;</operator><name>cipher_suite</name></name> <operator>=</operator> <call><name>br_dec16be</name><argument_list>(
			<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>CIPHER_SUITE_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>params</name><operator>-&gt;</operator><name>master_secret</name></name></expr></argument>,
			<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>x</name> <operator>+</operator> <name>MASTER_SECRET_OFF</name></expr></argument>,
			<argument><expr><name>MASTER_SECRET_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name><name>cc</name><operator>-&gt;</operator><name>head</name></name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * Found node is not at list head, so move
			 * it to the head.
			 */</comment>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>p</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>get_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_next</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_next</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><call><name>set_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>set_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_next</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>set_prev</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>ADDR_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>br_ssl_session_cache_class</name></type> <name>lru_class</name> <init>= <expr><block>{
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>br_ssl_session_cache_lru</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>&amp;</operator><name>lru_save</name></expr>,
	<expr><operator>&amp;</operator><name>lru_load</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_session_cache_lru_init</name><parameter_list>(<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>store</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>store_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>vtable</name></name> <operator>=</operator> <operator>&amp;</operator><name>lru_class</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>=</operator> <name>store</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>store_len</name></name> <operator>=</operator> <name>store_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>store_ptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>init_done</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name>ADDR_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>tail</name></name> <operator>=</operator> <name>ADDR_NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>root</name></name> <operator>=</operator> <name>ADDR_NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type> <name>br_ssl_session_cache_lru_forget</name><parameter_list>(
	<parameter><decl><type><name>br_ssl_session_cache_lru</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>mid</name><index>[<expr><name>SESSION_ID_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>addr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the cache is not initialised yet, then it is empty, and
	 * there is nothing to forget.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cc</name><operator>-&gt;</operator><name>init_done</name></name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look for the node in the tree. If found, the entry is marked
	 * as "disabled"; it will be reused in due course, as it ages
	 * through the list.
	 *
	 * We do not go through the complex moves of actually releasing
	 * the entry right away because explicitly forgetting sessions
	 * should be a rare event, meant mostly for testing purposes,
	 * so this is not worth the extra code size.
	 */</comment>
	<expr_stmt><expr><call><name>mask_id</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>find_node</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>mid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>ADDR_NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>br_enc16be</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>store</name></name> <operator>+</operator> <name>addr</name> <operator>+</operator> <name>VERSION_OFF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
