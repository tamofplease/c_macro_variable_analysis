<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/ssl/ssl_engine.c"><comment type="block">/*
 * Copyright (c) 2016 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* obsolete */</comment>

<comment type="block">/*
 * If BR_USE_URANDOM is not defined, then try to autodetect its presence
 * through compiler macros.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BR_USE_URANDOM</name></cpp:ifndef>

<comment type="block">/*
 * Macro values documented on:
 *    https://sourceforge.net/p/predef/wiki/OperatingSystems/
 *
 * Only the most common systems have been included here for now. This
 * should be enriched later on.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_AIX</name> \
	<operator>||</operator> <name>defined</name> <name>__ANDROID__</name> \
	<operator>||</operator> <name>defined</name> <name>__FreeBSD__</name> \
	<operator>||</operator> <name>defined</name> <name>__NetBSD__</name> \
	<operator>||</operator> <name>defined</name> <name>__OpenBSD__</name> \
	<operator>||</operator> <name>defined</name> <name>__DragonFly__</name> \
	<operator>||</operator> <name>defined</name> <name>__linux__</name> \
	<operator>||</operator> <operator>(</operator><name>defined</name> <name>__sun</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>defined</name> <name>__SVR4</name> <operator>||</operator> <name>defined</name> <name>__svr4__</name><operator>)</operator><operator>)</operator> \
	<operator>||</operator> <operator>(</operator><name>defined</name> <name>__APPLE__</name> <operator>&amp;&amp;</operator> <name>defined</name> <name>__MACH__</name><operator>)</operator></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BR_USE_URANDOM</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * If BR_USE_WIN32_RAND is not defined, perform autodetection here.
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BR_USE_WIN32_RAND</name></cpp:ifndef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_WIN32</name> <operator>||</operator> <name>defined</name> <name>_WIN64</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BR_USE_WIN32_RAND</name></cpp:macro>   <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_USE_URANDOM</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_USE_WIN32_RAND</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wincrypt.h&gt;</cpp:file></cpp:include>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>lib</name><name>,</name> <cpp:literal>"advapi32"</cpp:literal><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ==================================================================== */</comment>
<comment type="block">/*
 * This part of the file does the low-level record management.
 */</comment>

<comment type="block">/*
 * IMPLEMENTATION NOTES
 * ====================
 *
 * In this file, we designate by "input" (and the "i" letter) the "recv"
 * operations: incoming records from the peer, from which payload data
 * is obtained, and must be extracted by the application (or the SSL
 * handshake engine). Similarly, "output" (and the "o" letter) is for
 * "send": payload data injected by the application (and SSL handshake
 * engine), to be wrapped into records, that are then conveyed to the
 * peer over the transport medium.
 *
 * The input and output buffers may be distinct or shared. When
 * shared, input and output cannot occur concurrently; the caller
 * must make sure that it never needs to output data while input
 * data has been received. In practice, a shared buffer prevents
 * pipelining of HTTP requests, or similar protocols; however, a
 * shared buffer saves RAM.
 *
 * The input buffer is pointed to by 'ibuf' and has size 'ibuf_len';
 * the output buffer is pointed to by 'obuf' and has size 'obuf_len'.
 * From the size of these buffers is derived the maximum fragment
 * length, which will be honoured upon sending records; regardless of
 * that length, incoming records will be processed as long as they
 * fit in the input buffer, and their length still complies with the
 * protocol specification (maximum plaintext payload length is 16384
 * bytes).
 *
 * Three registers are used to manage buffering in ibuf, called ixa,
 * ixb and ixc. Similarly, three registers are used to manage buffering
 * in obuf, called oxa, oxb and oxc.
 *
 *
 * At any time, the engine is in one of the following modes:
 * -- Failed mode: an error occurs, no I/O can happen.
 * -- Input mode: the engine can either receive record bytes from the
 * transport layer, or it has some buffered payload bytes to yield.
 * -- Output mode: the engine can either receive payload bytes, or it
 * has some record bytes to send to the transport layer.
 * -- Input/Output mode: both input and output modes are active. When
 * the buffer is shared, this can happen only when the buffer is empty
 * (no buffered payload bytes or record bytes in either direction).
 *
 *
 * Failed mode:
 * ------------
 *
 * I/O failed for some reason (invalid received data, not enough room
 * for the next record...). No I/O may ever occur again for this context,
 * until an explicit reset is performed. This mode, and the error code,
 * are also used for protocol errors, especially handshake errors.
 *
 *
 * Input mode:
 * -----------
 *
 *  ixa   index within ibuf[] for the currently read data
 *  ixb   maximum index within ibuf[] for the currently read data
 *  ixc   number of bytes not yet received for the current record
 * 
 * -- When ixa == ixb, there is no available data for readers. When
 * ixa != ixb, there is available data and it starts at offset ixa.
 *
 * -- When waiting for the next record header, ixa and ixb are equal
 * and contain a value ranging from 0 to 4; ixc is equal to 5-ixa.
 *
 * -- When the header has been received, record data is obtained. The
 * ixc field records how many bytes are still needed to reach the
 * end of the current record.
 *
 *    ** If encryption is active, then ixa and ixb are kept equal, and
 *    point to the end of the currently received record bytes. When
 *    ixc reaches 0, decryption/MAC is applied, and ixa and ixb are
 *    adjusted.
 *
 *    ** If encryption is not active, then ixa and ixb are distinct
 *    and data can be read right away. Additional record data is
 *    obtained only when ixa == ixb.
 *
 * Note: in input mode and no encryption, records larger than the buffer
 * size are allowed. When encryption is active, the complete record must
 * fit within the buffer, since it cannot be decrypted/MACed until it
 * has been completely received.
 *
 * -- When receiving the next record header, 'version_in' contains the
 * expected input version (0 if not expecting a specific version); on
 * mismatch, the mode switches to 'failed'.
 *
 * -- When the header has been received, 'version_in' contains the received
 * version. It is up to the caller to check and adjust the 'version_in' field
 * to implement the required semantics.
 *
 * -- The 'record_type_in' field is updated with the incoming record type
 * when the next record header has been received.
 *
 *
 * Output mode:
 * ------------
 *
 *  oxa   index within obuf[] for the currently accumulated data
 *  oxb   maximum index within obuf[] for record data
 *  oxc   pointer for start of record data, and for record sending
 *
 * -- When oxa != oxb, more data can be accumulated into the current
 * record; when oxa == oxb, a closed record is being sent.
 *
 * -- When accumulating data, oxc points to the start of the data.
 *
 * -- During record sending, oxa (and oxb) point to the next record byte
 * to send, and oxc indicates the end of the current record.
 *
 * Note: sent records must fit within the buffer, since the header is
 * adjusted only when the complete record has been assembled.
 *
 * -- The 'version_out' and 'record_type_out' fields are used to build the
 * record header when the mode is switched to 'sending'.
 *
 *
 * Modes:
 * ------
 *
 * The state register iomode contains one of the following values:
 *
 *  BR_IO_FAILED   I/O failed
 *  BR_IO_IN       input mode
 *  BR_IO_OUT      output mode
 *  BR_IO_INOUT    input/output mode
 *
 * Whether encryption is active on incoming records is indicated by the
 * incrypt flag. For outgoing records, there is no such flag; "encryption"
 * is always considered active, but initially uses functions that do not
 * encrypt anything. The 'incrypt' flag is needed because when there is
 * no active encryption, records larger than the I/O buffer are accepted.
 *
 * Note: we do not support no-encryption modes (MAC only).
 *
 * TODO: implement GCM support
 *
 *
 * Misc:
 * -----
 *
 * 'max_frag_len' is the maximum plaintext size for an outgoing record.
 * By default, it is set to the maximum value that fits in the provided
 * buffers, in the following list: 512, 1024, 2048, 4096, 16384. The
 * caller may change it if needed, but the new value MUST still fit in
 * the buffers, and it MUST be one of the list above for compatibility
 * with the Maximum Fragment Length extension.
 *
 * For incoming records, only the total buffer length and current
 * encryption mode impact the maximum length for incoming records. The
 * 'max_frag_len' value is still adjusted so that records up to that
 * length can be both received and sent.
 *
 *
 * Offsets and lengths:
 * --------------------
 *
 * When sending fragments with TLS-1.1+, the maximum overhead is:
 *   5 bytes for the record header
 *   16 bytes for the explicit IV
 *   48 bytes for the MAC (HMAC/SHA-384)
 *   16 bytes for the padding (AES)
 * so a total of 85 extra bytes. Note that we support block cipher sizes
 * up to 16 bytes (AES) and HMAC output sizes up to 48 bytes (SHA-384).
 *
 * With TLS-1.0 and CBC mode, we apply a 1/n-1 split, for a maximum
 * overhead of:
 *   5 bytes for the first record header
 *   32 bytes for the first record payload (AES-CBC + HMAC/SHA-1)
 *   5 bytes for the second record header
 *   20 bytes for the MAC (HMAC/SHA-1)
 *   16 bytes for the padding (AES)
 *   -1 byte to account for the payload byte in the first record
 * so a total of 77 extra bytes at most, less than the 85 bytes above.
 * Note that with TLS-1.0, the MAC is HMAC with either MD5 or SHA-1, but
 * no other hash function.
 *
 * The implementation does not try to send larger records when the current
 * encryption mode has less overhead.
 *
 * Maximum input record overhead is:
 *   5 bytes for the record header
 *   16 bytes for the explicit IV (TLS-1.1+)
 *   48 bytes for the MAC (HMAC/SHA-384)
 *   256 bytes for the padding
 * so a total of 325 extra bytes.
 *
 * When receiving the next record header, it is written into the buffer
 * bytes 0 to 4 (inclusive). Record data is always written into buf[]
 * starting at offset 5. When encryption is active, the plaintext data
 * may start at a larger offset (e.g. because of an explicit IV).
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_OUT_OVERHEAD</name></cpp:macro>    <cpp:value>85</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_IN_OVERHEAD</name></cpp:macro>    <cpp:value>325</cpp:value></cpp:define>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_fail</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>err</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>!=</operator> <name>BR_IO_FAILED</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_FAILED</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>err</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust registers for a new incoming record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_ready_in</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>==</operator> <name>BR_IO_IN</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_INOUT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust registers for a new outgoing record.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>make_ready_out</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>a</name></decl>, <decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>a</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>obuf_len</name></name> <operator>-</operator> <name>a</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>rc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>vtable</name><operator>-&gt;</operator><name>max_plaintext</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>vtable</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>b</name> <operator>-</operator> <name>a</name><operator>)</operator> <operator>&gt;</operator> <name><name>rc</name><operator>-&gt;</operator><name>max_frag_len</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name> <operator>+</operator> <name><name>rc</name><operator>-&gt;</operator><name>max_frag_len</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>==</operator> <name>BR_IO_OUT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_INOUT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_new_max_frag_len</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>max_frag_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>nxb</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>max_frag_len</name></name> <operator>=</operator> <name>max_frag_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nxb</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name> <operator>+</operator> <name>max_frag_len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>&lt;</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>&gt;</operator> <name>nxb</name> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>&lt;</operator> <name>nxb</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>=</operator> <name>nxb</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_set_buffer</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>,
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buf_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bidi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>br_ssl_engine_set_buffers_bidi</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/*
		 * In bidirectional mode, we want to maximise input
		 * buffer size, since we support arbitrary fragmentation
		 * when sending, but the peer will not necessarily
		 * comply to any low fragment length (in particular if
		 * we are the server, because the maximum fragment
		 * length extension is under client control).
		 *
		 * We keep a minimum size of 512 bytes for the plaintext
		 * of our outgoing records.
		 *
		 * br_ssl_engine_set_buffers_bidi() will compute the maximum
		 * fragment length for outgoing records by using the minimum
		 * of allocated spaces for both input and output records,
		 * rounded down to a standard length.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>bidi</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type> <name>w</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">512</literal> <operator>+</operator> <name>MAX_IN_OVERHEAD</name>
				<operator>+</operator> <literal type="number">512</literal> <operator>+</operator> <name>MAX_OUT_OVERHEAD</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_FAILED</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>BR_ERR_BAD_PARAM</name></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>buf_len</name> <operator>&lt;</operator> <operator>(</operator><literal type="number">16384</literal> <operator>+</operator> <name>MAX_IN_OVERHEAD</name>
				<operator>+</operator> <literal type="number">512</literal> <operator>+</operator> <name>MAX_OUT_OVERHEAD</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">512</literal> <operator>+</operator> <name>MAX_OUT_OVERHEAD</name></expr>;</expr_stmt>
			</block_content>}</block></if> <else>else <block>{<block_content>
				<expr_stmt><expr><name>w</name> <operator>=</operator> <name>buf_len</name> <operator>-</operator> <operator>(</operator><literal type="number">16384</literal> <operator>+</operator> <name>MAX_IN_OVERHEAD</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>br_ssl_engine_set_buffers_bidi</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,
				<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name> <operator>-</operator> <name>w</name></expr></argument>,
				<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>w</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>br_ssl_engine_set_buffers_bidi</name><argument_list>(<argument><expr><name>rc</name></expr></argument>,
				<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_set_buffers_bidi</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>,
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ibuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ibuf_len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obuf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>obuf_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_INOUT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>incrypt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>err</name></name> <operator>=</operator> <name>BR_ERR_OK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>version_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>record_type_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>version_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>record_type_out</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ibuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>u</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>=</operator> <name>ibuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf_len</name></name> <operator>=</operator> <name>ibuf_len</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>obuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>obuf</name> <operator>=</operator> <name>ibuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>obuf_len</name> <operator>=</operator> <name>ibuf_len</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name> <operator>=</operator> <name>obuf</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>obuf_len</name></name> <operator>=</operator> <name>obuf_len</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute the maximum fragment length, that fits for
		 * both incoming and outgoing records. This length will
		 * be used in fragment length negotiation, so we must
		 * honour it both ways. Regardless, larger incoming
		 * records will be accepted, as long as they fit in the
		 * actual buffer size.
		 */</comment>
		<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">14</literal></expr>;</init> <condition><expr><name>u</name> <operator>&gt;=</operator> <literal type="number">9</literal></expr>;</condition> <incr><expr><name>u</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type> <name>flen</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>flen</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>u</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>obuf_len</name> <operator>&gt;=</operator> <name>flen</name> <operator>+</operator> <name>MAX_OUT_OVERHEAD</name>
				<operator>&amp;&amp;</operator> <name>ibuf_len</name> <operator>&gt;=</operator> <name>flen</name> <operator>+</operator> <name>MAX_IN_OVERHEAD</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>u</name> <operator>==</operator> <literal type="number">8</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>u</name> <operator>==</operator> <literal type="number">13</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>u</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>max_frag_len</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>u</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>log_max_frag_len</name></name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>peer_log_max_frag_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>vtable</name></name> <operator>=</operator> <operator>&amp;</operator><name>br_sslrec_out_clear_vtable</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_ready_in</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_ready_out</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Clear buffers in both directions.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>engine_clearbuf</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>make_ready_in</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>make_ready_out</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Make sure the internal PRNG is initialised (but not necessarily
 * seeded properly yet).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>rng_init</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>br_hash_class</name> <modifier>*</modifier></type><name>h</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>rng_init_done</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If using TLS-1.2, then SHA-256 or SHA-384 must be present (or
	 * both); we prefer SHA-256 which is faster for 32-bit systems.
	 *
	 * If using TLS-1.0 or 1.1 then SHA-1 must be present.
	 *
	 * Though HMAC_DRBG/SHA-1 is, as far as we know, as safe as
	 * these things can be, we still prefer the SHA-2 functions over
	 * SHA-1, if only for public relations (known theoretical
	 * weaknesses of SHA-1 with regards to collisions are mostly
	 * irrelevant here, but they still make people nervous).
	 */</comment>
	<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>br_multihash_getimpl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>mhash</name></name></expr></argument>, <argument><expr><name>br_sha256_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>br_multihash_getimpl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>mhash</name></name></expr></argument>, <argument><expr><name>br_sha384_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>h</name> <operator>=</operator> <call><name>br_multihash_getimpl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>mhash</name></name></expr></argument>,
				<argument><expr><name>br_sha1_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_STATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>br_hmac_drbg_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>, <argument><expr><name>h</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>rng_init_done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>int</name></type>
<name>br_ssl_engine_init_rand</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rng_init</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We always try OS/hardware seeding once. If it works, then
	 * we assume proper seeding. If not, then external entropy must
	 * have been injected; otherwise, we report an error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cc</name><operator>-&gt;</operator><name>rng_os_rand_done</name></name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>br_prng_seeder</name></type> <name>sd</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sd</name> <operator>=</operator> <call><name>br_prng_seeder_system</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sd</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>rng</name><operator>.</operator><name>vtable</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>rng_init_done</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>rng_os_rand_done</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>rng_init_done</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>BR_ERR_NO_RANDOM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_inject_entropy</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Externally provided entropy is assumed to be "good enough"
	 * (we cannot really test its quality) so if the RNG structure
	 * could be initialised at all, then we marked the RNG as
	 * "properly seeded".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rng_init</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>br_hmac_drbg_update</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>rng</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>rng_init_done</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * We define a few internal functions that implement the low-level engine
 * API for I/O; the external API (br_ssl_engine_sendapp_buf() and similar
 * functions) is built upon these function, with special processing for
 * records which are not of type "application data".
 *
 *   recvrec_buf, recvrec_ack     receives bytes from transport medium
 *   sendrec_buf, sendrec_ack     send bytes to transport medium
 *   recvpld_buf, recvpld_ack     receives payload data from engine
 *   sendpld_buf, sendpld_ack     send payload data to engine
 */</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>recvrec_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>shutdown_recv</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Bytes from the transport can be injected only if the mode is
	 * compatible (in or in/out), and ixa == ixb; ixc then contains
	 * the number of bytes that are still expected (but it may
	 * exceed our buffer size).
	 *
	 * We cannot get "stuck" here (buffer is full, but still more
	 * data is expected) because oversized records are detected when
	 * their header is processed.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>BR_IO_IN</name></expr>:</case>
	<case>case <expr><name>BR_IO_INOUT</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>size_t</name></type> <name>z</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>z</name> <operator>&gt;</operator> <name><name>rc</name><operator>-&gt;</operator><name>ibuf_len</name></name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ibuf_len</name></name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>z</name></expr>;</expr_stmt>
			<return>return <expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>recvrec_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pbuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>pbuf_len</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Adjust state if necessary (for a shared input/output buffer):
	 * we got some incoming bytes, so we cannot (temporarily) handle
	 * outgoing data.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>==</operator> <name>BR_IO_INOUT</name> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_IN</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Adjust data pointers.
	 */</comment>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name> <operator>=</operator> <operator>(</operator><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>+=</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we are receiving a header and did not fully obtained it
	 * yet, then just wait for the next bytes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>&lt;</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we just obtained a full header, process it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>version</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>rlen</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get record type and version. We support only versions
		 * 3.x (if the version major number does not match, then
		 * we suppose that the record format is too alien for us
		 * to process it).
		 *
		 * Note: right now, we reject clients that try to send
		 * a ClientHello in a format compatible with SSL-2.0. It
		 * is unclear whether this will ever be supported; and
		 * if we want to support it, then this might be done in
		 * in the server-specific code, not here.
		 */</comment>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>record_type_in</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ibuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>version</name> <operator>=</operator> <call><name>br_dec16be</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>version</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_UNSUPPORTED_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * We ensure that successive records have the same
		 * version. The handshake code must check and adjust the
		 * variables when necessary to accommodate the protocol
		 * negotiation details.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>version_in</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>version_in</name></name> <operator>!=</operator> <name>version</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>version_in</name></name> <operator>=</operator> <name>version</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Decode record length. We must check that the length
		 * is valid (relatively to the current encryption mode)
		 * and also (if encryption is active) that the record
		 * will fit in our buffer.
		 *
		 * When no encryption is active, we can process records
		 * by chunks, and thus accept any record up to the
		 * maximum allowed plaintext length (16384 bytes).
		 */</comment>
		<expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>br_dec16be</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>incrypt</name></name></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>rc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>vtable</name><operator>-&gt;</operator><name>check_length</name></name><argument_list>(
				<argument><expr><operator>&amp;</operator><name><name>rc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>vtable</name></name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <operator>(</operator><name><name>rc</name><operator>-&gt;</operator><name>ibuf_len</name></name> <operator>-</operator> <literal type="number">5</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_TOO_LARGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>&gt;</operator> <literal type="number">16384</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * If the record is completely empty then we must switch
		 * to a new record. Note that, in that case, we
		 * completely ignore the record type, which is fitting
		 * since we received no actual data of that type.
		 *
		 * A completely empty record is technically allowed as
		 * long as encryption/MAC is not active, i.e. before
		 * completion of the first handshake. It it still weird;
		 * it might conceptually be useful as a heartbeat or
		 * keep-alive mechanism while some lengthy operation is
		 * going on, e.g. interaction with a human user.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>make_ready_in</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name> <operator>=</operator> <name>rlen</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there is no active encryption, then the data can be read
	 * right away. Note that we do not receive bytes from the
	 * transport medium when we still have payload bytes to be
	 * acknowledged.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rc</name><operator>-&gt;</operator><name>incrypt</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since encryption is active, we must wait for a full record
	 * before processing it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We got the full record. Decrypt it.
	 */</comment>
	<expr_stmt><expr><name>pbuf_len</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>-</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name><name>rc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>vtable</name><operator>-&gt;</operator><name>decrypt</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>vtable</name></name></expr></argument>,
		<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>record_type_in</name></name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>version_in</name></name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>pbuf_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pbuf</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_MAC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>pbuf</name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>+</operator> <name>pbuf_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decryption may have yielded an empty record, in which case
	 * we get back to "ready" state immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>make_ready_in</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>int</name></type>
<name>br_ssl_engine_recvrec_finished</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>BR_IO_IN</name></expr>:</case>
	<case>case <expr><name>BR_IO_INOUT</name></expr>:</case>
		<return>return <expr><name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</return>
	<default>default:</default>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>recvpld_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * There is payload data to be read only if the mode is
	 * compatible, and ixa != ixb.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>BR_IO_IN</name></expr>:</case>
	<case>case <expr><name>BR_IO_INOUT</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name></expr>;</expr_stmt>
		<return>return <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>len</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>+</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
	<default>default:</default>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>recvpld_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we read all the available data, then we either expect
	 * the remainder of the current record (if the current record
	 * was not finished; this may happen when encryption is not
	 * active), or go to "ready" state.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>ixc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>make_ready_in</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>ixa</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>ixb</name></name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>sendpld_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Payload data can be injected only if the current mode is
	 * compatible, and oxa != oxb.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>BR_IO_OUT</name></expr>:</case>
	<case>case <expr><name>BR_IO_INOUT</name></expr>:</case>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name></expr>;</expr_stmt>
		<return>return <expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name>len</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name> <operator>+</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name><operator>)</operator></expr></else></ternary></expr>;</return>
	<default>default:</default>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * If some payload bytes have been accumulated, then wrap them into
 * an outgoing record. Otherwise, this function does nothing, unless
 * 'force' is non-zero, in which case an empty record is assembled.
 *
 * The caller must take care not to invoke this function if the engine
 * is not currently ready to receive payload bytes to send.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendpld_flush</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>xlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>xlen</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xlen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>force</name></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name><name>rc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>vtable</name><operator>-&gt;</operator><name>encrypt</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>vtable</name></name></expr></argument>,
		<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>record_type_out</name></name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>version_out</name></name></expr></argument>,
		<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name> <operator>+</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name>buf</name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>+</operator> <name>xlen</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendpld_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If using a shared buffer, then we may have to modify the
	 * current mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>==</operator> <name>BR_IO_INOUT</name> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>ibuf</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name> <operator>=</operator> <name>BR_IO_OUT</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>&gt;=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * Set oxb to one more than oxa so that sendpld_flush()
		 * does not mistakingly believe that a record is
		 * already prepared and being sent.
		 */</comment>
		<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sendpld_flush</name><argument_list>(<argument><expr><name>rc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>sendrec_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * When still gathering payload bytes, oxc points to the start
	 * of the record data, so oxc &lt;= oxa. However, when a full
	 * record has been completed, oxc points to the end of the record,
	 * so oxc &gt; oxa.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>iomode</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>BR_IO_OUT</name></expr>:</case>
	<case>case <expr><name>BR_IO_INOUT</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name> <operator>&gt;</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name> <operator>-</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name></expr>;</expr_stmt>
			<return>return <expr><name><name>rc</name><operator>-&gt;</operator><name>obuf</name></name> <operator>+</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>sendrec_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>=</operator> <operator>(</operator><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>+=</operator> <name>len</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>make_ready_out</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Test whether there is some buffered outgoing record that still must
 * sent.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type>
<name>has_rec_tosend</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>rc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>==</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxb</name></name> <operator>&amp;&amp;</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxa</name></name> <operator>!=</operator> <name><name>rc</name><operator>-&gt;</operator><name>oxc</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The "no encryption" mode has no overhead. It limits the payload size
 * to the maximum size allowed by the standard (16384 bytes); the caller
 * is responsible for possibly enforcing a smaller fragment length.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_max_plaintext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_sslrec_out_clear_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>end</name> <operator>-</operator> <operator>*</operator><name>start</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">16384</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <operator>*</operator><name>start</name> <operator>+</operator> <literal type="number">16384</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * In "no encryption" mode, encryption is trivial (a no-operation) so
 * we just have to encode the header.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>clear_encrypt</name><parameter_list>(<parameter><decl><type><name>br_sslrec_out_clear_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>record_type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>data_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>data</name> <operator>-</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>record_type</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc16be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc16be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><operator>*</operator><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>data_len</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>br_sslrec_out_class</name></type> <name>br_sslrec_out_clear_vtable</name> <init>= <expr><block>{
	<expr><sizeof>sizeof<argument_list>(<argument><expr><name>br_sslrec_out_clear_context</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><specifier>const</specifier> <name>br_sslrec_out_class</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator>
		<operator>&amp;</operator><name>clear_max_plaintext</name></expr>,
	<expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><call>(<modifier>*</modifier>)<argument_list>(<argument><expr><specifier>const</specifier> <name>br_sslrec_out_class</name> <operator>*</operator><operator>*</operator></expr></argument>,
		<argument><expr><name>int</name></expr></argument>, <argument><expr><name>unsigned</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>, <argument><expr><name>size_t</name> <operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator>
		<operator>&amp;</operator><name>clear_encrypt</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ==================================================================== */</comment>
<comment type="block">/*
 * In this part of the file, we handle the various record types, and
 * communications with the handshake processor.
 */</comment>

<comment type="block">/*
 * IMPLEMENTATION NOTES
 * ====================
 *
 * The handshake processor is written in T0 and runs as a coroutine.
 * It receives the contents of all records except application data, and
 * is responsible for producing the contents of all records except
 * application data.
 *
 * A state flag is maintained, which specifies whether application data
 * is acceptable or not. When it is set:
 *
 * -- Application data can be injected as payload data (provided that
 *    the output buffer is ready for that).
 *
 * -- Incoming application data records are accepted, and yield data
 *    that the caller may retrieve.
 *
 * When the flag is cleared, application data is not accepted from the
 * application, and incoming application data records trigger an error.
 *
 *
 * Records of type handshake, alert or change-cipher-spec are handled
 * by the handshake processor. The handshake processor is written in T0
 * and runs as a coroutine; it gets invoked whenever one of the following
 * situations is reached:
 *
 * -- An incoming record has type handshake, alert or change-cipher-spec,
 *    and yields data that can be read (zero-length records are thus
 *    ignored).
 *
 * -- An outgoing record has just finished being sent, and the "application
 *    data" flag is cleared.
 *
 * -- The caller wishes to perform a close (call to br_ssl_engine_close()).
 *
 * -- The caller wishes to perform a renegotiation (call to
 *    br_ssl_engine_renegotiate()).
 *
 * Whenever the handshake processor is entered, access to the payload
 * buffers is provided, along with some information about explicit
 * closures or renegotiations.
 */</comment>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_set_suites</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>suites</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>suites_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>suites_num</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>suites</name><operator>)</operator> <operator>&gt;</operator> <sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>suites_buf</name></name></sizeof></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>BR_ERR_BAD_PARAM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>suites_buf</name></name></expr></argument>, <argument><expr><name>suites</name></expr></argument>, <argument><expr><name>suites_num</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>suites</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>suites_num</name></name> <operator>=</operator> <name>suites_num</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Give control to handshake processor. 'action' is 1 for a close,
 * 2 for a renegotiation, or 0 for a jump due to I/O completion.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>jump_handshake</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We use a loop because the handshake processor actions may
	 * allow for more actions; namely, if the processor reads all
	 * input data, then it may allow for output data to be produced,
	 * in case of a shared in/out buffer.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>hlen_in</name></decl>, <decl><type ref="prev"/><name>hlen_out</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get input buffer. We do not want to provide
		 * application data to the handshake processor (we could
		 * get called with an explicit close or renegotiation
		 * while there is application data ready to be read).
		 */</comment>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_in</name></name> <operator>=</operator> <call><name>recvpld_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hlen_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_in</name></name> <operator>!=</operator> <name>NULL</name>
			<operator>&amp;&amp;</operator> <name><name>cc</name><operator>-&gt;</operator><name>record_type_in</name></name> <operator>==</operator> <name>BR_SSL_APPLICATION_DATA</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hlen_in</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Get output buffer. The handshake processor never
		 * leaves an unfinished outgoing record, so if there is
		 * buffered output, then it MUST be some application
		 * data, so the processor cannot write to it.
		 */</comment>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>saved_hbuf_out</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>=</operator> <call><name>sendpld_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hlen_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>br_ssl_engine_has_pld_to_send</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>hlen_out</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Note: hlen_in and hlen_out can be both non-zero only if
		 * the input and output buffers are disjoint. Thus, we can
		 * offer both buffers to the handshake code.
		 */</comment>

		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>hlen_in</name></name> <operator>=</operator> <name>hlen_in</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>hlen_out</name></name> <operator>=</operator> <name>hlen_out</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>hsrun</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>cpu</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_closed</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>!=</operator> <name><name>cc</name><operator>-&gt;</operator><name>saved_hbuf_out</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>sendpld_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>-</operator> <name><name>cc</name><operator>-&gt;</operator><name>saved_hbuf_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>hlen_in</name> <operator>!=</operator> <name><name>cc</name><operator>-&gt;</operator><name>hlen_in</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>recvpld_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>hlen_in</name> <operator>-</operator> <name><name>cc</name><operator>-&gt;</operator><name>hlen_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>hlen_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<comment type="block">/*
				 * We read all data bytes, which may have
				 * released the output buffer in case it
				 * is shared with the input buffer, and
				 * the handshake code might be waiting for
				 * that.
				 */</comment>
				<expr_stmt><expr><name>action</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_flush_record</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>!=</operator> <name><name>cc</name><operator>-&gt;</operator><name>saved_hbuf_out</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sendpld_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>-</operator> <name><name>cc</name><operator>-&gt;</operator><name>saved_hbuf_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_has_pld_to_send</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sendpld_flush</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>saved_hbuf_out</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>hbuf_out</name></name> <operator>=</operator> <call><name>sendpld_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>hlen_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>br_ssl_engine_sendapp_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>sendpld_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_sendapp_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sendpld_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>br_ssl_engine_recvapp_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator>
		<operator>||</operator> <name><name>cc</name><operator>-&gt;</operator><name>record_type_in</name></name> <operator>!=</operator> <name>BR_SSL_APPLICATION_DATA</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>recvpld_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_recvapp_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>recvpld_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>br_ssl_engine_sendrec_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>sendrec_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_sendrec_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>sendrec_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>has_rec_tosend</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>record_type_out</name></name> <operator>!=</operator> <name>BR_SSL_APPLICATION_DATA</name>
		<operator>||</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>jump_handshake</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>br_ssl_engine_recvrec_buf</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>recvrec_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_recvrec_ack</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>recvrec_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_closed</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We just received some bytes from the peer. This may have
	 * yielded some payload bytes, in which case we must process
	 * them according to the record type.
	 */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>recvpld_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<switch>switch <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>record_type_in</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>BR_SSL_CHANGE_CIPHER_SPEC</name></expr>:</case>
		<case>case <expr><name>BR_SSL_ALERT</name></expr>:</case>
		<case>case <expr><name>BR_SSL_HANDSHAKE</name></expr>:</case>
			<expr_stmt><expr><call><name>jump_handshake</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BR_SSL_APPLICATION_DATA</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we are currently closing, and waiting for
			 * a close_notify from the peer, then incoming
			 * application data should be discarded.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>recvpld_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Fall through */</comment>
		<default>default:</default>
			<expr_stmt><expr><call><name>br_ssl_engine_fail</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>BR_ERR_UNEXPECTED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_close</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>br_ssl_engine_closed</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/*
		 * If we are not already closed, then we need to
		 * initiate the closure. Once closing, any incoming
		 * application data is discarded; we should also discard
		 * application data which is already there but has not
		 * been acknowledged by the application yet (this mimics
		 * usual semantics on BSD sockets: you cannot read()
		 * once you called close(), even if there was some
		 * unread data already buffered).
		 */</comment>
		<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_recvapp_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>br_ssl_engine_recvapp_ack</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>jump_handshake</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>int</name></type>
<name>br_ssl_engine_renegotiate</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_closed</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>cc</name><operator>-&gt;</operator><name>reneg</name></name> <operator>==</operator> <literal type="number">1</literal>
		<operator>||</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>BR_OPT_NO_RENEGOTIATION</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>
		<operator>||</operator> <call><name>br_ssl_engine_recvapp_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>jump_handshake</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl.h */</comment>
<function><type><name>unsigned</name></type>
<name>br_ssl_engine_current_state</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_closed</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>BR_SSL_CLOSED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_sendrec_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>|=</operator> <name>BR_SSL_SENDREC</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_recvrec_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>|=</operator> <name>BR_SSL_RECVREC</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_sendapp_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>|=</operator> <name>BR_SSL_SENDAPP</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>br_ssl_engine_recvapp_buf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s</name> <operator>|=</operator> <name>BR_SSL_RECVAPP</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>s</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ssl.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_flush</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>br_ssl_engine_closed</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sendpld_flush</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_hs_reset</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>hsinit</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>hsrun</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>engine_clearbuf</name><argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>cpu</name><operator>.</operator><name>dp</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>dp_stack</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>cpu</name><operator>.</operator><name>rp</name></name> <operator>=</operator> <name><name>cc</name><operator>-&gt;</operator><name>rp_stack</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>hsinit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>cpu</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>hsrun</name></name> <operator>=</operator> <name>hsrun</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>shutdown_recv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>application_data</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>alert</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>jump_handshake</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>br_tls_prf_impl</name></type>
<name>br_ssl_engine_get_PRF</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>version</name></name> <operator>&gt;=</operator> <name>BR_TLS12</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>prf_id</name> <operator>==</operator> <name>br_sha384_ID</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>prf_sha384</name></name></expr>;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>prf_sha256</name></name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<return>return <expr><name><name>cc</name><operator>-&gt;</operator><name>prf10</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_compute_master</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pms</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>pms_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>br_tls_prf_impl</name></type> <name>iprf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>br_tls_prf_seed_chunk</name></type> <name><name>seed</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><block>{ <expr><name><name>cc</name><operator>-&gt;</operator><name>client_random</name></name></expr>, <expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>client_random</name></name></sizeof></expr> }</block></expr>,
		<expr><block>{ <expr><name><name>cc</name><operator>-&gt;</operator><name>server_random</name></name></expr>, <expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>server_random</name></name></sizeof></expr> }</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>iprf</name> <operator>=</operator> <call><name>br_ssl_engine_get_PRF</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>iprf</name><argument_list>(<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>master_secret</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>master_secret</name></name></sizeof></expr></argument>,
		<argument><expr><name>pms</name></expr></argument>, <argument><expr><name>pms_len</name></expr></argument>, <argument><expr><literal type="string">"master secret"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Compute key block.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_key_block</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name></type> <name>half_len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>kb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>br_tls_prf_impl</name></type> <name>iprf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>br_tls_prf_seed_chunk</name></type> <name><name>seed</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{
		<expr><block>{ <expr><name><name>cc</name><operator>-&gt;</operator><name>server_random</name></name></expr>, <expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>server_random</name></name></sizeof></expr> }</block></expr>,
		<expr><block>{ <expr><name><name>cc</name><operator>-&gt;</operator><name>client_random</name></name></expr>, <expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>client_random</name></name></sizeof></expr> }</block></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>iprf</name> <operator>=</operator> <call><name>br_ssl_engine_get_PRF</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>iprf</name><argument_list>(<argument><expr><name>kb</name></expr></argument>, <argument><expr><name>half_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr></argument>,
		<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>master_secret</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>master_secret</name></name></sizeof></expr></argument>,
		<argument><expr><literal type="string">"key expansion"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_cbc_in</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mac_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_block_cbcdec_class</name> <modifier>*</modifier></type><name>bc_impl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cipher_key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">192</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mac_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>br_hash_class</name> <modifier>*</modifier></type><name>imh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>mac_key_len</name></decl>, <decl><type ref="prev"/><name>mac_out_len</name></decl>, <decl><type ref="prev"/><name>iv_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>imh</name> <operator>=</operator> <call><name>br_ssl_engine_get_hash</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>mac_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mac_out_len</name> <operator>=</operator> <operator>(</operator><name><name>imh</name><operator>-&gt;</operator><name>desc</name></name> <operator>&gt;&gt;</operator> <name>BR_HASHDESC_OUT_OFF</name><operator>)</operator> <operator>&amp;</operator> <name>BR_HASHDESC_OUT_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mac_key_len</name> <operator>=</operator> <name>mac_out_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * TLS 1.1+ uses per-record explicit IV, so no IV to generate here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>version</name></name> <operator>&gt;=</operator> <name>BR_TLS11</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>iv_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>iv_len</name> <operator>=</operator> <name><name>bc_impl</name><operator>-&gt;</operator><name>block_size</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>,
		<argument><expr><name>mac_key_len</name> <operator>+</operator> <name>cipher_key_len</name> <operator>+</operator> <name>iv_len</name></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>mac_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>mac_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>mac_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>cipher_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><operator>(</operator><name>mac_key_len</name> <operator>+</operator> <name>cipher_key_len</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>iv_len</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>mac_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>mac_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>mac_key_len</name> <operator>+</operator> <name>cipher_key_len</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>iv_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>icbc_in</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>cbc</name><operator>.</operator><name>vtable</name></name></expr></argument>,
		<argument><expr><name>bc_impl</name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>cipher_key_len</name></expr></argument>,
		<argument><expr><name>imh</name></expr></argument>, <argument><expr><name>mac_key</name></expr></argument>, <argument><expr><name>mac_key_len</name></expr></argument>, <argument><expr><name>mac_out_len</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>incrypt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_cbc_out</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mac_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_block_cbcenc_class</name> <modifier>*</modifier></type><name>bc_impl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cipher_key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">192</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>mac_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>br_hash_class</name> <modifier>*</modifier></type><name>imh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>mac_key_len</name></decl>, <decl><type ref="prev"/><name>mac_out_len</name></decl>, <decl><type ref="prev"/><name>iv_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>imh</name> <operator>=</operator> <call><name>br_ssl_engine_get_hash</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>mac_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mac_out_len</name> <operator>=</operator> <operator>(</operator><name><name>imh</name><operator>-&gt;</operator><name>desc</name></name> <operator>&gt;&gt;</operator> <name>BR_HASHDESC_OUT_OFF</name><operator>)</operator> <operator>&amp;</operator> <name>BR_HASHDESC_OUT_MASK</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>mac_key_len</name> <operator>=</operator> <name>mac_out_len</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * TLS 1.1+ uses per-record explicit IV, so no IV to generate here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cc</name><operator>-&gt;</operator><name>session</name><operator>.</operator><name>version</name></name> <operator>&gt;=</operator> <name>BR_TLS11</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>iv_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>iv_len</name> <operator>=</operator> <name><name>bc_impl</name><operator>-&gt;</operator><name>block_size</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>,
		<argument><expr><name>mac_key_len</name> <operator>+</operator> <name>cipher_key_len</name> <operator>+</operator> <name>iv_len</name></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>mac_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>mac_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>mac_key_len</name> <operator>+</operator> <name>cipher_key_len</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>mac_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>mac_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>mac_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>cipher_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><operator>(</operator><name>mac_key_len</name> <operator>+</operator> <name>cipher_key_len</name><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>iv_len</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>iv_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>icbc_out</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>cbc</name><operator>.</operator><name>vtable</name></name></expr></argument>,
		<argument><expr><name>bc_impl</name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>cipher_key_len</name></expr></argument>,
		<argument><expr><name>imh</name></expr></argument>, <argument><expr><name>mac_key</name></expr></argument>, <argument><expr><name>mac_key_len</name></expr></argument>, <argument><expr><name>mac_out_len</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_gcm_in</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_block_ctr_class</name> <modifier>*</modifier></type><name>bc_impl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cipher_key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">72</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>, <argument><expr><name>cipher_key_len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>igcm_in</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>gcm</name><operator>.</operator><name>vtable</name><operator>.</operator><name>in</name></name></expr></argument>,
		<argument><expr><name>bc_impl</name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>cipher_key_len</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>ighash</name></name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>incrypt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_gcm_out</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_block_ctr_class</name> <modifier>*</modifier></type><name>bc_impl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>cipher_key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">72</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>, <argument><expr><name>cipher_key_len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>igcm_out</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>gcm</name><operator>.</operator><name>vtable</name><operator>.</operator><name>out</name></name></expr></argument>,
		<argument><expr><name>bc_impl</name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>cipher_key_len</name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>ighash</name></name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_chapol_in</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">88</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">76</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>ichapol_in</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>chapol</name><operator>.</operator><name>vtable</name><operator>.</operator><name>in</name></name></expr></argument>,
		<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>ichacha</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>ipoly</name></name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>incrypt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_chapol_out</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">88</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>, <argument><expr><literal type="number">44</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">76</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>ichapol_out</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>chapol</name><operator>.</operator><name>vtable</name><operator>.</operator><name>out</name></name></expr></argument>,
		<argument><expr><name><name>cc</name><operator>-&gt;</operator><name>ichacha</name></name></expr></argument>, <argument><expr><name><name>cc</name><operator>-&gt;</operator><name>ipoly</name></name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_ccm_in</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_block_ctrcbc_class</name> <modifier>*</modifier></type><name>bc_impl</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name></type> <name>cipher_key_len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tag_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">72</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>, <argument><expr><name>cipher_key_len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>iccm_in</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>ccm</name><operator>.</operator><name>vtable</name><operator>.</operator><name>in</name></name></expr></argument>,
		<argument><expr><name>bc_impl</name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>cipher_key_len</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>, <argument><expr><name>tag_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cc</name><operator>-&gt;</operator><name>incrypt</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>void</name></type>
<name>br_ssl_engine_switch_ccm_out</name><parameter_list>(<parameter><decl><type><name>br_ssl_engine_context</name> <modifier>*</modifier></type><name>cc</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>is_client</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prf_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>br_block_ctrcbc_class</name> <modifier>*</modifier></type><name>bc_impl</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name></type> <name>cipher_key_len</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tag_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>kb</name><index>[<expr><literal type="number">72</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cipher_key</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>compute_key_block</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name>prf_id</name></expr></argument>, <argument><expr><name>cipher_key_len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>kb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>is_client</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>cipher_key</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><name>cipher_key_len</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>iv</name> <operator>=</operator> <operator>&amp;</operator><name><name>kb</name><index>[<expr><operator>(</operator><name>cipher_key_len</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name><name>cc</name><operator>-&gt;</operator><name>iccm_out</name><operator>-&gt;</operator><name>init</name></name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cc</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>ccm</name><operator>.</operator><name>vtable</name><operator>.</operator><name>out</name></name></expr></argument>,
		<argument><expr><name>bc_impl</name></expr></argument>, <argument><expr><name>cipher_key</name></expr></argument>, <argument><expr><name>cipher_key_len</name></expr></argument>, <argument><expr><name>iv</name></expr></argument>, <argument><expr><name>tag_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
