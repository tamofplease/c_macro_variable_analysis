<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/int/i15_moddiv.c"><comment type="block">/*
 * Copyright (c) 2018 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * In this file, we handle big integers with a custom format, i.e.
 * without the usual one-word header. Value is split into 15-bit words,
 * each stored in a 16-bit slot (top bit is zero) in little-endian
 * order. The length (in words) is provided explicitly. In some cases,
 * the value can be negative (using two's complement representation). In
 * some cases, the top word is allowed to have a 16th bit.
 */</comment>

<comment type="block">/*
 * Negate big integer conditionally. The value consists of 'len' words,
 * with 15 bits in each word (the top bit of each word should be 0,
 * except possibly for the last word). If 'ctl' is 1, the negation is
 * computed; otherwise, if 'ctl' is 0, then the value is unchanged.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cond_negate</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>, <decl><type ref="prev"/><name>xm</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>ctl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>xm</name> <operator>=</operator> <literal type="number">0x7FFF</literal> <operator>&amp;</operator> <operator>-</operator><name>ctl</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>aw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aw</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aw</name> <operator>=</operator> <operator>(</operator><name>aw</name> <operator>^</operator> <name>xm</name><operator>)</operator> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>aw</name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>aw</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Finish modular reduction. Rules on input parameters:
 *
 *   if neg = 1, then -m &lt;= a &lt; 0
 *   if neg = 0, then 0 &lt;= a &lt; 2*m
 *
 * If neg = 0, then the top word of a[] may use 16 bits.
 *
 * Also, modulus m must be odd.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>finish_mod</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>neg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>cc</name></decl>, <decl><type ref="prev"/><name>xm</name></decl>, <decl><type ref="prev"/><name>ym</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First pass: compare a (assumed nonnegative) with m.
	 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>aw</name></decl>, <decl><type ref="prev"/><name>mw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aw</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mw</name> <operator>=</operator> <name><name>m</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>aw</name> <operator>-</operator> <name>mw</name> <operator>-</operator> <name>cc</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * At this point:
	 *   if neg = 1, then we must add m (regardless of cc)
	 *   if neg = 0 and cc = 0, then we must subtract m
	 *   if neg = 0 and cc = 1, then we must do nothing
	 */</comment>
	<expr_stmt><expr><name>xm</name> <operator>=</operator> <literal type="number">0x7FFF</literal> <operator>&amp;</operator> <operator>-</operator><name>neg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ym</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>neg</name> <operator>|</operator> <operator>(</operator><literal type="number">1</literal> <operator>-</operator> <name>cc</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>neg</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>aw</name></decl>, <decl><type ref="prev"/><name>mw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aw</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>mw</name> <operator>=</operator> <operator>(</operator><name><name>m</name><index>[<expr><name>k</name></expr>]</index></name> <operator>^</operator> <name>xm</name><operator>)</operator> <operator>&amp;</operator> <name>ym</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>aw</name> <operator>=</operator> <name>aw</name> <operator>-</operator> <name>mw</name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name></expr>]</index></name> <operator>=</operator> <name>aw</name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>aw</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Compute:
 *   a &lt;- (a*pa+b*pb)/(2^15)
 *   b &lt;- (a*qa+b*qb)/(2^15)
 * The division is assumed to be exact (i.e. the low word is dropped).
 * If the final a is negative, then it is negated. Similarly for b.
 * Returned value is the combination of two bits:
 *   bit 0: 1 if a had to be negated, 0 otherwise
 *   bit 1: 1 if b had to be negated, 0 otherwise
 *
 * Factors pa, pb, qa and qb must be at most 2^15 in absolute value.
 * Source integers a and b must be nonnegative; top word is not allowed
 * to contain an extra 16th bit.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>co_reduce</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><name>int32_t</name></type> <name>pa</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>pb</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>qa</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>qb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>cca</name></decl>, <decl><type ref="prev"/><name>ccb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>nega</name></decl>, <decl><type ref="prev"/><name>negb</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cca</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ccb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>wa</name></decl>, <decl><type ref="prev"/><name>wb</name></decl>, <decl><type ref="prev"/><name>za</name></decl>, <decl><type ref="prev"/><name>zb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint16_t</name></type> <name>tta</name></decl>, <decl><type ref="prev"/><name>ttb</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since:
		 *   |pa| &lt;= 2^15
		 *   |pb| &lt;= 2^15
		 *   0 &lt;= wa &lt;= 2^15 - 1
		 *   0 &lt;= wb &lt;= 2^15 - 1
		 *   |cca| &lt;= 2^16 - 1
		 * Then:
		 *   |za| &lt;= (2^15-1)*(2^16) + (2^16-1) = 2^31 - 1
		 *
		 * Thus, the new value of cca is such that |cca| &lt;= 2^16 - 1.
		 * The same applies to ccb.
		 */</comment>
		<expr_stmt><expr><name>wa</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>wb</name> <operator>=</operator> <name><name>b</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>za</name> <operator>=</operator> <name>wa</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pa</name> <operator>+</operator> <name>wb</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pb</name> <operator>+</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>cca</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zb</name> <operator>=</operator> <name>wa</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>qa</name> <operator>+</operator> <name>wb</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>qb</name> <operator>+</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ccb</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>za</name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>b</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>zb</name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>tta</name> <operator>=</operator> <name>za</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ttb</name> <operator>=</operator> <name>zb</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cca</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tta</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ccb</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int16_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ttb</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>a</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>cca</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>ccb</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>nega</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>cca</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>negb</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ccb</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cond_negate</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>nega</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cond_negate</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>negb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nega</name> <operator>|</operator> <operator>(</operator><name>negb</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute:
 *   a &lt;- (a*pa+b*pb)/(2^15) mod m
 *   b &lt;- (a*qa+b*qb)/(2^15) mod m
 *
 * m0i is equal to -1/m[0] mod 2^15.
 *
 * Factors pa, pb, qa and qb must be at most 2^15 in absolute value.
 * Source integers a and b must be nonnegative; top word is not allowed
 * to contain an extra 16th bit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>co_reduce_mod</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><name>int32_t</name></type> <name>pa</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>pb</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>qa</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>qb</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>m0i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>cca</name></decl>, <decl><type ref="prev"/><name>ccb</name></decl>, <decl><type ref="prev"/><name>fa</name></decl>, <decl><type ref="prev"/><name>fb</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cca</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>ccb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fa</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pa</name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pb</name><operator>)</operator> <operator>*</operator> <name>m0i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fb</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>qa</name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>qb</name><operator>)</operator> <operator>*</operator> <name>m0i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>wa</name></decl>, <decl><type ref="prev"/><name>wb</name></decl>, <decl><type ref="prev"/><name>za</name></decl>, <decl><type ref="prev"/><name>zb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>tta</name></decl>, <decl><type ref="prev"/><name>ttb</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * In this loop, carries 'cca' and 'ccb' always fit on
		 * 17 bits (in absolute value).
		 */</comment>
		<expr_stmt><expr><name>wa</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>wb</name> <operator>=</operator> <name><name>b</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>za</name> <operator>=</operator> <name>wa</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pa</name> <operator>+</operator> <name>wb</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>pb</name>
			<operator>+</operator> <name><name>m</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>fa</name> <operator>+</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>cca</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zb</name> <operator>=</operator> <name>wa</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>qa</name> <operator>+</operator> <name>wb</name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>qb</name>
			<operator>+</operator> <name><name>m</name><index>[<expr><name>k</name></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>fb</name> <operator>+</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ccb</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>a</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>za</name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>b</name><index>[<expr><name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>zb</name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * The XOR-and-sub construction below does an arithmetic
		 * right shift in a portable way (technically, right-shifting
		 * a negative signed value is implementation-defined in C).
		 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M</name></cpp:macro>   <cpp:value>((uint32_t)1 &lt;&lt; 16)</cpp:value></cpp:define>
		<expr_stmt><expr><name>tta</name> <operator>=</operator> <name>za</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ttb</name> <operator>=</operator> <name>zb</name> <operator>&gt;&gt;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>tta</name> <operator>=</operator> <operator>(</operator><name>tta</name> <operator>^</operator> <name>M</name><operator>)</operator> <operator>-</operator> <name>M</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ttb</name> <operator>=</operator> <operator>(</operator><name>ttb</name> <operator>^</operator> <name>M</name><operator>)</operator> <operator>-</operator> <name>M</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cca</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>tta</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ccb</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int32_t</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>ttb</name></expr>;</expr_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>M</name></cpp:undef>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>a</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>cca</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>ccb</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * At this point:
	 *   -m &lt;= a &lt; 2*m
	 *   -m &lt;= b &lt; 2*m
	 * (this is a case of Montgomery reduction)
	 * The top word of 'a' and 'b' may have a 16-th bit set.
	 * We may have to add or subtract the modulus.
	 */</comment>
	<expr_stmt><expr><call><name>finish_mod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>cca</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>finish_mod</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name>ccb</name> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* see inner.h */</comment>
<function><type><name>uint32_t</name></type>
<name>br_i15_moddiv</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>m</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name></type> <name>m0i</name></decl></parameter>,
	<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Algorithm is an extended binary GCD. We maintain four values
	 * a, b, u and v, with the following invariants:
	 *
	 *   a * x = y * u mod m
	 *   b * x = y * v mod m
	 *
	 * Starting values are:
	 *
	 *   a = y
	 *   b = m
	 *   u = x
	 *   v = 0
	 *
	 * The formal definition of the algorithm is a sequence of steps:
	 *
	 *   - If a is even, then a &lt;- a/2 and u &lt;- u/2 mod m.
	 *   - Otherwise, if b is even, then b &lt;- b/2 and v &lt;- v/2 mod m.
	 *   - Otherwise, if a &gt; b, then a &lt;- (a-b)/2 and u &lt;- (u-v)/2 mod m.
	 *   - Otherwise, b &lt;- (b-a)/2 and v &lt;- (v-u)/2 mod m.
	 *
	 * Algorithm stops when a = b. At that point, they both are equal
	 * to GCD(y,m); the modular division succeeds if that value is 1.
	 * The result of the modular division is then u (or v: both are
	 * equal at that point).
	 *
	 * Each step makes either a or b shrink by at least one bit; hence,
	 * if m has bit length k bits, then 2k-2 steps are sufficient.
	 *
	 *
	 * Though complexity is quadratic in the size of m, the bit-by-bit
	 * processing is not very efficient. We can speed up processing by
	 * remarking that the decisions are taken based only on observation
	 * of the top and low bits of a and b.
	 *
	 * In the loop below, at each iteration, we use the two top words
	 * of a and b, and the low words of a and b, to compute reduction
	 * parameters pa, pb, qa and qb such that the new values for a
	 * and b are:
	 *
	 *   a' = (a*pa + b*pb) / (2^15)
	 *   b' = (a*qa + b*qb) / (2^15)
	 *
	 * the division being exact.
	 *
	 * Since the choices are based on the top words, they may be slightly
	 * off, requiring an optional correction: if a' &lt; 0, then we replace
	 * pa with -pa, and pb with -pb. The total length of a and b is
	 * thus reduced by at least 14 bits at each iteration.
	 *
	 * The stopping conditions are still the same, though: when a
	 * and b become equal, they must be both odd (since m is odd,
	 * the GCD cannot be even), therefore the next operation is a
	 * subtraction, and one of the values becomes 0. At that point,
	 * nothing else happens, i.e. one value is stuck at 0, and the
	 * other one is the GCD.
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>u</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>num</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">15</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>a</name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>b</name> <operator>=</operator> <name>a</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>u</name> <operator>=</operator> <name>x</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>v</name> <operator>=</operator> <name>b</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>y</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>m</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop below ensures that a and b are reduced by some bits each,
	 * for a total of at least 14 bits.
	 */</comment>
	<for>for <control>(<init><expr><name>num</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name><name>m</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">14</literal></expr>;</init> <condition><expr><name>num</name> <operator>&gt;=</operator> <literal type="number">14</literal></expr>;</condition> <incr><expr><name>num</name> <operator>-=</operator> <literal type="number">14</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>c0</name></decl>, <decl><type ref="prev"/><name>c1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>a0</name></decl>, <decl><type ref="prev"/><name>a1</name></decl>, <decl><type ref="prev"/><name>b0</name></decl>, <decl><type ref="prev"/><name>b1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>a_hi</name></decl>, <decl><type ref="prev"/><name>b_hi</name></decl>, <decl><type ref="prev"/><name>a_lo</name></decl>, <decl><type ref="prev"/><name>b_lo</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int32_t</name></type> <name>pa</name></decl>, <decl><type ref="prev"/><name>pb</name></decl>, <decl><type ref="prev"/><name>qa</name></decl>, <decl><type ref="prev"/><name>qb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Extract top words of a and b. If j is the highest
		 * index &gt;= 1 such that a[j] != 0 or b[j] != 0, then we want
		 * (a[j] &lt;&lt; 15) + a[j - 1], and (b[j] &lt;&lt; 15) + b[j - 1].
		 * If a and b are down to one word each, then we use a[0]
		 * and b[0].
		 */</comment>
		<expr_stmt><expr><name>c0</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>c1</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>a0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>a1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>b0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>b1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>j</name> <operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>aw</name></decl>, <decl><type ref="prev"/><name>bw</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>aw</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bw</name> <operator>=</operator> <name><name>b</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>a0</name> <operator>^=</operator> <operator>(</operator><name>a0</name> <operator>^</operator> <name>aw</name><operator>)</operator> <operator>&amp;</operator> <name>c0</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>a1</name> <operator>^=</operator> <operator>(</operator><name>a1</name> <operator>^</operator> <name>aw</name><operator>)</operator> <operator>&amp;</operator> <name>c1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b0</name> <operator>^=</operator> <operator>(</operator><name>b0</name> <operator>^</operator> <name>bw</name><operator>)</operator> <operator>&amp;</operator> <name>c0</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b1</name> <operator>^=</operator> <operator>(</operator><name>b1</name> <operator>^</operator> <name>bw</name><operator>)</operator> <operator>&amp;</operator> <name>c1</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>c1</name> <operator>=</operator> <name>c0</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>c0</name> <operator>&amp;=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>aw</name> <operator>|</operator> <name>bw</name><operator>)</operator> <operator>+</operator> <literal type="number">0xFFFF</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * If c1 = 0, then we grabbed two words for a and b.
		 * If c1 != 0 but c0 = 0, then we grabbed one word. It
		 * is not possible that c1 != 0 and c0 != 0, because that
		 * would mean that both integers are zero.
		 */</comment>
		<expr_stmt><expr><name>a1</name> <operator>|=</operator> <name>a0</name> <operator>&amp;</operator> <name>c1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>a0</name> <operator>&amp;=</operator> <operator>~</operator><name>c1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b1</name> <operator>|=</operator> <name>b0</name> <operator>&amp;</operator> <name>c1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b0</name> <operator>&amp;=</operator> <operator>~</operator><name>c1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>a_hi</name> <operator>=</operator> <operator>(</operator><name>a0</name> <operator>&lt;&lt;</operator> <literal type="number">15</literal><operator>)</operator> <operator>+</operator> <name>a1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b_hi</name> <operator>=</operator> <operator>(</operator><name>b0</name> <operator>&lt;&lt;</operator> <literal type="number">15</literal><operator>)</operator> <operator>+</operator> <name>b1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>a_lo</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>b_lo</name> <operator>=</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute reduction factors:
		 *
		 *   a' = a*pa + b*pb
		 *   b' = a*qa + b*qb
		 *
		 * such that a' and b' are both multiple of 2^15, but are
		 * only marginally larger than a and b.
		 */</comment>
		<expr_stmt><expr><name>pa</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pb</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>qa</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>qb</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">15</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<comment type="block">/*
			 * At each iteration:
			 *
			 *   a &lt;- (a-b)/2 if: a is odd, b is odd, a_hi &gt; b_hi
			 *   b &lt;- (b-a)/2 if: a is odd, b is odd, a_hi &lt;= b_hi
			 *   a &lt;- a/2 if: a is even
			 *   b &lt;- b/2 if: a is odd, b is even
			 *
			 * We multiply a_lo and b_lo by 2 at each
			 * iteration, thus a division by 2 really is a
			 * non-multiplication by 2.
			 */</comment>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>oa</name></decl>, <decl><type ref="prev"/><name>ob</name></decl>, <decl><type ref="prev"/><name>cAB</name></decl>, <decl><type ref="prev"/><name>cBA</name></decl>, <decl><type ref="prev"/><name>cA</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * cAB = 1 if b must be subtracted from a
			 * cBA = 1 if a must be subtracted from b
			 * cA = 1 if a is divided by 2, 0 otherwise
			 *
			 * Rules:
			 *
			 *   cAB and cBA cannot be both 1.
			 *   if a is not divided by 2, b is.
			 */</comment>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>GT</name><argument_list>(<argument><expr><name>a_hi</name></expr></argument>, <argument><expr><name>b_hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>oa</name> <operator>=</operator> <operator>(</operator><name>a_lo</name> <operator>&gt;&gt;</operator> <name>i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>ob</name> <operator>=</operator> <operator>(</operator><name>b_lo</name> <operator>&gt;&gt;</operator> <name>i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>cAB</name> <operator>=</operator> <name>oa</name> <operator>&amp;</operator> <name>ob</name> <operator>&amp;</operator> <name>r</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>cBA</name> <operator>=</operator> <name>oa</name> <operator>&amp;</operator> <name>ob</name> <operator>&amp;</operator> <call><name>NOT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cA</name> <operator>=</operator> <name>cAB</name> <operator>|</operator> <call><name>NOT</name><argument_list>(<argument><expr><name>oa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Conditional subtractions.
			 */</comment>
			<expr_stmt><expr><name>a_lo</name> <operator>-=</operator> <name>b_lo</name> <operator>&amp;</operator> <operator>-</operator><name>cAB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>a_hi</name> <operator>-=</operator> <name>b_hi</name> <operator>&amp;</operator> <operator>-</operator><name>cAB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pa</name> <operator>-=</operator> <name>qa</name> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cAB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>pb</name> <operator>-=</operator> <name>qb</name> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cAB</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b_lo</name> <operator>-=</operator> <name>a_lo</name> <operator>&amp;</operator> <operator>-</operator><name>cBA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b_hi</name> <operator>-=</operator> <name>a_hi</name> <operator>&amp;</operator> <operator>-</operator><name>cBA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qa</name> <operator>-=</operator> <name>pa</name> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cBA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qb</name> <operator>-=</operator> <name>pb</name> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cBA</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Shifting.
			 */</comment>
			<expr_stmt><expr><name>a_lo</name> <operator>+=</operator> <name>a_lo</name> <operator>&amp;</operator> <operator>(</operator><name>cA</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>pa</name> <operator>+=</operator> <name>pa</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cA</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>pb</name> <operator>+=</operator> <name>pb</name> <operator>&amp;</operator> <operator>(</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cA</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>a_hi</name> <operator>^=</operator> <operator>(</operator><name>a_hi</name> <operator>^</operator> <operator>(</operator><name>a_hi</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>-</operator><name>cA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b_lo</name> <operator>+=</operator> <name>b_lo</name> <operator>&amp;</operator> <operator>-</operator><name>cA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qa</name> <operator>+=</operator> <name>qa</name> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>qb</name> <operator>+=</operator> <name>qb</name> <operator>&amp;</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><name>cA</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>b_hi</name> <operator>^=</operator> <operator>(</operator><name>b_hi</name> <operator>^</operator> <operator>(</operator><name>b_hi</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>cA</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Replace a and b with new values a' and b'.
		 */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>co_reduce</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>qa</name></expr></argument>, <argument><expr><name>qb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pa</name> <operator>-=</operator> <name>pa</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>r</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>pb</name> <operator>-=</operator> <name>pb</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>r</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>qa</name> <operator>-=</operator> <name>qa</name> <operator>*</operator> <operator>(</operator><name>r</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>qb</name> <operator>-=</operator> <name>qb</name> <operator>*</operator> <operator>(</operator><name>r</name> <operator>&amp;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>co_reduce_mod</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pa</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>qa</name></expr></argument>, <argument><expr><name>qb</name></expr></argument>, <argument><expr><name>m</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>m0i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now one of the arrays should be 0, and the other contains
	 * the GCD. If a is 0, then u is 0 as well, and v contains
	 * the division result.
	 * Result is correct if and only if GCD is 1.
	 */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator> <operator>^</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>u</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name><name>v</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>r</name> <operator>|=</operator> <name><name>a</name><index>[<expr><name>k</name></expr>]</index></name> <operator>|</operator> <name><name>b</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>u</name><index>[<expr><name>k</name></expr>]</index></name> <operator>|=</operator> <name><name>v</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><call><name>EQ0</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
