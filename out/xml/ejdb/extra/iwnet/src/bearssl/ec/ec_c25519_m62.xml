<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/ec/ec_c25519_m62.c"><comment type="block">/*
 * Copyright (c) 2018 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name> <operator>||</operator> <name>BR_UMUL128</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>GEN</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
	<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
	<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
	<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ORDER</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x7F</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_generator</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><name>GEN</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_order</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><name>ORDER</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_xoff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A field element is encoded as five 64-bit integers, in basis 2^51.
 * Limbs may be occasionally larger than 2^51, to save on carry
 * propagation costs.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASK51</name></cpp:macro>   <cpp:value>(((uint64_t)1 &lt;&lt; 51) - (uint64_t)1)</cpp:value></cpp:define>

<comment type="block">/*
 * Swap two field elements, conditionally on a flag.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f255_cswap</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>ctl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>^</operator> <name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt> <expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>^=</operator> <name>w</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Addition with no carry propagation. Limbs double in size.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f255_add</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Subtraction.
 * On input, limbs must fit on 60 bits each. On output, result is
 * partially reduced, with max value 2^255+19456; moreover, all
 * limbs will fit on 51 bits, except the low limb, which may have
 * value up to 2^51+19455.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f255_sub</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>cc</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We compute d = (2^255-19)*1024 + a - b. Since the limbs
	 * fit on 60 bits, the maximum value of operands are slightly
	 * more than 2^264, but much less than 2^265-19456. This
	 * ensures that the result is positive.
	 */</comment>

	<comment type="block">/*
	 * Initial carry is 19456, since we add 2^265-19456. Each
	 * individual subtraction may yield a carry up to 513.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <literal type="number">19456</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3FF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">61</literal><operator>)</operator> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Partial reduction. The intermediate result may be up to
	 * slightly above 2^265, but less than 2^265+2^255. When we
	 * truncate to 255 bits, the upper bits will be at most 1024.
	 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <operator>(</operator><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;=</operator> <name>MASK51</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * UMUL51(hi, lo, x, y) computes:
 *
 *   hi = floor((x * y) / (2^51))
 *   lo = x * y mod 2^51
 *
 * Note that lo &lt; 2^51, but "hi" may be larger, if the input operands are
 * larger.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UMUL51</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>, <parameter><type><name>lo</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>do { \
		unsigned __int128 umul_tmp; \
		umul_tmp = (unsigned __int128)(x) * (unsigned __int128)(y); \
		(hi) = (uint64_t)(umul_tmp &gt;&gt; 51); \
		(lo) = (uint64_t)umul_tmp &amp; MASK51; \
	} while (0)</cpp:value></cpp:define>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:elif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UMUL51</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>, <parameter><type><name>lo</name></type></parameter>, <parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>do { \
		uint64_t umul_hi, umul_lo; \
		umul_lo = _umul128((x), (y), &amp;umul_hi); \
		(hi) = (umul_hi &lt;&lt; 13) | (umul_lo &gt;&gt; 51); \
		(lo) = umul_lo &amp; MASK51; \
	} while (0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Multiplication.
 * On input, limbs must fit on 54 bits each.
 * On output, limb 0 is at most 2^51 + 155647, and other limbs fit
 * on 51 bits each.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f255_mul</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Perform cross products, accumulating values without carry
	 * propagation.
	 *
	 * Since input limbs fit on 54 bits each, each individual
	 * UMUL51 will produce a "hi" of less than 2^57. The maximum
	 * sum will be at most 5*(2^57-1) + 4*(2^51-1) (for t[5]),
	 * i.e. less than 324*2^51.
	 */</comment>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>+=</operator> <name>hi</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>UMUL51</name><argument_list>(<argument><expr><name><name>t</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>+=</operator> <name>lo</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The upper words t[5]..t[9] are folded back into the lower
	 * words, using the rule that 2^255 = 19 in the field.
	 *
	 * Since each t[i] is less than 324*2^51, the additions below
	 * will yield less than 6480*2^51 in each limb; this fits in
	 * 64 bits (6480*2^51 &lt; 8192*2^51 = 2^64), hence there is
	 * no overflow.
	 */</comment>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <name><name>t</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <name><name>t</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <name><name>t</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <name><name>t</name><index>[<expr><literal type="number">9</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Propagate carries.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since the limbs were 64-bit values, the top carry is at
	 * most 8192 (in practice, that cannot be reached). We simply
	 * performed a partial reduction.
	 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <name>cc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Multiplication by A24 = 121665.
 * Input must have limbs of 60 bits at most.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f255_mul_a24</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>cc</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * 121665 = 15 * 8111. We first multiply by 15, with carry
	 * propagation and partial reduction.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <literal type="number">15</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">15</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <literal type="number">15</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>*</operator> <literal type="number">15</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>*</operator> <literal type="number">15</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Then multiplication by 8111. At that point, we known that
	 * t[0] is less than 2^51 + 19*8192, and other limbs are less
	 * than 2^51; thus, there will be no overflow.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <literal type="number">8111</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">8111</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <literal type="number">8111</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>*</operator> <literal type="number">8111</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>*</operator> <literal type="number">8111</literal> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <literal type="number">19</literal> <operator>*</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finalize reduction.
 * On input, limbs must fit on 51 bits, except possibly the low limb,
 * which may be slightly above 2^51.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f255_final_reduce</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>cc</name></decl>, <decl><type ref="prev"/><name>w</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We add 19. If the result (in t[]) is below 2^255, then a[]
	 * is already less than 2^255-19, thus already reduced.
	 * Otherwise, we subtract 2^255 from t[], in which case we
	 * have t = a - (2^255-19), and that's our result.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">19</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * The bit 255 of t is in cc. If that bit is 0, when a[] must
	 * be unchanged; otherwise, it must be replaced with t[].
	 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>^</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_mul</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>Glen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>kb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>kblen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>k</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>x2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>z2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>x3</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>z3</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>swap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Points are encoded over exactly 32 bytes. Multipliers must fit
	 * in 32 bytes as well.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Glen</name> <operator>!=</operator> <literal type="number">32</literal> <operator>||</operator> <name>kblen</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * RFC 7748 mandates that the high bit of the last point byte must
	 * be ignored/cleared; the "&amp; MASK51" in the initialization for
	 * x1[4] clears that bit.
	 */</comment>
	<expr_stmt><expr><name><name>x1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64le</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>G</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>br_dec64le</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>G</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>br_dec64le</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>G</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x1</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>br_dec64le</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>G</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>br_dec64le</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>G</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <name>MASK51</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We can use memset() to clear values, because exact-width types
	 * like uint64_t are guaranteed to have no padding bits or
	 * trap representations.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>x2</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>z2</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><sizeof>sizeof <name>x1</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><sizeof>sizeof <name>x2</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The multiplier is provided in big-endian notation, and
	 * possibly shorter than 32 bytes.
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><sizeof>sizeof <name>k</name></sizeof><operator>)</operator> <operator>-</operator> <name>kblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>k</name> <operator>+</operator> <operator>(</operator><sizeof>sizeof <name>k</name></sizeof><operator>)</operator> <operator>-</operator> <name>kblen</name></expr></argument>, <argument><expr><name>kb</name></expr></argument>, <argument><expr><name>kblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0xF8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7F</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>swap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">254</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>a</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>aa</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>b</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>bb</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>e</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>c</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>d</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>da</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>cb</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>kt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>kt</name> <operator>=</operator> <operator>(</operator><name><name>k</name><index>[<expr><literal type="number">31</literal> <operator>-</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>swap</name> <operator>^=</operator> <name>kt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_cswap</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_cswap</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>swap</name> <operator>=</operator> <name>kt</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * At that point, limbs of x_2 and z_2 are assumed to fit
		 * on at most 52 bits each.
		 *
		 * Each f255_add() adds one bit to the maximum range of
		 * the values, but f255_sub() and f255_mul() bring back
		 * the limbs into 52 bits. All f255_add() outputs are
		 * used only as inputs for f255_mul(), which ensures
		 * that limbs remain in the proper range.
		 */</comment>

		<comment type="block">/* A = x_2 + z_2   -- limbs fit on 53 bits each */</comment>
		<expr_stmt><expr><call><name>f255_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* AA = A^2 */</comment>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>aa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* B = x_2 - z_2 */</comment>
		<expr_stmt><expr><call><name>f255_sub</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* BB = B^2 */</comment>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* E = AA - BB */</comment>
		<expr_stmt><expr><call><name>f255_sub</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* C = x_3 + z_3   -- limbs fit on 53 bits each */</comment>
		<expr_stmt><expr><call><name>f255_add</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* D = x_3 - z_3 */</comment>
		<expr_stmt><expr><call><name>f255_sub</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* DA = D * A */</comment>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* CB = C * B */</comment>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* x_3 = (DA + CB)^2 */</comment>
		<expr_stmt><expr><call><name>f255_add</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* z_3 = x_1 * (DA - CB)^2 */</comment>
		<expr_stmt><expr><call><name>f255_sub</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* x_2 = AA * BB */</comment>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* z_2 = E * (AA + a24 * E) */</comment>
		<expr_stmt><expr><call><name>f255_mul_a24</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_add</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>f255_cswap</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f255_cswap</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute 1/z2 = z2^(p-2). Since p = 2^255-19, we can mutualize
	 * most non-squarings. We use x1 and x3, now useless, as temporaries.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><sizeof>sizeof <name>z2</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">15</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><sizeof>sizeof <name>x1</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">14</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">14</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xFFEB</literal> <operator>&gt;&gt;</operator> <name>i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Compute x2/z2. We have 1/z2 in x3.
	 */</comment>
	<expr_stmt><expr><call><name>f255_mul</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f255_final_reduce</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Encode the final x2 value in little-endian. We first assemble
	 * the limbs into 64-bit values.
	 */</comment>
	<expr_stmt><expr><name><name>x2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name><name>x2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">51</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>x2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">13</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>x2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">38</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>x2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">26</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>x2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">25</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>x2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">39</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>x2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64le</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><name><name>x2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64le</name><argument_list>(<argument><expr><name>G</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name><name>x2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64le</name><argument_list>(<argument><expr><name>G</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name><name>x2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64le</name><argument_list>(<argument><expr><name>G</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>, <argument><expr><name><name>x2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_mulgen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>Glen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>G</name> <operator>=</operator> <call><name>api_generator</name><argument_list>(<argument><expr><name>curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>api_mul</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Glen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_muladd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>B</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't implement this method, since it is used for ECDSA
	 * only, and there is no ECDSA over Curve25519 (which instead
	 * uses EdDSA).
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>A</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>B</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>xlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>y</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ylen</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ec.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_impl</name></type> <name>br_ec_c25519_m62</name> <init>= <expr><block>{
	<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0x20000000</literal></expr>,
	<expr><operator>&amp;</operator><name>api_generator</name></expr>,
	<expr><operator>&amp;</operator><name>api_order</name></expr>,
	<expr><operator>&amp;</operator><name>api_xoff</name></expr>,
	<expr><operator>&amp;</operator><name>api_mul</name></expr>,
	<expr><operator>&amp;</operator><name>api_mulgen</name></expr>,
	<expr><operator>&amp;</operator><name>api_muladd</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* see bearssl_ec.h */</comment>
<function><type><specifier>const</specifier> <name>br_ec_impl</name> <modifier>*</modifier></type>
<name>br_ec_c25519_m62_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>br_ec_c25519_m62</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* see bearssl_ec.h */</comment>
<function><type><specifier>const</specifier> <name>br_ec_impl</name> <modifier>*</modifier></type>
<name>br_ec_c25519_m62_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
