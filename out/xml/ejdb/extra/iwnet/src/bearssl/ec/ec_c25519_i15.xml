<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/ec/ec_c25519_i15.c"><comment type="block">/*
 * Copyright (c) 2017 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Parameters for the field:
 *   - field modulus p = 2^255-19
 *   - R^2 mod p (R = 2^(15k) for the smallest k such that R &gt;= p)
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>C255_P</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0110</literal></expr>,
	<expr><literal type="number">0x7FED</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>, <expr><literal type="number">0x7FFF</literal></expr>,
	<expr><literal type="number">0x7FFF</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P0I</name></cpp:macro>   <cpp:value>0x4A1B</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>C255_R2</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0110</literal></expr>,
	<expr><literal type="number">0x0169</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* obsolete
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
static void
print_int_mont(const char *name, const uint16_t *x)
{
	uint16_t y[18];
	unsigned char tmp[32];
	size_t u;

	printf("%s = ", name);
	memcpy(y, x, sizeof y);
	br_i15_from_monty(y, C255_P, P0I);
	br_i15_encode(tmp, sizeof tmp, y);
	for (u = 0; u &lt; sizeof tmp; u ++) {
		printf("%02X", tmp[u]);
	}
	printf("\n");
}
*/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint16_t</name></type> <name><name>C255_A24</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0110</literal></expr>,
	<expr><literal type="number">0x45D3</literal></expr>, <expr><literal type="number">0x0046</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>, <expr><literal type="number">0x0000</literal></expr>,
	<expr><literal type="number">0x0000</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>GEN</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x09</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
	<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
	<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>,
	<expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ORDER</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x7F</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_generator</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><name>GEN</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_order</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><name>ORDER</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_xoff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cswap</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>ctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <operator>-</operator><name>ctl</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">18</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>aw</name></decl>, <decl><type ref="prev"/><name>bw</name></decl>, <decl><type ref="prev"/><name>tw</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>aw</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bw</name> <operator>=</operator> <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tw</name> <operator>=</operator> <name>ctl</name> <operator>&amp;</operator> <operator>(</operator><name>aw</name> <operator>^</operator> <name>bw</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>aw</name> <operator>^</operator> <name>tw</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>bw</name> <operator>^</operator> <name>tw</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>c255_add</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>t</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctl</name> <operator>=</operator> <call><name>br_i15_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctl</name> <operator>|=</operator> <call><name>NOT</name><argument_list>(<argument><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><name>ctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>c255_sub</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>t</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>c255_mul</name><parameter_list>(<parameter><decl><type><name>uint16_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint16_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>t</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>br_i15_montymul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><name>P0I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>byteswap</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>t</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>t</name> <operator>=</operator> <name><name>G</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>G</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>G</name><index>[<expr><literal type="number">31</literal> <operator>-</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>G</name><index>[<expr><literal type="number">31</literal> <operator>-</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_mul</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>Glen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>kb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>kblen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ILEN</name></cpp:macro>   <cpp:value>(18 * sizeof(uint16_t))</cpp:value></cpp:define>

	<comment type="block">/*
	 * The a[] and b[] arrays have an extra word to allow for
	 * decoding without using br_i15_decode_reduce().
	 */</comment>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>x1</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>x2</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>x3</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>z2</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>z3</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>a</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>aa</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>b</name><index>[<expr><literal type="number">19</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>bb</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint16_t</name></type> <name><name>c</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>d</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>e</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>da</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>cb</name><index>[<expr><literal type="number">18</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>k</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>swap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Points are encoded over exactly 32 bytes. Multipliers must fit
	 * in 32 bytes as well.
	 * RFC 7748 mandates that the high bit of the last point byte must
	 * be ignored/cleared.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Glen</name> <operator>!=</operator> <literal type="number">32</literal> <operator>||</operator> <name>kblen</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>G</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7F</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Byteswap the point encoding, because it uses little-endian, and
	 * the generic decoding routine uses big-endian.
	 */</comment>
	<expr_stmt><expr><call><name>byteswap</name><argument_list>(<argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decode the point ('u' coordinate). This should be reduced
	 * modulo p, but we prefer to avoid the dependency on
	 * br_i15_decode_reduce(). Instead, we use br_i15_decode_mod()
	 * with a synthetic modulus of value 2^255 (this must work
	 * since G was truncated to 255 bits), then use a conditional
	 * subtraction. We use br_i15_decode_mod() and not
	 * br_i15_decode(), because the ec_prime_i15 implementation uses
	 * the former but not the latter.
	 *    br_i15_decode_reduce(a, G, 32, C255_P);
	 */</comment>
	<expr_stmt><expr><call><name>br_i15_zero</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0x111</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>b</name><index>[<expr><literal type="number">18</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_decode_mod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x110</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><call><name>NOT</name><argument_list>(<argument><expr><call><name>br_i15_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialise variables x1, x2, z2, x3 and z3. We set all of them
	 * into Montgomery representation.
	 */</comment>
	<expr_stmt><expr><call><name>br_i15_montymul</name><argument_list>(<argument><expr><name>x1</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>C255_R2</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><name>P0I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>, <argument><expr><name>ILEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_zero</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name><name>C255_P</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>ILEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">19</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>ILEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><sizeof>sizeof <name>k</name></sizeof><operator>)</operator> <operator>-</operator> <name>kblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>k</name> <operator>+</operator> <operator>(</operator><sizeof>sizeof <name>k</name></sizeof><operator>)</operator> <operator>-</operator> <name>kblen</name></expr></argument>, <argument><expr><name>kb</name></expr></argument>, <argument><expr><name>kblen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><index>[<expr><literal type="number">31</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0xF8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;=</operator> <literal type="number">0x7F</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>k</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <literal type="number">0x40</literal></expr>;</expr_stmt>

	<comment type="block">/* obsolete
	print_int_mont("x1", x1);
	*/</comment>

	<expr_stmt><expr><name>swap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">254</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>kt</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>kt</name> <operator>=</operator> <operator>(</operator><name><name>k</name><index>[<expr><literal type="number">31</literal> <operator>-</operator> <operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">3</literal><operator>)</operator></expr>]</index></name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>swap</name> <operator>^=</operator> <name>kt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cswap</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>cswap</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>swap</name> <operator>=</operator> <name>kt</name></expr>;</expr_stmt>

		<comment type="block">/* obsolete
		print_int_mont("x2", x2);
		print_int_mont("z2", z2);
		print_int_mont("x3", x3);
		print_int_mont("z3", z3);
		*/</comment>

		<expr_stmt><expr><call><name>c255_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>aa</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_sub</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_sub</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_add</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_sub</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>da</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>cb</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* obsolete
		print_int_mont("a ", a);
		print_int_mont("aa", aa);
		print_int_mont("b ", b);
		print_int_mont("bb", bb);
		print_int_mont("e ", e);
		print_int_mont("c ", c);
		print_int_mont("d ", d);
		print_int_mont("da", da);
		print_int_mont("cb", cb);
		*/</comment>

		<expr_stmt><expr><call><name>c255_add</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_sub</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>da</name></expr></argument>, <argument><expr><name>cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>z3</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>x1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>C255_A24</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_add</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>aa</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* obsolete
		print_int_mont("x2", x2);
		print_int_mont("z2", z2);
		print_int_mont("x3", x3);
		print_int_mont("z3", z3);
		*/</comment>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>cswap</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cswap</name><argument_list>(<argument><expr><name>z2</name></expr></argument>, <argument><expr><name>z3</name></expr></argument>, <argument><expr><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Inverse z2 with a modular exponentiation. This is a simple
	 * square-and-multiply algorithm; we mutualise most non-squarings
	 * since the exponent contains almost only ones.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>ILEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">15</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>ILEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">14</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">14</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><literal type="number">0xFFEB</literal> <operator>&gt;&gt;</operator> <name>i</name><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>z2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>c255_mul</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>x2</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To avoid a dependency on br_i15_from_monty(), we use a
	 * Montgomery multiplication with 1.
	 *    memcpy(x2, b, ILEN);
	 *    br_i15_from_monty(x2, C255_P, P0I);
	 */</comment>
	<expr_stmt><expr><call><name>br_i15_zero</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>C255_P</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_i15_montymul</name><argument_list>(<argument><expr><name>x2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>C255_P</name></expr></argument>, <argument><expr><name>P0I</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>br_i15_encode</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><literal type="number">32</literal></expr></argument>, <argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>byteswap</name><argument_list>(<argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ILEN</name></cpp:undef>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_mulgen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>Glen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>G</name> <operator>=</operator> <call><name>api_generator</name><argument_list>(<argument><expr><name>curve</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>G</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>api_mul</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><name>Glen</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>, <argument><expr><name>curve</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>Glen</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_muladd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>B</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We don't implement this method, since it is used for ECDSA
	 * only, and there is no ECDSA over Curve25519 (which instead
	 * uses EdDSA).
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>A</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>B</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>xlen</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>y</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>ylen</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ec.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_impl</name></type> <name>br_ec_c25519_i15</name> <init>= <expr><block>{
	<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0x20000000</literal></expr>,
	<expr><operator>&amp;</operator><name>api_generator</name></expr>,
	<expr><operator>&amp;</operator><name>api_order</name></expr>,
	<expr><operator>&amp;</operator><name>api_xoff</name></expr>,
	<expr><operator>&amp;</operator><name>api_mul</name></expr>,
	<expr><operator>&amp;</operator><name>api_mulgen</name></expr>,
	<expr><operator>&amp;</operator><name>api_muladd</name></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
