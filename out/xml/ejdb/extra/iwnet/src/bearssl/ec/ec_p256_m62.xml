<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/ec/ec_p256_m62.c"><comment type="block">/*
 * Copyright (c) 2018 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name> <operator>||</operator> <name>BR_UMUL128</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>P256_G</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x17</literal></expr>, <expr><literal type="number">0xD1</literal></expr>, <expr><literal type="number">0xF2</literal></expr>, <expr><literal type="number">0xE1</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0xF8</literal></expr>,
	<expr><literal type="number">0xBC</literal></expr>, <expr><literal type="number">0xE6</literal></expr>, <expr><literal type="number">0xE5</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0xA4</literal></expr>, <expr><literal type="number">0x40</literal></expr>, <expr><literal type="number">0xF2</literal></expr>, <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x7D</literal></expr>,
	<expr><literal type="number">0x81</literal></expr>, <expr><literal type="number">0x2D</literal></expr>, <expr><literal type="number">0xEB</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0xA0</literal></expr>, <expr><literal type="number">0xF4</literal></expr>, <expr><literal type="number">0xA1</literal></expr>, <expr><literal type="number">0x39</literal></expr>, <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0xD8</literal></expr>,
	<expr><literal type="number">0x98</literal></expr>, <expr><literal type="number">0xC2</literal></expr>, <expr><literal type="number">0x96</literal></expr>, <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0xE3</literal></expr>, <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0xE2</literal></expr>, <expr><literal type="number">0xFE</literal></expr>, <expr><literal type="number">0x1A</literal></expr>, <expr><literal type="number">0x7F</literal></expr>,
	<expr><literal type="number">0x9B</literal></expr>, <expr><literal type="number">0x8E</literal></expr>, <expr><literal type="number">0xE7</literal></expr>, <expr><literal type="number">0xEB</literal></expr>, <expr><literal type="number">0x4A</literal></expr>, <expr><literal type="number">0x7C</literal></expr>, <expr><literal type="number">0x0F</literal></expr>, <expr><literal type="number">0x9E</literal></expr>, <expr><literal type="number">0x16</literal></expr>, <expr><literal type="number">0x2B</literal></expr>,
	<expr><literal type="number">0xCE</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x31</literal></expr>, <expr><literal type="number">0x5E</literal></expr>, <expr><literal type="number">0xCE</literal></expr>, <expr><literal type="number">0xCB</literal></expr>, <expr><literal type="number">0xB6</literal></expr>, <expr><literal type="number">0x40</literal></expr>,
	<expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x37</literal></expr>, <expr><literal type="number">0xBF</literal></expr>, <expr><literal type="number">0x51</literal></expr>, <expr><literal type="number">0xF5</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>P256_N</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xBC</literal></expr>, <expr><literal type="number">0xE6</literal></expr>, <expr><literal type="number">0xFA</literal></expr>, <expr><literal type="number">0xAD</literal></expr>,
	<expr><literal type="number">0xA7</literal></expr>, <expr><literal type="number">0x17</literal></expr>, <expr><literal type="number">0x9E</literal></expr>, <expr><literal type="number">0x84</literal></expr>, <expr><literal type="number">0xF3</literal></expr>, <expr><literal type="number">0xB9</literal></expr>, <expr><literal type="number">0xCA</literal></expr>, <expr><literal type="number">0xC2</literal></expr>, <expr><literal type="number">0xFC</literal></expr>, <expr><literal type="number">0x63</literal></expr>,
	<expr><literal type="number">0x25</literal></expr>, <expr><literal type="number">0x51</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_generator</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <sizeof>sizeof <name>P256_G</name></sizeof></expr>;</expr_stmt>
	<return>return <expr><name>P256_G</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_order</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <sizeof>sizeof <name>P256_N</name></sizeof></expr>;</expr_stmt>
	<return>return <expr><name>P256_N</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_xoff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A field element is encoded as five 64-bit integers, in basis 2^52.
 * Limbs may occasionally exceed 2^52.
 *
 * A _partially reduced_ value is such that the following hold:
 *   - top limb is less than 2^48 + 2^30
 *   - the other limbs fit on 53 bits each
 * In particular, such a value is less than twice the modulus p.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro>   <cpp:value>((uint64_t)1 &lt;&lt; (n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASK48</name></cpp:macro>   <cpp:value>(BIT(48) - BIT(0))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MASK52</name></cpp:macro>   <cpp:value>(BIT(52) - BIT(0))</cpp:value></cpp:define>

<comment type="block">/* R = 2^260 mod p */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>F256_R</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0000000000010</literal></expr>, <expr><literal type="number">0xF000000000000</literal></expr>, <expr><literal type="number">0xFFFFFFFFFFFFF</literal></expr>,
	<expr><literal type="number">0xFFEFFFFFFFFFF</literal></expr>, <expr><literal type="number">0x00000000FFFFF</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Curve equation is y^2 = x^3 - 3*x + B. This constant is B*R mod p
   (Montgomery representation of B). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>P256_B_MONTY</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0xDF6229C4BDDFD</literal></expr>, <expr><literal type="number">0xCA8843090D89C</literal></expr>, <expr><literal type="number">0x212ED6ACF005C</literal></expr>,
	<expr><literal type="number">0x83415A220ABF7</literal></expr>, <expr><literal type="number">0x0C30061DD4874</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Addition in the field. Carry propagation is not performed.
 * On input, limbs may be up to 63 bits each; on output, they will
 * be up to one bit more than on input.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_add</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Partially reduce the provided value.
 * Input: limbs can go up to 61 bits each.
 * Output: partially reduced.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_partial_reduce</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>w</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Propagate carries.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+=</operator> <name>cc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>             <comment type="block">/* s &lt; 2^14 */</comment>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>                  <comment type="block">/* a[0] &lt; 2^52 + 2^14 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">44</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* a[1] &lt; 2^52 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>    <comment type="block">/* cc &lt; 16 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* a[2] &lt; 2^52 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>               <comment type="block">/* cc = 0 or 1 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>cc</name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* a[3] &lt; 2^52 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>               <comment type="block">/* cc = 0 or 1 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <name>MASK48</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>  <comment type="block">/* a[4] &lt; 2^48 + 2^30 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Subtraction in the field.
 * Input: limbs must fit on 60 bits each; in particular, the complete
 * integer will be less than 2^268 + 2^217.
 * Output: partially reduced.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_sub</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We compute d = 2^13*p + a - b; this ensures a positive
	 * intermediate value.
	 *
	 * Each individual addition/subtraction may yield a positive or
	 * negative result; thus, we need to handle a signed carry, thus
	 * with sign extension. We prefer not to use signed types (int64_t)
	 * because conversion from unsigned to signed is cumbersome (a
	 * direct cast with the top bit set is undefined behavior; instead,
	 * we have to use pointer aliasing, using the guaranteed properties
	 * of exact-width types, but this requires the compiler to optimize
	 * away the writes and reads from RAM), and right-shifting a
	 * signed negative value is implementation-defined. Therefore,
	 * we use a custom sign extension.
	 */</comment>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>|=</operator> <operator>-</operator><operator>(</operator><name>cc</name> <operator>&amp;</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>|=</operator> <operator>-</operator><operator>(</operator><name>cc</name> <operator>&amp;</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>&amp;</operator> <name>MASK52</name><operator>)</operator> <operator>+</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>|=</operator> <operator>-</operator><operator>(</operator><name>cc</name> <operator>&amp;</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>&amp;</operator> <name>MASK52</name><operator>)</operator> <operator>+</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">49</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>|=</operator> <operator>-</operator><operator>(</operator><name>cc</name> <operator>&amp;</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><literal type="number">61</literal></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>+</operator> <name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform partial reduction. Rule is:
	 *  2^256 = 2^224 - 2^192 - 2^96 + 1 mod p
	 *
	 * At that point:
	 *    0 &lt;= t[0] &lt;= 2^52 - 1
	 *    0 &lt;= t[1] &lt;= 2^52 - 1
	 *    2^5 &lt;= t[2] &lt;= 2^52 + 2^5 - 1
	 *    2^49 &lt;= t[3] &lt;= 2^52 + 2^49 - 1
	 *    2^59 &lt; t[4] &lt;= 2^61 + 2^60 - 2^29
	 *
	 * Thus, the value 's' (t[4] / 2^48) will be necessarily
	 * greater than 2048, and less than 12288.
	 */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>s</name></expr>;</expr_stmt>             <comment type="block">/* d[0] &lt;= 2^52 + 12287 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">44</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>           <comment type="block">/* d[1] &lt;= 2^52 - 1 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>     <comment type="block">/* cc &lt;= 48 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>                <comment type="block">/* cc = 0 or 1 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>       <comment type="block">/* d[2] &lt;= 2^52 + 31 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>cc</name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>                <comment type="block">/* cc = 0 or 1 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>cc</name> <operator>&lt;&lt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>       <comment type="block">/* t[3] &lt;= 2^52 + 2^49 - 1 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <name>MASK48</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>  <comment type="block">/* d[4] &lt; 2^48 + 2^30 */</comment>

	<comment type="block">/*
	 * If s = 0, then none of the limbs is modified, and there cannot
	 * be an overflow; if s != 0, then (s &lt;&lt; 16) &gt; cc, and there is
	 * no overflow either.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Montgomery multiplication in the field.
 * Input: limbs must fit on 56 bits each.
 * Output: partially reduced.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_montymul</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name></expr></cpp:if>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>f</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>__int128</name></type> <name>z</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since limbs of a[] and b[] fit on 56 bits each,
		 * each individual product fits on 112 bits. Also,
		 * the factor f fits on 52 bits, so f&lt;&lt;48 fits on
		 * 112 bits too. This guarantees that carries (cc)
		 * will fit on 62 bits, thus no overflow.
		 *
		 * The operations below compute:
		 *   t &lt;- (t + x*b + f*p) / 2^64
		 */</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>x</name>
			<operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>x</name>
			<operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cc</name>
			<operator>+</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">44</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>x</name>
			<operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>x</name>
			<operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name>cc</name>
			<operator>+</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>*</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>x</name>
			<operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name>cc</name>
			<operator>+</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">48</literal><operator>)</operator>
			<operator>-</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * t[4] may be up to 62 bits here; we need to do a
		 * partial reduction. Note that limbs t[0] to t[3]
		 * fit on 52 bits each.
		 */</comment>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>             <comment type="block">/* s &lt; 2^14 */</comment>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>                  <comment type="block">/* t[0] &lt; 2^52 + 2^14 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">44</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* t[1] &lt; 2^52 */</comment>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>    <comment type="block">/* cc &lt; 16 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* t[2] &lt; 2^52 */</comment>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>               <comment type="block">/* cc = 0 or 1 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>cc</name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* t[3] &lt; 2^52 */</comment>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>               <comment type="block">/* cc = 0 or 1 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <name>MASK48</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>  <comment type="block">/* t[4] &lt; 2^48 + 2^30 */</comment>

		<comment type="block">/*
		 * The final t[4] cannot overflow because cc is 0 or 1,
		 * and cc can be 1 only if s != 0.
		 */</comment>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:elif>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>f</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>s</name></decl>, <decl><type ref="prev"/><name>zh</name></decl>, <decl><type ref="prev"/><name>zl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>k</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Since limbs of a[] and b[] fit on 56 bits each,
		 * each individual product fits on 112 bits. Also,
		 * the factor f fits on 52 bits, so f&lt;&lt;48 fits on
		 * 112 bits too. This guarantees that carries (cc)
		 * will fit on 62 bits, thus no overflow.
		 *
		 * The operations below compute:
		 *   t &lt;- (t + x*b + f*p) / 2^64
		 */</comment>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <name>zl</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>zl</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>zh</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">44</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">20</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>zl</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>zl</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>zh</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>zl</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>zl</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>zh</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">28</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>zl</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>(</operator><name>zl</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>zh</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>zl</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>zl</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>zh</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * t[4] may be up to 62 bits here; we need to do a
		 * partial reduction. Note that limbs t[0] to t[3]
		 * fit on 52 bits each.
		 */</comment>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>             <comment type="block">/* s &lt; 2^14 */</comment>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>                  <comment type="block">/* t[0] &lt; 2^52 + 2^14 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">44</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* t[1] &lt; 2^52 */</comment>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xFFF</literal></expr>;</expr_stmt>    <comment type="block">/* cc &lt; 16 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* t[2] &lt; 2^52 */</comment>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>               <comment type="block">/* cc = 0 or 1 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name>cc</name> <operator>-</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>          <comment type="block">/* t[3] &lt; 2^52 */</comment>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>               <comment type="block">/* cc = 0 or 1 */</comment>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;</operator> <name>MASK48</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>+</operator> <operator>(</operator><name>s</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>  <comment type="block">/* t[4] &lt; 2^48 + 2^30 */</comment>

		<comment type="block">/*
		 * The final t[4] cannot overflow because cc is 0 or 1,
		 * and cc can be 1 only if s != 0.
		 */</comment>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Montgomery squaring in the field; currently a basic wrapper around
 * multiplication (inline, should be optimized away).
 * TODO: see if some extra speed can be gained here.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_montysquare</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert to Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_tomonty</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * R2 = 2^520 mod p.
	 * If R = 2^260 mod p, then R2 = R^2 mod p; and the Montgomery
	 * multiplication of a by R2 is: a*R2/R = a*R mod p, i.e. the
	 * conversion to Montgomery representation.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>R2</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="number">0x0000000000300</literal></expr>, <expr><literal type="number">0xFFFFFFFF00000</literal></expr>, <expr><literal type="number">0xFFFFEFFFFFFFB</literal></expr>,
		<expr><literal type="number">0xFDFFFFFFFFFFF</literal></expr>, <expr><literal type="number">0x0000004FFFFFF</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>R2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert from Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_frommonty</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Montgomery multiplication by 1 is division by 2^260 modulo p.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>one</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inversion in the field. If the source value is 0 modulo p, then this
 * returns 0 or p. This function uses Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_invert</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We compute a^(p-2) mod p. The exponent pattern (from high to
	 * low) is:
	 *  - 32 bits of value 1
	 *  - 31 bits of value 0
	 *  - 1 bit of value 1
	 *  - 96 bits of value 0
	 *  - 94 bits of value 1
	 *  - 1 bit of value 0
	 *  - 1 bit of value 1
	 * To speed up the square-and-multiply algorithm, we precompute
	 * a^(2^31-1).
	 */</comment>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">30</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">224</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
		<case>case <expr><literal type="number">192</literal></expr>:</case>
		<case>case <expr><literal type="number">224</literal></expr>:</case>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
		<case>case <expr><literal type="number">34</literal></expr>:</case>
		<case>case <expr><literal type="number">65</literal></expr>:</case>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof <name>r</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finalize reduction.
 * Input value should be partially reduced.
 * On output, limbs a[0] to a[3] fit on 52 bits each, limb a[4] fits
 * on 48 bits, and the integer is less than p.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_final_reduce</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>r</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Propagate carries to ensure that limbs 0 to 3 fit on 52 bits.
	 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We compute t = r + (2^256 - p) = r + 2^224 - 2^192 - 2^96 + 1.
	 * If t &lt; 2^256, then r &lt; p, and we return r. Otherwise, we
	 * want to return r - p = t - 2^256.
	 */</comment>

	<comment type="block">/*
	 * Add 2^224 + 1, and propagate carries to ensure that limbs
	 * t[0] to t[3] fit in 52 bits each.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>+</operator> <name>cc</name> <operator>+</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Subtract 2^192 + 2^96. Since we just added 2^224 + 1, the
	 * result cannot be negative.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">44</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <call><name>BIT</name><argument_list>(<argument><expr><literal type="number">36</literal></expr></argument>)</argument_list></call> <operator>-</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>w</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <name>w</name> <operator>&gt;&gt;</operator> <literal type="number">63</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>-=</operator> <name>cc</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the top limb t[4] fits on 48 bits, then r[] is already
	 * in the proper range. Otherwise, t[] is the value to return
	 * (truncated to 256 bits).
	 */</comment>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">48</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&amp;=</operator> <name>MASK48</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <operator>(</operator><name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>r</name><index>[<expr><name>i</name></expr>]</index></name> <operator>^</operator> <name><name>t</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Points in affine and Jacobian coordinates.
 *
 *  - In affine coordinates, the point-at-infinity cannot be encoded.
 *  - Jacobian coordinates (X,Y,Z) correspond to affine (X/Z^2,Y/Z^3);
 *    if Z = 0 then this is the point-at-infinity.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>y</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>p256_affine</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>y</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>z</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>p256_jacobian</name>;</typedef>

<comment type="block">/*
 * Decode a field element (unsigned big endian notation).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_decode</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>w0</name></decl>, <decl><type ref="prev"/><name>w1</name></decl>, <decl><type ref="prev"/><name>w2</name></decl>, <decl><type ref="prev"/><name>w3</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>w3</name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w2</name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w1</name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>w0</name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>w0</name> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w0</name> <operator>&gt;&gt;</operator> <literal type="number">52</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>w1</name> <operator>&lt;&lt;</operator> <literal type="number">12</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w1</name> <operator>&gt;&gt;</operator> <literal type="number">40</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>w2</name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>w2</name> <operator>&gt;&gt;</operator> <literal type="number">28</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>w3</name> <operator>&lt;&lt;</operator> <literal type="number">36</literal><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <name>MASK52</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>w3</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Encode a field element (unsigned big endian notation). The field
 * element MUST be fully reduced.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_encode</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>w0</name></decl>, <decl><type ref="prev"/><name>w1</name></decl>, <decl><type ref="prev"/><name>w2</name></decl>, <decl><type ref="prev"/><name>w3</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>w0</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">52</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>w1</name> <operator>=</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>w2</name> <operator>=</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">28</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>w3</name> <operator>=</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&gt;&gt;</operator> <literal type="number">36</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">0</literal></expr></argument>, <argument><expr><name>w3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">8</literal></expr></argument>, <argument><expr><name>w2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>w1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">24</literal></expr></argument>, <argument><expr><name>w0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decode a point. The returned point is in Jacobian coordinates, but
 * with z = 1. If the encoding is invalid, or encodes a point which is
 * not on the curve, or encodes the point at infinity, then this function
 * returns 0. Otherwise, 1 is returned.
 *
 * The buffer is assumed to have length exactly 65 bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>point_decode</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>y</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>x3</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Header byte shall be 0x04.
	 */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>EQ</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0x04</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decode X and Y coordinates, and convert them into
	 * Montgomery representation.
	 */</comment>
	<expr_stmt><expr><call><name>f256_decode</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_decode</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_tomonty</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_tomonty</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify y^2 = x^3 + A*x + B. In curve P-256, A = -3.
	 * Note that the Montgomery representation of 0 is 0. We must
	 * take care to apply the final reduction to make sure we have
	 * 0 and not p.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>P256_B_MONTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>EQ</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>tt</name> <operator>|</operator> <operator>(</operator><name>tt</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return the point in Jacobian coordinates (and Montgomery
	 * representation).
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof <name>x</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><sizeof>sizeof <name>y</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>F256_R</name></expr></argument>, <argument><expr><sizeof>sizeof <name>F256_R</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Final conversion for a point:
 *  - The point is converted back to affine coordinates.
 *  - Final reduction is performed.
 *  - The point is encoded into the provided buffer.
 *
 * If the point is the point-at-infinity, all operations are performed,
 * but the buffer contents are indeterminate, and 0 is returned. Otherwise,
 * the encoded point is written in the buffer, and 1 is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>point_encode</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

	<comment type="block">/* Set t1 = 1/z^2 and t2 = 1/z^3. */</comment>
	<expr_stmt><expr><call><name>f256_invert</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute affine coordinates x (in t1) and y (in t2). */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert back from Montgomery representation, and finalize
	   reductions. */</comment>
	<expr_stmt><expr><call><name>f256_frommonty</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_frommonty</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Encode. */</comment>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_encode</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">1</literal></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_encode</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">33</literal></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return success if and only if P-&gt;z != 0. */</comment>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><call><name>NEQ</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>|</operator> <name>z</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Point doubling in Jacobian coordinates: point P is doubled.
 * Note: if the source point is the point-at-infinity, then the result is
 * still the point-at-infinity, which is correct. Moreover, if the three
 * coordinates were zero, then they still are zero in the returned value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>p256_double</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Doubling formulas are:
	 *
	 *   s = 4*x*y^2
	 *   m = 3*(x + z^2)*(x - z^2)
	 *   x' = m^2 - 2*s
	 *   y' = m*(s - x') - 8*y^4
	 *   z' = 2*y*z
	 *
	 * These formulas work for all points, including points of order 2
	 * and points at infinity:
	 *   - If y = 0 then z' = 0. But there is no such point in P-256
	 *     anyway.
	 *   - If z = 0 then z' = 0.
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t3</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t4</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute z^2 in t1.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x-z^2 in t2 and x+z^2 in t1.
	 */</comment>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute 3*(x+z^2)*(x-z^2) in t1.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute 4*x*y^2 (in t2) and 2*y^2 (in t3).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x' = m^2 - 2*s.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute z' = 2*y*z.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_partial_reduce</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute y' = m*(s - x') - 8*y^4. Note that we already have
	 * 2*y^2 in t3.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Point addition (Jacobian coordinates): P1 is replaced with P1+P2.
 * This function computes the wrong result in the following cases:
 *
 *   - If P1 == 0 but P2 != 0
 *   - If P1 != 0 but P2 == 0
 *   - If P1 == P2
 *
 * In all three cases, P1 is set to the point at infinity.
 *
 * Returned value is 0 if one of the following occurs:
 *
 *   - P1 and P2 have the same Y coordinate.
 *   - P1 == 0 and P2 == 0.
 *   - The Y coordinate of one of the points is 0 and the other point is
 *     the point at infinity.
 *
 * The third case cannot actually happen with valid points, since a point
 * with Y == 0 is a point of order 2, and there is no point of order 2 on
 * curve P-256.
 *
 * Therefore, assuming that P1 != 0 and P2 != 0 on input, then the caller
 * can apply the following:
 *
 *   - If the result is not the point at infinity, then it is correct.
 *   - Otherwise, if the returned value is 1, then this is a case of
 *     P1+P2 == 0, so the result is indeed the point at infinity.
 *   - Otherwise, P1 == P2, so a "double" operation should have been
 *     performed.
 *
 * Note that you can get a returned value of 0 with a correct result,
 * e.g. if P1 and P2 have the same Y coordinate, but distinct X coordinates.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>p256_add</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_jacobian</name> <modifier>*</modifier></type><name>P2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Addtions formulas are:
	 *
	 *   u1 = x1 * z2^2
	 *   u2 = x2 * z1^2
	 *   s1 = y1 * z2^3
	 *   s2 = y2 * z1^3
	 *   h = u2 - u1
	 *   r = s2 - s1
	 *   x3 = r^2 - h^3 - 2 * u1 * h^2
	 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
	 *   z3 = h * z1 * z2
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t3</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t4</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t5</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t6</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t7</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>ret</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute u1 = x1*z2^2 (in t1) and s1 = y1*z2^3 (in t3).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute h = h2 - u1 (in t2) and r = s2 - s1 (in t4).
	 * We need to test whether r is zero, so we will do some extra
	 * reduce.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <name><name>t4</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>tt</name> <operator>|</operator> <operator>(</operator><name>tt</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ret</name> <operator>|</operator> <operator>-</operator><name>ret</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5);
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute z3 = h*z1*z2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Point addition (mixed coordinates): P1 is replaced with P1+P2.
 * This is a specialised function for the case when P2 is a non-zero point
 * in affine coordinates.
 *
 * This function computes the wrong result in the following cases:
 *
 *   - If P1 == 0
 *   - If P1 == P2
 *
 * In both cases, P1 is set to the point at infinity.
 *
 * Returned value is 0 if one of the following occurs:
 *
 *   - P1 and P2 have the same Y (affine) coordinate.
 *   - The Y coordinate of P2 is 0 and P1 is the point at infinity.
 *
 * The second case cannot actually happen with valid points, since a point
 * with Y == 0 is a point of order 2, and there is no point of order 2 on
 * curve P-256.
 *
 * Therefore, assuming that P1 != 0 on input, then the caller
 * can apply the following:
 *
 *   - If the result is not the point at infinity, then it is correct.
 *   - Otherwise, if the returned value is 1, then this is a case of
 *     P1+P2 == 0, so the result is indeed the point at infinity.
 *   - Otherwise, P1 == P2, so a "double" operation should have been
 *     performed.
 *
 * Again, a value of 0 may be returned in some cases where the addition
 * result is correct.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>p256_add_mixed</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_affine</name> <modifier>*</modifier></type><name>P2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Addtions formulas are:
	 *
	 *   u1 = x1
	 *   u2 = x2 * z1^2
	 *   s1 = y1
	 *   s2 = y2 * z1^3
	 *   h = u2 - u1
	 *   r = s2 - s1
	 *   x3 = r^2 - h^3 - 2 * u1 * h^2
	 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
	 *   z3 = h * z1
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t3</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t4</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t5</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t6</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t7</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>ret</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute u1 = x1 (in t1) and s1 = y1 (in t3).
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name>t1</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name>t3</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute h = h2 - u1 (in t2) and r = s2 - s1 (in t4).
	 * We need to test whether r is zero, so we will do some extra
	 * reduce.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <name><name>t4</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>tt</name> <operator>|</operator> <operator>(</operator><name>tt</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ret</name> <operator>|</operator> <operator>-</operator><name>ret</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5);
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute z3 = h*z1*z2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* unused */</comment>
<comment type="block">/*
 * Point addition (mixed coordinates, complete): P1 is replaced with P1+P2.
 * This is a specialised function for the case when P2 is a non-zero point
 * in affine coordinates.
 *
 * This function returns the correct result in all cases.
 */</comment>
static uint32_t
p256_add_complete_mixed(p256_jacobian *P1, const p256_affine *P2)
{
	<comment type="block">/*
	 * Addtions formulas, in the general case, are:
	 *
	 *   u1 = x1
	 *   u2 = x2 * z1^2
	 *   s1 = y1
	 *   s2 = y2 * z1^3
	 *   h = u2 - u1
	 *   r = s2 - s1
	 *   x3 = r^2 - h^3 - 2 * u1 * h^2
	 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
	 *   z3 = h * z1
	 *
	 * These formulas mishandle the two following cases:
	 *
	 *  - If P1 is the point-at-infinity (z1 = 0), then z3 is
	 *    incorrectly set to 0.
	 *
	 *  - If P1 = P2, then u1 = u2 and s1 = s2, and x3, y3 and z3
	 *    are all set to 0.
	 *
	 * However, if P1 + P2 = 0, then u1 = u2 but s1 != s2, and then
	 * we correctly get z3 = 0 (the point-at-infinity).
	 *
	 * To fix the case P1 = 0, we perform at the end a copy of P2
	 * over P1, conditional to z1 = 0.
	 *
	 * For P1 = P2: in that case, both h and r are set to 0, and
	 * we get x3, y3 and z3 equal to 0. We can test for that
	 * occurrence to make a mask which will be all-one if P1 = P2,
	 * or all-zero otherwise; then we can compute the double of P2
	 * and add it, combined with the mask, to (x3,y3,z3).
	 *
	 * Using the doubling formulas in p256_double() on (x2,y2),
	 * simplifying since P2 is affine (i.e. z2 = 1, implicitly),
	 * we get:
	 *   s = 4*x2*y2^2
	 *   m = 3*(x2 + 1)*(x2 - 1)
	 *   x' = m^2 - 2*s
	 *   y' = m*(s - x') - 8*y2^4
	 *   z' = 2*y2
	 * which requires only 6 multiplications. Added to the 11
	 * multiplications of the normal mixed addition in Jacobian
	 * coordinates, we get a cost of 17 multiplications in total.
	 */</comment>
	uint64_t t1[5], t2[5], t3[5], t4[5], t5[5], t6[5], t7[5], tt, zz;
	int i;

	<comment type="block">/*
	 * Set zz to -1 if P1 is the point at infinity, 0 otherwise.
	 */</comment>
	zz = P1-&gt;z[0] | P1-&gt;z[1] | P1-&gt;z[2] | P1-&gt;z[3] | P1-&gt;z[4];
	zz = ((zz | -zz) &gt;&gt; 63) - (uint64_t)1;

	<comment type="block">/*
	 * Compute u1 = x1 (in t1) and s1 = y1 (in t3).
	 */</comment>
	memcpy(t1, P1-&gt;x, sizeof t1);
	memcpy(t3, P1-&gt;y, sizeof t3);

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	f256_montysquare(t4, P1-&gt;z);
	f256_montymul(t2, P2-&gt;x, t4);
	f256_montymul(t5, P1-&gt;z, t4);
	f256_montymul(t4, P2-&gt;y, t5);

	<comment type="block">/*
	 * Compute h = h2 - u1 (in t2) and r = s2 - s1 (in t4).
	 * reduce.
	 */</comment>
	f256_sub(t2, t2, t1);
	f256_sub(t4, t4, t3);

	<comment type="block">/*
	 * If both h = 0 and r = 0, then P1 = P2, and we want to set
	 * the mask tt to -1; otherwise, the mask will be 0.
	 */</comment>
	f256_final_reduce(t2);
	f256_final_reduce(t4);
	tt = t2[0] | t2[1] | t2[2] | t2[3] | t2[4]
		| t4[0] | t4[1] | t4[2] | t4[3] | t4[4];
	tt = ((tt | -tt) &gt;&gt; 63) - (uint64_t)1;

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5);
	 */</comment>
	f256_montysquare(t7, t2);
	f256_montymul(t6, t1, t7);
	f256_montymul(t5, t7, t2);

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 */</comment>
	f256_montysquare(P1-&gt;x, t4);
	f256_sub(P1-&gt;x, P1-&gt;x, t5);
	f256_sub(P1-&gt;x, P1-&gt;x, t6);
	f256_sub(P1-&gt;x, P1-&gt;x, t6);

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	f256_sub(t6, t6, P1-&gt;x);
	f256_montymul(P1-&gt;y, t4, t6);
	f256_montymul(t1, t5, t3);
	f256_sub(P1-&gt;y, P1-&gt;y, t1);

	<comment type="block">/*
	 * Compute z3 = h*z1.
	 */</comment>
	f256_montymul(P1-&gt;z, P1-&gt;z, t2);

	<comment type="block">/*
	 * The "double" result, in case P1 = P2.
	 */</comment>

	<comment type="block">/*
	 * Compute z' = 2*y2 (in t1).
	 */</comment>
	f256_add(t1, P2-&gt;y, P2-&gt;y);
	f256_partial_reduce(t1);

	<comment type="block">/*
	 * Compute 2*(y2^2) (in t2) and s = 4*x2*(y2^2) (in t3).
	 */</comment>
	f256_montysquare(t2, P2-&gt;y);
	f256_add(t2, t2, t2);
	f256_add(t3, t2, t2);
	f256_montymul(t3, P2-&gt;x, t3);

	<comment type="block">/*
	 * Compute m = 3*(x2^2 - 1) (in t4).
	 */</comment>
	f256_montysquare(t4, P2-&gt;x);
	f256_sub(t4, t4, F256_R);
	f256_add(t5, t4, t4);
	f256_add(t4, t4, t5);

	<comment type="block">/*
	 * Compute x' = m^2 - 2*s (in t5).
	 */</comment>
	f256_montysquare(t5, t4);
	f256_sub(t5, t3);
	f256_sub(t5, t3);

	<comment type="block">/*
	 * Compute y' = m*(s - x') - 8*y2^4 (in t6).
	 */</comment>
	f256_sub(t6, t3, t5);
	f256_montymul(t6, t6, t4);
	f256_montysquare(t7, t2);
	f256_sub(t6, t6, t7);
	f256_sub(t6, t6, t7);

	<comment type="block">/*
	 * We now have the alternate (doubling) coordinates in (t5,t6,t1).
	 * We combine them with (x3,y3,z3).
	 */</comment>
	for (i = 0; i &lt; 5; i ++) {
		P1-&gt;x[i] |= tt &amp; t5[i];
		P1-&gt;y[i] |= tt &amp; t6[i];
		P1-&gt;z[i] |= tt &amp; t1[i];
	}

	<comment type="block">/*
	 * If P1 = 0, then we get z3 = 0 (which is invalid); if z1 is 0,
	 * then we want to replace the result with a copy of P2. The
	 * test on z1 was done at the start, in the zz mask.
	 */</comment>
	for (i = 0; i &lt; 5; i ++) {
		P1-&gt;x[i] ^= zz &amp; (P1-&gt;x[i] ^ P2-&gt;x[i]);
		P1-&gt;y[i] ^= zz &amp; (P1-&gt;y[i] ^ P2-&gt;y[i]);
		P1-&gt;z[i] ^= zz &amp; (P1-&gt;z[i] ^ F256_R[i]);
	}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Inner function for computing a point multiplication. A window is
 * provided, with points 1*P to 15*P in affine coordinates.
 *
 * Assumptions:
 *  - All provided points are valid points on the curve.
 *  - Multiplier is non-zero, and smaller than the curve order.
 *  - Everything is in Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>point_mul_inner</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_affine</name> <modifier>*</modifier></type><name>W</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>Q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>qz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>klen</name> <operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>bk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bk</name> <operator>=</operator> <operator>*</operator><name>k</name> <operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>bnz</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>p256_affine</name></type> <name>T</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>U</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64_t</name></type> <name>m</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>bk</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>bnz</name> <operator>=</operator> <call><name>NEQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Lookup point in window. If the bits are 0,
			 * we get something invalid, which is not a
			 * problem because we will use it only if the
			 * bits are non-zero.
			 */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>T</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">15</literal></expr>;</condition> <incr><expr><name>n</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>EQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>U</name> <operator>=</operator> <name>Q</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_add_mixed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If qz is still 1, then Q was all-zeros, and this
			 * is conserved through p256_double().
			 */</comment>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>bnz</name> <operator>&amp;</operator> <name>qz</name><operator>)</operator></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>Q</name><operator>.</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^</operator> <name><name>T</name><operator>.</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>y</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>Q</name><operator>.</operator><name>y</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^</operator> <name><name>T</name><operator>.</operator><name>y</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>Q</name><operator>.</operator><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>^</operator> <name><name>F256_R</name><index>[<expr><name>j</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>bnz</name> <operator>&amp;</operator> <operator>~</operator><name>qz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qz</name> <operator>&amp;=</operator> <operator>~</operator><name>bnz</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bk</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>R</name> <operator>=</operator> <name>Q</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a window from Jacobian to affine coordinates. A single
 * field inversion is used. This function works for windows up to
 * 32 elements.
 *
 * The destination array (aff[]) and the source array (jac[]) may
 * overlap, provided that the start of aff[] is not after the start of
 * jac[]. Even if the arrays do _not_ overlap, the source array is
 * modified.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>window_to_affine</name><parameter_list>(<parameter><decl><type><name>p256_affine</name> <modifier>*</modifier></type><name>aff</name></decl></parameter>, <parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>jac</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Convert the window points to affine coordinates. We use the
	 * following trick to mutualize the inversion computation: if
	 * we have z1, z2, z3, and z4, and want to invert all of them,
	 * we compute u = 1/(z1*z2*z3*z4), and then we have:
	 *   1/z1 = u*z2*z3*z4
	 *   1/z2 = u*z1*z3*z4
	 *   1/z3 = u*z1*z2*z4
	 *   1/z4 = u*z1*z2*z3
	 *
	 * The partial products are computed recursively:
	 *
	 *  - on input (z_1,z_2), return (z_2,z_1) and z_1*z_2
	 *  - on input (z_1,z_2,... z_n):
	 *       recurse on (z_1,z_2,... z_(n/2)) -&gt; r1 and m1
	 *       recurse on (z_(n/2+1),z_(n/2+2)... z_n) -&gt; r2 and m2
	 *       multiply elements of r1 by m2 -&gt; s1
	 *       multiply elements of r2 by m1 -&gt; s2
	 *       return r1||r2 and m1*m2
	 *
	 * In the example below, we suppose that we have 14 elements.
	 * Let z1, z2,... zE be the 14 values to invert (index noted in
	 * hexadecimal, starting at 1).
	 *
	 *  - Depth 1:
	 *      swap(z1, z2); z12 = z1*z2
	 *      swap(z3, z4); z34 = z3*z4
	 *      swap(z5, z6); z56 = z5*z6
	 *      swap(z7, z8); z78 = z7*z8
	 *      swap(z9, zA); z9A = z9*zA
	 *      swap(zB, zC); zBC = zB*zC
	 *      swap(zD, zE); zDE = zD*zE
	 *
	 *  - Depth 2:
	 *      z1 &lt;- z1*z34, z2 &lt;- z2*z34, z3 &lt;- z3*z12, z4 &lt;- z4*z12
	 *      z1234 = z12*z34
	 *      z5 &lt;- z5*z78, z6 &lt;- z6*z78, z7 &lt;- z7*z56, z8 &lt;- z8*z56
	 *      z5678 = z56*z78
	 *      z9 &lt;- z9*zBC, zA &lt;- zA*zBC, zB &lt;- zB*z9A, zC &lt;- zC*z9A
	 *      z9ABC = z9A*zBC
	 *
	 *  - Depth 3:
	 *      z1 &lt;- z1*z5678, z2 &lt;- z2*z5678, z3 &lt;- z3*z5678, z4 &lt;- z4*z5678
	 *      z5 &lt;- z5*z1234, z6 &lt;- z6*z1234, z7 &lt;- z7*z1234, z8 &lt;- z8*z1234
	 *      z12345678 = z1234*z5678
	 *      z9 &lt;- z9*zDE, zA &lt;- zA*zDE, zB &lt;- zB*zDE, zC &lt;- zC*zDE
	 *      zD &lt;- zD*z9ABC, zE*z9ABC
	 *      z9ABCDE = z9ABC*zDE
	 *
	 *  - Depth 4:
	 *      multiply z1..z8 by z9ABCDE
	 *      multiply z9..zE by z12345678
	 *      final z = z12345678*z9ABCDE
	 */</comment>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>z</name><index>[<expr><literal type="number">16</literal></expr>]</index><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zt</name></cpp:macro>   <cpp:value>(z[15])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zu</name></cpp:macro>   <cpp:value>(z[14])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zv</name></cpp:macro>   <cpp:value>(z[13])</cpp:value></cpp:define>

	<comment type="block">/*
	 * First recursion step (pairwise swapping and multiplication).
	 * If there is an odd number of elements, then we "invent" an
	 * extra one with coordinate Z = 1 (in Montgomery representation).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zt</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>zt</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>num</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>num</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>F256_R</name></expr></argument>, <argument><expr><sizeof>sizeof <name>F256_R</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform further recursion steps. At the entry of each step,
	 * the process has been done for groups of 's' points. The
	 * integer k is the log2 of s.
	 */</comment>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr><operator>,</operator> <expr><name>s</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <name>k</name><operator>)</operator> <operator>^</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>num</name> <operator>+</operator> <name>s</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>k</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Invert the final result, and convert all points.
	 */</comment>
	<expr_stmt><expr><call><name>f256_invert</name><argument_list>(<argument><expr><name>zt</name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>zv</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>zt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>zu</name></expr></argument>, <argument><expr><name>zv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>zv</name></expr></argument>, <argument><expr><name>zv</name></expr></argument>, <argument><expr><name>zu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>aff</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name>zu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>aff</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name>zv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Multiply the provided point by an integer.
 * Assumptions:
 *  - Source point is a valid curve point.
 *  - Source point is not the point-at-infinity.
 *  - Integer is not 0, and is lower than the curve order.
 * If these conditions are not met, then the result is indeterminate
 * (but the process is still constant-time).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>p256_mul</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<union>union <block>{
		<decl_stmt><decl><type><name>p256_affine</name></type> <name><name>aff</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>p256_jacobian</name></type> <name><name>jac</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
	}</block> <decl><name>window</name></decl>;</union>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute window, in Jacobian coordinates.
	 */</comment>
	<expr_stmt><expr><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>P</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>p256_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Convert the window points to affine coordinates. Point
	 * window[0] is the source point, already in affine coordinates.
	 */</comment>
	<expr_stmt><expr><call><name>window_to_affine</name><argument_list>(<argument><expr><name><name>window</name><operator>.</operator><name>aff</name></name></expr></argument>, <argument><expr><name><name>window</name><operator>.</operator><name>jac</name></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform point multiplication.
	 */</comment>
	<expr_stmt><expr><call><name>point_mul_inner</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>window</name><operator>.</operator><name>aff</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Precomputed window for the conventional generator: P256_Gwin[n]
 * contains (n+1)*G (affine coordinates, in Montgomery representation).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>p256_affine</name></type> <name><name>P256_Gwin</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x30D418A9143C1</literal></expr>, <expr><literal type="number">0xC4FEDB60179E7</literal></expr>, <expr><literal type="number">0x62251075BA95F</literal></expr>,
		  <expr><literal type="number">0x5C669FB732B77</literal></expr>, <expr><literal type="number">0x08905F76B5375</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x5357CE95560A8</literal></expr>, <expr><literal type="number">0x43A19E45CDDF2</literal></expr>, <expr><literal type="number">0x21F3258B4AB8E</literal></expr>,
		  <expr><literal type="number">0xD8552E88688DD</literal></expr>, <expr><literal type="number">0x0571FF18A5885</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x46D410DDD64DF</literal></expr>, <expr><literal type="number">0x0B433827D8500</literal></expr>, <expr><literal type="number">0x1490D9AA6AE3C</literal></expr>,
		  <expr><literal type="number">0xA3A832205038D</literal></expr>, <expr><literal type="number">0x06BB32E52DCF3</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x48D361BEE1A57</literal></expr>, <expr><literal type="number">0xB7B236FF82F36</literal></expr>, <expr><literal type="number">0x042DBE152CD7C</literal></expr>,
		  <expr><literal type="number">0xA3AA9A8FB0E92</literal></expr>, <expr><literal type="number">0x08C577517A5B8</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x3F904EEBC1272</literal></expr>, <expr><literal type="number">0x9E87D81FBFFAC</literal></expr>, <expr><literal type="number">0xCBBC98B027F84</literal></expr>,
		  <expr><literal type="number">0x47E46AD77DD87</literal></expr>, <expr><literal type="number">0x06936A3FD6FF7</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x5C1FC983A7EBD</literal></expr>, <expr><literal type="number">0xC3861FE1AB04C</literal></expr>, <expr><literal type="number">0x2EE98E583E47A</literal></expr>,
		  <expr><literal type="number">0xC06A88208311A</literal></expr>, <expr><literal type="number">0x05F06A2AB587C</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xB50D46918DCC5</literal></expr>, <expr><literal type="number">0xD7623C17374B0</literal></expr>, <expr><literal type="number">0x100AF24650A6E</literal></expr>,
		  <expr><literal type="number">0x76ABCDAACACE8</literal></expr>, <expr><literal type="number">0x077362F591B01</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xF24CE4CBABA68</literal></expr>, <expr><literal type="number">0x17AD6F4472D96</literal></expr>, <expr><literal type="number">0xDDD22E1762847</literal></expr>,
		  <expr><literal type="number">0x862EB6C36DEE5</literal></expr>, <expr><literal type="number">0x04B14C39CC5AB</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x8AAEC45C61F5C</literal></expr>, <expr><literal type="number">0x9D4B9537DBE1B</literal></expr>, <expr><literal type="number">0x76C20C90EC649</literal></expr>,
		  <expr><literal type="number">0x3C7D41CB5AAD0</literal></expr>, <expr><literal type="number">0x0907960649052</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x9B4AE7BA4F107</literal></expr>, <expr><literal type="number">0xF75EB882BEB30</literal></expr>, <expr><literal type="number">0x7A1F6873C568E</literal></expr>,
		  <expr><literal type="number">0x915C540A9877E</literal></expr>, <expr><literal type="number">0x03A076BB9DD1E</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x47373E77664A1</literal></expr>, <expr><literal type="number">0xF246CEE3E4039</literal></expr>, <expr><literal type="number">0x17A3AD55AE744</literal></expr>,
		  <expr><literal type="number">0x673C50A961A5B</literal></expr>, <expr><literal type="number">0x03074B5964213</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x6220D377E44BA</literal></expr>, <expr><literal type="number">0x30DFF14B593D3</literal></expr>, <expr><literal type="number">0x639F11299C2B5</literal></expr>,
		  <expr><literal type="number">0x75F5424D44CEF</literal></expr>, <expr><literal type="number">0x04C9916DEA07F</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x354EA0173B4F1</literal></expr>, <expr><literal type="number">0x3C23C00F70746</literal></expr>, <expr><literal type="number">0x23BB082BD2021</literal></expr>,
		  <expr><literal type="number">0xE03E43EAAB50C</literal></expr>, <expr><literal type="number">0x03BA5119D3123</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xD0303F5B9D4DE</literal></expr>, <expr><literal type="number">0x17DA67BDD2847</literal></expr>, <expr><literal type="number">0xC941956742F2F</literal></expr>,
		  <expr><literal type="number">0x8670F933BDC77</literal></expr>, <expr><literal type="number">0x0AEDD9164E240</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x4CD19499A78FB</literal></expr>, <expr><literal type="number">0x4BF9B345527F1</literal></expr>, <expr><literal type="number">0x2CFC6B462AB5C</literal></expr>,
		  <expr><literal type="number">0x30CDF90F02AF0</literal></expr>, <expr><literal type="number">0x0763891F62652</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xA3A9532D49775</literal></expr>, <expr><literal type="number">0xD7F9EBA15F59D</literal></expr>, <expr><literal type="number">0x60BBF021E3327</literal></expr>,
		  <expr><literal type="number">0xF75C23C7B84BE</literal></expr>, <expr><literal type="number">0x06EC12F2C706D</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x6E8F264E20E8E</literal></expr>, <expr><literal type="number">0xC79A7A84175C9</literal></expr>, <expr><literal type="number">0xC8EB00ABE6BFE</literal></expr>,
		  <expr><literal type="number">0x16A4CC09C0444</literal></expr>, <expr><literal type="number">0x005B3081D0C4E</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x777AA45F33140</literal></expr>, <expr><literal type="number">0xDCE5D45E31EB7</literal></expr>, <expr><literal type="number">0xB12F1A56AF7BE</literal></expr>,
		  <expr><literal type="number">0xF9B2B6E019A88</literal></expr>, <expr><literal type="number">0x086659CDFD835</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xDBD19DC21EC8C</literal></expr>, <expr><literal type="number">0x94FCF81392C18</literal></expr>, <expr><literal type="number">0x250B4998F9868</literal></expr>,
		  <expr><literal type="number">0x28EB37D2CD648</literal></expr>, <expr><literal type="number">0x0C61C947E4B34</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x407880DD9E767</literal></expr>, <expr><literal type="number">0x0C83FBE080C2B</literal></expr>, <expr><literal type="number">0x9BE5D2C43A899</literal></expr>,
		  <expr><literal type="number">0xAB4EF7D2D6577</literal></expr>, <expr><literal type="number">0x08719A555B3B4</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x260A6245E4043</literal></expr>, <expr><literal type="number">0x53E7FDFE0EA7D</literal></expr>, <expr><literal type="number">0xAC1AB59DE4079</literal></expr>,
		  <expr><literal type="number">0x072EFF3A4158D</literal></expr>, <expr><literal type="number">0x0E7090F1949C9</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x85612B944E886</literal></expr>, <expr><literal type="number">0xE857F61C81A76</literal></expr>, <expr><literal type="number">0xAD643D250F939</literal></expr>,
		  <expr><literal type="number">0x88DAC0DAA891E</literal></expr>, <expr><literal type="number">0x089300244125B</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x1AA7D26977684</literal></expr>, <expr><literal type="number">0x58A345A3304B7</literal></expr>, <expr><literal type="number">0x37385EABDEDEF</literal></expr>,
		  <expr><literal type="number">0x155E409D29DEE</literal></expr>, <expr><literal type="number">0x0EE1DF780B83E</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x12D91CBB5B437</literal></expr>, <expr><literal type="number">0x65A8956370CAC</literal></expr>, <expr><literal type="number">0xDE6D66170ED2F</literal></expr>,
		  <expr><literal type="number">0xAC9B8228CFA8A</literal></expr>, <expr><literal type="number">0x0FF57C95C3238</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x25634B2ED7097</literal></expr>, <expr><literal type="number">0x9156FD30DCCC4</literal></expr>, <expr><literal type="number">0x9E98110E35676</literal></expr>,
		  <expr><literal type="number">0x7594CBCD43F55</literal></expr>, <expr><literal type="number">0x038477ACC395B</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x2B90C00EE17FF</literal></expr>, <expr><literal type="number">0xF842ED2E33575</literal></expr>, <expr><literal type="number">0x1F5BC16874838</literal></expr>,
		  <expr><literal type="number">0x7968CD06422BD</literal></expr>, <expr><literal type="number">0x0BC0876AB9E7B</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xA35BB0CF664AF</literal></expr>, <expr><literal type="number">0x68F9707E3A242</literal></expr>, <expr><literal type="number">0x832660126E48F</literal></expr>,
		  <expr><literal type="number">0x72D2717BF54C6</literal></expr>, <expr><literal type="number">0x0AAE7333ED12C</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x2DB7995D586B1</literal></expr>, <expr><literal type="number">0xE732237C227B5</literal></expr>, <expr><literal type="number">0x65E7DBBE29569</literal></expr>,
		  <expr><literal type="number">0xBBBD8E4193E2A</literal></expr>, <expr><literal type="number">0x052706DC3EAA1</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xD8B7BC60055BE</literal></expr>, <expr><literal type="number">0xD76E27E4B72BC</literal></expr>, <expr><literal type="number">0x81937003CC23E</literal></expr>,
		  <expr><literal type="number">0xA090E337424E4</literal></expr>, <expr><literal type="number">0x02AA0E43EAD3D</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x524F6383C45D2</literal></expr>, <expr><literal type="number">0x422A41B2540B8</literal></expr>, <expr><literal type="number">0x8A4797D766355</literal></expr>,
		  <expr><literal type="number">0xDF444EFA6DE77</literal></expr>, <expr><literal type="number">0x0042170A9079A</literal></expr> }</block></expr>
	}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Multiply the conventional generator of the curve by the provided
 * integer. Return is written in *P.
 *
 * Assumptions:
 *  - Integer is not 0, and is lower than the curve order.
 * If this conditions is not met, then the result is indeterminate
 * (but the process is still constant-time).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>p256_mulgen</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>point_mul_inner</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>P256_Gwin</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return 1 if all of the following hold:
 *  - klen &lt;= 32
 *  - k != 0
 *  - k is lower than the curve order
 * Otherwise, return 0.
 *
 * Constant-time behaviour: only klen may be observable.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>check_scalar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>klen</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>klen</name></expr>;</condition> <incr><expr><name>u</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>z</name> <operator>|=</operator> <name><name>k</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>klen</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>klen</name></expr>;</condition> <incr><expr><name>u</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>EQ0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>CMP</name><argument_list>(<argument><expr><name><name>k</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>P256_N</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><call><name>NEQ</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>LT0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_mul</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>Glen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>P</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Glen</name> <operator>!=</operator> <literal type="number">65</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_scalar</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_encode</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_mulgen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>P</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_mulgen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_encode</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">65</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_muladd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>B</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We might want to use Shamir's trick here: make a composite
	 * window of u*P+v*Q points, to merge the two doubling-ladders
	 * into one. This, however, has some complications:
	 *
	 *  - During the computation, we may hit the point-at-infinity.
	 *    Thus, we would need p256_add_complete_mixed() (complete
	 *    formulas for point addition), with a higher cost (17 muls
	 *    instead of 11).
	 *
	 *  - A 4-bit window would be too large, since it would involve
	 *    16*16-1 = 255 points. For the same window size as in the
	 *    p256_mul() case, we would need to reduce the window size
	 *    to 2 bits, and thus perform twice as many non-doubling
	 *    point additions.
	 *
	 *  - The window may itself contain the point-at-infinity, and
	 *    thus cannot be in all generality be made of affine points.
	 *    Instead, we would need to make it a window of points in
	 *    Jacobian coordinates. Even p256_add_complete_mixed() would
	 *    be inappropriate.
	 *
	 * For these reasons, the code below performs two separate
	 * point multiplications, then computes the final point addition
	 * (which is both a "normal" addition, and a doubling, to handle
	 * all cases).
	 */</comment>

	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>P</name></decl>, <decl><type ref="prev"/><name>Q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>t</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">65</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>B</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>p256_mulgen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>p256_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The final addition may fail in case both points are equal.
	 */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>p256_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name><name>P</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>EQ</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>|</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If s is 1 then either P+Q = 0 (t = 1) or P = Q (t = 0). So we
	 * have the following:
	 *
	 *   s = 0, t = 0   return P (normal addition)
	 *   s = 0, t = 1   return P (normal addition)
	 *   s = 1, t = 0   return Q (a 'double' case)
	 *   s = 1, t = 1   report an error (P+Q = 0)
	 */</comment>
	<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>s</name> <operator>&amp;</operator> <operator>~</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_encode</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>s</name> <operator>&amp;</operator> <name>t</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ec.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_impl</name></type> <name>br_ec_p256_m62</name> <init>= <expr><block>{
	<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0x00800000</literal></expr>,
	<expr><operator>&amp;</operator><name>api_generator</name></expr>,
	<expr><operator>&amp;</operator><name>api_order</name></expr>,
	<expr><operator>&amp;</operator><name>api_xoff</name></expr>,
	<expr><operator>&amp;</operator><name>api_mul</name></expr>,
	<expr><operator>&amp;</operator><name>api_mulgen</name></expr>,
	<expr><operator>&amp;</operator><name>api_muladd</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* see bearssl_ec.h */</comment>
<function><type><specifier>const</specifier> <name>br_ec_impl</name> <modifier>*</modifier></type>
<name>br_ec_p256_m62_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>br_ec_p256_m62</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* see bearssl_ec.h */</comment>
<function><type><specifier>const</specifier> <name>br_ec_impl</name> <modifier>*</modifier></type>
<name>br_ec_p256_m62_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
