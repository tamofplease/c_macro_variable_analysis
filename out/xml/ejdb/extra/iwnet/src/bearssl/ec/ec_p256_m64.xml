<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iwnet/src/bearssl/ec/ec_p256_m64.c"><comment type="block">/*
 * Copyright (c) 2018 Thomas Pornin &lt;pornin@bolet.org&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining 
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be 
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"inner.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name> <operator>||</operator> <name>BR_UMUL128</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;intrin.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>P256_G</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x04</literal></expr>, <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x17</literal></expr>, <expr><literal type="number">0xD1</literal></expr>, <expr><literal type="number">0xF2</literal></expr>, <expr><literal type="number">0xE1</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0x47</literal></expr>, <expr><literal type="number">0xF8</literal></expr>,
	<expr><literal type="number">0xBC</literal></expr>, <expr><literal type="number">0xE6</literal></expr>, <expr><literal type="number">0xE5</literal></expr>, <expr><literal type="number">0x63</literal></expr>, <expr><literal type="number">0xA4</literal></expr>, <expr><literal type="number">0x40</literal></expr>, <expr><literal type="number">0xF2</literal></expr>, <expr><literal type="number">0x77</literal></expr>, <expr><literal type="number">0x03</literal></expr>, <expr><literal type="number">0x7D</literal></expr>,
	<expr><literal type="number">0x81</literal></expr>, <expr><literal type="number">0x2D</literal></expr>, <expr><literal type="number">0xEB</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0xA0</literal></expr>, <expr><literal type="number">0xF4</literal></expr>, <expr><literal type="number">0xA1</literal></expr>, <expr><literal type="number">0x39</literal></expr>, <expr><literal type="number">0x45</literal></expr>, <expr><literal type="number">0xD8</literal></expr>,
	<expr><literal type="number">0x98</literal></expr>, <expr><literal type="number">0xC2</literal></expr>, <expr><literal type="number">0x96</literal></expr>, <expr><literal type="number">0x4F</literal></expr>, <expr><literal type="number">0xE3</literal></expr>, <expr><literal type="number">0x42</literal></expr>, <expr><literal type="number">0xE2</literal></expr>, <expr><literal type="number">0xFE</literal></expr>, <expr><literal type="number">0x1A</literal></expr>, <expr><literal type="number">0x7F</literal></expr>,
	<expr><literal type="number">0x9B</literal></expr>, <expr><literal type="number">0x8E</literal></expr>, <expr><literal type="number">0xE7</literal></expr>, <expr><literal type="number">0xEB</literal></expr>, <expr><literal type="number">0x4A</literal></expr>, <expr><literal type="number">0x7C</literal></expr>, <expr><literal type="number">0x0F</literal></expr>, <expr><literal type="number">0x9E</literal></expr>, <expr><literal type="number">0x16</literal></expr>, <expr><literal type="number">0x2B</literal></expr>,
	<expr><literal type="number">0xCE</literal></expr>, <expr><literal type="number">0x33</literal></expr>, <expr><literal type="number">0x57</literal></expr>, <expr><literal type="number">0x6B</literal></expr>, <expr><literal type="number">0x31</literal></expr>, <expr><literal type="number">0x5E</literal></expr>, <expr><literal type="number">0xCE</literal></expr>, <expr><literal type="number">0xCB</literal></expr>, <expr><literal type="number">0xB6</literal></expr>, <expr><literal type="number">0x40</literal></expr>,
	<expr><literal type="number">0x68</literal></expr>, <expr><literal type="number">0x37</literal></expr>, <expr><literal type="number">0xBF</literal></expr>, <expr><literal type="number">0x51</literal></expr>, <expr><literal type="number">0xF5</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>P256_N</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0x00</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>,
	<expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xFF</literal></expr>, <expr><literal type="number">0xBC</literal></expr>, <expr><literal type="number">0xE6</literal></expr>, <expr><literal type="number">0xFA</literal></expr>, <expr><literal type="number">0xAD</literal></expr>,
	<expr><literal type="number">0xA7</literal></expr>, <expr><literal type="number">0x17</literal></expr>, <expr><literal type="number">0x9E</literal></expr>, <expr><literal type="number">0x84</literal></expr>, <expr><literal type="number">0xF3</literal></expr>, <expr><literal type="number">0xB9</literal></expr>, <expr><literal type="number">0xCA</literal></expr>, <expr><literal type="number">0xC2</literal></expr>, <expr><literal type="number">0xFC</literal></expr>, <expr><literal type="number">0x63</literal></expr>,
	<expr><literal type="number">0x25</literal></expr>, <expr><literal type="number">0x51</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_generator</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <sizeof>sizeof <name>P256_G</name></sizeof></expr>;</expr_stmt>
	<return>return <expr><name>P256_G</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type>
<name>api_order</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <sizeof>sizeof <name>P256_N</name></sizeof></expr>;</expr_stmt>
	<return>return <expr><name>P256_N</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_xoff</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * A field element is encoded as four 64-bit integers, in basis 2^64.
 * Values may reach up to 2^256-1. Montgomery multiplication is used.
 */</comment>

<comment type="block">/* R = 2^256 mod p */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>F256_R</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0x0000000000000001</literal></expr>, <expr><literal type="number">0xFFFFFFFF00000000</literal></expr>,
	<expr><literal type="number">0xFFFFFFFFFFFFFFFF</literal></expr>, <expr><literal type="number">0x00000000FFFFFFFE</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Curve equation is y^2 = x^3 - 3*x + B. This constant is B*R mod p
   (Montgomery representation of B). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>P256_B_MONTY</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="number">0xD89CDF6229C4BDDF</literal></expr>, <expr><literal type="number">0xACF005CD78843090</literal></expr>,
	<expr><literal type="number">0xE5A220ABF7212ED6</literal></expr>, <expr><literal type="number">0xDC30061D04874834</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Addition in the field.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_add</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name></expr></cpp:if>
	<decl_stmt><decl><type><name>unsigned</name> <name>__int128</name></type> <name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * 2^256 = 2^224 - 2^192 - 2^96 + 1 in the field.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<comment type="block">/* Here, carry "w &gt;&gt; 64" can only be 0 or -1 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<comment type="block">/* Again, carry is 0 or -1 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>-</operator> <name>t</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:elif>

	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a carry, then we want to subtract p, which we
	 * do by adding 2^256 - p.
	 */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Subtraction in the field.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_sub</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name></expr></cpp:if>

	<decl_stmt><decl><type><name>unsigned</name> <name>__int128</name></type> <name>w</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * p = 2^256 - 2^224 + 2^192 + 2^96 - 1.
	 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>t</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<comment type="block">/* Here, carry "w &gt;&gt; 64" can only be 0 or +1 */</comment>
	<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>w</name></expr>;</expr_stmt>
	<comment type="block">/* Again, carry is 0 or +1 */</comment>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>+=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>w</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>t</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:elif>

	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>t</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a carry, then we need to add p.
	 */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><operator>-</operator><name>t</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>cc</name></expr></argument>, <argument><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>t</name> <operator>-</operator> <operator>(</operator><name>t</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Montgomery multiplication in the field.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_montymul</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name></expr></cpp:if>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>f</name></decl>, <decl><type ref="prev"/><name>t0</name></decl>, <decl><type ref="prev"/><name>t1</name></decl>, <decl><type ref="prev"/><name>t2</name></decl>, <decl><type ref="prev"/><name>t3</name></decl>, <decl><type ref="prev"/><name>t4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>__int128</name></type> <name>z</name></decl>, <decl><type ref="prev"/><name>ff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When computing d &lt;- d + a[u]*b, we also add f*p such
	 * that d + a[u]*b + f*p is a multiple of 2^64. Since
	 * p = -1 mod 2^64, we can compute f = d[0] + a[u]*b[0] mod 2^64.
	 */</comment>

	<comment type="block">/*
	 * Step 1: t &lt;- (a[0]*b + f*p) / 2^64
	 * We have f = a[0]*b[0] mod 2^64. Since p = -1 mod 2^64, this
	 * ensures that (a[0]*b + f*p) is a multiple of 2^64.
	 *
	 * We also have: f*p = f*2^256 - f*2^224 + f*2^192 + f*2^96 - f.
	 */</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t3</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ff</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t2</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>ff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t3</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>ff</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t3</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t4</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Steps 2 to 4: t &lt;- (t + a[i]*b + f*p) / 2^64
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/* t &lt;- (t + x*b - f) / 2^64 */</comment>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name>t0</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name>t1</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name>t2</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>*</operator> <name>x</name> <operator>+</operator> <name>t3</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <name>t4</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t3</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t4</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* t &lt;- t + f*2^32, carry in the upper half of z */</comment>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t0</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t1</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>

		<comment type="block">/* t &lt;- t + f*2^192 - f*2^160 + f*2^128 */</comment>
		<expr_stmt><expr><name>ff</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">64</literal><operator>)</operator> 
			<operator>-</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> <name>f</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t2</name> <operator>+</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>ff</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t3</name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>ff</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>t3</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>t4</name> <operator>+=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * At that point, we have computed t = (a*b + F*p) / 2^256, where
	 * F is a 256-bit integer whose limbs are the "f" coefficients
	 * in the steps above. We have:
	 *   a &lt;= 2^256-1
	 *   b &lt;= 2^256-1
	 *   F &lt;= 2^256-1
	 * Hence:
	 *   a*b + F*p &lt;= (2^256-1)*(2^256-1) + p*(2^256-1)
	 *   a*b + F*p &lt;= 2^256*(2^256 - 2 + p) + 1 - p
	 * Therefore:
	 *   t &lt; 2^256 + p - 2
	 * Since p &lt; 2^256, it follows that:
	 *   t4 can be only 0 or 1
	 *   t - p &lt; 2^256
	 * We can therefore subtract p from t, conditionally on t4, to
	 * get a nonnegative result that fits on 256 bits.
	 */</comment>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t0</name> <operator>+</operator> <name>t4</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t1</name> <operator>-</operator> <operator>(</operator><name>t4</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name>t2</name> <operator>-</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t3</name> <operator>=</operator> <name>t3</name> <operator>-</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">127</literal><operator>)</operator> <operator>-</operator> <name>t4</name> <operator>+</operator> <operator>(</operator><name>t4</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>t0</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>t1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>t2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>t3</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:elif>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>f</name></decl>, <decl><type ref="prev"/><name>t0</name></decl>, <decl><type ref="prev"/><name>t1</name></decl>, <decl><type ref="prev"/><name>t2</name></decl>, <decl><type ref="prev"/><name>t3</name></decl>, <decl><type ref="prev"/><name>t4</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>zl</name></decl>, <decl><type ref="prev"/><name>zh</name></decl>, <decl><type ref="prev"/><name>ffl</name></decl>, <decl><type ref="prev"/><name>ffh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When computing d &lt;- d + a[u]*b, we also add f*p such
	 * that d + a[u]*b + f*p is a multiple of 2^64. Since
	 * p = -1 mod 2^64, we can compute f = d[0] + a[u]*b[0] mod 2^64.
	 */</comment>

	<comment type="block">/*
	 * Step 1: t &lt;- (a[0]*b + f*p) / 2^64
	 * We have f = a[0]*b[0] mod 2^64. Since p = -1 mod 2^64, this
	 * ensures that (a[0]*b + f*p) is a multiple of 2^64.
	 *
	 * We also have: f*p = f*2^256 - f*2^224 + f*2^192 + f*2^96 - f.
	 */</comment>
	<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t0</name> <operator>=</operator> <name>zh</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t0</name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <name>zh</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <name>zh</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <name>zl</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>t3</name> <operator>=</operator> <name>zh</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>t4</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Steps 2 to 4: t &lt;- (t + a[i]*b + f*p) / 2^64
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<comment type="block">/* f = t0 + x * b[0]; -- computed below */</comment>

		<comment type="block">/* t &lt;- (t + x*b - f) / 2^64 */</comment>
		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>zl</name> <operator>=</operator> <call><name>_umul128</name><argument_list>(<argument><expr><name><name>b</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>zl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>zh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>zl</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>zh</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>t4</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* t &lt;- t + f*2^32, carry in k */</comment>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* t &lt;- t + f*2^192 - f*2^160 + f*2^128 */</comment>
		<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>_subborrow_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>f</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ffl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_subborrow_u64</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>f</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ffh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>ffl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>ffh</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * At that point, we have computed t = (a*b + F*p) / 2^256, where
	 * F is a 256-bit integer whose limbs are the "f" coefficients
	 * in the steps above. We have:
	 *   a &lt;= 2^256-1
	 *   b &lt;= 2^256-1
	 *   F &lt;= 2^256-1
	 * Hence:
	 *   a*b + F*p &lt;= (2^256-1)*(2^256-1) + p*(2^256-1)
	 *   a*b + F*p &lt;= 2^256*(2^256 - 2 + p) + 1 - p
	 * Therefore:
	 *   t &lt; 2^256 + p - 2
	 * Since p &lt; 2^256, it follows that:
	 *   t4 can be only 0 or 1
	 *   t - p &lt; 2^256
	 * We can therefore subtract p from t, conditionally on t4, to
	 * get a nonnegative result that fits on 256 bits.
	 */</comment>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>t0</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>t4</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><operator>-</operator><name>t4</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><operator>(</operator><name>t4</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><name>t4</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>t0</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>t1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>t2</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>t3</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Montgomery squaring in the field; currently a basic wrapper around
 * multiplication (inline, should be optimized away).
 * TODO: see if some extra speed can be gained here.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_montysquare</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert to Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_tomonty</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * R2 = 2^512 mod p.
	 * If R = 2^256 mod p, then R2 = R^2 mod p; and the Montgomery
	 * multiplication of a by R2 is: a*R2/R = a*R mod p, i.e. the
	 * conversion to Montgomery representation.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>R2</name><index>[]</index></name> <init>= <expr><block>{
		<expr><literal type="number">0x0000000000000003</literal></expr>,
		<expr><literal type="number">0xFFFFFFFBFFFFFFFF</literal></expr>,
		<expr><literal type="number">0xFFFFFFFFFFFFFFFE</literal></expr>,
		<expr><literal type="number">0x00000004FFFFFFFD</literal></expr>
	}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>R2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert from Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_frommonty</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Montgomery multiplication by 1 is division by 2^256 modulo p.
	 */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>uint64_t</name></type> <name><name>one</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inversion in the field. If the source value is 0 modulo p, then this
 * returns 0 or p. This function uses Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>f256_invert</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We compute a^(p-2) mod p. The exponent pattern (from high to
	 * low) is:
	 *  - 32 bits of value 1
	 *  - 31 bits of value 0
	 *  - 1 bit of value 1
	 *  - 96 bits of value 0
	 *  - 94 bits of value 1
	 *  - 1 bit of value 0
	 *  - 1 bit of value 1
	 * To speed up the square-and-multiply algorithm, we precompute
	 * a^(2^31-1).
	 */</comment>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>r</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">30</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><sizeof>sizeof <name>t</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">224</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>--</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
		<case>case <expr><literal type="number">2</literal></expr>:</case>
		<case>case <expr><literal type="number">192</literal></expr>:</case>
		<case>case <expr><literal type="number">224</literal></expr>:</case>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><literal type="number">3</literal></expr>:</case>
		<case>case <expr><literal type="number">34</literal></expr>:</case>
		<case>case <expr><literal type="number">65</literal></expr>:</case>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><sizeof>sizeof <name>r</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Finalize reduction.
 * Input value fits on 256 bits. This function subtracts p if and only
 * if the input is greater than or equal to p.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>f256_final_reduce</name><parameter_list>(<parameter><decl><type><name>uint64_t</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BR_INT128</name></expr></cpp:if>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>t0</name></decl>, <decl><type ref="prev"/><name>t1</name></decl>, <decl><type ref="prev"/><name>t2</name></decl>, <decl><type ref="prev"/><name>t3</name></decl>, <decl><type ref="prev"/><name>cc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>__int128</name></type> <name>z</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We add 2^224 - 2^192 - 2^96 + 1 to a. If there is no carry,
	 * then a &lt; p; otherwise, the addition result we computed is
	 * the value we must return.
	 */</comment>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>t0</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator> <operator>-</operator> <operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">127</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>__int128</name><operator>)</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>-</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">127</literal><operator>)</operator> <operator>+</operator> <literal type="number">0xFFFFFFFF</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>t3</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name>z</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">64</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name>t0</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name>t1</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name>t2</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name>cc</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^</operator> <name>t3</name><operator>)</operator></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>BR_UMUL128</name></expr></cpp:elif>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name>t0</name></decl>, <decl><type ref="prev"/><name>t1</name></decl>, <decl><type ref="prev"/><name>t2</name></decl>, <decl><type ref="prev"/><name>t3</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>k</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>_addcarry_u64</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><name>k</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>^</operator> <name>t0</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>^</operator> <name>t1</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>^</operator> <name>t2</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^=</operator> <name>m</name> <operator>&amp;</operator> <operator>(</operator><name><name>a</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>^</operator> <name>t3</name><operator>)</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Points in affine and Jacobian coordinates.
 *
 *  - In affine coordinates, the point-at-infinity cannot be encoded.
 *  - Jacobian coordinates (X,Y,Z) correspond to affine (X/Z^2,Y/Z^3);
 *    if Z = 0 then this is the point-at-infinity.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>y</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>p256_affine</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>y</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>z</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>p256_jacobian</name>;</typedef>

<comment type="block">/*
 * Decode a point. The returned point is in Jacobian coordinates, but
 * with z = 1. If the encoding is invalid, or encodes a point which is
 * not on the curve, or encodes the point at infinity, then this function
 * returns 0. Otherwise, 1 is returned.
 *
 * The buffer is assumed to have length exactly 65 bytes.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>point_decode</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>x</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>y</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>x3</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Header byte shall be 0x04.
	 */</comment>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>EQ</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0x04</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decode X and Y coordinates, and convert them into
	 * Montgomery representation.
	 */</comment>
	<expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">17</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>y</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">33</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>y</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">41</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>y</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">49</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>y</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>br_dec64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">57</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_tomonty</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_tomonty</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify y^2 = x^3 + A*x + B. In curve P-256, A = -3.
	 * Note that the Montgomery representation of 0 is 0. We must
	 * take care to apply the final reduction to make sure we have
	 * 0 and not p.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>P256_B_MONTY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <name><name>t</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>t</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>EQ</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>tt</name> <operator>|</operator> <operator>(</operator><name>tt</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return the point in Jacobian coordinates (and Montgomery
	 * representation).
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><sizeof>sizeof <name>x</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><sizeof>sizeof <name>y</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>F256_R</name></expr></argument>, <argument><expr><sizeof>sizeof <name>F256_R</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Final conversion for a point:
 *  - The point is converted back to affine coordinates.
 *  - Final reduction is performed.
 *  - The point is encoded into the provided buffer.
 *
 * If the point is the point-at-infinity, all operations are performed,
 * but the buffer contents are indeterminate, and 0 is returned. Otherwise,
 * the encoded point is written in the buffer, and 1 is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>point_encode</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

	<comment type="block">/* Set t1 = 1/z^2 and t2 = 1/z^3. */</comment>
	<expr_stmt><expr><call><name>f256_invert</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compute affine coordinates x (in t1) and y (in t2). */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert back from Montgomery representation, and finalize
	   reductions. */</comment>
	<expr_stmt><expr><call><name>f256_frommonty</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_frommonty</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Encode. */</comment>
	<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x04</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>t1</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator>  <literal type="number">9</literal></expr></argument>, <argument><expr><name><name>t1</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">17</literal></expr></argument>, <argument><expr><name><name>t1</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">25</literal></expr></argument>, <argument><expr><name><name>t1</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">33</literal></expr></argument>, <argument><expr><name><name>t2</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">41</literal></expr></argument>, <argument><expr><name><name>t2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">49</literal></expr></argument>, <argument><expr><name><name>t2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>br_enc64be</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">57</literal></expr></argument>, <argument><expr><name><name>t2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return success if and only if P-&gt;z != 0. */</comment>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>-&gt;</operator><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<return>return <expr><call><name>NEQ</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>|</operator> <name>z</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Point doubling in Jacobian coordinates: point P is doubled.
 * Note: if the source point is the point-at-infinity, then the result is
 * still the point-at-infinity, which is correct. Moreover, if the three
 * coordinates were zero, then they still are zero in the returned value.
 *
 * (Note: this is true even without the final reduction: if the three
 * coordinates are encoded as four words of value zero each, then the
 * result will also have all-zero coordinate encodings, not the alternate
 * encoding as the integer p.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>p256_double</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Doubling formulas are:
	 *
	 *   s = 4*x*y^2
	 *   m = 3*(x + z^2)*(x - z^2)
	 *   x' = m^2 - 2*s
	 *   y' = m*(s - x') - 8*y^4
	 *   z' = 2*y*z
	 *
	 * These formulas work for all points, including points of order 2
	 * and points at infinity:
	 *   - If y = 0 then z' = 0. But there is no such point in P-256
	 *     anyway.
	 *   - If z = 0 then z' = 0.
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t3</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t4</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute z^2 in t1.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x-z^2 in t2 and x+z^2 in t1.
	 */</comment>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute 3*(x+z^2)*(x-z^2) in t1.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute 4*x*y^2 (in t2) and 2*y^2 (in t3).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x' = m^2 - 2*s.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute z' = 2*y*z.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute y' = m*(s - x') - 8*y^4. Note that we already have
	 * 2*y^2 in t3.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_add</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Point addition (Jacobian coordinates): P1 is replaced with P1+P2.
 * This function computes the wrong result in the following cases:
 *
 *   - If P1 == 0 but P2 != 0
 *   - If P1 != 0 but P2 == 0
 *   - If P1 == P2
 *
 * In all three cases, P1 is set to the point at infinity.
 *
 * Returned value is 0 if one of the following occurs:
 *
 *   - P1 and P2 have the same Y coordinate.
 *   - P1 == 0 and P2 == 0.
 *   - The Y coordinate of one of the points is 0 and the other point is
 *     the point at infinity.
 *
 * The third case cannot actually happen with valid points, since a point
 * with Y == 0 is a point of order 2, and there is no point of order 2 on
 * curve P-256.
 *
 * Therefore, assuming that P1 != 0 and P2 != 0 on input, then the caller
 * can apply the following:
 *
 *   - If the result is not the point at infinity, then it is correct.
 *   - Otherwise, if the returned value is 1, then this is a case of
 *     P1+P2 == 0, so the result is indeed the point at infinity.
 *   - Otherwise, P1 == P2, so a "double" operation should have been
 *     performed.
 *
 * Note that you can get a returned value of 0 with a correct result,
 * e.g. if P1 and P2 have the same Y coordinate, but distinct X coordinates.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>p256_add</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_jacobian</name> <modifier>*</modifier></type><name>P2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Addtions formulas are:
	 *
	 *   u1 = x1 * z2^2
	 *   u2 = x2 * z1^2
	 *   s1 = y1 * z2^3
	 *   s2 = y2 * z1^3
	 *   h = u2 - u1
	 *   r = s2 - s1
	 *   x3 = r^2 - h^3 - 2 * u1 * h^2
	 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
	 *   z3 = h * z1 * z2
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t3</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t4</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t5</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t6</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t7</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>ret</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute u1 = x1*z2^2 (in t1) and s1 = y1*z2^3 (in t3).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute h = h2 - u1 (in t2) and r = s2 - s1 (in t4).
	 * We need to test whether r is zero, so we will do some extra
	 * reduce.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <name><name>t4</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>tt</name> <operator>|</operator> <operator>(</operator><name>tt</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ret</name> <operator>|</operator> <operator>-</operator><name>ret</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5);
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute z3 = h*z1*z2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Point addition (mixed coordinates): P1 is replaced with P1+P2.
 * This is a specialised function for the case when P2 is a non-zero point
 * in affine coordinates.
 *
 * This function computes the wrong result in the following cases:
 *
 *   - If P1 == 0
 *   - If P1 == P2
 *
 * In both cases, P1 is set to the point at infinity.
 *
 * Returned value is 0 if one of the following occurs:
 *
 *   - P1 and P2 have the same Y (affine) coordinate.
 *   - The Y coordinate of P2 is 0 and P1 is the point at infinity.
 *
 * The second case cannot actually happen with valid points, since a point
 * with Y == 0 is a point of order 2, and there is no point of order 2 on
 * curve P-256.
 *
 * Therefore, assuming that P1 != 0 on input, then the caller
 * can apply the following:
 *
 *   - If the result is not the point at infinity, then it is correct.
 *   - Otherwise, if the returned value is 1, then this is a case of
 *     P1+P2 == 0, so the result is indeed the point at infinity.
 *   - Otherwise, P1 == P2, so a "double" operation should have been
 *     performed.
 *
 * Again, a value of 0 may be returned in some cases where the addition
 * result is correct.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>p256_add_mixed</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_affine</name> <modifier>*</modifier></type><name>P2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Addtions formulas are:
	 *
	 *   u1 = x1
	 *   u2 = x2 * z1^2
	 *   s1 = y1
	 *   s2 = y2 * z1^3
	 *   h = u2 - u1
	 *   r = s2 - s1
	 *   x3 = r^2 - h^3 - 2 * u1 * h^2
	 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
	 *   z3 = h * z1
	 */</comment>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>t1</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t2</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t3</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t4</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t5</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t6</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>t7</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name>tt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>ret</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute u1 = x1 (in t1) and s1 = y1 (in t3).
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name>t1</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>t3</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name>t3</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name><name>P2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute h = h2 - u1 (in t2) and r = s2 - s1 (in t4).
	 * We need to test whether r is zero, so we will do some extra
	 * reduce.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tt</name> <operator>=</operator> <name><name>t4</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>t4</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>tt</name> <operator>|</operator> <operator>(</operator><name>tt</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>ret</name> <operator>|</operator> <operator>-</operator><name>ret</name><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">31</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5);
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t7</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name>t6</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t4</name></expr></argument>, <argument><expr><name>t6</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t5</name></expr></argument>, <argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_sub</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute z3 = h*z1*z2.
	 */</comment>
	<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name><name>P1</name><operator>-&gt;</operator><name>z</name></name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* unused */</comment>
<comment type="block">/*
 * Point addition (mixed coordinates, complete): P1 is replaced with P1+P2.
 * This is a specialised function for the case when P2 is a non-zero point
 * in affine coordinates.
 *
 * This function returns the correct result in all cases.
 */</comment>
static uint32_t
p256_add_complete_mixed(p256_jacobian *P1, const p256_affine *P2)
{
	<comment type="block">/*
	 * Addtions formulas, in the general case, are:
	 *
	 *   u1 = x1
	 *   u2 = x2 * z1^2
	 *   s1 = y1
	 *   s2 = y2 * z1^3
	 *   h = u2 - u1
	 *   r = s2 - s1
	 *   x3 = r^2 - h^3 - 2 * u1 * h^2
	 *   y3 = r * (u1 * h^2 - x3) - s1 * h^3
	 *   z3 = h * z1
	 *
	 * These formulas mishandle the two following cases:
	 *
	 *  - If P1 is the point-at-infinity (z1 = 0), then z3 is
	 *    incorrectly set to 0.
	 *
	 *  - If P1 = P2, then u1 = u2 and s1 = s2, and x3, y3 and z3
	 *    are all set to 0.
	 *
	 * However, if P1 + P2 = 0, then u1 = u2 but s1 != s2, and then
	 * we correctly get z3 = 0 (the point-at-infinity).
	 *
	 * To fix the case P1 = 0, we perform at the end a copy of P2
	 * over P1, conditional to z1 = 0.
	 *
	 * For P1 = P2: in that case, both h and r are set to 0, and
	 * we get x3, y3 and z3 equal to 0. We can test for that
	 * occurrence to make a mask which will be all-one if P1 = P2,
	 * or all-zero otherwise; then we can compute the double of P2
	 * and add it, combined with the mask, to (x3,y3,z3).
	 *
	 * Using the doubling formulas in p256_double() on (x2,y2),
	 * simplifying since P2 is affine (i.e. z2 = 1, implicitly),
	 * we get:
	 *   s = 4*x2*y2^2
	 *   m = 3*(x2 + 1)*(x2 - 1)
	 *   x' = m^2 - 2*s
	 *   y' = m*(s - x') - 8*y2^4
	 *   z' = 2*y2
	 * which requires only 6 multiplications. Added to the 11
	 * multiplications of the normal mixed addition in Jacobian
	 * coordinates, we get a cost of 17 multiplications in total.
	 */</comment>
	uint64_t t1[4], t2[4], t3[4], t4[4], t5[4], t6[4], t7[4], tt, zz;
	int i;

	<comment type="block">/*
	 * Set zz to -1 if P1 is the point at infinity, 0 otherwise.
	 */</comment>
	zz = P1-&gt;z[0] | P1-&gt;z[1] | P1-&gt;z[2] | P1-&gt;z[3];
	zz = ((zz | -zz) &gt;&gt; 63) - (uint64_t)1;

	<comment type="block">/*
	 * Compute u1 = x1 (in t1) and s1 = y1 (in t3).
	 */</comment>
	memcpy(t1, P1-&gt;x, sizeof t1);
	memcpy(t3, P1-&gt;y, sizeof t3);

	<comment type="block">/*
	 * Compute u2 = x2*z1^2 (in t2) and s2 = y2*z1^3 (in t4).
	 */</comment>
	f256_montysquare(t4, P1-&gt;z);
	f256_montymul(t2, P2-&gt;x, t4);
	f256_montymul(t5, P1-&gt;z, t4);
	f256_montymul(t4, P2-&gt;y, t5);

	<comment type="block">/*
	 * Compute h = h2 - u1 (in t2) and r = s2 - s1 (in t4).
	 * reduce.
	 */</comment>
	f256_sub(t2, t2, t1);
	f256_sub(t4, t4, t3);

	<comment type="block">/*
	 * If both h = 0 and r = 0, then P1 = P2, and we want to set
	 * the mask tt to -1; otherwise, the mask will be 0.
	 */</comment>
	f256_final_reduce(t2);
	f256_final_reduce(t4);
	tt = t2[0] | t2[1] | t2[2] | t2[3] | t4[0] | t4[1] | t4[2] | t4[3];
	tt = ((tt | -tt) &gt;&gt; 63) - (uint64_t)1;

	<comment type="block">/*
	 * Compute u1*h^2 (in t6) and h^3 (in t5);
	 */</comment>
	f256_montysquare(t7, t2);
	f256_montymul(t6, t1, t7);
	f256_montymul(t5, t7, t2);

	<comment type="block">/*
	 * Compute x3 = r^2 - h^3 - 2*u1*h^2.
	 */</comment>
	f256_montysquare(P1-&gt;x, t4);
	f256_sub(P1-&gt;x, P1-&gt;x, t5);
	f256_sub(P1-&gt;x, P1-&gt;x, t6);
	f256_sub(P1-&gt;x, P1-&gt;x, t6);

	<comment type="block">/*
	 * Compute y3 = r*(u1*h^2 - x3) - s1*h^3.
	 */</comment>
	f256_sub(t6, t6, P1-&gt;x);
	f256_montymul(P1-&gt;y, t4, t6);
	f256_montymul(t1, t5, t3);
	f256_sub(P1-&gt;y, P1-&gt;y, t1);

	<comment type="block">/*
	 * Compute z3 = h*z1.
	 */</comment>
	f256_montymul(P1-&gt;z, P1-&gt;z, t2);

	<comment type="block">/*
	 * The "double" result, in case P1 = P2.
	 */</comment>

	<comment type="block">/*
	 * Compute z' = 2*y2 (in t1).
	 */</comment>
	f256_add(t1, P2-&gt;y, P2-&gt;y);

	<comment type="block">/*
	 * Compute 2*(y2^2) (in t2) and s = 4*x2*(y2^2) (in t3).
	 */</comment>
	f256_montysquare(t2, P2-&gt;y);
	f256_add(t2, t2, t2);
	f256_add(t3, t2, t2);
	f256_montymul(t3, P2-&gt;x, t3);

	<comment type="block">/*
	 * Compute m = 3*(x2^2 - 1) (in t4).
	 */</comment>
	f256_montysquare(t4, P2-&gt;x);
	f256_sub(t4, t4, F256_R);
	f256_add(t5, t4, t4);
	f256_add(t4, t4, t5);

	<comment type="block">/*
	 * Compute x' = m^2 - 2*s (in t5).
	 */</comment>
	f256_montysquare(t5, t4);
	f256_sub(t5, t3);
	f256_sub(t5, t3);

	<comment type="block">/*
	 * Compute y' = m*(s - x') - 8*y2^4 (in t6).
	 */</comment>
	f256_sub(t6, t3, t5);
	f256_montymul(t6, t6, t4);
	f256_montysquare(t7, t2);
	f256_sub(t6, t6, t7);
	f256_sub(t6, t6, t7);

	<comment type="block">/*
	 * We now have the alternate (doubling) coordinates in (t5,t6,t1).
	 * We combine them with (x3,y3,z3).
	 */</comment>
	for (i = 0; i &lt; 4; i ++) {
		P1-&gt;x[i] |= tt &amp; t5[i];
		P1-&gt;y[i] |= tt &amp; t6[i];
		P1-&gt;z[i] |= tt &amp; t1[i];
	}

	<comment type="block">/*
	 * If P1 = 0, then we get z3 = 0 (which is invalid); if z1 is 0,
	 * then we want to replace the result with a copy of P2. The
	 * test on z1 was done at the start, in the zz mask.
	 */</comment>
	for (i = 0; i &lt; 4; i ++) {
		P1-&gt;x[i] ^= zz &amp; (P1-&gt;x[i] ^ P2-&gt;x[i]);
		P1-&gt;y[i] ^= zz &amp; (P1-&gt;y[i] ^ P2-&gt;y[i]);
		P1-&gt;z[i] ^= zz &amp; (P1-&gt;z[i] ^ F256_R[i]);
	}
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Inner function for computing a point multiplication. A window is
 * provided, with points 1*P to 15*P in affine coordinates.
 *
 * Assumptions:
 *  - All provided points are valid points on the curve.
 *  - Multiplier is non-zero, and smaller than the curve order.
 *  - Everything is in Montgomery representation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>point_mul_inner</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>R</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>p256_affine</name> <modifier>*</modifier></type><name>W</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>Q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>qz</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qz</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>klen</name> <operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>bk</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>bk</name> <operator>=</operator> <operator>*</operator><name>k</name> <operator>++</operator></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>bits</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>bnz</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>p256_affine</name></type> <name>T</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>U</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>uint64_t</name></type> <name>m</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>bits</name> <operator>=</operator> <operator>(</operator><name>bk</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x0F</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>bnz</name> <operator>=</operator> <call><name>NEQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Lookup point in window. If the bits are 0,
			 * we get something invalid, which is not a
			 * problem because we will use it only if the
			 * bits are non-zero.
			 */</comment>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>T</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>T</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <literal type="number">15</literal></expr>;</condition> <incr><expr><name>n</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><call><name>EQ</name><argument_list>(<argument><expr><name>bits</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>x</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>T</name><operator>.</operator><name>y</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>W</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name><name>y</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><name>U</name> <operator>=</operator> <name>Q</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>p256_add_mixed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If qz is still 1, then Q was all-zeros, and this
			 * is conserved through p256_double().
			 */</comment>
			<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>uint64_t</name><operator>)</operator><operator>(</operator><name>bnz</name> <operator>&amp;</operator> <name>qz</name><operator>)</operator></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>j</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>T</name><operator>.</operator><name>x</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>y</name><index>[<expr><name>j</name></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>T</name><operator>.</operator><name>y</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>Q</name><operator>.</operator><name>z</name><index>[<expr><name>j</name></expr>]</index></name> <operator>|=</operator> <name>m</name> <operator>&amp;</operator> <name><name>F256_R</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>bnz</name> <operator>&amp;</operator> <operator>~</operator><name>qz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>U</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>qz</name> <operator>&amp;=</operator> <operator>~</operator><name>bnz</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bk</name> <operator>&lt;&lt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>R</name> <operator>=</operator> <name>Q</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a window from Jacobian to affine coordinates. A single
 * field inversion is used. This function works for windows up to
 * 32 elements.
 *
 * The destination array (aff[]) and the source array (jac[]) may
 * overlap, provided that the start of aff[] is not after the start of
 * jac[]. Even if the arrays do _not_ overlap, the source array is
 * modified.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>window_to_affine</name><parameter_list>(<parameter><decl><type><name>p256_affine</name> <modifier>*</modifier></type><name>aff</name></decl></parameter>, <parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>jac</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Convert the window points to affine coordinates. We use the
	 * following trick to mutualize the inversion computation: if
	 * we have z1, z2, z3, and z4, and want to inverse all of them,
	 * we compute u = 1/(z1*z2*z3*z4), and then we have:
	 *   1/z1 = u*z2*z3*z4
	 *   1/z2 = u*z1*z3*z4
	 *   1/z3 = u*z1*z2*z4
	 *   1/z4 = u*z1*z2*z3
	 *
	 * The partial products are computed recursively:
	 *
	 *  - on input (z_1,z_2), return (z_2,z_1) and z_1*z_2
	 *  - on input (z_1,z_2,... z_n):
	 *       recurse on (z_1,z_2,... z_(n/2)) -&gt; r1 and m1
	 *       recurse on (z_(n/2+1),z_(n/2+2)... z_n) -&gt; r2 and m2
	 *       multiply elements of r1 by m2 -&gt; s1
	 *       multiply elements of r2 by m1 -&gt; s2
	 *       return r1||r2 and m1*m2
	 *
	 * In the example below, we suppose that we have 14 elements.
	 * Let z1, z2,... zE be the 14 values to invert (index noted in
	 * hexadecimal, starting at 1).
	 *
	 *  - Depth 1:
	 *      swap(z1, z2); z12 = z1*z2
	 *      swap(z3, z4); z34 = z3*z4
	 *      swap(z5, z6); z56 = z5*z6
	 *      swap(z7, z8); z78 = z7*z8
	 *      swap(z9, zA); z9A = z9*zA
	 *      swap(zB, zC); zBC = zB*zC
	 *      swap(zD, zE); zDE = zD*zE
	 *
	 *  - Depth 2:
	 *      z1 &lt;- z1*z34, z2 &lt;- z2*z34, z3 &lt;- z3*z12, z4 &lt;- z4*z12
	 *      z1234 = z12*z34
	 *      z5 &lt;- z5*z78, z6 &lt;- z6*z78, z7 &lt;- z7*z56, z8 &lt;- z8*z56
	 *      z5678 = z56*z78
	 *      z9 &lt;- z9*zBC, zA &lt;- zA*zBC, zB &lt;- zB*z9A, zC &lt;- zC*z9A
	 *      z9ABC = z9A*zBC
	 *
	 *  - Depth 3:
	 *      z1 &lt;- z1*z5678, z2 &lt;- z2*z5678, z3 &lt;- z3*z5678, z4 &lt;- z4*z5678
	 *      z5 &lt;- z5*z1234, z6 &lt;- z6*z1234, z7 &lt;- z7*z1234, z8 &lt;- z8*z1234
	 *      z12345678 = z1234*z5678
	 *      z9 &lt;- z9*zDE, zA &lt;- zA*zDE, zB &lt;- zB*zDE, zC &lt;- zC*zDE
	 *      zD &lt;- zD*z9ABC, zE*z9ABC
	 *      z9ABCDE = z9ABC*zDE
	 *
	 *  - Depth 4:
	 *      multiply z1..z8 by z9ABCDE
	 *      multiply z9..zE by z12345678
	 *      final z = z12345678*z9ABCDE
	 */</comment>

	<decl_stmt><decl><type><name>uint64_t</name></type> <name><name>z</name><index>[<expr><literal type="number">16</literal></expr>]</index><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zt</name></cpp:macro>   <cpp:value>(z[15])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zu</name></cpp:macro>   <cpp:value>(z[14])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zv</name></cpp:macro>   <cpp:value>(z[13])</cpp:value></cpp:define>

	<comment type="block">/*
	 * First recursion step (pairwise swapping and multiplication).
	 * If there is an odd number of elements, then we "invent" an
	 * extra one with coordinate Z = 1 (in Montgomery representation).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>zt</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>zt</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>num</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>num</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>num</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>F256_R</name></expr></argument>, <argument><expr><sizeof>sizeof <name>F256_R</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Perform further recursion steps. At the entry of each step,
	 * the process has been done for groups of 's' points. The
	 * integer k is the log2 of s.
	 */</comment>
	<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>k</name> <operator>++</operator></expr><operator>,</operator> <expr><name>s</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <name>k</name><operator>)</operator> <operator>^</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>num</name> <operator>+</operator> <name>s</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;&gt;</operator> <name>k</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>z</name><index>[<expr><name>n</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <name>zt</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Invert the final result, and convert all points.
	 */</comment>
	<expr_stmt><expr><call><name>f256_invert</name><argument_list>(<argument><expr><name>zt</name></expr></argument>, <argument><expr><name><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>zv</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>z</name></expr></argument>, <argument><expr><name>zt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montysquare</name><argument_list>(<argument><expr><name>zu</name></expr></argument>, <argument><expr><name>zv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name>zv</name></expr></argument>, <argument><expr><name>zv</name></expr></argument>, <argument><expr><name>zu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>aff</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>x</name></expr></argument>, <argument><expr><name>zu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>f256_montymul</name><argument_list>(<argument><expr><name><name>aff</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name><name>jac</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>y</name></expr></argument>, <argument><expr><name>zv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Multiply the provided point by an integer.
 * Assumptions:
 *  - Source point is a valid curve point.
 *  - Source point is not the point-at-infinity.
 *  - Integer is not 0, and is lower than the curve order.
 * If these conditions are not met, then the result is indeterminate
 * (but the process is still constant-time).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>p256_mul</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<union>union <block>{
		<decl_stmt><decl><type><name>p256_affine</name></type> <name><name>aff</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>p256_jacobian</name></type> <name><name>jac</name><index>[<expr><literal type="number">15</literal></expr>]</index></name></decl>;</decl_stmt>
	}</block> <decl><name>window</name></decl>;</union>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Compute window, in Jacobian coordinates.
	 */</comment>
	<expr_stmt><expr><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>P</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>;</condition> <incr><expr><name>i</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><call><name>p256_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>window</name><operator>.</operator><name>jac</name><index>[<expr><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Convert the window points to affine coordinates. Point
	 * window[0] is the source point, already in affine coordinates.
	 */</comment>
	<expr_stmt><expr><call><name>window_to_affine</name><argument_list>(<argument><expr><name><name>window</name><operator>.</operator><name>aff</name></name></expr></argument>, <argument><expr><name><name>window</name><operator>.</operator><name>jac</name></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform point multiplication.
	 */</comment>
	<expr_stmt><expr><call><name>point_mul_inner</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name><name>window</name><operator>.</operator><name>aff</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Precomputed window for the conventional generator: P256_Gwin[n]
 * contains (n+1)*G (affine coordinates, in Montgomery representation).
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>p256_affine</name></type> <name><name>P256_Gwin</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x79E730D418A9143C</literal></expr>, <expr><literal type="number">0x75BA95FC5FEDB601</literal></expr>,
		  <expr><literal type="number">0x79FB732B77622510</literal></expr>, <expr><literal type="number">0x18905F76A53755C6</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xDDF25357CE95560A</literal></expr>, <expr><literal type="number">0x8B4AB8E4BA19E45C</literal></expr>,
		  <expr><literal type="number">0xD2E88688DD21F325</literal></expr>, <expr><literal type="number">0x8571FF1825885D85</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x850046D410DDD64D</literal></expr>, <expr><literal type="number">0xAA6AE3C1A433827D</literal></expr>,
		  <expr><literal type="number">0x732205038D1490D9</literal></expr>, <expr><literal type="number">0xF6BB32E43DCF3A3B</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x2F3648D361BEE1A5</literal></expr>, <expr><literal type="number">0x152CD7CBEB236FF8</literal></expr>,
		  <expr><literal type="number">0x19A8FB0E92042DBE</literal></expr>, <expr><literal type="number">0x78C577510A5B8A3B</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xFFAC3F904EEBC127</literal></expr>, <expr><literal type="number">0xB027F84A087D81FB</literal></expr>,
		  <expr><literal type="number">0x66AD77DD87CBBC98</literal></expr>, <expr><literal type="number">0x26936A3FB6FF747E</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xB04C5C1FC983A7EB</literal></expr>, <expr><literal type="number">0x583E47AD0861FE1A</literal></expr>,
		  <expr><literal type="number">0x788208311A2EE98E</literal></expr>, <expr><literal type="number">0xD5F06A29E587CC07</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x74B0B50D46918DCC</literal></expr>, <expr><literal type="number">0x4650A6EDC623C173</literal></expr>,
		  <expr><literal type="number">0x0CDAACACE8100AF2</literal></expr>, <expr><literal type="number">0x577362F541B0176B</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x2D96F24CE4CBABA6</literal></expr>, <expr><literal type="number">0x17628471FAD6F447</literal></expr>,
		  <expr><literal type="number">0x6B6C36DEE5DDD22E</literal></expr>, <expr><literal type="number">0x84B14C394C5AB863</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xBE1B8AAEC45C61F5</literal></expr>, <expr><literal type="number">0x90EC649A94B9537D</literal></expr>,
		  <expr><literal type="number">0x941CB5AAD076C20C</literal></expr>, <expr><literal type="number">0xC9079605890523C8</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xEB309B4AE7BA4F10</literal></expr>, <expr><literal type="number">0x73C568EFE5EB882B</literal></expr>,
		  <expr><literal type="number">0x3540A9877E7A1F68</literal></expr>, <expr><literal type="number">0x73A076BB2DD1E916</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x403947373E77664A</literal></expr>, <expr><literal type="number">0x55AE744F346CEE3E</literal></expr>,
		  <expr><literal type="number">0xD50A961A5B17A3AD</literal></expr>, <expr><literal type="number">0x13074B5954213673</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x93D36220D377E44B</literal></expr>, <expr><literal type="number">0x299C2B53ADFF14B5</literal></expr>,
		  <expr><literal type="number">0xF424D44CEF639F11</literal></expr>, <expr><literal type="number">0xA4C9916D4A07F75F</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x0746354EA0173B4F</literal></expr>, <expr><literal type="number">0x2BD20213D23C00F7</literal></expr>,
		  <expr><literal type="number">0xF43EAAB50C23BB08</literal></expr>, <expr><literal type="number">0x13BA5119C3123E03</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x2847D0303F5B9D4D</literal></expr>, <expr><literal type="number">0x6742F2F25DA67BDD</literal></expr>,
		  <expr><literal type="number">0xEF933BDC77C94195</literal></expr>, <expr><literal type="number">0xEAEDD9156E240867</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x27F14CD19499A78F</literal></expr>, <expr><literal type="number">0x462AB5C56F9B3455</literal></expr>,
		  <expr><literal type="number">0x8F90F02AF02CFC6B</literal></expr>, <expr><literal type="number">0xB763891EB265230D</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0xF59DA3A9532D4977</literal></expr>, <expr><literal type="number">0x21E3327DCF9EBA15</literal></expr>,
		  <expr><literal type="number">0x123C7B84BE60BBF0</literal></expr>, <expr><literal type="number">0x56EC12F27706DF76</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x75C96E8F264E20E8</literal></expr>, <expr><literal type="number">0xABE6BFED59A7A841</literal></expr>,
		  <expr><literal type="number">0x2CC09C0444C8EB00</literal></expr>, <expr><literal type="number">0xE05B3080F0C4E16B</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x1EB7777AA45F3314</literal></expr>, <expr><literal type="number">0x56AF7BEDCE5D45E3</literal></expr>,
		  <expr><literal type="number">0x2B6E019A88B12F1A</literal></expr>, <expr><literal type="number">0x086659CDFD835F9B</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x2C18DBD19DC21EC8</literal></expr>, <expr><literal type="number">0x98F9868A0FCF8139</literal></expr>,
		  <expr><literal type="number">0x737D2CD648250B49</literal></expr>, <expr><literal type="number">0xCC61C94724B3428F</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x0C2B407880DD9E76</literal></expr>, <expr><literal type="number">0xC43A8991383FBE08</literal></expr>,
		  <expr><literal type="number">0x5F7D2D65779BE5D2</literal></expr>, <expr><literal type="number">0x78719A54EB3B4AB5</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xEA7D260A6245E404</literal></expr>, <expr><literal type="number">0x9DE407956E7FDFE0</literal></expr>,
		  <expr><literal type="number">0x1FF3A4158DAC1AB5</literal></expr>, <expr><literal type="number">0x3E7090F1649C9073</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x1A7685612B944E88</literal></expr>, <expr><literal type="number">0x250F939EE57F61C8</literal></expr>,
		  <expr><literal type="number">0x0C0DAA891EAD643D</literal></expr>, <expr><literal type="number">0x68930023E125B88E</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x04B71AA7D2697768</literal></expr>, <expr><literal type="number">0xABDEDEF5CA345A33</literal></expr>,
		  <expr><literal type="number">0x2409D29DEE37385E</literal></expr>, <expr><literal type="number">0x4EE1DF77CB83E156</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x0CAC12D91CBB5B43</literal></expr>, <expr><literal type="number">0x170ED2F6CA895637</literal></expr>,
		  <expr><literal type="number">0x28228CFA8ADE6D66</literal></expr>, <expr><literal type="number">0x7FF57C9553238ACA</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xCCC425634B2ED709</literal></expr>, <expr><literal type="number">0x0E356769856FD30D</literal></expr>,
		  <expr><literal type="number">0xBCBCD43F559E9811</literal></expr>, <expr><literal type="number">0x738477AC5395B759</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x35752B90C00EE17F</literal></expr>, <expr><literal type="number">0x68748390742ED2E3</literal></expr>,
		  <expr><literal type="number">0x7CD06422BD1F5BC1</literal></expr>, <expr><literal type="number">0xFBC08769C9E7B797</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0xA242A35BB0CF664A</literal></expr>, <expr><literal type="number">0x126E48F77F9707E3</literal></expr>,
		  <expr><literal type="number">0x1717BF54C6832660</literal></expr>, <expr><literal type="number">0xFAAE7332FD12C72E</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x27B52DB7995D586B</literal></expr>, <expr><literal type="number">0xBE29569E832237C2</literal></expr>,
		  <expr><literal type="number">0xE8E4193E2A65E7DB</literal></expr>, <expr><literal type="number">0x152706DC2EAA1BBB</literal></expr> }</block></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{ <expr><literal type="number">0x72BCD8B7BC60055B</literal></expr>, <expr><literal type="number">0x03CC23EE56E27E4B</literal></expr>,
		  <expr><literal type="number">0xEE337424E4819370</literal></expr>, <expr><literal type="number">0xE2AA0E430AD3DA09</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">0x40B8524F6383C45D</literal></expr>, <expr><literal type="number">0xD766355442A41B25</literal></expr>,
		  <expr><literal type="number">0x64EFA6DE778A4797</literal></expr>, <expr><literal type="number">0x2042170A7079ADF4</literal></expr> }</block></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Multiply the conventional generator of the curve by the provided
 * integer. Return is written in *P.
 *
 * Assumptions:
 *  - Integer is not 0, and is lower than the curve order.
 * If this conditions is not met, then the result is indeterminate
 * (but the process is still constant-time).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>p256_mulgen</name><parameter_list>(<parameter><decl><type><name>p256_jacobian</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>point_mul_inner</name><argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>P256_Gwin</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return 1 if all of the following hold:
 *  - klen &lt;= 32
 *  - k != 0
 *  - k is lower than the curve order
 * Otherwise, return 0.
 *
 * Constant-time behaviour: only klen may be observable.
 */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>check_scalar</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>u</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>klen</name> <operator>&gt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>klen</name></expr>;</condition> <incr><expr><name>u</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>z</name> <operator>|=</operator> <name><name>k</name><index>[<expr><name>u</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>klen</name> <operator>==</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>u</name> <operator>&lt;</operator> <name>klen</name></expr>;</condition> <incr><expr><name>u</name> <operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>-</operator><operator>(</operator><name>int32_t</name><operator>)</operator><call><name>EQ0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>CMP</name><argument_list>(<argument><expr><name><name>k</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>P256_N</name><index>[<expr><name>u</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><call><name>NEQ</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;</operator> <call><name>LT0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_mul</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>G</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>Glen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>P</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Glen</name> <operator>!=</operator> <literal type="number">65</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>check_scalar</name><argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>G</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_encode</name><argument_list>(<argument><expr><name>G</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>api_mulgen</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>R</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>klen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>P</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_mulgen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_encode</name><argument_list>(<argument><expr><name>R</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">65</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type>
<name>api_muladd</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>A</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>B</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>x</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>xlen</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>curve</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We might want to use Shamir's trick here: make a composite
	 * window of u*P+v*Q points, to merge the two doubling-ladders
	 * into one. This, however, has some complications:
	 *
	 *  - During the computation, we may hit the point-at-infinity.
	 *    Thus, we would need p256_add_complete_mixed() (complete
	 *    formulas for point addition), with a higher cost (17 muls
	 *    instead of 11).
	 *
	 *  - A 4-bit window would be too large, since it would involve
	 *    16*16-1 = 255 points. For the same window size as in the
	 *    p256_mul() case, we would need to reduce the window size
	 *    to 2 bits, and thus perform twice as many non-doubling
	 *    point additions.
	 *
	 *  - The window may itself contain the point-at-infinity, and
	 *    thus cannot be in all generality be made of affine points.
	 *    Instead, we would need to make it a window of points in
	 *    Jacobian coordinates. Even p256_add_complete_mixed() would
	 *    be inappropriate.
	 *
	 * For these reasons, the code below performs two separate
	 * point multiplications, then computes the final point addition
	 * (which is both a "normal" addition, and a doubling, to handle
	 * all cases).
	 */</comment>

	<decl_stmt><decl><type><name>p256_jacobian</name></type> <name>P</name></decl>, <decl><type ref="prev"/><name>Q</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>t</name></decl>, <decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64_t</name></type> <name>z</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>curve</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">65</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>xlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>B</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>p256_mulgen</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <call><name>point_decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>p256_mul</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><name>y</name></expr></argument>, <argument><expr><name>ylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * The final addition may fail in case both points are equal.
	 */</comment>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>p256_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>f256_final_reduce</name><argument_list>(<argument><expr><name><name>P</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>z</name> <operator>=</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>|</operator> <name><name>P</name><operator>.</operator><name>z</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>EQ</name><argument_list>(<argument><expr><operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name>z</name> <operator>|</operator> <operator>(</operator><name>z</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>p256_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If s is 1 then either P+Q = 0 (t = 1) or P = Q (t = 0). So we
	 * have the following:
	 *
	 *   s = 0, t = 0   return P (normal addition)
	 *   s = 0, t = 1   return P (normal addition)
	 *   s = 1, t = 0   return Q (a 'double' case)
	 *   s = 1, t = 1   report an error (P+Q = 0)
	 */</comment>
	<expr_stmt><expr><call><name>CCOPY</name><argument_list>(<argument><expr><name>s</name> <operator>&amp;</operator> <operator>~</operator><name>t</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Q</name></expr></argument>, <argument><expr><sizeof>sizeof <name>Q</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>point_encode</name><argument_list>(<argument><expr><name>A</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>r</name> <operator>&amp;=</operator> <operator>~</operator><operator>(</operator><name>s</name> <operator>&amp;</operator> <name>t</name><operator>)</operator></expr>;</expr_stmt>
	<return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* see bearssl_ec.h */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>br_ec_impl</name></type> <name>br_ec_p256_m64</name> <init>= <expr><block>{
	<expr><operator>(</operator><name>uint32_t</name><operator>)</operator><literal type="number">0x00800000</literal></expr>,
	<expr><operator>&amp;</operator><name>api_generator</name></expr>,
	<expr><operator>&amp;</operator><name>api_order</name></expr>,
	<expr><operator>&amp;</operator><name>api_xoff</name></expr>,
	<expr><operator>&amp;</operator><name>api_mul</name></expr>,
	<expr><operator>&amp;</operator><name>api_mulgen</name></expr>,
	<expr><operator>&amp;</operator><name>api_muladd</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* see bearssl_ec.h */</comment>
<function><type><specifier>const</specifier> <name>br_ec_impl</name> <modifier>*</modifier></type>
<name>br_ec_p256_m64_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>br_ec_p256_m64</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<comment type="block">/* see bearssl_ec.h */</comment>
<function><type><specifier>const</specifier> <name>br_ec_impl</name> <modifier>*</modifier></type>
<name>br_ec_p256_m64_get</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
