<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/ejdb/extra/iowow/src/json/iwbinn.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;inttypes.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdint.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;memory.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iwbinn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"iwutils.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT64_FORMAT</name></cpp:macro>     <cpp:value>PRId64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UINT64_FORMAT</name></cpp:macro>    <cpp:value>PRIu64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT64_HEX_FORMAT</name></cpp:macro> <cpp:value>PRIx64</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UNUSED</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(void) (x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>round</name><parameter_list>(<parameter><type><name>dbl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>dbl &gt;= 0.0 ? (int) (dbl + 0.5) : ((dbl - (double) (int) dbl) &lt;= -0.5 ? (int) dbl : (int) (dbl - 0.5))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNK_SIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>             <comment type="line">// 1024</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINN_STRUCT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BINN_BUFFER</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<function_decl><type><name>void</name><modifier>*</modifier></type>(<modifier>*</modifier><name>malloc_fn</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <init>= <expr><name>malloc</name></expr></init>;</function_decl>
<function_decl><type><name>void</name><modifier>*</modifier></type> (<modifier>*</modifier><name>realloc_fn</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <init>= <expr><name>realloc</name></expr></init>;</function_decl>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>free_fn</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <init>= <expr><name>free</name></expr></init>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__BIG_ENDIAN</name></cpp:macro>    <cpp:value>0x1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__LITTLE_ENDIAN</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__BYTE_ORDER</name></cpp:macro>    <cpp:value>__LITTLE_ENDIAN</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__OpenBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__NetBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__DragonFly__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/endian.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__BIG_ENDIAN</name></cpp:macro>    <cpp:value>BIG_ENDIAN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__LITTLE_ENDIAN</name></cpp:macro> <cpp:value>LITTLE_ENDIAN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__BYTE_ORDER</name></cpp:macro>    <cpp:value>BYTE_ORDER</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/machine.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__BIG_ENDIAN</name></cpp:macro>    <cpp:value>BIG_ENDIAN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__LITTLE_ENDIAN</name></cpp:macro> <cpp:value>LITTLE_ENDIAN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__BYTE_ORDER</name></cpp:macro>    <cpp:value>BYTE_ORDER</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;endian.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__BYTE_ORDER</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"__BYTE_ORDER not defined"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__BIG_ENDIAN</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"__BIG_ENDIAN not defined"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__LITTLE_ENDIAN</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"__LITTLE_ENDIAN not defined"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BIG_ENDIAN</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> <cpp:literal>"__BIG_ENDIAN == __LITTLE_ENDIAN"</cpp:literal></cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__BIG_ENDIAN</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tobe16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tobe32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tobe64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tobe16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IW_SWAB16(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tobe32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IW_SWAB32(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tobe64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>IW_SWAB64(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>frombe16</name></cpp:macro> <cpp:value>tobe16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>frombe32</name></cpp:macro> <cpp:value>tobe32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>frombe64</name></cpp:macro> <cpp:value>tobe64</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>stricmp</name></cpp:macro>  <cpp:value>strcasecmp</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strnicmp</name></cpp:macro> <cpp:value>strncasecmp</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>binn_set_alloc_functions</name><parameter_list>(
  <parameter><function_decl><type><name>void</name><modifier>*</modifier></type>(<modifier>*</modifier><name>new_malloc</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><function_decl><type><name>void</name><modifier>*</modifier></type>(<modifier>*</modifier><name>new_realloc</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>,
  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>new_free</name>)<parameter_list>(<parameter><decl><type><name>void</name><modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>
  )</parameter_list> <block>{<block_content>
  <expr_stmt><expr><name>malloc_fn</name> <operator>=</operator> <name>new_malloc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>realloc_fn</name> <operator>=</operator> <name>new_realloc</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>free_fn</name> <operator>=</operator> <name>new_free</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>IW_INLINE</name> <name>void</name><modifier>*</modifier></type> <name>binn_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>malloc_fn</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>void</name><modifier>*</modifier></type> <name>binn_memdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>src</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>size_t</name></type> <name>strlen2</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_create_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>storage_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_type_index</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>data_type_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>storage_type</name> <operator>&lt;</operator> <name>BINN_STORAGE_MIN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>storage_type</name> <operator>&gt;</operator> <name>BINN_STORAGE_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>data_type_index</name> <operator>&lt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>storage_type</name> <operator>|</operator> <name>data_type_index</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>data_type_index</name> <operator>&lt;</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>storage_type</name> <operator>|=</operator> <name>BINN_STORAGE_HAS_MORE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>storage_type</name> <operator>&lt;&lt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>data_type_index</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <return>return <expr><name>storage_type</name> <operator>|</operator> <name>data_type_index</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_get_type_info</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>long_type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pstorage_type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pextra_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>, <decl><type ref="prev"/><name>extra_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<label><name>again</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>long_type</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_invalid</name>;</goto>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>long_type</name> <operator>&lt;=</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <name>long_type</name> <operator>&amp;</operator> <name>BINN_STORAGE_MASK</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra_type</name> <operator>=</operator> <name>long_type</name> <operator>&amp;</operator> <name>BINN_TYPE_MASK</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>long_type</name> <operator>&lt;=</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <name>long_type</name> <operator>&amp;</operator> <name>BINN_STORAGE_MASK16</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>storage_type</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra_type</name> <operator>=</operator> <name>long_type</name> <operator>&amp;</operator> <name>BINN_TYPE_MASK16</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra_type</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>long_type</name> <operator>&amp;</operator> <name>BINN_STORAGE_VIRTUAL</name></expr>)</condition> <block>{<block_content>
    <comment type="line">//storage_type = BINN_STORAGE_VIRTUAL;</comment>
    <comment type="line">//extra_type = xxx;</comment>
    <expr_stmt><expr><name>long_type</name> <operator>&amp;=</operator> <literal type="number">0xffff</literal></expr>;</expr_stmt>
    <goto>goto <name>again</name>;</goto>
  </block_content>}</block></if> <else>else <block>{<block_content>
<label><name>loc_invalid</name>:</label>
    <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>extra_type</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pstorage_type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pstorage_type</name> <operator>=</operator> <name>storage_type</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pextra_type</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pextra_type</name> <operator>=</operator> <name>extra_type</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_create</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_LIST</name></expr>:</case>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <break>break;</break>
    <default>default:</default>
      <goto>goto <name>loc_exit</name>;</goto>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>item</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_exit</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>MIN_BINN_SIZE</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pointer</name></expr>)</condition> <block>{<block_content>
      <goto>goto <name>loc_exit</name>;</goto>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>pointer</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pre_allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name> <operator>=</operator> <name>pointer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>alloc_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pre_allocated</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <name>CHUNK_SIZE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>pointer</name> <operator>=</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>pointer</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>INVALID_BINN</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name> <operator>=</operator> <name>pointer</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>alloc_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>BINN_MAGIC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>writable</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>=</operator> <name>MAX_BINN_HEADER</name></expr>;</expr_stmt>  <comment type="line">// save space for the header</comment>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>          <comment type="line">// the header is not written to the buffer</comment>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<label><name>loc_exit</name>:</label>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_new</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pointer</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_create</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>pointer</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_create_list</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_create</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>BINN_LIST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_create_map</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_create</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_create_object</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>object</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_create</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_new</name><argument_list>(<argument><expr><name>BINN_LIST</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_map</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_new</name><argument_list>(<argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_object</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_new</name><argument_list>(<argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_load</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>data</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>value</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>BINN_MAGIC</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_is_valid</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_open</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_load</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>int</name></type> <name>binn_get_ptr_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>unsigned</name></type> <name>type</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_MAGIC</name></expr>:</case>
      <return>return <expr><name>BINN_STRUCT</name></expr>;</return>
    <default>default:</default>
      <return>return <expr><name>BINN_BUFFER</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_is_struct</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator> <operator>==</operator> <name>BINN_MAGIC</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>int</name></type> <name>CalcAllocation</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>needed_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>alloc_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>calc_size</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>calc_size</name> <operator>=</operator> <name>alloc_size</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name>calc_size</name> <operator>&lt;</operator> <name>needed_size</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>calc_size</name> <operator>&lt;&lt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>  <comment type="line">// same as *= 2</comment>
    <comment type="line">//calc_size += CHUNK_SIZE;  -- this is slower than the above line, because there are more reallocations</comment>
  </block_content>}</block></while>
  <return>return <expr><name>calc_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>CheckAllocation</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>add_size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>alloc_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+</operator> <name>add_size</name> <operator>&gt;</operator> <name><name>item</name><operator>-&gt;</operator><name>alloc_size</name></name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>pre_allocated</name></name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>alloc_size</name> <operator>=</operator> <call><name>CalcAllocation</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+</operator> <name>add_size</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>alloc_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>realloc_fn</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr></argument>, <argument><expr><name>alloc_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>alloc_size</name></name> <operator>=</operator> <name>alloc_size</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__BIG_ENDIAN</name></expr></cpp:if>

<function><type><name>BINN_PRIVATE</name> <name>int</name></type> <name>get_storage_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>storage_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <return>return <expr><literal type="number">1</literal></expr>;</return>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <return>return <expr><literal type="number">2</literal></expr>;</return>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <return>return <expr><literal type="number">4</literal></expr>;</return>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <return>return <expr><literal type="number">8</literal></expr>;</return>
    <default>default:</default>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>BINN_PRIVATE</name> <name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>AdvanceDataPos</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>plimit</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>, <decl><type ref="prev"/><name>dsize</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <name>byte</name> <operator>&amp;</operator> <name>BINN_STORAGE_MASK</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>byte</name> <operator>&amp;</operator> <name>BINN_STORAGE_HAS_MORE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsize</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dsize</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal> <operator>+</operator> <name>dsize</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>dsize</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dsize</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsize</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dsize</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dsize</name> <operator>&amp;=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>dsize</name><operator>--</operator></expr>;</expr_stmt>  <comment type="line">// remove the type byte already added before</comment>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>dsize</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>dsize</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>dsize</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dsize</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>dsize</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>dsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>dsize</name> <operator>&amp;=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>dsize</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>  <comment type="line">// null terminator.</comment>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>SearchForID</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>header_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numitems</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>plimit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>int32</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>base</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plimit</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>header_size</name></expr>;</expr_stmt>

  <comment type="line">// search for the ID in all the arguments.</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Compare if the IDs are equal.</comment>
    <if_stmt><if>if <condition>(<expr><name>int32</name> <operator>==</operator> <name>id</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>p</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// xxx</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>base</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>unsigned</name> <name>char</name><modifier>*</modifier></type> <name>SearchForKey</name><parameter_list>(
  <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>header_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numitems</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
  <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>
  )</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>len</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plimit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>base</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plimit</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>header_size</name></expr>;</expr_stmt>

  <comment type="line">// search for the key in all the arguments.</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numitems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// Compare if the strings are equal.</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strnicmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>p</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>   <comment type="line">// note that there is no null terminator here</comment>
        <if_stmt><if>if <condition>(<expr><name>keylen</name> <operator>==</operator> <name>len</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
          <return>return <expr><name>p</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
        <break>break;</break>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <name>keylen</name></expr>)</condition> <block>{<block_content>   <comment type="line">// in the case of empty string: ""</comment>
      <return>return <expr><name>p</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="line">// xxx</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>base</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <break>break;</break>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>AddValue</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>binn_list_add_raw</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>item</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>BINN_LIST</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>writable</name></name> <operator>==</operator> <name>FALSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">//if (CheckAllocation(item, 4) == FALSE) return FALSE;  // 4 bytes used for data_store and data_format.</comment>
  <if_stmt><if>if <condition>(<expr><call><name>AddValue</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>binn_object_set_raw</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>int32</name> <init>= <expr><name>keylen</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(  <expr><operator>(</operator><name>key</name> <operator>==</operator> <name>NULL</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>item</name> <operator>==</operator> <name>NULL</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>BINN_OBJECT</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>writable</name></name> <operator>==</operator> <name>FALSE</name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name>keylen</name> <operator>&gt;</operator> <literal type="number">255</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// is the key already in it?</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SearchForKey</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr></argument>, <argument><expr><name>MAX_BINN_HEADER</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// start adding it</comment>
  <if_stmt><if>if <condition>(<expr><call><name>CheckAllocation</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">1</literal> <operator>+</operator> <name>int32</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>                                               <comment type="line">// bytes used for the key size and the key itself.</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name><operator>)</operator> <operator>+</operator> <name><name>item</name><operator>-&gt;</operator><name>used_size</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> <operator>=</operator> <name>int32</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>int32</name><operator>++</operator></expr>;</expr_stmt>  <comment type="line">// now contains the strlen + 1 byte for the len</comment>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <name>int32</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>AddValue</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>-=</operator> <name>int32</name></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>binn_map_set_raw</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>int32</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>item</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>BINN_MAP</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>writable</name></name> <operator>==</operator> <name>FALSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// is the ID already in it?</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SearchForID</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr></argument>, <argument><expr><name>MAX_BINN_HEADER</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>CheckAllocation</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>                                       <comment type="line">// 4 bytes used for the id.</comment>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name><operator>)</operator> <operator>+</operator> <name><name>item</name><operator>-&gt;</operator><name>used_size</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>AddValue</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>void</name><modifier>*</modifier></type> <name>compress_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pstorage_type</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>psource</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>, <decl><type ref="prev"/><name>storage_type2</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>type2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64</name></type> <name>vint</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64</name></type> <name>vuint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pvalue</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__BIG_ENDIAN</name></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name>size1</name></decl>, <decl><type ref="prev"/><name>size2</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <operator>*</operator><name>pstorage_type</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>storage_type</name> <operator>==</operator> <name>BINN_STORAGE_BYTE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>psource</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>type</name> <operator>=</operator> <operator>*</operator><name>ptype</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_INT64</name></expr>:</case>
      <expr_stmt><expr><name>vint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int64</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <goto>goto <name>loc_signed</name>;</goto>
    <case>case <expr><name>BINN_INT32</name></expr>:</case>
      <expr_stmt><expr><name>vint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <goto>goto <name>loc_signed</name>;</goto>
    <case>case <expr><name>BINN_INT16</name></expr>:</case>
      <expr_stmt><expr><name>vint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <goto>goto <name>loc_signed</name>;</goto>
    <case>case <expr><name>BINN_UINT64</name></expr>:</case>
      <expr_stmt><expr><name>vuint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <goto>goto <name>loc_positive</name>;</goto>
    <case>case <expr><name>BINN_UINT32</name></expr>:</case>
      <expr_stmt><expr><name>vuint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <goto>goto <name>loc_positive</name>;</goto>
    <case>case <expr><name>BINN_UINT16</name></expr>:</case>
      <expr_stmt><expr><name>vuint</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>short</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <goto>goto <name>loc_positive</name>;</goto>
  </block_content>}</block></switch>

<label><name>loc_signed</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>vint</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>vuint</name> <operator>=</operator> <name>vint</name></expr>;</expr_stmt>
    <goto>goto <name>loc_positive</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="line">//loc_negative:</comment>
  <if_stmt><if>if <condition>(<expr><name>vint</name> <operator>&gt;=</operator> <name>INT8_MIN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <name>BINN_INT8</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vint</name> <operator>&gt;=</operator> <name>INT16_MIN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <name>BINN_INT16</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vint</name> <operator>&gt;=</operator> <name>INT32_MIN</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <name>BINN_INT32</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <goto>goto <name>loc_exit</name>;</goto>

<label><name>loc_positive</name>:</label>
  <if_stmt><if>if <condition>(<expr><name>vuint</name> <operator>&lt;=</operator> <name>UINT8_MAX</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <name>BINN_UINT8</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vuint</name> <operator>&lt;=</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <name>BINN_UINT16</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vuint</name> <operator>&lt;=</operator> <name>UINT32_MAX</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>type2</name> <operator>=</operator> <name>BINN_UINT32</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

<label><name>loc_exit</name>:</label>
  <expr_stmt><expr><name>pvalue</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>type2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>type2</name> <operator>!=</operator> <name>type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name>type2</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>storage_type2</name> <operator>=</operator> <call><name>binn_get_write_storage</name><argument_list>(<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pstorage_type</name> <operator>=</operator> <name>storage_type2</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__BIG_ENDIAN</name></expr></cpp:if>
    <expr_stmt><expr><name>size1</name> <operator>=</operator> <call><name>get_storage_size</name><argument_list>(<argument><expr><name>storage_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>size2</name> <operator>=</operator> <call><name>get_storage_size</name><argument_list>(<argument><expr><name>storage_type2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>pvalue</name> <operator>+=</operator> <operator>(</operator><name>size1</name> <operator>-</operator> <name>size2</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>pvalue</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><name>BINN_PRIVATE</name> <name>int</name></type> <name>type_family</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>AddValue</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>argsz</name></decl>, <decl><type ref="prev"/><name>storage_type</name></decl>, <decl><type ref="prev"/><name>extra_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>su</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>lu</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>llu</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>binn_get_type_info</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>pvalue</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
        <break>break;</break>
      <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
      <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <break>break;</break>              <comment type="line">// the 2 above are allowed to have 0 length</comment>
        </block_content>}</block></if></if_stmt>
      <default>default:</default>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>pvalue</name> <operator>=</operator> <call><name>compress_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name>storage_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <comment type="line">//if (size == 0) ...</comment>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen2</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt> <comment type="line">// at least this size</comment>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>argsz</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>

  <expr_stmt><expr><name>argsz</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>  <comment type="line">// at least 2 bytes used for data_type.</comment>
  <if_stmt><if>if <condition>(<expr><call><name>CheckAllocation</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>argsz</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// Gets the pointer to the next place in buffer</comment>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name><operator>)</operator> <operator>+</operator> <name><name>item</name><operator>-&gt;</operator><name>used_size</name></name></expr>;</expr_stmt>

  <comment type="line">// If the data is not a container, store the data type</comment>
  <if_stmt><if>if <condition>(<expr><name>storage_type</name> <operator>!=</operator> <name>BINN_STORAGE_CONTAINER</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>type</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>tobe16</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// correct the endianess, if needed</comment>
      <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>ptr</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>*</operator><name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <comment type="line">// Nothing to do.</comment>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>p</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>pvalue</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <expr_stmt><expr><name>su</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint16_t</name><operator>*</operator><operator>)</operator> <name>pvalue</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>su</name> <operator>=</operator> <call><name>tobe16</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>su</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <expr_stmt><expr><name>lu</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint32_t</name><operator>*</operator><operator>)</operator> <name>pvalue</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>lu</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>lu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lu</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <comment type="line">// is there an htond or htonq to be used with qwords? (64 bits)</comment>
      <expr_stmt><expr><name>llu</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator> <name>pvalue</name><operator>)</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>llu</name> <operator>=</operator> <call><name>tobe64</name><argument_list>(<argument><expr><name>llu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>llu</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
      <expr_stmt><expr><name>lu</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lu</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">4</literal> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>lu</name> <operator>=</operator> <name>size</name> <operator>|</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>lu</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>lu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lu</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>p</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>size</name><operator>++</operator></expr>;</expr_stmt>  <comment type="line">// null terminator</comment>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_save_header</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>int32</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>BINN_DISABLE_SMALL_HEADER</name></cpp:ifndef>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name><operator>)</operator> <operator>+</operator> <name>MAX_BINN_HEADER</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>-</operator> <name>MAX_BINN_HEADER</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>  <comment type="line">// at least 3 bytes for the header</comment>

  <comment type="line">// write the count</comment>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>count</name></name> <operator>|</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="line">// write the size</comment>
  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">127</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <name>size</name> <operator>|</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>size</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <comment type="line">// write the type.</comment>
  <expr_stmt><expr><name>p</name><operator>--</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

  <comment type="line">// set the values</comment>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr>;</expr_stmt>

  <comment type="line">// write the type.</comment>
  <expr_stmt><expr><name>byte</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <comment type="line">// write the size</comment>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>|</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
  <comment type="line">// write the count</comment>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>count</name></name> <operator>|</operator> <literal type="number">0x80000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>tobe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>used_size</name></name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>binn_free</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>userdata_freefn</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name><name>item</name><operator>-&gt;</operator><name>userdata_freefn</name></name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>userdata_freefn</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>writable</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>item</name><operator>-&gt;</operator><name>pre_allocated</name></name> <operator>==</operator> <name>FALSE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>allocated</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>BINN_MAGIC</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="line">// free the binn structure but keeps the binn buffer allocated, returning a pointer to it. use the free function to</comment>
<comment type="line">// release the buffer later</comment>
<function><type><name>void</name><modifier>*</modifier></type> <name>binn_release</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>data</name> <operator>&gt;</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>allocated</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>BINN_MAGIC</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>IsValidBinnHeader</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pbuf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pcount</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pheadersize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plimit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>int32</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>count</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>pbuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>pbuf</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>psize</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>plimit</name> <operator>=</operator> <name>p</name> <operator>+</operator> <operator>*</operator><name>psize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// get the type</comment>
  <expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>byte</name> <operator>&amp;</operator> <name>BINN_STORAGE_MASK</name><operator>)</operator> <operator>!=</operator> <name>BINN_STORAGE_CONTAINER</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>byte</name> <operator>&amp;</operator> <name>BINN_STORAGE_HAS_MORE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>type</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_LIST</name></expr>:</case>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>

  <comment type="line">// get the size</comment>
  <if_stmt><if>if <condition>(<expr><name>plimit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>&gt;</operator> <name>plimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>int32</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>plimit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>plimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>&amp;=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <name>int32</name></expr>;</expr_stmt>

  <comment type="line">// get the count</comment>
  <if_stmt><if>if <condition>(<expr><name>plimit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>&gt;</operator> <name>plimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>int32</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>int32</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>plimit</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>plimit</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>int32</name> <operator>&amp;=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name>count</name> <operator>=</operator> <name>int32</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <name>MIN_BINN_SIZE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// return the values</comment>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pcount</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pcount</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>psize</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pheadersize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pheadersize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>p</name> <operator>-</operator> <operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>pbuf</name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_copy</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>old_ptr</name> <init>= <expr><call><name>binn_ptr</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>old_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>binn_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>header_size</name> <operator>+</operator> <name>MAX_BINN_HEADER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name><name>item</name><operator>-&gt;</operator><name>pbuf</name></name><operator>)</operator> <operator>+</operator> <name>MAX_BINN_HEADER</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>old_ptr</name> <operator>+</operator> <name>header_size</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>header_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>used_size</name></name> <operator>=</operator> <name>MAX_BINN_HEADER</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name>header_size</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_is_valid_header</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pbuf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pcount</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pheadersize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pcount</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>, <argument><expr><name>pheadersize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_buf_type</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pbuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>INVALID_BINN</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>type</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_buf_count</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pbuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>nitems</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>nitems</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_buf_size</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pbuf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_ptr</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>binn_get_ptr_type</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STRUCT</name></expr>:</case>
      <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>writable</name></name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>binn_save_header</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
    <case>case <expr><name>BINN_BUFFER</name></expr>:</case>
      <return>return <expr><name>ptr</name></expr>;</return>
    <default>default:</default>
      <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>binn_get_ptr_type</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STRUCT</name></expr>:</case>
      <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>writable</name></name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>binn_save_header</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>
    <case>case <expr><name>BINN_BUFFER</name></expr>:</case>
      <return>return <expr><call><name>binn_buf_size</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>binn_get_ptr_type</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STRUCT</name></expr>:</case>
      <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
      <return>return <expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>;</return>
    <case>case <expr><name>BINN_BUFFER</name></expr>:</case>
      <return>return <expr><call><name>binn_buf_type</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_count</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><call><name>binn_get_ptr_type</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STRUCT</name></expr>:</case>
      <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
      <return>return <expr><name><name>item</name><operator>-&gt;</operator><name>count</name></name></expr>;</return>
    <case>case <expr><name>BINN_BUFFER</name></expr>:</case>
      <return>return <expr><call><name>binn_buf_count</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_is_valid_ex</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pcount</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plimit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pbuf</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>pbuf</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>pbuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// is there an informed size?</comment>
  <if_stmt><if>if <condition>(<expr><name>psize</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>psize</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <operator>*</operator><name>psize</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// is there an informed size?</comment>
  <if_stmt><if>if <condition>(<expr><name>psize</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>psize</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="line">// is it the same as the one in the buffer?</comment>
    <if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <operator>*</operator><name>psize</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// is there an informed count?</comment>
  <if_stmt><if>if <condition>(<expr><name>pcount</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pcount</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="line">// is it the same as the one in the buffer?</comment>
    <if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <operator>*</operator><name>pcount</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// is there an informed type?</comment>
  <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>ptype</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <comment type="line">// is it the same as the one in the buffer?</comment>
    <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <operator>*</operator><name>ptype</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></if></if_stmt>
  <comment type="line">// it could compare the content size with the size informed on the header</comment>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>pbuf</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plimit</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>header_size</name></expr>;</expr_stmt>

  <comment type="line">// process all the arguments.</comment>
  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
        <comment type="line">// gets the string size (argument name)</comment>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <comment type="line">//if (len == 0) goto Invalid;</comment>
        <comment type="line">// increment the used space</comment>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>BINN_MAP</name></expr>:</case>
        <comment type="line">// increment the used space</comment>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <break>break;</break>
        <comment type="line">//case BINN_LIST:</comment>
        <comment type="line">//  break;</comment>
    </block_content>}</block></switch>
    <comment type="line">// xxx</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>base</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <goto>goto <name>Invalid</name>;</goto>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>ptype</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>ptype</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pcount</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>pcount</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pcount</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>psize</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>

<label><name>Invalid</name>:</label>
  <return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_is_valid</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pcount</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pcount</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>binn_is_valid_ex</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>pcount</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** INTERNAL FUNCTIONS ****************************************************/</comment>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>GetValue</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>byte</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>data_type</name></decl>, <decl><type ref="prev"/><name>storage_type</name></decl>;</decl_stmt>  <comment type="line">//, extra_type;</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>datasz</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>BINN_MAGIC</name></expr>;</expr_stmt>

  <comment type="line">// saves for use with BINN_STORAGE_CONTAINER</comment>
  <expr_stmt><expr><name>p2</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <comment type="line">// read the data type</comment>
  <expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <name>byte</name> <operator>&amp;</operator> <name>BINN_STORAGE_MASK</name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>byte</name> <operator>&amp;</operator> <name>BINN_STORAGE_HAS_MORE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>data_type</name> <operator>=</operator> <name>byte</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>byte</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>data_type</name> <operator>|=</operator> <name>byte</name></expr>;</expr_stmt>
    <comment type="line">//extra_type = data_type &amp; BINN_TYPE_MASK16;</comment>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>data_type</name> <operator>=</operator> <name>byte</name></expr>;</expr_stmt>
    <comment type="line">//extra_type = byte &amp; BINN_TYPE_MASK;</comment>
  </block_content>}</block></else></if_stmt>

  <comment type="line">//value-&gt;storage_type = storage_type;</comment>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>data_type</name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vuint8</name></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>   <comment type="line">//value-&gt;ptr = &amp;value-&gt;vuint8;</comment>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vint16</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vint16</name></name> <operator>=</operator> <call><name>frombe16</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vint16</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vint16</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vint32</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vint32</name></name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vint32</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vint32</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vint64</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vint64</name></name> <operator>=</operator> <call><name>frombe64</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vint64</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vint64</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>p2</name></expr>;</expr_stmt>  <comment type="line">// &lt;-- it returns the pointer to the container, not the data</comment>
      <if_stmt><if>if <condition>(<expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
      <expr_stmt><expr><name>datasz</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>datasz</name> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datasz</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>datasz</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>datasz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>datasz</name> <operator>&amp;=</operator> <literal type="number">0x7FFFFFFF</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>datasz</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>

  <comment type="line">// convert the returned value, if needed</comment>
  <switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_TRUE</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_BOOL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vbool</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_FALSE</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_BOOL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vbool</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>;</expr_stmt>
      <break>break;</break>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BINN_EXTENDED</name></cpp:ifdef>
    <case>case <expr><name>BINN_SINGLE_STR</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_SINGLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <call><name>atof</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// converts from string to double, and then to float</comment>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_DOUBLE_STR</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_DOUBLE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name> <operator>=</operator> <call><name>atof</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// converts from string to double</comment>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      <comment type="block">/*
         case BINN_DECIMAL:
         case BINN_CURRENCYSTR:
         case BINN_DATE:
         case BINN_DATETIME:
         case BINN_TIME:
       */</comment>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>

<comment type="line">// on little-endian devices we store the value so we can return a pointer to integers.</comment>
<comment type="line">// it's valid only for single-threaded apps. multi-threaded apps must use the _get_ functions instead.</comment>

<decl_stmt><decl><type><name>binn</name></type> <name>local_value</name></decl>;</decl_stmt>

<function><type><name>BINN_PRIVATE</name> <name>void</name><modifier>*</modifier></type> <name>store_value</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>local_value</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><call><name>binn_get_read_storage</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
    <comment type="line">// return a valid pointer</comment>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <return>return <expr><operator>&amp;</operator><name><name>local_value</name><operator>.</operator><name>vint32</name></name></expr>;</return>  <comment type="line">// returns the pointer to the converted value, from big-endian to little-endian</comment>
  </block_content>}</block></switch>
  <return>return <expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>   <comment type="line">// returns from the on stack value to be thread-safe (for list, map, object, string and blob)</comment>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*** READ FUNCTIONS ********************************************************/</comment>

<function><type><name>BOOL</name></type> <name>binn_object_get_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>key</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// check the header</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>BINN_OBJECT</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SearchForKey</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>header_size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_get_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// check the header</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>BINN_MAP</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SearchForID</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>header_size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_list_get_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plimit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>value</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <comment type="line">// check the header</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>BINN_LIST</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pos</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>pos</name> <operator>&gt;</operator> <name>count</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>pos</name><operator>--</operator></expr>;</expr_stmt>  <comment type="line">// convert from base 1 to base 0</comment>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plimit</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>header_size</name></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pos</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>base</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** READ PAIR BY POSITION *************************************************/</comment>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>binn_read_pair</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>expected_type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>int32</name></decl>, <decl><type ref="prev"/><name>id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>counter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>plimit</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>base</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// check the header</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>type</name> <operator>!=</operator> <name>expected_type</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>count</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pos</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pos</name> <operator>&gt;</operator> <name>count</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>base</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>plimit</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>header_size</name></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BINN_MAP</name></expr>:</case>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>id</name> <operator>=</operator> <name>int32</name></expr>;</expr_stmt>
        <break>break;</break>
      <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>key</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>plimit</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>FALSE</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <break>break;</break>
    </block_content>}</block></switch>
    <expr_stmt><expr><name>counter</name><operator>++</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>counter</name> <operator>==</operator> <name>pos</name></expr>)</condition> <block>{<block_content>
      <goto>goto <name>found</name>;</goto>
    </block_content>}</block></if></if_stmt>
    <comment type="line">//</comment>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>plimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>p</name> <operator>&lt;</operator> <name>base</name><operator>)</operator></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>FALSE</name></expr>;</return>

<label><name>found</name>:</label>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>pid</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pid</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>pkey</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pkey</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_get_pair</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_read_pair</name><argument_list>(<argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_get_pair</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_read_pair</name><argument_list>(<argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_map_pair</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_read_pair</name><argument_list>(<argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><name>map</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_object_pair</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_read_pair</name><argument_list>(<argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_read_pair</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>binn_map_get_pair</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_read_pair</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>binn_object_get_pair</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** SEQUENTIAL READ FUNCTIONS *********************************************/</comment>

<function><type><name>BOOL</name></type> <name>binn_iter_init</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expected_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>, <decl><type ref="prev"/><name>count</name></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>header_size</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>binn_ptr</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>iter</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn_iter</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="line">// check the header</comment>
  <if_stmt><if>if <condition>(<expr><call><name>IsValidBinnHeader</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>expected_type</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <comment type="line">//if (count == 0) return FALSE;  -- should not be used</comment>

  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>size</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>header_size</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_list_next</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>pnow</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(  <expr><operator>(</operator><name>iter</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>BINN_LIST</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>pnow</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>pnow</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>&lt;</operator> <name>pnow</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>pnow</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>binn_read_next_pair</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>expected_type</name></decl></parameter>, <parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>int32</name></decl>, <decl><type ref="prev"/><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>len</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(  <expr><operator>(</operator><name>iter</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>expected_type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>expected_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <name>int32</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>pid</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pid</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>key</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>pkey</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>pkey</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>&lt;</operator> <name>p</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_read_next_pair2</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>expected_type</name></decl></parameter>, <parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>klidx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>int32</name></decl>, <decl><type ref="prev"/><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>len</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(  <expr><operator>(</operator><name>iter</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name><operator>)</operator>
     <operator>||</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>expected_type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>count</name></name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pkey</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>pkey</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>expected_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>int32</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
      <expr_stmt><expr><name>int32</name> <operator>=</operator> <call><name>frombe32</name><argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name>id</name> <operator>=</operator> <name>int32</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>klidx</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>klidx</name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <expr_stmt><expr><name>len</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>key</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>klidx</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>klidx</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>pkey</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pkey</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>key</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <expr_stmt><expr><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>=</operator> <call><name>AdvanceDataPos</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>iter</name><operator>-&gt;</operator><name>plimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>iter</name><operator>-&gt;</operator><name>pnext</name></name> <operator>&lt;</operator> <name>p</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>GetValue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_next</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_read_next_pair</name><argument_list>(<argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><name>iter</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_next</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_read_next_pair</name><argument_list>(<argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><name>iter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_next2</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>klen</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_read_next_pair2</name><argument_list>(<argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><name>iter</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_list_next_value</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_list_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_map_next_value</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_map_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_object_next_value</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_object_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_list_read_next</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_list_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_read_next</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_map_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_read_next</name><parameter_list>(<parameter><decl><type><name>binn_iter</name> <modifier>*</modifier></type><name>iter</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pkey</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>binn_object_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr><name>pkey</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****** EXTENDED INTERFACE ***********************************************************/</comment>
<comment type="block" format="doxygen">/****** none of the functions above call the functions below *************************/</comment>

<function><type><name>int</name></type> <name>binn_get_write_storage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_SINGLE_STR</name></expr>:</case>
    <case>case <expr><name>BINN_DOUBLE_STR</name></expr>:</case>
      <return>return <expr><name>BINN_STORAGE_STRING</name></expr>;</return>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <return>return <expr><name>BINN_STORAGE_NOBYTES</name></expr>;</return>
    <default>default:</default>
      <expr_stmt><expr><call><name>binn_get_type_info</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>storage_type</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_get_read_storage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BINN_EXTENDED</name></cpp:ifdef>
    <case>case <expr><name>BINN_SINGLE_STR</name></expr>:</case>
      <return>return <expr><name>BINN_STORAGE_DWORD</name></expr>;</return>
    <case>case <expr><name>BINN_DOUBLE_STR</name></expr>:</case>
      <return>return <expr><name>BINN_STORAGE_QWORD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
    <case>case <expr><name>BINN_TRUE</name></expr>:</case>
    <case>case <expr><name>BINN_FALSE</name></expr>:</case>
      <return>return <expr><name>BINN_STORAGE_DWORD</name></expr>;</return>
    <default>default:</default>
      <expr_stmt><expr><call><name>binn_get_type_info</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>storage_type</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>GetWriteConvertedData</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ppvalue</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>f1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>d1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>pstr</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>UNUSED</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>type</name> <operator>=</operator> <operator>*</operator><name>ptype</name></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>ppvalue</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BINN_NULL</name></expr>:</case>
      <case>case <expr><name>BINN_TRUE</name></expr>:</case>
      <case>case <expr><name>BINN_FALSE</name></expr>:</case>
        <break>break;</break>
      <case>case <expr><name>BINN_STRING</name></expr>:</case>
      <case>case <expr><name>BINN_BLOB</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>psize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      <default>default:</default>
        <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BINN_EXTENDED</name></cpp:ifdef>
    <case>case <expr><name>BINN_SINGLE</name></expr>:</case>
      <expr_stmt><expr><name>f1</name> <operator>=</operator> <operator>*</operator><operator>*</operator><operator>(</operator><name>float</name><operator>*</operator><operator>*</operator><operator>)</operator> <name>ppvalue</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>d1</name> <operator>=</operator> <name>f1</name></expr>;</expr_stmt>  <comment type="line">// convert from float (32bits) to double (64bits)</comment>
      <expr_stmt><expr><name>type</name> <operator>=</operator> <name>BINN_SINGLE_STR</name></expr>;</expr_stmt>
      <goto>goto <name>conv_double</name>;</goto>
    <case>case <expr><name>BINN_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><name>d1</name> <operator>=</operator> <operator>*</operator><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>*</operator><operator>)</operator> <name>ppvalue</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>type</name> <operator>=</operator> <name>BINN_DOUBLE_STR</name></expr>;</expr_stmt>
<label><name>conv_double</name>:</label>
      <comment type="line">// the '%.17e' is more precise than the '%g'</comment>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>pstr</name></expr></argument>, <argument><expr><literal type="number">127</literal></expr></argument>, <argument><expr><literal type="string">"%.17e"</literal></expr></argument>, <argument><expr><name>d1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ppvalue</name> <operator>=</operator> <name>pstr</name></expr>;</expr_stmt>
      <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
      <break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <case>case <expr><name>BINN_DECIMAL</name></expr>:</case>
    <case>case <expr><name>BINN_CURRENCYSTR</name></expr>:</case>
    <case>case <expr><name>BINN_DATE</name></expr>:</case>
    <case>case <expr><name>BINN_DATETIME</name></expr>:</case>
    <case>case <expr><name>BINN_TIME</name></expr>:</case>
      <return>return <expr><name>TRUE</name></expr>;</return>
      <break>break;</break>

    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>BOOL</name><operator>*</operator><operator>*</operator><operator>)</operator> <name>ppvalue</name><operator>)</operator> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name>BINN_FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>type</name> <operator>=</operator> <name>BINN_TRUE</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>int</name></type> <name>type_family</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_LIST</name></expr>:</case>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_BINN</name></expr>;</return>

    <case>case <expr><name>BINN_INT8</name></expr>:</case>
    <case>case <expr><name>BINN_INT16</name></expr>:</case>
    <case>case <expr><name>BINN_INT32</name></expr>:</case>
    <case>case <expr><name>BINN_INT64</name></expr>:</case>
    <case>case <expr><name>BINN_UINT8</name></expr>:</case>
    <case>case <expr><name>BINN_UINT16</name></expr>:</case>
    <case>case <expr><name>BINN_UINT32</name></expr>:</case>
    <case>case <expr><name>BINN_UINT64</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_INT</name></expr>;</return>

    <case>case <expr><name>BINN_FLOAT32</name></expr>:</case>
    <case>case <expr><name>BINN_FLOAT64</name></expr>:</case>
    <comment type="line">//case BINN_SINGLE:</comment>
    <case>case <expr><name>BINN_SINGLE_STR</name></expr>:</case>
    <comment type="line">//case BINN_DOUBLE:</comment>
    <case>case <expr><name>BINN_DOUBLE_STR</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_FLOAT</name></expr>;</return>

    <case>case <expr><name>BINN_STRING</name></expr>:</case>
    <case>case <expr><name>BINN_HTML</name></expr>:</case>
    <case>case <expr><name>BINN_CSS</name></expr>:</case>
    <case>case <expr><name>BINN_XML</name></expr>:</case>
    <case>case <expr><name>BINN_JSON</name></expr>:</case>
    <case>case <expr><name>BINN_JAVASCRIPT</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_STRING</name></expr>;</return>

    <case>case <expr><name>BINN_BLOB</name></expr>:</case>
    <case>case <expr><name>BINN_JPEG</name></expr>:</case>
    <case>case <expr><name>BINN_GIF</name></expr>:</case>
    <case>case <expr><name>BINN_PNG</name></expr>:</case>
    <case>case <expr><name>BINN_BMP</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_BLOB</name></expr>;</return>

    <case>case <expr><name>BINN_DECIMAL</name></expr>:</case>
    <case>case <expr><name>BINN_CURRENCY</name></expr>:</case>
    <case>case <expr><name>BINN_DATE</name></expr>:</case>
    <case>case <expr><name>BINN_TIME</name></expr>:</case>
    <case>case <expr><name>BINN_DATETIME</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_STRING</name></expr>;</return>

    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_BOOL</name></expr>;</return>

    <case>case <expr><name>BINN_NULL</name></expr>:</case>
      <return>return <expr><name>BINN_FAMILY_NULL</name></expr>;</return>

    <default>default:</default>
      <comment type="line">// if it wasn't found</comment>
      <return>return <expr><name>BINN_FAMILY_NONE</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>int</name></type> <name>int_type</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_INT8</name></expr>:</case>
    <case>case <expr><name>BINN_INT16</name></expr>:</case>
    <case>case <expr><name>BINN_INT32</name></expr>:</case>
    <case>case <expr><name>BINN_INT64</name></expr>:</case>
      <return>return <expr><name>BINN_SIGNED_INT</name></expr>;</return>
    <case>case <expr><name>BINN_UINT8</name></expr>:</case>
    <case>case <expr><name>BINN_UINT16</name></expr>:</case>
    <case>case <expr><name>BINN_UINT32</name></expr>:</case>
    <case>case <expr><name>BINN_UINT64</name></expr>:</case>
      <return>return <expr><name>BINN_UNSIGNED_INT</name></expr>;</return>
    <default>default:</default>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>copy_raw_value</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>psource</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_store</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>data_store</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>pdest</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator> <name>pdest</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>short</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator> <name>pdest</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>int</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>uint64</name><operator>*</operator><operator>)</operator> <name>pdest</name><operator>)</operator> <operator>=</operator> <operator>*</operator><operator>(</operator><specifier>const</specifier> <name>uint64</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
    <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
    <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>*</operator><operator>)</operator> <name>pdest</name><operator>)</operator> <operator>=</operator> <operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>copy_int_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>psource</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64</name></type> <name>vuint64</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64</name></type> <name>vf64</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <switch>switch <condition>(<expr><name>source_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_INT8</name></expr>:</case>
      <expr_stmt><expr><name>vf64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>signed</name> <name>char</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_INT16</name></expr>:</case>
      <expr_stmt><expr><name>vf64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_INT32</name></expr>:</case>
      <expr_stmt><expr><name>vf64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_INT64</name></expr>:</case>
      <expr_stmt><expr><name>vf64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int64</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT8</name></expr>:</case>
      <expr_stmt><expr><name>vuint64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT16</name></expr>:</case>
      <expr_stmt><expr><name>vuint64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>short</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT32</name></expr>:</case>
      <expr_stmt><expr><name>vuint64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT64</name></expr>:</case>
      <expr_stmt><expr><name>vuint64</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>uint64</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <comment type="line">// copy from int64 to uint64, if possible</comment>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>int_type</name><argument_list>(<argument><expr><name>source_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_UNSIGNED_INT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>int_type</name><argument_list>(<argument><expr><name>dest_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_SIGNED_INT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>vuint64</name> <operator>&gt;</operator> <name>INT64_MAX</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>vf64</name> <operator>=</operator> <name>vuint64</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>int_type</name><argument_list>(<argument><expr><name>source_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_SIGNED_INT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>int_type</name><argument_list>(<argument><expr><name>dest_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_UNSIGNED_INT</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>vf64</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>vuint64</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>vf64</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name>dest_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_INT8</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>vf64</name> <operator>&lt;</operator> <name>INT8_MIN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>vf64</name> <operator>&gt;</operator> <name>INT8_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>signed</name> <name>char</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>signed</name> <name>char</name><operator>)</operator> <name>vf64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_INT16</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>vf64</name> <operator>&lt;</operator> <name>INT16_MIN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>vf64</name> <operator>&gt;</operator> <name>INT16_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>short</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>short</name><operator>)</operator> <name>vf64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_INT32</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><operator>(</operator><name>vf64</name> <operator>&lt;</operator> <name>INT32_MIN</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>vf64</name> <operator>&gt;</operator> <name>INT32_MAX</name><operator>)</operator></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>vf64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_INT64</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>int64</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <name>vf64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT8</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>vuint64</name> <operator>&gt;</operator> <name>UINT8_MAX</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>char</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>vuint64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT16</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>vuint64</name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>short</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>vuint64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT32</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name>vuint64</name> <operator>&gt;</operator> <name>UINT32_MAX</name></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>unsigned</name> <name>int</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>vuint64</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_UINT64</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint64</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <name>vuint64</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>IW_TESTS</name></cpp:ifdef>

<function><type><name>BOOL</name></type> <name>copy_int_value_tests</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>psource</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name>psource</name></expr></argument>, <argument><expr><name>pdest</name></expr></argument>, <argument><expr><name>source_type</name></expr></argument>, <argument><expr><name>dest_type</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>copy_float_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>psource</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>source_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_FLOAT32</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_FLOAT64</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>float</name><operator>*</operator><operator>)</operator> <name>pdest</name> <operator>=</operator> <operator>(</operator><name>float</name><operator>)</operator> <operator>*</operator><operator>(</operator><name>double</name><operator>*</operator><operator>)</operator> <name>psource</name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>void</name></type> <name>zero_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><call><name>binn_get_read_storage</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BYTE</name></expr>:</case>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_WORD</name></expr>:</case>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_DWORD</name></expr>:</case>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_QWORD</name></expr>:</case>
      <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
    <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
    <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><operator>(</operator><name>char</name><operator>*</operator><operator>*</operator><operator>)</operator> <name>pvalue</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>copy_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>psource</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pdest</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>source_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_store</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name>source_type</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>type_family</name><argument_list>(<argument><expr><name>dest_type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>type_family</name><argument_list>(<argument><expr><name>source_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>source_type</name> <operator>!=</operator> <name>dest_type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name>psource</name></expr></argument>, <argument><expr><name>pdest</name></expr></argument>, <argument><expr><name>source_type</name></expr></argument>, <argument><expr><name>dest_type</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>type_family</name><argument_list>(<argument><expr><name>source_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_FLOAT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>source_type</name> <operator>!=</operator> <name>dest_type</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>copy_float_value</name><argument_list>(<argument><expr><name>psource</name></expr></argument>, <argument><expr><name>pdest</name></expr></argument>, <argument><expr><name>source_type</name></expr></argument>, <argument><expr><name>dest_type</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><call><name>copy_raw_value</name><argument_list>(<argument><expr><name>psource</name></expr></argument>, <argument><expr><name>pdest</name></expr></argument>, <argument><expr><name>data_store</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** WRITE FUNCTIONS *****************************************************************/</comment>

<function><type><name>BOOL</name></type> <name>binn_list_add</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>GetWriteConvertedData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>binn_list_add_raw</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_set</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>GetWriteConvertedData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>binn_map_set_raw</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_set</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>GetWriteConvertedData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>binn_object_set_raw</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_set2</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><call><name>GetWriteConvertedData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pvalue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><call><name>binn_object_set_raw</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// this function is used by the wrappers</comment>
<function><type><name>BOOL</name></type> <name>binn_add_value</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>binn_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>binn_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_LIST</name></expr>:</case>
      <return>return <expr><call><name>binn_list_add</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
      <return>return <expr><call><name>binn_map_set</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <return>return <expr><call><name>binn_object_set</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_list_add_new</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>binn_list_add_value</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>binn_free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_set_new</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>binn_map_set_value</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>binn_free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_set_new</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>binn_object_set_value</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>binn_free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_set_new2</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keylen</name></decl></parameter>, <parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>binn_object_set_value2</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>binn_free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** READ FUNCTIONS ******************************************************************/</comment>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_list_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_list_get_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_map_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_map_get_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_object_value</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_object_get_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_list_read</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_list_get_value</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_read</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_map_get_value</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_read</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ptype</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_object_get_value</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>ptype</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>ptype</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>type</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__BYTE_ORDER</name> <operator>==</operator> <name>__LITTLE_ENDIAN</name></expr></cpp:if>
  <return>return <expr><call><name>store_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_list_get</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <call><name>binn_get_read_storage</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>storage_type</name> <operator>!=</operator> <name>BINN_STORAGE_NOBYTES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pvalue</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>zero_value</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_list_get_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>copy_value</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>storage_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_get</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <call><name>binn_get_read_storage</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>storage_type</name> <operator>!=</operator> <name>BINN_STORAGE_NOBYTES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pvalue</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>zero_value</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_map_get_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>copy_value</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>storage_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_get</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name></type> <name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>storage_type</name> <operator>=</operator> <call><name>binn_get_read_storage</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>storage_type</name> <operator>!=</operator> <name>BINN_STORAGE_NOBYTES</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pvalue</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>zero_value</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>binn_object_get_value</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>copy_value</name><argument_list>(<argument><expr><name><name>value</name><operator>.</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name><name>value</name><operator>.</operator><name>type</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>storage_type</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>psize</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>psize</name> <operator>=</operator> <name><name>value</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="line">// these functions below may not be implemented as inline functions, because</comment>
<comment type="line">// they use a lot of space, even for the variable. so they will be exported.</comment>

<comment type="line">// but what about using as static?</comment>
<comment type="line">//    is there any problem with wrappers? can these wrappers implement these functions using the header?</comment>
<comment type="line">//    if as static, will they be present even on modules that don't use the functions?</comment>

<function><type><name>signed</name> <name>char</name></type> <name>binn_list_int8</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_INT8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>short</name></type> <name>binn_list_int16</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>short</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_INT16</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_list_int32</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_INT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type> <name>binn_list_int64</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name></type> <name>binn_list_uint8</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_UINT8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>short</name></type> <name>binn_list_uint16</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_UINT16</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name>binn_list_uint32</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_UINT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type> <name>binn_list_uint64</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_UINT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>float</name></type> <name>binn_list_float</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_FLOAT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type> <name>binn_list_double</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_FLOAT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_list_bool</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_BOOL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_list_null</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>binn_list_str</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_STRING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_list_blob</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_list_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_LIST</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_list_map</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_list_object</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_list_get</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>signed</name> <name>char</name></type> <name>binn_map_int8</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_INT8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>short</name></type> <name>binn_map_int16</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>short</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_INT16</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_map_int32</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_INT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type> <name>binn_map_int64</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name></type> <name>binn_map_uint8</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_UINT8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>short</name></type> <name>binn_map_uint16</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_UINT16</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name>binn_map_uint32</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_UINT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type> <name>binn_map_uint64</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_UINT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>float</name></type> <name>binn_map_float</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_FLOAT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type> <name>binn_map_double</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_FLOAT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_bool</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_BOOL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_map_null</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>binn_map_str</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_STRING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_blob</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_LIST</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_map</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_map_object</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_map_get</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>signed</name> <name>char</name></type> <name>binn_object_int8</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>signed</name> <name>char</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_INT8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>short</name></type> <name>binn_object_int16</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>short</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_INT16</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>binn_object_int32</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_INT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64</name></type> <name>binn_object_int64</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>char</name></type> <name>binn_object_uint8</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_UINT8</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>short</name></type> <name>binn_object_uint16</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_UINT16</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>unsigned</name> <name>int</name></type> <name>binn_object_uint32</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_UINT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>uint64</name></type> <name>binn_object_uint64</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_UINT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>float</name></type> <name>binn_object_float</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_FLOAT32</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type> <name>binn_object_double</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_FLOAT64</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_bool</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_BOOL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_object_null</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>binn_object_str</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_STRING</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_blob</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>psize</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_BLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>psize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_LIST</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_map</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_MAP</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name><modifier>*</modifier></type> <name>binn_object_object</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>binn_object_get</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>BINN_OBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>value</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>binn</name><modifier>*</modifier></type> <name>binn_alloc_item</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>item</name> <operator>=</operator> <operator>(</operator><name>binn</name><operator>*</operator><operator>)</operator> <call><name>binn_malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>binn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>header</name></name> <operator>=</operator> <name>BINN_MAGIC</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>allocated</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>binn</name><modifier>*</modifier></type> <name>binn_value</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>binn_mem_free</name></type> <name>freefn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>storage_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>binn_alloc_item</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>binn_get_type_info</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>storage_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <switch>switch <condition>(<expr><name>storage_type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>BINN_STORAGE_NOBYTES</name></expr>:</case>
        <break>break;</break>
      <case>case <expr><name>BINN_STORAGE_STRING</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator><operator>)</operator> <name>pvalue</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      <case>case <expr><name>BINN_STORAGE_BLOB</name></expr>:</case>
      <case>case <expr><name>BINN_STORAGE_CONTAINER</name></expr>:</case>
        <if_stmt><if>if <condition>(<expr><name>freefn</name> <operator>==</operator> <name>BINN_TRANSIENT</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>binn_memdup</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>free_fn</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>NULL</name></expr>;</return>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name> <operator>=</operator> <name>free_fn</name></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name>storage_type</name> <operator>==</operator> <name>BINN_STORAGE_STRING</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><name>size</name><operator>--</operator></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>pvalue</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name> <operator>=</operator> <name>freefn</name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
        <break>break;</break>
      <default>default:</default>
        <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>vint32</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>copy_raw_value</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>storage_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>item</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_set_string</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>item</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>str</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>strndup</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name> <operator>=</operator> <name>free_fn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_STRING</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_set_blob</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>binn_mem_free</name></type> <name>pfree</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>item</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>ptr</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>pfree</name> <operator>==</operator> <name>BINN_TRANSIENT</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>binn_memdup</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name> <operator>=</operator> <name>free_fn</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>freefn</name></name> <operator>=</operator> <name>pfree</name></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_BLOB</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** READ CONVERTED VALUE ************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_MSC_VER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atoi64</name></cpp:macro> <cpp:value>_atoi64</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>int64</name></type> <name>atoi64</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>retval</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>is_negative</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>is_negative</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <for>for <control>( <init>;</init> <condition><expr><operator>*</operator><name>str</name></expr>;</condition> <incr><expr><name>str</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <literal type="number">10</literal> <operator>*</operator> <name>retval</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></for>
  <if_stmt><if>if <condition>(<expr><name>is_negative</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>retval</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>is_integer</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <for>for <control>( <init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>is_float</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>BOOL</name></type> <name>retval</name></decl>, <decl><type ref="prev"/><name>number_found</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <for>for <control>( <init>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>number_found</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>number_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>
  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BINN_PRIVATE</name> <name>BOOL</name></type> <name>is_bool_str</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>pbool</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>vint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>vdouble</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>str</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pbool</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_true</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"yes"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_true</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"on"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_true</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="line">//if (stricmp(str, "1") == 0) goto loc_true;</comment>

  <if_stmt><if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_false</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_false</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>stricmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"off"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <goto>goto <name>loc_false</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <comment type="line">//if (stricmp(str, "0") == 0) goto loc_false;</comment>

  <if_stmt><if>if <condition>(<expr><call><name>is_integer</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>vint</name> <operator>=</operator> <call><name>atoi64</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vint</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_float</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>vdouble</name> <operator>=</operator> <call><name>atof</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vdouble</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>FALSE</name></expr>;</return>

<label><name>loc_true</name>:</label>
  <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>

<label><name>loc_false</name>:</label>
  <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_get_int32</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>pint</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pint</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>pint</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>BINN_INT32</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_FLOAT</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STRING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>is_integer</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_float</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><call><name>atof</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_get_int64</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>pint</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pint</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>pint</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_FLOAT</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STRING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>is_integer</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>atoi64</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_float</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <call><name>round</name><argument_list>(<argument><expr><call><name>atof</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pint</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_get_double</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>pfloat</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>vint</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pfloat</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vint</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pfloat</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>vint</name></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_FLOAT</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pfloat</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pfloat</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STRING</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><call><name>is_integer</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pfloat</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>atoi64</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>is_float</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pfloat</name> <operator>=</operator> <call><name>atof</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <return>return <expr><name>FALSE</name></expr>;</return>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pfloat</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>BOOL</name></type> <name>binn_get_bool</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>BOOL</name> <modifier>*</modifier></type><name>pbool</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>vint</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>value</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>pbool</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vint</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>FALSE</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>vint</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
    <return>return <expr><name>TRUE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_FLOAT</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><operator>*</operator><name>pbool</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>BINN_STRING</name></expr>:</case>
      <return>return <expr><call><name>is_bool_str</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><name>pbool</name></expr></argument>)</argument_list></call></expr>;</return>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
  <return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier></type> <name>binn_get_str</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64</name></type> <name>vint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>type_family</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BINN_FAMILY_INT</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>copy_int_value</name><argument_list>(<argument><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vint</name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name>BINN_INT64</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FALSE</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><name>NULL</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>INT64_FORMAT</name></expr></argument>, <argument><expr><name>vint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// -V576</comment>
    <goto>goto <name>loc_convert_value</name>;</goto>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>vfloat</name></name></expr>;</expr_stmt>
    <case>case <expr><name>BINN_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>vdouble</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>loc_convert_value</name>;</goto>
    <case>case <expr><name>BINN_STRING</name></expr>:</case>
      <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
    <case>case <expr><name>BINN_BOOL</name></expr>:</case>
      <if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>vbool</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <goto>goto <name>loc_convert_value</name>;</goto>
  </block_content>}</block></switch>
  <return>return <expr><name>NULL</name></expr>;</return>

<label><name>loc_convert_value</name>:</label>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>NULL</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>freefn</name></name> <operator>=</operator> <name>free</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>value</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>BINN_STRING</name></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>value</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** GENERAL FUNCTIONS ***************************************************************/</comment>

<function><type><name>BOOL</name></type> <name>binn_is_container</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>item</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <switch>switch <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>BINN_LIST</name></expr>:</case>
    <case>case <expr><name>BINN_MAP</name></expr>:</case>
    <case>case <expr><name>BINN_OBJECT</name></expr>:</case>
      <return>return <expr><name>TRUE</name></expr>;</return>
    <default>default:</default>
      <return>return <expr><name>FALSE</name></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>binn_set_user_data</name><parameter_list>(<parameter><decl><type><name>binn</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>, <parameter><decl><type><name>binn_user_data_free</name></type> <name>freefn</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>item</name><operator>-&gt;</operator><name>userdata_freefn</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name><name>item</name><operator>-&gt;</operator><name>userdata_freefn</name></name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>user_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>user_data</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>userdata_freefn</name></name> <operator>=</operator> <name>free_fn</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
