<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/dqlite/src/fsm.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;raft.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/serialize.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"command.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tracing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vfs.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<struct>struct <name>fsm</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>logger</name></name> <modifier>*</modifier></type><name>logger</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>registry</name></name> <modifier>*</modifier></type><name>registry</name></decl>;</decl_stmt>
	<struct>struct
	<block>{
		<decl_stmt><decl><type><name>unsigned</name></type> <name>n_pages</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>page_numbers</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pages</name></decl>;</decl_stmt>
	}</block> <decl><name>pending</name></decl>;</struct> <comment type="block">/* For upgrades from V1 */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_open</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>command_open</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm apply open"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>c</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>add_pending_pages</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
			     <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>page_numbers</name></decl></parameter>,
			     <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>,
			     <parameter><decl><type><name>unsigned</name></type> <name>n_pages</name></decl></parameter>,
			     <parameter><decl><type><name>unsigned</name></type> <name>page_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>+</operator> <name>n_pages</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(
	    <argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_pages</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>page_numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>page_size</name></expr></argument>,
		       <argument><expr><operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator><name>pages</name> <operator>+</operator> <name>i</name> <operator>*</operator> <name>page_size</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>databaseReadLock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>db</name><operator>-&gt;</operator><name>read_lock</name></name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>read_lock</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	    <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
	    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>databaseReadUnlock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>db</name><operator>-&gt;</operator><name>read_lock</name></name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>read_lock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	    <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
	    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>maybeCheckpoint</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"maybe checkpoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_file</name></name> <modifier>*</modifier></type><name>main_f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_file</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>void</name> <modifier>*</modifier></type><name>region</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>wal_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>ckpt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<comment type="block">/* Don't run when a snapshot is busy. Running a checkpoint while a snapshot
	 * is busy will result in illegal memory accesses by the routines that try
	 * to access database page pointers contained in the snapshot. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>databaseReadLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"busy snapshot %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>db__open_follower</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"open follower failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err_after_db_lock</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>page_size</name></name></expr>;</expr_stmt>
	<comment type="block">/* Get the database wal file associated with this connection */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>SQLITE_FCNTL_JOURNAL_POINTER</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should never fail */</comment>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>wal</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should never fail */</comment>

	<comment type="block">/* Calculate the number of frames. */</comment>
	<expr_stmt><expr><name>pages</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><literal type="number">24</literal> <operator>+</operator> <name>page_size</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Check if the size of the WAL is beyond the threshold. */</comment>
	<if_stmt><if>if <condition>(<expr><name>pages</name> <operator>&lt;</operator> <name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>checkpoint_threshold</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal size (%u) &lt; threshold (%u)"</literal></expr></argument>, <argument><expr><name>pages</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>checkpoint_threshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err_after_db_open</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get the database file associated with this db-&gt;follower connection */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_file_control</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>SQLITE_FCNTL_FILE_POINTER</name></expr></argument>,
				  <argument><expr><operator>&amp;</operator><name>main_f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should never fail */</comment>

	<comment type="block">/* Get the first SHM region, which contains the WAL header. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>main_f</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmMap</name></name><argument_list>(<argument><expr><name>main_f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should never fail */</comment>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>main_f</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmUnmap</name></name><argument_list>(<argument><expr><name>main_f</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Should never fail */</comment>

	<comment type="block">/* Try to acquire all locks. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SQLITE_SHM_NLOCK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>main_f</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>main_f</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>SQLITE_BUSY</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"busy reader or writer - retry next time"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<goto>goto <name>err_after_db_open</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Not locked. Let's release the lock we just
		 * acquired. */</comment>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>main_f</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xShmLock</name></name><argument_list>(<argument><expr><name>main_f</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_wal_checkpoint_v2</name><argument_list>(
	     <argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>, <argument><expr><name>SQLITE_CHECKPOINT_TRUNCATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wal_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ckpt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* TODO assert(rv == 0) here? Which failure modes do we expect? */</comment>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"sqlite3_wal_checkpoint_v2 failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err_after_db_open</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"sqlite3_wal_checkpoint_v2 success"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since no reader transaction is in progress, we must be able to
	 * checkpoint the entire WAL */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>wal_size</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ckpt</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>err_after_db_open</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<label><name>err_after_db_lock</name>:</label>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>databaseReadUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_frames</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>command_frames</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm apply frames"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>page_numbers</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>registry__db_get</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>registry</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"db get failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the database file exists, and create it by opening a
	 * connection if it doesn't. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>vfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>db__open_follower</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"open follower failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>command_frames__page_numbers</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>page_numbers</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"page numbers failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>command_frames__pages</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the commit marker is set, we apply the changes directly to the
	 * VFS. Otherwise, if the commit marker is not set, this must be an
	 * upgrade from V1, we accumulate uncommitted frames in memory until the
	 * final commit or a rollback. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>c</name><operator>-&gt;</operator><name>is_commit</name></name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>add_pending_pages</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>page_numbers</name></expr></argument>, <argument><expr><name>pages</name></expr></argument>,
					       <argument><expr><name><name>c</name><operator>-&gt;</operator><name>frames</name><operator>.</operator><name>n_pages</name></name></expr></argument>,
					       <argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>page_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator>
			    <call><name>VfsApply</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name></expr></argument>,
				     <argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"VfsApply failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>rv</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsApply</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>frames</name><operator>.</operator><name>n_pages</name></name></expr></argument>,
				      <argument><expr><name>page_numbers</name></expr></argument>, <argument><expr><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"VfsApply failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>rv</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator>
		    <call><name>add_pending_pages</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>page_numbers</name></expr></argument>, <argument><expr><name>pages</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>frames</name><operator>.</operator><name>n_pages</name></name></expr></argument>,
				      <argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>page_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"add pending pages failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>page_numbers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>maybeCheckpoint</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_undo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>command_undo</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"apply undo %"</literal> <name>PRIu64</name></expr></argument>, <argument><expr><name><name>c</name><operator>-&gt;</operator><name>tx_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>c</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Checkpoints used to be coordinated cluster-wide, these days a node
 * checkpoints independently in `apply_frames`, the checkpoint command becomes a
 * no-op for modern nodes. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>apply_checkpoint</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>command_checkpoint</name></name> <modifier>*</modifier></type><name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>c</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"apply no-op checkpoint"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__apply</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
		      <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
		      <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm apply"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>command</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>command__decode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm: decode command: %d"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>COMMAND_OPEN</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>apply_open</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COMMAND_FRAMES</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>apply_frames</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COMMAND_UNDO</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>apply_undo</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>COMMAND_CHECKPOINT</name></expr>:</case>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>apply_checkpoint</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>RAFT_MALFORMED</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_FORMAT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_HEADER</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>          \
	<cpp:value>X(uint64, format, ##__VA_ARGS__) \
	X(uint64, n, ##__VA_ARGS__)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>SERIALIZE__DEFINE</name><argument_list>(<argument><expr><name>snapshotHeader</name></expr></argument>, <argument><expr><name>SNAPSHOT_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SERIALIZE__IMPLEMENT</name><argument_list>(<argument><expr><name>snapshotHeader</name></expr></argument>, <argument><expr><name>SNAPSHOT_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_DATABASE</name><parameter_list>(<parameter><type><name>X</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro>           \
	<cpp:value>X(text, filename, ##__VA_ARGS__)    \
	X(uint64, main_size, ##__VA_ARGS__) \
	X(uint64, wal_size, ##__VA_ARGS__)</cpp:value></cpp:define>
<expr_stmt><expr><call><name>SERIALIZE__DEFINE</name><argument_list>(<argument><expr><name>snapshotDatabase</name></expr></argument>, <argument><expr><name>SNAPSHOT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SERIALIZE__IMPLEMENT</name><argument_list>(<argument><expr><name>snapshotDatabase</name></expr></argument>, <argument><expr><name>SNAPSHOT_DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* Encode the global snapshot header. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encodeSnapshotHeader</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotHeader</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>format</name></name> <operator>=</operator> <name>SNAPSHOT_FORMAT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>n</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>snapshotHeader__sizeof</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>RAFT_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snapshotHeader__encode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Encode the given database. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encodeDatabase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name></type> <name><name>r_bufs</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotDatabase</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>database_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name> <modifier>*</modifier></type><name>bufs</name> <init>= <expr><operator>(</operator>struct <name>dqlite_buffer</name><operator>*</operator><operator>)</operator> <name>r_bufs</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsShallowSnapshot</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bufs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Extract the database size from the first page. */</comment>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>bufs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>database_size</name> <operator>+=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>page</name><index>[<expr><literal type="number">28</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database_size</name> <operator>+=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>page</name><index>[<expr><literal type="number">29</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database_size</name> <operator>+=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>page</name><index>[<expr><literal type="number">30</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database_size</name> <operator>+=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><operator>(</operator><name><name>page</name><index>[<expr><literal type="number">31</literal></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>=</operator> <name>database_size</name> <operator>*</operator> <name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>page_size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>wal_size</name></name> <operator>=</operator> <name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>

	<comment type="block">/* Database header. */</comment>
	<expr_stmt><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <call><name>snapshotDatabase__sizeof</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>RAFT_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>err_after_snapshot</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snapshotDatabase__encode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err_after_snapshot</name>:</label>
	<comment type="block">/* Free the wal buffer */</comment>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decode the database contained in a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decodeDatabase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotDatabase</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotDatabase__decode</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>registry__db_get</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>registry</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the database file exists, and create it by opening a
	 * connection if it doesn't. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>vfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>filename</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>db__open_follower</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>+</operator> <name><name>header</name><operator>.</operator><name>wal_size</name></name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"main_size + wal_size would overflow max DB size"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Due to the check above, this cast is safe. */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>+</operator> <name><name>header</name><operator>.</operator><name>wal_size</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsRestore</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>dbNumPages</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsDatabaseNumPages</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Determine the total number of raft buffers needed for a snapshot */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>snapshotNumBufs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* snapshot header */</comment>

	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <comment type="block">/* database header &amp; wal */</comment>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>dbNumPages</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 1 buffer per page (zero copy) */</comment>
	</block_content>}</block>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* An example array of snapshot buffers looks like this:
 *
 * bufs:  SH DH1 P1 P2 P3 WAL1 DH2 P1 P2 WAL2
 * index:  0   1  2  3  4    5   6  7  8    9
 *
 * SH:   Snapshot Header
 * DHx:  Database Header
 * Px:   Database Page (not to be freed)
 * WALx: a WAL
 * */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeSnapshotBufs</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
			     <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name></type> <name><name>bufs</name><index>[]</index></name></decl></parameter>,
			     <parameter><decl><type><name>unsigned</name></type> <name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bufs</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>n_bufs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free snapshot header */</comment>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Free all database headers &amp; WAL buffers */</comment>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>n_bufs</name></expr>)</condition> <block>{<block_content>
		    <break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* i is the index of the database header */</comment>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* i is now the index of the next database header (if any) */</comment>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal> <comment type="block">/* db header */</comment> <operator>+</operator> <call><name>dbNumPages</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> <comment type="block">/* WAL */</comment>;</expr_stmt>
		<comment type="block">/* free WAL buffer */</comment>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__snapshot</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name><name>bufs</name><index>[]</index></name></decl></parameter>,
			 <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<comment type="block">/* First count how many databases we have and check that no transaction
	 * nor checkpoint nor other snapshot is in progress. */</comment>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>db</name><operator>-&gt;</operator><name>tx_id</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>read_lock</name></name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>RAFT_BUSY</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n_db</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Lock all databases, preventing the checkpoint from running */</comment>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>databaseReadLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><operator>*</operator><name>n_bufs</name> <operator>=</operator> <call><name>snapshotNumBufs</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bufs</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>*</operator><name>n_bufs</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<operator>*</operator><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>RAFT_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>encodeSnapshotHeader</name><argument_list>(<argument><expr><name>n_db</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>err_after_bufs_alloc</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Encode individual databases. */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* database_header + num_pages + wal */</comment>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <call><name>dbNumPages</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>encodeDatabase</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<goto>goto <name>err_after_encode_header</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <operator>*</operator><name>n_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err_after_encode_header</name>:</label>
	<expr_stmt><expr><call><name>freeSnapshotBufs</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>*</operator><name>bufs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err_after_bufs_alloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>databaseReadUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__snapshot_finalize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
				  <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name><name>bufs</name><index>[]</index></name></decl></parameter>,
				  <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotHeader</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bufs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Decode the header to determine the number of databases. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name></type> <name>cursor</name> <init>= <expr><block>{<expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>base</name></expr>, <expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>len</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotHeader__decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>format</name></name> <operator>!=</operator> <name>SNAPSHOT_FORMAT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"bad format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free allocated buffers */</comment>
	<expr_stmt><expr><call><name>freeSnapshotBufs</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>*</operator><name>bufs</name></expr></argument>, <argument><expr><operator>*</operator><name>n_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bufs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>n_bufs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Unlock all databases that were locked for the snapshot, this is safe
	 * because DB's are only ever added at the back of the queue. */</comment>
	<expr_stmt><expr><name>n_db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n_db</name> <operator>==</operator> <name><name>header</name><operator>.</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>databaseReadUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_db</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__restore</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm restore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name></type> <name>cursor</name> <init>= <expr><block>{<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>, <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotHeader</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotHeader__decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>format</name></name> <operator>!=</operator> <name>SNAPSHOT_FORMAT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"bad format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>RAFT_MALFORMED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>header</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>decodeDatabase</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Don't use sqlite3_free as this buffer is allocated by raft. */</comment>
	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>fsm__init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
	      <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>config</name></decl></parameter>,
	      <parameter><decl><type><name><name>struct</name> <name>registry</name></name> <modifier>*</modifier></type><name>registry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm init"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>raft_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>logger</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>logger</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>registry</name></name> <operator>=</operator> <name>registry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>apply</name></name> <operator>=</operator> <name>fsm__apply</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>fsm__snapshot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>snapshot_finalize</name></name> <operator>=</operator> <name>fsm__snapshot_finalize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>restore</name></name> <operator>=</operator> <name>fsm__restore</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>fsm__close</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************
 Disk-based FSM
 *****************************************************************************/</comment>

<comment type="block">/* The synchronous part of the database encoding */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encodeDiskDatabaseSync</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name><modifier>*</modifier></type> <name>r_buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator>struct <name>dqlite_buffer</name><operator>*</operator><operator>)</operator> <name>r_buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsDiskSnapshotWal</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* The asynchronous part of the database encoding */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encodeDiskDatabaseAsync</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name></type> <name><name>r_bufs</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotDatabase</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name> <modifier>*</modifier></type><name>bufs</name> <init>= <expr><operator>(</operator>struct <name>dqlite_buffer</name><operator>*</operator><operator>)</operator> <name>r_bufs</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsDiskSnapshotDb</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bufs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Database header. */</comment>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>filename</name></name> <operator>=</operator> <name><name>db</name><operator>-&gt;</operator><name>filename</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>=</operator> <name><name>bufs</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><operator>.</operator><name>wal_size</name></name> <operator>=</operator> <name><name>bufs</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <call><name>snapshotDatabase__sizeof</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>RAFT_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snapshotDatabase__encode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>header</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

	<comment type="block">/* Cleanup is performed by call to snapshot_finalize */</comment>
<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Determine the total number of raft buffers needed
 * for a snapshot in disk-mode */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name></type> <name>snapshotNumBufsDisk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* snapshot header */</comment>

	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <comment type="block">/* database header, database file and wal */</comment>
	</block_content>}</block>

	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* An example array of snapshot buffers looks like this:
 *
 * bufs:  SH DH1 DBMMAP1 WAL1 DH2 DMMAP2 WAL2
 * index:  0   1       2    3   4      5    6
 *
 * SH:     Snapshot Header
 * DHx:    Database Header
 * DBMMAP: Pointer to mmap'ed database file
 * WALx:   a WAL
 * */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>freeSnapshotBufsDisk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
			         <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name></type> <name><name>bufs</name><index>[]</index></name></decl></parameter>,
			         <parameter><decl><type><name>unsigned</name></type> <name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bufs</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>n_bufs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free snapshot header */</comment>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<comment type="block">/* Free all database headers &amp; WAL buffers. Unmap the DB file. */</comment>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>n_bufs</name></expr>)</condition> <block>{<block_content>
		    <break>break;</break>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* i is the index of the database header */</comment>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>bufs</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>munmap</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>, <argument><expr><name><name>bufs</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* i is now the index of the next database header (if any) */</comment>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__snapshot_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name><name>bufs</name><index>[]</index></name></decl></parameter>,
			 <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_db</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<comment type="block">/* First count how many databases we have and check that no transaction
	 * nor checkpoint nor other snapshot is in progress. */</comment>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>db</name><operator>-&gt;</operator><name>tx_id</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>db</name><operator>-&gt;</operator><name>read_lock</name></name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>RAFT_BUSY</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n_db</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Lock all databases, preventing the checkpoint from running. This
	 * ensures the database is not written while it is mmap'ed and copied by
	 * raft. */</comment>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>databaseReadLock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>


	<expr_stmt><expr><operator>*</operator><name>n_bufs</name> <operator>=</operator> <call><name>snapshotNumBufsDisk</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bufs</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><operator>*</operator><name>n_bufs</name> <operator>*</operator> <sizeof>sizeof <name/></sizeof>*<operator>*</operator><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bufs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>RAFT_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* zero-init buffers, helps with cleanup */</comment>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>*</operator><name>n_bufs</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index><operator>.</operator><name>base</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><name>j</name></expr>]</index><operator>.</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>encodeSnapshotHeader</name><argument_list>(<argument><expr><name>n_db</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<goto>goto <name>err_after_bufs_alloc</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy WAL of all databases. */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* database_header + db + WAL */</comment>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* pass pointer to buffer that will contain WAL. */</comment>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>encodeDiskDatabaseSync</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><name>i</name><operator>+</operator><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<goto>goto <name>err_after_encode_sync</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <operator>*</operator><name>n_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err_after_encode_sync</name>:</label>
	<expr_stmt><expr><call><name>freeSnapshotBufsDisk</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>*</operator><name>bufs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err_after_bufs_alloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>databaseReadUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__snapshot_async_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
			 <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name><name>bufs</name><index>[]</index></name></decl></parameter>,
			 <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotHeader</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<comment type="block">/* Decode the header to determine the number of databases. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name></type> <name>cursor</name> <init>= <expr><block>{<expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>base</name></expr>, <expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>len</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotHeader__decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>format</name></name> <operator>!=</operator> <name>SNAPSHOT_FORMAT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"bad format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Encode individual databases. */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <operator>*</operator><name>n_bufs</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* In case a db was added in meanwhile */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* database_header + database file + wal */</comment>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>encodeDiskDatabaseAsync</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__snapshot_finalize_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
				  <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name><name>bufs</name><index>[]</index></name></decl></parameter>,
				  <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n_bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>queue</name> <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotHeader</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bufs</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Decode the header to determine the number of databases. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name></type> <name>cursor</name> <init>= <expr><block>{<expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>base</name></expr>, <expr><operator>(</operator><operator>*</operator><name>bufs</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index><operator>.</operator><name>len</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotHeader__decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>format</name></name> <operator>!=</operator> <name>SNAPSHOT_FORMAT</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"bad format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Free allocated buffers */</comment>
	<expr_stmt><expr><call><name>freeSnapshotBufsDisk</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>*</operator><name>bufs</name></expr></argument>, <argument><expr><operator>*</operator><name>n_bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>bufs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>n_bufs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Unlock all databases that were locked for the snapshot, this is safe
	 * because DB's are only ever added at the back of the queue. */</comment>
	<expr_stmt><expr><name>n_db</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>QUEUE__FOREACH</name><argument_list>(<argument>head</argument>, <argument>&amp;f-&gt;registry-&gt;dbs</argument>)</argument_list></macro>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>n_db</name> <operator>==</operator> <name><name>header</name><operator>.</operator><name>n</name></name></expr>)</condition> <block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>QUEUE__DATA</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr>struct <name>db</name></expr></argument>, <argument><expr><name>queue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>databaseReadUnlock</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_db</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decode the disk database contained in a snapshot. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decodeDiskDatabase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>cursor</name></name> <modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotDatabase</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>db</name></name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotDatabase__decode</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>registry__db_get</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>registry</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>filename</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>config</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check if the database file exists, and create it by opening a
	 * connection if it doesn't. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>vfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>db__open_follower</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>sqlite3_close</name><argument_list>(<argument><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>follower</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The last check can overflow, but we would already be lost anyway, as
	 * the raft snapshot restore API only supplies one buffer and the data
	 * has to fit in size_t bytes anyway. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>&gt;</operator> <name>SIZE_MAX</name>
	    <operator>||</operator> <name><name>header</name><operator>.</operator><name>wal_size</name></name> <operator>&gt;</operator> <name>SIZE_MAX</name>
	    <operator>||</operator> <name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>+</operator> <name><name>header</name><operator>.</operator><name>wal_size</name></name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"main_size:%"</literal><name>PRIu64</name> <literal type="string">"B wal_size:%"</literal><name>PRIu64</name> <literal type="string">"B would overflow max DB size (%zuB)"</literal></expr></argument>,
		       <argument><expr><name><name>header</name><operator>.</operator><name>main_size</name></name></expr></argument>, <argument><expr><name><name>header</name><operator>.</operator><name>wal_size</name></name></expr></argument>, <argument><expr><name>SIZE_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Due to the check above, these casts are safe. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>VfsDiskRestore</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name><name>db</name><operator>-&gt;</operator><name>path</name></name></expr></argument>, <argument><expr><name><name>cursor</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>header</name><operator>.</operator><name>main_size</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>header</name><operator>.</operator><name>wal_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"VfsDiskRestore %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>cursor</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name><name>header</name><operator>.</operator><name>main_size</name></name> <operator>+</operator> <name><name>header</name><operator>.</operator><name>wal_size</name></name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fsm__restore_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>raft_buffer</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm restore disk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>cursor</name></name></type> <name>cursor</name> <init>= <expr><block>{<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>, <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshotHeader</name></name></type> <name>header</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snapshotHeader__decode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>header</name><operator>.</operator><name>format</name></name> <operator>!=</operator> <name>SNAPSHOT_FORMAT</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"bad format"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>RAFT_MALFORMED</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>header</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>decodeDiskDatabase</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"decode failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Don't use sqlite3_free as this buffer is allocated by raft. */</comment>
	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>fsm__init_disk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>raft_fsm</name></name> <modifier>*</modifier></type><name>fsm</name></decl></parameter>,
	           <parameter><decl><type><name><name>struct</name> <name>config</name></name> <modifier>*</modifier></type><name>config</name></decl></parameter>,
	           <parameter><decl><type><name><name>struct</name> <name>registry</name></name> <modifier>*</modifier></type><name>registry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fsm init"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>fsm</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>raft_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>logger</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>config</name><operator>-&gt;</operator><name>logger</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>registry</name></name> <operator>=</operator> <name>registry</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>n_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>page_numbers</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>apply</name></name> <operator>=</operator> <name>fsm__apply</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <name>fsm__snapshot_disk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>snapshot_async</name></name> <operator>=</operator> <name>fsm__snapshot_async_disk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>snapshot_finalize</name></name> <operator>=</operator> <name>fsm__snapshot_finalize_disk</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fsm</name><operator>-&gt;</operator><name>restore</name></name> <operator>=</operator> <name>fsm__restore_disk</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
