<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/dqlite/src/vfs.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;raft.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sqlite3.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../include/dqlite.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/assert.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/byte.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"format.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tracing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vfs.h"</cpp:file></cpp:include>

<comment type="block">/* Byte order */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DQLITE_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__BIGENDIAN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DQLITE_BIG_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__BIGENDIAN</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>vfsOne</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__BIGENDIAN</name></cpp:macro> <cpp:value>(*(char *)(&amp;vfsOne) == 0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Maximum pathname length supported by this VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__MAX_PATHNAME</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/* WAL magic value. Either this value, or the same value with the least
 * significant bit also set (FORMAT__WAL_MAGIC | 0x00000001) is stored in 32-bit
 * big-endian format in the first 4 bytes of a WAL file.
 *
 * If the LSB is set, then the checksums for each frame within the WAL file are
 * calculated by treating all data as an array of 32-bit big-endian
 * words. Otherwise, they are calculated by interpreting all data as 32-bit
 * little-endian words. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__WAL_MAGIC</name></cpp:macro> <cpp:value>0x377f0682</cpp:value></cpp:define>

<comment type="block">/* WAL format version (same for WAL index). */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__WAL_VERSION</name></cpp:macro> <cpp:value>3007000</cpp:value></cpp:define>

<comment type="block">/* Index of the write lock in the WAL-index header locks area. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__WAL_WRITE_LOCK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* Write ahead log header size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__WAL_HEADER_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>

<comment type="block">/* Write ahead log frame header size. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__FRAME_HEADER_SIZE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>

<comment type="block">/* Size of the first part of the WAL index header. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__WAL_INDEX_HEADER_SIZE</name></cpp:macro> <cpp:value>48</cpp:value></cpp:define>

<comment type="block">/* Size of a single memory-mapped WAL index region. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS__WAL_INDEX_REGION_SIZE</name></cpp:macro> <cpp:value>32768</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>vfsFrameSize</name><parameter_list>(<parameter><type><name>PAGE_SIZE</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(VFS__FRAME_HEADER_SIZE + PAGE_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Hold content for a shared memory mapping. */</comment>
<struct>struct <name>vfsShm</name>
<block>{
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>regions</name></decl>;</decl_stmt>     <comment type="block">/* Pointers to shared memory regions. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_regions</name></decl>;</decl_stmt> <comment type="block">/* Number of shared memory regions. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>refcount</name></decl>;</decl_stmt>  <comment type="block">/* Number of outstanding mappings. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name><name>shared</name><index>[<expr><name>SQLITE_SHM_NLOCK</name></expr>]</index></name></decl>;</decl_stmt>    <comment type="block">/* Count of shared locks */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name><name>exclusive</name><index>[<expr><name>SQLITE_SHM_NLOCK</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Count of exclusive locks */</comment>
}</block>;</struct>

<comment type="block">/* Hold the content of a single WAL frame. */</comment>
<struct>struct <name>vfsFrame</name>
<block>{
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>header</name><index>[<expr><name>VFS__FRAME_HEADER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt> <comment type="block">/* Content of the page. */</comment>
}</block>;</struct>

<comment type="block">/* WAL-specific content.
 * Watch out when changing the members of this struct, see
 * comment in `formatWalChecksumBytes`. */</comment>
<struct>struct <name>vfsWal</name>
<block>{
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>hdr</name><index>[<expr><name>VFS__WAL_HEADER_SIZE</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* Header. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>frames</name></decl>;</decl_stmt>          <comment type="block">/* All frames committed. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_frames</name></decl>;</decl_stmt>                 <comment type="block">/* Number of committed frames. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tx</name></decl>;</decl_stmt>              <comment type="block">/* Frames added by a transaction. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_tx</name></decl>;</decl_stmt>                     <comment type="block">/* Number of added frames. */</comment>
}</block>;</struct>

<comment type="block">/* Database-specific content */</comment>
<struct>struct <name>vfsDatabase</name>
<block>{
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>        <comment type="block">/* Database name. */</comment>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pages</name></decl>;</decl_stmt>      <comment type="block">/* All database. */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>page_size</name></decl>;</decl_stmt><comment type="block">/* Only used for on-disk db */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_pages</name></decl>;</decl_stmt>  <comment type="block">/* Number of pages. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsShm</name></name></type> <name>shm</name></decl>;</decl_stmt> <comment type="block">/* Shared memory. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name></type> <name>wal</name></decl>;</decl_stmt> <comment type="block">/* Associated WAL. */</comment>
}</block>;</struct>

<comment type="block">/*
 * Generate or extend an 8 byte checksum based on the data in array data[] and
 * the initial values of in[0] and in[1] (or initial values of 0 and 0 if
 * in==NULL).
 *
 * The checksum is written back into out[] before returning.
 *
 * n must be a positive multiple of 8. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsChecksum</name><parameter_list>(
    <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <comment type="block">/* Content to be checksummed */</comment>
    <parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>,    <comment type="block">/* Bytes of content in a[].  Must be a multiple of 8. */</comment>
    <parameter><decl><type><specifier>const</specifier> <name>uint32_t</name></type> <name><name>in</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>, <comment type="block">/* Initial checksum value input */</comment>
    <parameter><decl><type><name>uint32_t</name></type> <name><name>out</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>       <comment type="block">/* OUT: Final checksum value output */</comment>
)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>data</name><operator>)</operator> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32_t</name></type> <name>s1</name></decl>, <decl><type ref="prev"/><name>s2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>in</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <name><name>in</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s2</name> <operator>=</operator> <name><name>in</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>n</name> <operator>&amp;</operator> <literal type="number">0x00000007</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&lt;=</operator> <literal type="number">65536</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do <block>{<block_content>
		<expr_stmt><expr><name>s1</name> <operator>+=</operator> <operator>*</operator><name>cur</name><operator>++</operator> <operator>+</operator> <name>s2</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>s2</name> <operator>+=</operator> <operator>*</operator><name>cur</name><operator>++</operator> <operator>+</operator> <name>s1</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>cur</name> <operator>&lt;</operator> <name>end</name></expr>)</condition>;</do>

	<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>s1</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>s2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Create a new frame of a WAL file. */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>vfsFrameCreate</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>page</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom_after_page_alloc</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>f</name></expr>;</return>

<label><name>oom_after_page_alloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>oom</name>:</label>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Destroy a WAL frame */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsFrameDestroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>page</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize the shared memory mapping of a database file. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsShmInit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>regions</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>n_regions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>refcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SQLITE_SHM_NLOCK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>shared</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Release all resources used by a shared memory mapping. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsShmClose</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>region</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Free all regions. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>n_regions</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>region</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>regions</name></name> <operator>+</operator> <name>i</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>region</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Free the shared memory region array. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>regions</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>regions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Revert the shared mamory to its initial state. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsShmReset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>vfsShmClose</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsShmInit</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize a new WAL object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsWalInit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize a new database object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDatabaseInit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>page_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsShmInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>shm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsWalInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Release all memory used by a WAL object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsWalClose</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>tx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Release all memory used by a database object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDatabaseClose</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>vfsShmClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>shm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsWalClose</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Destroy the content of a database object. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDatabaseDestroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vfsDatabaseClose</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Comment copied entirely for sqlite source code, it is safe to assume
 * the value 0x40000000 will never change. dq_sqlite_pending_byte is global
 * to be able to adapt it in the unittest, the value must never be changed.
 *
 * ==BEGIN COPY==
 * The value of the "pending" byte must be 0x40000000 (1 byte past the
 * 1-gibabyte boundary) in a compatible database.  SQLite never uses
 * the database page that contains the pending byte.  It never attempts
 * to read or write that page.  The pending byte page is set aside
 * for use by the VFS layers as space for managing file locks.
 *
 * During testing, it is often desirable to move the pending byte to
 * a different position in the file.  This allows code that has to
 * deal with the pending byte to run on files that are much smaller
 * than 1 GiB.  The sqlite3_test_control() interface can be used to
 * move the pending byte.
 *
 * IMPORTANT:  Changing the pending byte to any value other than
 * 0x40000000 results in an incompatible database file format!
 * Changing the pending byte during operation will result in undefined
 * and incorrect behavior.
 * ==END COPY==
 */</comment>
<decl_stmt><decl><type><name>unsigned</name></type> <name>dq_sqlite_pending_byte</name> <init>= <expr><literal type="number">0x40000000</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Get a page from the given database, possibly creating a new one. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDatabaseGetPage</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
			      <parameter><decl><type><name>uint32_t</name></type> <name>page_size</name></decl></parameter>,
			      <parameter><decl><type><name>unsigned</name></type> <name>pgno</name></decl></parameter>,
			      <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pgno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* SQLite should access pages progressively, without jumping more than
         * one page after the end unless one would attempt to access a page at
         * `sqlite_pending_byte` offset, skipping a page is permitted then. */</comment>
        <decl_stmt><decl><type><name>bool</name></type> <name>pending_byte_page_reached</name> <init>= <expr><operator>(</operator><name>page_size</name> <operator>*</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>==</operator> <name>dq_sqlite_pending_byte</name><operator>)</operator></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pgno</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>pending_byte_page_reached</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
        </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgno</name> <operator>&lt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Return the existing page. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>page</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>pgno</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
                <return>return <expr><name>SQLITE_OK</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Create a new page, grow the page array, and append the
         * new page to it. */</comment>
        <expr_stmt><expr><operator>*</operator><name>page</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
                <goto>goto <name>err</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pages</name> <init>= <expr><call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>pages</name> <operator>*</operator> <name>pgno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>pages</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
                <goto>goto <name>err_after_vfs_page_create</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>pages</name><index>[<expr><name>pgno</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>page</name></expr>;</expr_stmt>

        <comment type="block">/* Allocate a page to store the pending_byte */</comment>
        <if_stmt><if>if <condition>(<expr><name>pending_byte_page_reached</name></expr>)</condition> <block>{<block_content>
                <decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>pending_byte_page</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <if_stmt><if>if <condition>(<expr><name>pending_byte_page</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
                        <expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
                        <goto>goto <name>err_after_pending_byte_page</name>;</goto>
                </block_content>}</block></if></if_stmt>
                <expr_stmt><expr><name><name>pages</name><index>[<expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>]</index></name> <operator>=</operator> <name>pending_byte_page</name></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Update the page array. */</comment>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>pages</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>err_after_pending_byte_page</name>:</label>
        <expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>pages</name></expr>;</expr_stmt>

<label><name>err_after_vfs_page_create</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<expr_stmt><expr><operator>*</operator><name>page</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get a frame from the current transaction, possibly creating a new one. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalFrameGet</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>,
			  <parameter><decl><type><name>unsigned</name></type> <name>index</name></decl></parameter>,
			  <parameter><decl><type><name>uint32_t</name></type> <name>page_size</name></decl></parameter>,
			  <parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>frame</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SQLite should access pages progressively, without jumping more than
	 * one page after the end. */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Create a new frame, grow the transaction array, and append
		 * the new frame to it. */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>tx</name></decl>;</decl_stmt>

		<comment type="block">/* We assume that the page size has been set, either by
		 * intervepting the first main database file write, or by
		 * handling a 'PRAGMA page_size=N' command in
		 * vfs__file_control(). This assumption is enforved in
		 * vfsFileWrite(). */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>frame</name> <operator>=</operator> <call><name>vfsFrameCreate</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>frame</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>tx</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>tx</name> <operator>*</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tx</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
			<goto>goto <name>err_after_vfs_frame_create</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Append the new page to the new page array. */</comment>
		<expr_stmt><expr><name><name>tx</name><index>[<expr><name>index</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>frame</name></expr>;</expr_stmt>

		<comment type="block">/* Update the page array. */</comment>
		<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name></name> <operator>=</operator> <name>tx</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* Return the existing page. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>frame</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>index</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>err_after_vfs_frame_create</name>:</label>
	<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><operator>*</operator><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<expr_stmt><expr><operator>*</operator><name>frame</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Lookup a page from the given database, returning NULL if it doesn't exist. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>vfsDatabasePageLookup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>pgno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pgno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgno</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* This page hasn't been written yet. */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>pgno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>page</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Lookup a frame from the WAL, returning NULL if it doesn't exist. */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>vfsWalFrameLookup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>w</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* This page hasn't been written yet. */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>frame</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>frames</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>frame</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>n</name> <operator>-</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>frame</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>frame</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Parse the page size ("Must be a power of two between 512 and 32768
 * inclusive, or the value 1 representing a page size of 65536").
 *
 * Return 0 if the page size is out of bound. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsParsePageSize</name><parameter_list>(<parameter><decl><type><name>uint32_t</name></type> <name>page_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>page_size</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <name>FORMAT__PAGE_SIZE_MAX</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>page_size</name> <operator>&lt;</operator> <name>FORMAT__PAGE_SIZE_MIN</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>page_size</name> <operator>&gt;</operator> <operator>(</operator><name>FORMAT__PAGE_SIZE_MAX</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>page_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>page_size</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>page_size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsDatabaseGetPageSize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<comment type="block">/* Only set in disk-mode */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>page_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name><name>d</name><operator>-&gt;</operator><name>page_size</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* The page size is stored in the 16th and 17th bytes of the first
	 * database page (big-endian) */</comment>
	<return>return <expr><call><name>vfsParsePageSize</name><argument_list>(<argument><expr><call><name>ByteGetBe16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Truncate a database file to be exactly the given number of pages. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDatabaseTruncate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>SQLITE_IOERR_TRUNCATE</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Since the file size is not zero, some content must
	 * have been written and the page size must be known. */</comment>
	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>%</operator> <name>page_size</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_IOERR_TRUNCATE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>n_pages</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>size</name> <operator>/</operator> <name>page_size</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* We expect callers to only invoke us if some actual content has been
	 * written already. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Truncate should always shrink a file. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n_pages</name> <operator>&lt;=</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Destroy pages beyond pages_len. */</comment>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>+</operator> <name>n_pages</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>-</operator> <name>n_pages</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cursor</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Shrink the page array, possibly to 0.
	 *
	 * TODO: in principle realloc could fail also when shrinking. */</comment>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>*</operator> <name>n_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the page count. */</comment>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>=</operator> <name>n_pages</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Truncate a WAL file to zero. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalTruncate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<comment type="block">/* We expect SQLite to only truncate to zero, after a
	 * full checkpoint.
	 *
	 * TODO: figure out other case where SQLite might
	 * truncate to a different size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_PROTOCOL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restart the header. */</comment>
	<expr_stmt><expr><call><name>formatWalRestartHeader</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Destroy all frames. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<enum>enum <name>vfsFileType</name> <block>{
	<decl><name>VFS__DATABASE</name></decl>, <comment type="block">/* Main database file */</comment>
	<decl><name>VFS__JOURNAL</name></decl>,  <comment type="block">/* Default SQLite journal file */</comment>
	<decl><name>VFS__WAL</name></decl>       <comment type="block">/* Write-Ahead Log */</comment>
}</block>;</enum>

<comment type="block">/* Implementation of the abstract sqlite3_file base class. */</comment>
<struct>struct <name>vfsFile</name>
<block>{
	<decl_stmt><decl><type><name>sqlite3_file</name></type> <name>base</name></decl>;</decl_stmt>            <comment type="block">/* Base class. Must be first. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>vfs</name></decl>;</decl_stmt>              <comment type="block">/* Pointer to volatile VFS data. */</comment>
	<decl_stmt><decl><type><name><name>enum</name> <name>vfsFileType</name></name></type> <name>type</name></decl>;</decl_stmt>        <comment type="block">/* Associated file (main db or WAL). */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt> <comment type="block">/* Underlying database content. */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>                    <comment type="block">/* Flags passed to xOpen */</comment>
	<decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>           <comment type="block">/* For temp-files, actual VFS. */</comment>
	<decl_stmt><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>             <comment type="block">/* For on-disk DB files, actual VFS. */</comment>
}</block>;</struct>

<comment type="block">/* Custom dqlite VFS. Contains pointers to all databases that were created. */</comment>
<struct>struct <name>vfs</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>databases</name></decl>;</decl_stmt> <comment type="block">/* Database objects */</comment>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_databases</name></decl>;</decl_stmt>           <comment type="block">/* Number of databases */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>                      <comment type="block">/* Last error occurred. */</comment>
	<decl_stmt><decl><type><name>bool</name></type> <name>disk</name></decl>;</decl_stmt>                      <comment type="block">/* True if the database is kept on disk. */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_vfs</name></name> <modifier>*</modifier></type><name>base_vfs</name></decl>;</decl_stmt>   <comment type="block">/* Base VFS. */</comment>
}</block>;</struct>

<comment type="block">/* Create a new vfs object. */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>vfsCreate</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>databases</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>n_databases</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>disk</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>base_vfs</name></name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="string">"unix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>base_vfs</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Release the memory used internally by the VFS object.
 *
 * All file content will be de-allocated, so dangling open FDs against
 * those files will be broken.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDestroy</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>n_databases</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>databases</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>vfsDatabaseDestroy</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>r</name><operator>-&gt;</operator><name>databases</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>r</name><operator>-&gt;</operator><name>databases</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>vfsFilenameEndsWith</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n_filename</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n_suffix</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>n_suffix</name> <operator>&gt;</operator> <name>n_filename</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>n_filename</name> <operator>-</operator> <name>n_suffix</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>n_suffix</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find the database object associated with the given filename. */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>vfsDatabaseLookup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>,
					     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>filename</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-wal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>-=</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"-wal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-journal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>n</name> <operator>-=</operator> <call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"-journal"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>v</name><operator>-&gt;</operator><name>n_databases</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>databases</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>database</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<comment type="line">// Found matching file.</comment>
			<return>return <expr><name>database</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDeleteDatabase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>n_databases</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name> <init>= <expr><name><name>r</name><operator>-&gt;</operator><name>databases</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>database</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Free all memory allocated for this file. */</comment>
		<expr_stmt><expr><call><name>vfsDatabaseDestroy</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Shift all other contents objects. */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>r</name><operator>-&gt;</operator><name>n_databases</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>databases</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>r</name><operator>-&gt;</operator><name>databases</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>n_databases</name></name><operator>--</operator></expr>;</expr_stmt>

		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
	<return>return <expr><name>SQLITE_IOERR_DELETE_NOENT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Close the actual temporary file. */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>f</name><operator>-&gt;</operator><name>temp</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vfsDeleteDatabase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read data from the main database. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDatabaseRead</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
			   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
			   <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>pgno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If the main database file is not empty, we expect the
	 * page size to have been set by an initial write. */</comment>
	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Reading from page 1. We expect the read to be
		 * at most page_size bytes. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&lt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* For pages greater than 1, we expect a full
		 * page read, with an offset that starts exectly
		 * at the page boundary. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>offset</name> <operator>%</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pgno</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pgno</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <call><name>vfsDatabasePageLookup</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgno</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Read the desired part of page 1. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>page</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* Read the full page. */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Get the page size stored in the WAL header. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsWalGetPageSize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* The page size is stored in the 4 bytes starting at 8
	 * (big-endian) */</comment>
	<return>return <expr><call><name>vfsParsePageSize</name><argument_list>(<argument><expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Read data from the WAL. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalRead</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>,
		      <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
		      <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
		      <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Read the header. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>==</operator> <name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsWalGetPageSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* For any other frame, we expect either a header read,
	 * a checksum read, a page read or a full frame read. */</comment>
	<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name><operator>)</operator> <operator>%</operator>
			<operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>formatWalCalcFrameIndex</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>amount</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* Read the checksum from the WAL
			 * header. */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_OK</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <literal type="number">16</literal> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name><operator>)</operator> <operator>%</operator>
			<operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <literal type="number">16</literal> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name><operator>)</operator> <operator>/</operator>
			    <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator><operator>)</operator> <operator>+</operator>
			<literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>amount</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name> <operator>-</operator>
			 <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator> <operator>%</operator>
			<operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>formatWalCalcFrameIndex</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>==</operator> <operator>(</operator><name>FORMAT__WAL_FRAME_HDR_SIZE</name> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>formatWalCalcFrameIndex</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="line">// This is an attempt to read a page that was</comment>
		<comment type="line">// never written.</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>vfsWalFrameLookup</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>frame</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="line">// Again, the requested page doesn't exist.</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_IOERR_SHORT_READ</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>amount</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>header</name></name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>amount</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>page</name></name></expr></argument>,
		       <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
		       <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
		       <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
		       <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Read from the actual temporary file. */</comment>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>temp</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDatabaseRead</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* From SQLite docs:
	 *
	 *   If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
	 *   in the unread portions of the buffer with zeros.  A VFS that
	 *   fails to zero-fill short reads might seem to work.  However,
	 *   failure to zero-fill short reads will eventually lead to
	 *   database corruption.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>SQLITE_IOERR_SHORT_READ</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDatabaseWrite</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
			    <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			    <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
			    <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>pgno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This is the first database page. We expect
		 * the data to contain at least the header. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;=</operator> <name>FORMAT__DB_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Extract the page size from the header. */</comment>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsParsePageSize</name><argument_list>(<argument><expr><call><name>ByteGetBe16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>header</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>page_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>pgno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The header must have been written and the page size set. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* For pages beyond the first we expect offset to be a multiple
		 * of the page size. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><name>offset</name> <operator>%</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We expect that SQLite writes a page at time. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>pgno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>offset</name> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vfsDatabaseGetPage</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><name>pgno</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalWrite</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>,
		       <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
		       <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
		       <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name></decl>;</decl_stmt>

	<comment type="block">/* WAL header. */</comment>
	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<comment type="block">/* We expect the data to contain exactly 32
		 * bytes. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>==</operator> <name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsWalGetPageSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This is a WAL frame write. We expect either a frame
	 * header or page write. */</comment>
	<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Frame header write. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name><operator>)</operator> <operator>%</operator>
			<operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>formatWalCalcFrameIndex</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>vfsWalFrameGet</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>frame</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* Frame page write. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>offset</name> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name> <operator>-</operator>
			 <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator> <operator>%</operator>
			<operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name> <operator>+</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>formatWalCalcFrameIndex</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>page_size</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The header for the this frame must already
		 * have been written, so the page is there. */</comment>
		<expr_stmt><expr><name>frame</name> <operator>=</operator> <call><name>vfsWalFrameLookup</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>frame</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileWrite</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
			<parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Write to the actual temporary file. */</comment>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>temp</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDatabaseWrite</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator>
			    <call><name>vfsWalWrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VFS__JOURNAL</name></expr>:</case>
			<comment type="block">/* Silently swallow writes to the journal */</comment>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDatabaseTruncate</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalTruncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_TRUNCATE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>flags</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_IOERR_FSYNC</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the size of the database file in bytes. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>vfsDatabaseFileSize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>*</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the size of the WAL file in bytes. */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>vfsWalFileSize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
		<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsWalGetPageSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>VFS__WAL_HEADER_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>FORMAT__WAL_FRAME_HDR_SIZE</name> <operator>+</operator> <name>page_size</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__DATABASE</name></expr>:</case>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vfsDatabaseFileSize</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<comment type="block">/* TODO? here we assume that FileSize() is never invoked
			 * between a header write and a page write. */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vfsWalFileSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>n</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Locking a file is a no-op, since no other process has visibility on it. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>lock</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unlocking a file is a no-op, since no other process has visibility on it. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>lock</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* We always report that a lock is held. This routine should be used only in
 * journal mode, so it doesn't matter. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Handle pragma a pragma file control. See the xFileControl
 * docstring in sqlite.h.in for more details. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileControlPragma</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fnctl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>fnctl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <name><name>fnctl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>left</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="string">"page_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* When the user executes 'PRAGMA page_size=N' we save the
		 * size internally.
		 *
		 * The page size must be between 512 and 65536, and be a
		 * power of two. The check below was copied from
		 * sqlite3BtreeSetPageSize in btree.c.
		 *
		 * Invalid sizes are simply ignored, SQLite will do the same.
		 *
		 * It's not possible to change the size after it's set.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>page_size</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>page_size</name> <operator>&gt;=</operator> <name>FORMAT__PAGE_SIZE_MIN</name> <operator>&amp;&amp;</operator>
		    <name>page_size</name> <operator>&lt;=</operator> <name>FORMAT__PAGE_SIZE_MAX</name> <operator>&amp;&amp;</operator>
		    <operator>(</operator><operator>(</operator><name>page_size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;</operator> <name>page_size</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			    <name>page_size</name> <operator>!=</operator>
				<operator>(</operator><name>int</name><operator>)</operator><call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>fnctl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator>
				    <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"changing page size is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="string">"journal_mode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* When the user executes 'PRAGMA journal_mode=x' we ensure
		 * that the desired mode is 'wal'. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="string">"wal"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>fnctl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"only WAL mode is supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We're returning NOTFOUND here to tell SQLite that we wish it to go on
	 * with its own handling as well. If we returned SQLITE_OK the page size
	 * of the journal mode wouldn't be effectively set, as the processing of
	 * the PRAGMA would stop here. */</comment>
	<return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/* Return the page number field stored in the header of the given frame. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsFrameGetPageNumber</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the database size field stored in the header of the given frame. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsFrameGetDatabaseSize</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the checksum-1 field stored in the header of the given frame. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsFrameGetChecksum1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the checksum-2 field stored in the header of the given frame. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsFrameGetChecksum2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Fill the header and the content of a WAL frame. The given checksum is the
 * rolling one of all preceeding frames and is updated by this function. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsFrameFill</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>,
			 <parameter><decl><type><name>uint32_t</name></type> <name>page_number</name></decl></parameter>,
			 <parameter><decl><type><name>uint32_t</name></type> <name>database_size</name></decl></parameter>,
			 <parameter><decl><type><name>uint32_t</name></type> <name><name>salt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>,
			 <parameter><decl><type><name>uint32_t</name></type> <name><name>checksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl></parameter>,
			 <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl></parameter>,
			 <parameter><decl><type><name>uint32_t</name></type> <name>page_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name>page_number</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name>database_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vfsChecksum</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsChecksum</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>salt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>salt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>salt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>salt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name><name>checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name><name>checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>header</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>page</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function modifies part of the WAL index header to reflect the current
 * content of the WAL.
 *
 * It is called in two cases. First, after a write transaction gets completed
 * and the SQLITE_FCNTL_COMMIT_PHASETWO file control op code is triggered, in
 * order to "rewind" the mxFrame and szPage fields of the WAL index header back
 * to when the write transaction started, effectively "shadowing" the
 * transaction, which will be replicated asynchronously. Second, when the
 * replication actually succeeds and dqlite_vfs_apply() is called on the VFS
 * that originated the transaction, in order to make the transaction visible.
 *
 * Note that the hash table contained in the WAL index does not get modified,
 * and even after a rewind following a write transaction it will still contain
 * entries for the frames committed by the transaction. That's safe because
 * mxFrame will make clients ignore those hash table entries. However it means
 * that in case the replication is not actually successful and
 * dqlite_vfs_abort() is called the WAL index must be invalidated.
 **/</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsAmendWalIndexHeader</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>shm</name> <init>= <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>shm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name> <init>= <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>wal</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>frame_checksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>n_pages</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>checksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>wal</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name><name>wal</name><operator>-&gt;</operator><name>frames</name><index>[<expr><name><name>wal</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>frame_checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsFrameGetChecksum1</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame_checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsFrameGetChecksum2</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n_pages</name> <operator>=</operator> <call><name>vfsFrameGetDatabaseSize</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shm</name><operator>-&gt;</operator><name>n_regions</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <name><name>shm</name><operator>-&gt;</operator><name>regions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* index is an alias for shm-&gt;regions[0] which is a void* that points to
	 * memory allocated by `sqlite3_malloc64` and has the required alignment */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator>
			     <operator>==</operator> <name>VFS__WAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* iVersion */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>index</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>                               <comment type="block">/* isInit */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>index</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>==</operator> <name>VFS__BIGENDIAN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>                  <comment type="block">/* bigEndCksum */</comment>

	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name><name>wal</name><operator>-&gt;</operator><name>n_frames</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name>n_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name><name>frame_checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>=</operator> <name><name>frame_checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vfsChecksum</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">40</literal></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">40</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>index</name><index>[<expr><literal type="number">44</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>=</operator> <name><name>checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* Update the second copy of the first part of the WAL index header. */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>index</name> <operator>+</operator> <name>VFS__WAL_INDEX_HEADER_SIZE</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
	       <argument><expr><name>VFS__WAL_INDEX_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* The SQLITE_FCNTL_COMMIT_PHASETWO file control op code is trigged by the
 * SQLite pager after completing a transaction. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileControlCommitPhaseTwo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name> <init>= <expr><operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>wal</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsAmendWalIndexHeader</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VFS__DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SQLITE_FCNTL_PRAGMA</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsFileControlPragma</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SQLITE_FCNTL_COMMIT_PHASETWO</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsFileControlCommitPhaseTwo</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr>:</case>
			<comment type="block">/* This prevents SQLite from deleting the WAL after the
			 * last connection is closed. */</comment>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>arg</name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsShmMap</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
		     <parameter><decl><type><name>unsigned</name></type> <name>region_index</name></decl></parameter>,
		     <parameter><decl><type><name>unsigned</name></type> <name>region_size</name></decl></parameter>,
		     <parameter><decl><type><name>bool</name></type> <name>extend</name></decl></parameter>,
		     <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>region</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>regions</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>region_index</name> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>n_regions</name></name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* The region was already allocated. */</comment>
		<expr_stmt><expr><name>region</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>regions</name><index>[<expr><name>region_index</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>region</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>extend</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>regions</name></decl>;</decl_stmt>

			<comment type="block">/* We should grow the map one region at a time. */</comment>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>region_size</name> <operator>==</operator> <name>VFS__WAL_INDEX_REGION_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>region_index</name> <operator>==</operator> <name><name>s</name><operator>-&gt;</operator><name>n_regions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>region</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>region_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>region</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
				<goto>goto <name>err</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>region</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>region_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>regions</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(
			    <argument><expr><name><name>s</name><operator>-&gt;</operator><name>regions</name></name></expr></argument>,
			    <argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>s</name><operator>-&gt;</operator><name>regions</name></name> <operator>*</operator> <operator>(</operator><name><name>s</name><operator>-&gt;</operator><name>n_regions</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>regions</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
				<goto>goto <name>err_after_region_malloc</name>;</goto>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>regions</name></name> <operator>=</operator> <name>regions</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>regions</name><index>[<expr><name>region_index</name></expr>]</index></name> <operator>=</operator> <name>region</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>n_regions</name></name><operator>++</operator></expr>;</expr_stmt>

		</block_content>}</block></if> <else>else <block>{<block_content>
			<comment type="block">/* The region was not allocated and we don't have to
			 * extend the map. */</comment>
			<expr_stmt><expr><name>region</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>region</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>region_index</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>region</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>err_after_region_malloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>!=</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>out</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Simulate shared memory by allocating on the C heap. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileShmMap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <comment type="block">/* Handle open on database file */</comment>
			 <parameter><decl><type><name>int</name></type> <name>region_index</name></decl></parameter>,   <comment type="block">/* Region to retrieve */</comment>
			 <parameter><decl><type><name>int</name></type> <name>region_size</name></decl></parameter>,    <comment type="block">/* Size of regions */</comment>
			 <parameter><decl><type><name>int</name></type> <name>extend</name></decl></parameter>, <comment type="block">/* True to extend file if necessary */</comment>
			 <parameter><decl><type><name>void</name> <specifier>volatile</specifier> <modifier>*</modifier><modifier>*</modifier></type><name>out</name></decl></parameter> <comment type="block">/* OUT: Mapped memory */</comment>
)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VFS__DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>vfsShmMap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>shm</name></name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>region_index</name></expr></argument>,
			 <argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>region_size</name></expr></argument>, <argument><expr><name>extend</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsShmLock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_EXCLUSIVE</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* No shared or exclusive lock must be held in the region. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ofst</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ofst</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>shared</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"EXCLUSIVE lock contention ofst:%d n:%d exclusive[%d]=%d shared[%d]=%d"</literal></expr></argument>,
			                <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>shared</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ofst</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ofst</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* No exclusive lock must be held in the region. */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ofst</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ofst</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"SHARED lock contention ofst:%d n:%d exclusive[%d]=%d shared[%d]=%d"</literal></expr></argument>,
			                <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>shared</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>SQLITE_BUSY</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ofst</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ofst</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>shared</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsShmUnlock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>these_locks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>other_locks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_SHARED</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>these_locks</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>shared</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>other_locks</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>exclusive</name></name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>these_locks</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>exclusive</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>other_locks</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>shared</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>ofst</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ofst</name> <operator>+</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<comment type="block">/* Coherence check that no lock of the other type is held in this
		 * region. */</comment>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>other_locks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Only decrease the lock count if it's positive. In other words
		 * releasing a never acquired lock is legal and idemponent. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>these_locks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>these_locks</name><index>[<expr><name>i</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* If there's a uncommitted transaction, roll it back. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsWalRollbackIfUncommitted</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>commit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

        <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"rollback n_tx:%d"</literal></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>vfsFrameGetDatabaseSize</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>commit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
                <expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"rollback commit:%u"</literal></expr></argument>, <argument><expr><name>commit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileShmLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ofst</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>shm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ofst</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Legal values for the offset and the range */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ofst</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ofst</name> <operator>+</operator> <name>n</name> <operator>&lt;=</operator> <name>SQLITE_SHM_NLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Legal values for the flags.
	 *
	 * See https://sqlite.org/c3ref/c_shm_exclusive.html. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flags</name> <operator>==</operator> <operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name><operator>)</operator> <operator>||</operator>
	       <name>flags</name> <operator>==</operator> <operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator> <operator>||</operator>
	       <name>flags</name> <operator>==</operator> <operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_SHARED</name><operator>)</operator> <operator>||</operator>
	       <name>flags</name> <operator>==</operator> <operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* This is a no-op since shared-memory locking is relevant only for
	 * inter-process concurrency. See also the unix-excl branch from
	 * upstream (git commit cda6b3249167a54a0cf892f949d52760ee557129). */</comment>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VFS__DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shm</name> <operator>=</operator> <operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>shm</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_SHM_UNLOCK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsShmUnlock</name><argument_list>(<argument><expr><name>shm</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsShmLock</name><argument_list>(<argument><expr><name>shm</name></expr></argument>, <argument><expr><name>ofst</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>SQLITE_OK</name> <operator>&amp;&amp;</operator> <name>ofst</name> <operator>==</operator> <name>VFS__WAL_WRITE_LOCK</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* When acquiring the write lock, make sure there's no
		 * transaction that hasn't been rolled back or polled. */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <operator>(</operator><name>SQLITE_SHM_LOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>wal</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* When releasing the write lock, if we find a pending
		 * uncommitted transaction then a rollback must have occurred.
		 * In that case we delete the pending transaction. */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <operator>(</operator><name>SQLITE_SHM_UNLOCK</name> <operator>|</operator> <name>SQLITE_SHM_EXCLUSIVE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>vfsWalRollbackIfUncommitted</name><argument_list>(<argument><expr><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsFileShmBarrier</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>file</name></expr>;</expr_stmt>
	<comment type="block">/* This is a no-op since we expect SQLite to be compiled with mutex
	 * support (i.e. SQLITE_MUTEX_OMIT or SQLITE_MUTEX_NOOP are *not*
	 * defined, see sqliteInt.h). */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsShmUnmap</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>s</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsShmReset</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFileShmUnmap</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delete_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>delete_flag</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsShmUnmap</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>shm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name></type> <name>vfsFileMethods</name> <init>= <expr><block>{
    <expr><literal type="number">2</literal></expr>,                             <comment type="line">// iVersion</comment>
    <expr><name>vfsFileClose</name></expr>,                  <comment type="line">// xClose</comment>
    <expr><name>vfsFileRead</name></expr>,                   <comment type="line">// xRead</comment>
    <expr><name>vfsFileWrite</name></expr>,                  <comment type="line">// xWrite</comment>
    <expr><name>vfsFileTruncate</name></expr>,               <comment type="line">// xTruncate</comment>
    <expr><name>vfsFileSync</name></expr>,                   <comment type="line">// xSync</comment>
    <expr><name>vfsFileSize</name></expr>,                   <comment type="line">// xFileSize</comment>
    <expr><name>vfsFileLock</name></expr>,                   <comment type="line">// xLock</comment>
    <expr><name>vfsFileUnlock</name></expr>,                 <comment type="line">// xUnlock</comment>
    <expr><name>vfsFileCheckReservedLock</name></expr>,      <comment type="line">// xCheckReservedLock</comment>
    <expr><name>vfsFileControl</name></expr>,                <comment type="line">// xFileControl</comment>
    <expr><name>vfsFileSectorSize</name></expr>,             <comment type="line">// xSectorSize</comment>
    <expr><name>vfsFileDeviceCharacteristics</name></expr>,  <comment type="line">// xDeviceCharacteristics</comment>
    <expr><name>vfsFileShmMap</name></expr>,                 <comment type="line">// xShmMap</comment>
    <expr><name>vfsFileShmLock</name></expr>,                <comment type="line">// xShmLock</comment>
    <expr><name>vfsFileShmBarrier</name></expr>,             <comment type="line">// xShmBarrier</comment>
    <expr><name>vfsFileShmUnmap</name></expr>,               <comment type="line">// xShmUnmap</comment>
    <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Create a database object and add it to the databases array. */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>vfsCreateDatabase</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name> <init>= <expr><name><name>v</name><operator>-&gt;</operator><name>n_databases</name></name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>databases</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a new entry. */</comment>
	<expr_stmt><expr><name>databases</name> <operator>=</operator> <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>databases</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>databases</name> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>databases</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>databases</name></name> <operator>=</operator> <name>databases</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom_after_database_malloc</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vfsDatabaseInit</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>databases</name><index>[<expr><name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>d</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>n_databases</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

	<return>return <expr><name>d</name></expr>;</return>

<label><name>oom_after_database_malloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>oom</name>:</label>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
		   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
		   <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
		   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>vfsFileType</name></name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exclusive</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_EXCLUSIVE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>create</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_CREATE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>out_flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* From sqlite3.h.in:
	 *
	 *   The SQLITE_OPEN_EXCLUSIVE flag is always used in conjunction with
	 *   the SQLITE_OPEN_CREATE flag, which are both directly analogous to
	 *   the O_EXCL and O_CREAT flags of the POSIX open() API.  The
	 *   SQLITE_OPEN_EXCLUSIVE flag, when paired with the
	 *   SQLITE_OPEN_CREATE, is used to indicate that file should always be
	 *   created, and that it is an error if it already exists.  It is not
	 *   used to indicate the file should be opened for exclusive access.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>exclusive</name> <operator>||</operator> <name>create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr>;</expr_stmt>

	<comment type="block">/* This tells SQLite to not call Close() in case we return an error. */</comment>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Save the flags */</comment>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<comment type="block">/* From SQLite documentation:
	 *
	 * If the zFilename parameter to xOpen is a NULL pointer then xOpen
	 * must invent its own temporary name for the file. Whenever the
	 * xFilename parameter is NULL it will also be the case that the
	 * flags parameter will include SQLITE_OPEN_DELETEONCLOSE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Open an actual temporary file. */</comment>
		<expr_stmt><expr><name>vfs</name> <operator>=</operator> <call><name>sqlite3_vfs_find</name><argument_list>(<argument><expr><literal type="string">"unix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>vfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>out_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>vfsFileMethods</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>vfs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Search if the database object exists already. */</comment>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exists</name> <operator>=</operator> <name>database</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_DB</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VFS__DATABASE</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_JOURNAL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VFS__JOURNAL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_WAL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VFS__WAL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If file exists, and the exclusive flag is on, return an error. */</comment>
	<if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator> <name>exclusive</name> <operator>&amp;&amp;</operator> <name>create</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>VFS__DATABASE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>EEXIST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* When opening a WAL or journal file we expect the main
		 * database file to have already been created. */</comment>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VFS__WAL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>VFS__JOURNAL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>VFS__DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check the create flag. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsCreateDatabase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Populate the new file handle. */</comment>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>vfsFileMethods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>vfs</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name> <operator>=</operator> <name>database</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir_sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dir_sync</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-journal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-wal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>

	<return>return <expr><call><name>vfsDeleteDatabase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsAccess</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
		     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
		     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
		     <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* If the database object exists, we consider all associated files as
	 * existing and accessible. */</comment>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsFullPathname</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>pathname_len</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>pathname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>

	<comment type="block">/* Just return the path unchanged. */</comment>
	<expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>pathname_len</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>vfsDlOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>filename</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDlError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zErrMsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>sqlite3_snprintf</name><argument_list>(<argument><expr><name>nByte</name></expr></argument>, <argument><expr><name>zErrMsg</name></expr></argument>,
			 <argument><expr><literal type="string">"Loadable extensions are not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>zErrMsg</name><index>[<expr><name>nByte</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <macro><name>void</name> <argument_list>(<argument>*vfsDlSym(sqlite3_vfs *vfs, void *pH, const char *z)</argument>)</argument_list></macro><operator>(</operator><name>void</name><operator>)</operator>
<block>{
	<expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;
	<expr><operator>(</operator><name>void</name><operator>)</operator><name>pH</name></expr>;
	<expr><operator>(</operator><name>void</name><operator>)</operator><name>z</name></expr>;

	<return>return <expr><literal type="number">0</literal></expr>;</return>
}</block></expr></expr_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDlClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>pHandle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>pHandle</name></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsRandomness</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nByte</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>zByte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nByte</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>zByte</name></expr>;</expr_stmt>

	<comment type="block">/* TODO (is this needed?) */</comment>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsSleep</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>microseconds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>

	<comment type="block">/* TODO (is this needed?) */</comment>
	<return>return <expr><name>microseconds</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsCurrentTimeInt64</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>sqlite3_int64</name> <modifier>*</modifier></type><name>piNow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_int64</name></type> <name>unixEpoch</name> <init>=
	    <expr><literal type="number">24405875</literal> <operator>*</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><literal type="number">8640000</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>now</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>piNow</name> <operator>=</operator>
	    <name>unixEpoch</name> <operator>+</operator> <literal type="number">1000</literal> <operator>*</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>+</operator> <name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsCurrentTime</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>piNow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="line">// TODO: check if it's always safe to cast a double* to a</comment>
	<comment type="line">// sqlite3_int64*.</comment>
	<return>return <expr><call><name>vfsCurrentTimeInt64</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><operator>(</operator><name>sqlite3_int64</name> <operator>*</operator><operator>)</operator><name>piNow</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsGetLastError</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>vfs</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>x</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>y</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>rc</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>error</name></name></expr>;</expr_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsInit</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sqlite3_vfs</name></name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs init"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>iVersion</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>szOsFile</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>vfsFile</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>mxPathname</name></name> <operator>=</operator> <name>VFS__MAX_PATHNAME</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>pNext</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>=</operator> <call><name>vfsCreate</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xOpen</name></name> <operator>=</operator> <name>vfsOpen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDelete</name></name> <operator>=</operator> <name>vfsDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xAccess</name></name> <operator>=</operator> <name>vfsAccess</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xFullPathname</name></name> <operator>=</operator> <name>vfsFullPathname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlOpen</name></name> <operator>=</operator> <name>vfsDlOpen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlError</name></name> <operator>=</operator> <name>vfsDlError</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlSym</name></name> <operator>=</operator> <name>vfsDlSym</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlClose</name></name> <operator>=</operator> <name>vfsDlClose</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xRandomness</name></name> <operator>=</operator> <name>vfsRandomness</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xSleep</name></name> <operator>=</operator> <name>vfsSleep</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name> <operator>=</operator> <name>vfsCurrentTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xGetLastError</name></name> <operator>=</operator> <name>vfsGetLastError</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name> <operator>=</operator> <name>vfsCurrentTimeInt64</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>zName</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>VfsClose</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sqlite3_vfs</name></name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs close"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>vfsDestroy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalPoll</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>dqlite_vfs_frame</name> <modifier>*</modifier><modifier>*</modifier></type><name>frames</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>commit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>frames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if the last frame in the transaction has the commit marker. */</comment>
	<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>commit</name> <operator>=</operator> <call><name>vfsFrameGetDatabaseSize</name><argument_list>(<argument><expr><name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>commit</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>frames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>frames</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<operator>*</operator><name>frames</name> <operator>*</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>frames</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>dqlite_vfs_frame</name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><operator>*</operator><name>frames</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_number</name> <init>= <expr><call><name>vfsFrameGetPageNumber</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>page</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>frame</name><operator>-&gt;</operator><name>page_number</name></name> <operator>=</operator> <name>page_number</name></expr>;</expr_stmt>
		<comment type="block">/* Release the vfsFrame object, but not its buf attribute, since
		 * responsibility for that memory has been transferred to the
		 * caller. */</comment>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>tx</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsPoll</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
	    <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
	    <parameter><decl><type><name>dqlite_vfs_frame</name> <modifier>*</modifier><modifier>*</modifier></type><name>frames</name></decl></parameter>,
	    <parameter><decl><type><name>unsigned</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs poll filename:%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>shm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DQLITE_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>shm</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>shm</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>wal</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>frames</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalPoll</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><name>frames</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal poll failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If some frames have been written take the write lock. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsShmLock</name><argument_list>(<argument><expr><name>shm</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_SHM_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"shm lock failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>vfsAmendWalIndexHeader</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the salt-1 field stored in the WAL header.*/</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsWalGetSalt1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<comment type="block">/* `hdr` field is pointer aligned, cast is safe */</comment>
	<return>return <expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the salt-2 field stored in the WAL header.*/</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsWalGetSalt2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* `hdr` field is pointer aligned, cast is safe */</comment>
	<return>return <expr><operator>*</operator><operator>(</operator><name>uint32_t</name> <operator>*</operator><operator>)</operator><call><name>__builtin_assume_aligned</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the checksum-1 field stored in the WAL header.*/</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsWalGetChecksum1</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the checksum-2 field stored in the WAL header.*/</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsWalGetChecksum2</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Append the given pages as new frames. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalAppend</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>,
			<parameter><decl><type><name>unsigned</name></type> <name>database_n_pages</name></decl></parameter>,
			<parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>,
			<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>page_numbers</name></decl></parameter>,
			<parameter><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>pages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>frames</name></decl>;</decl_stmt> <comment type="block">/* New frames array. */</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>database_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>salt</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>checksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* No pending transactions. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsWalGetPageSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the salt from the WAL header. */</comment>
	<expr_stmt><expr><name><name>salt</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsWalGetSalt1</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>salt</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsWalGetSalt2</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there are currently no frames in the WAL, the starting database
	 * size will be equal to the current number of pages in the main
	 * database, and the starting checksum should be set to the one stored
	 * in the WAL header. Otherwise, the starting database size and checksum
	 * will be the ones stored in the last frame of the WAL. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>database_size</name> <operator>=</operator> <operator>(</operator><name>uint32_t</name><operator>)</operator><name>database_n_pages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsWalGetChecksum1</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsWalGetChecksum2</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>frames</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsFrameGetChecksum1</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>vfsFrameGetChecksum2</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>database_size</name> <operator>=</operator> <call><name>vfsFrameGetDatabaseSize</name><argument_list>(<argument><expr><name>frame</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>frames</name> <operator>=</operator>
	    <call><name>sqlite3_realloc64</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>frames</name> <operator>*</operator> <operator>(</operator><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+</operator> <name>n</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>frames</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name> <operator>=</operator> <name>frames</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><call><name>vfsFrameCreate</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_number</name> <init>= <expr><operator>(</operator><name>uint32_t</name><operator>)</operator><name><name>page_numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32_t</name></type> <name>commit</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name> <init>= <expr><operator>&amp;</operator><name><name>pages</name><index>[<expr><name>i</name> <operator>*</operator> <name>page_size</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>frame</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<goto>goto <name>oom_after_frames_alloc</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>page_number</name> <operator>&gt;</operator> <name>database_size</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>database_size</name> <operator>=</operator> <name>page_number</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* For commit records, the size of the database file in pages
		 * after the commit. For all other records, zero. */</comment>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>commit</name> <operator>=</operator> <name>database_size</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>vfsFrameFill</name><argument_list>(<argument><expr><name>frame</name></expr></argument>, <argument><expr><name>page_number</name></expr></argument>, <argument><expr><name>commit</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>page</name></expr></argument>,
			     <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>frames</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>frame</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>oom_after_frames_alloc</name>:</label>
	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><name><name>frames</name><index>[<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>+</operator> <name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
<label><name>oom</name>:</label>
	<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Write the header of a brand new WAL file image. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsWalStartHeader</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>page_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name><name>checksum</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<comment type="block">/* SQLite calculates checksums for the WAL header and frames either
	 * using little endian or big endian byte order when adding up 32-bit
	 * words. The byte order that should be used is recorded in the WAL file
	 * header by setting the least significant bit of the magic value stored
	 * in the first 32 bits. This allows portability of the WAL file across
	 * hosts with different native byte order.
	 *
	 * When creating a brand new WAL file, SQLite will set the byte order
	 * bit to match the host's native byte order, so checksums are a bit
	 * more efficient.
	 *
	 * In Dqlite the WAL file image is always generated at run time on the
	 * host, so we can always use the native byte order. */</comment>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name>VFS__WAL_MAGIC</name> <operator>|</operator> <name>VFS__BIGENDIAN</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name>VFS__WAL_VERSION</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>sqlite3_randomness</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>w</name><operator>-&gt;</operator><name>hdr</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsChecksum</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name><name>checksum</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name> <operator>+</operator> <literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BytePutBe32</name><argument_list>(<argument><expr><name><name>checksum</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name> <operator>+</operator> <literal type="number">28</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Invalidate the WAL index header, forcing the next connection that tries to
 * start a read transaction to rebuild the WAL index by reading the WAL.
 *
 * No read or write lock must be currently held. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsInvalidateWalIndexHeader</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>shm</name> <init>= <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>shm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>header</name> <init>= <expr><name><name>shm</name><operator>-&gt;</operator><name>regions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SQLITE_SHM_NLOCK</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shm</name><operator>-&gt;</operator><name>shared</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>shm</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* The walIndexTryHdr function in sqlite/wal.c (which is indirectly
	 * called by sqlite3WalBeginReadTransaction), compares the first and
	 * second copy of the WAL index header to see if it is valid. Changing
	 * the first byte of each of the two copies is enough to make the check
	 * fail. */</comment>
	<expr_stmt><expr><name><name>header</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>header</name><index>[<expr><name>VFS__WAL_INDEX_HEADER_SIZE</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsApply</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
	     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
	     <parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>,
	     <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>page_numbers</name></decl></parameter>,
	     <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>frames</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs apply filename %s n %u"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsShm</name></name> <modifier>*</modifier></type><name>shm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>database</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shm</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>shm</name></name></expr>;</expr_stmt>

	<comment type="block">/* If there's no page size set in the WAL header, it must mean that WAL
	 * file was never written. In that case we need to initialize the WAL
	 * header. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>vfsWalGetPageSize</name><argument_list>(<argument><expr><name>wal</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>vfsWalStartHeader</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalAppend</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><name><name>database</name><operator>-&gt;</operator><name>n_pages</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>page_numbers</name></expr></argument>, <argument><expr><name>frames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal append failed rv:%d n_pages:%u n:%u"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>, <argument><expr><name><name>database</name><operator>-&gt;</operator><name>n_pages</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If a write lock is held it means that this is the VFS that orginated
	 * this commit and on which dqlite_vfs_poll() was called. In that case
	 * we release the lock and update the WAL index.
	 *
	 * Otherwise, if the WAL index header is mapped it means that this VFS
	 * has one or more open connections even if it's not the one that
	 * originated the transaction (this can happen for example when applying
	 * a Raft barrier and replaying the Raft log in order to serve a request
	 * of a newly connected client). */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>shm</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>shm</name><operator>-&gt;</operator><name>exclusive</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>vfsAmendWalIndexHeader</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>shm</name><operator>-&gt;</operator><name>n_regions</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>vfsInvalidateWalIndexHeader</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsAbort</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs abort filename %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"database: %s does not exist"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DQLITE_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsShmUnlock</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>shm</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>SQLITE_SHM_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"shm unlock failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Extract the number of pages field from the database header. */</comment>
<function><type><specifier>static</specifier> <name>uint32_t</name></type> <name>vfsDatabaseGetNumberOfPages</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* The page size is stored in the 16th and 17th bytes of the first
	 * database page (big-endian) */</comment>
	<return>return <expr><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsDatabaseNumPages</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
		        <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>,
		        <parameter><decl><type><name>uint32_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>vfsDatabaseGetNumberOfPages</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDatabaseSnapshot</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>==</operator> <call><name>vfsDatabaseGetNumberOfPages</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>cursor</name> <operator>+=</operator> <name>page_size</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsWalSnapshot</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>cursor</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>cursor</name> <operator>+=</operator> <name>VFS__WAL_HEADER_SIZE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsWalGetPageSize</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><name><name>w</name><operator>-&gt;</operator><name>frames</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>cursor</name> <operator>+=</operator> <name>FORMAT__WAL_FRAME_HDR_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>cursor</name></expr></argument>, <argument><expr><name><name>frame</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>cursor</name> <operator>+=</operator> <name>page_size</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsSnapshot</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs snapshot filename %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>database</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>!=</operator> <call><name>vfsDatabaseGetNumberOfPages</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"corrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>vfsDatabaseFileSize</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>vfsWalFileSize</name><argument_list>(<argument><expr><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* TODO: we should fix the tests and use sqlite3_malloc instead. */</comment>
	<expr_stmt><expr><operator>*</operator><name>data</name> <operator>=</operator> <call><name>raft_malloc</name><argument_list>(<argument><expr><operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <operator>*</operator><name>data</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>vfsDatabaseSnapshot</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsWalSnapshot</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsDatabaseShallowSnapshot</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name> <modifier>*</modifier></type><name>bufs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fill the buffers with pointers to all of the database pages */</comment>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base</name> <operator>=</operator> <name><name>d</name><operator>-&gt;</operator><name>pages</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>page_size</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsShallowSnapshot</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name></type> <name><name>bufs</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>uint32_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs snapshot filename %s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>database</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>!=</operator> <call><name>vfsDatabaseGetNumberOfPages</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"corrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_CORRUPT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>database</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>!=</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"not enough buffers provided"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_MISUSE</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy WAL to last buffer. */</comment>
	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <call><name>vfsWalFileSize</name><argument_list>(<argument><expr><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* WAL can have 0 length! */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>bufs</name><index>[<expr><name>n</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsWalSnapshot</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy page pointers to first n-1 buffers */</comment>
	<expr_stmt><expr><call><name>vfsDatabaseShallowSnapshot</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>bufs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDatabaseRestore</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
			      <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
			      <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name> <init>= <expr><call><name>vfsParsePageSize</name><argument_list>(<argument><expr><call><name>ByteGetBe16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check that the page size of the snapshot is consistent with what we
	 * have here. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n_pages</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>n_pages</name> <operator>*</operator> <name>page_size</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>DQLITE_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>pages</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>pages</name> <operator>*</operator> <name>n_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>pages</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_pages</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>page</name> <init>= <expr><call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>page</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>pages</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<goto>goto <name>oom_after_pages_alloc</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>pages</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>page</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><name>i</name> <operator>*</operator> <name>page_size</name></expr>]</index></name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Truncate any existing content. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDatabaseTruncate</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>pages</name></name> <operator>=</operator> <name>pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>=</operator> <name>n_pages</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>oom_after_pages_alloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>oom</name>:</label>
	<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsWalRestore</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>w</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
			 <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>,
			 <parameter><decl><type><name>uint32_t</name></type> <name>page_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>frames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_frames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>n_tx</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;</operator> <name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name><operator>)</operator> <operator>%</operator> <call><name>vfsFrameSize</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n_frames</name> <operator>=</operator>
	    <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><operator>(</operator><name>n</name> <operator>-</operator> <name>VFS__WAL_HEADER_SIZE</name><operator>)</operator> <operator>/</operator> <call><name>vfsFrameSize</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>frames</name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>frames</name> <operator>*</operator> <name>n_frames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>frames</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<goto>goto <name>oom</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_frames</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>vfsFrame</name></name> <modifier>*</modifier></type><name>frame</name> <init>= <expr><call><name>vfsFrameCreate</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>frame</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>unsigned</name></type> <name>j</name></decl>;</decl_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
				<expr_stmt><expr><call><name>vfsFrameDestroy</name><argument_list>(<argument><expr><name><name>frames</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<goto>goto <name>oom_after_frames_alloc</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>frames</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>frame</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><index>[<expr><name>VFS__WAL_HEADER_SIZE</name> <operator>+</operator> <name>i</name> <operator>*</operator> <call><name>vfsFrameSize</name><argument_list>(<argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>header</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>VFS__FRAME_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>frame</name><operator>-&gt;</operator><name>page</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>VFS__FRAME_HEADER_SIZE</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>w</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>VFS__WAL_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalTruncate</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rv</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>frames</name></name> <operator>=</operator> <name>frames</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>w</name><operator>-&gt;</operator><name>n_frames</name></name> <operator>=</operator> <name>n_frames</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>oom_after_frames_alloc</name>:</label>
	<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name>frames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>oom</name>:</label>
	<return>return <expr><name>DQLITE_NOMEM</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsRestore</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
	       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
	       <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
	       <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs restore filename %s size %zd"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>database</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>

	<comment type="block">/* Truncate any existing content. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalTruncate</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal truncate failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore the content of the main database and of the WAL. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDatabaseRestore</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"database restore failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <name><name>database</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>*</operator> <name>page_size</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalRestore</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal restore failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/******************************************************************************
 Disk-based VFS
 *****************************************************************************/</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileClose</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Close the actual temporary file. */</comment>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>f</name><operator>-&gt;</operator><name>temp</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rc</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xClose</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>vfsDeleteDatabase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileRead</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
		       	   <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
		           <parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
		           <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Read from the actual temporary file. */</comment>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>temp</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Read from the actual database file. */</comment>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xRead</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalRead</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VFS__JOURNAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>vfs</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>disk</name></name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_READ</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* From SQLite docs:
	 *
	 *   If xRead() returns SQLITE_IOERR_SHORT_READ it must also fill
	 *   in the unread portions of the buffer with zeros.  A VFS that
	 *   fails to zero-fill short reads might seem to work.  However,
	 *   failure to zero-fill short reads will eventually lead to
	 *   database corruption.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>SQLITE_IOERR_SHORT_READ</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>amount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Need to keep track of the number of database pages to allow creating correct
 * WAL headers when in on-disk mode. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskDatabaseTrackNumPages</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
		       		        <parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>pgno</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>pgno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>page_size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>-&gt;</operator><name>page_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>SQLITE_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>pgno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>offset</name> <operator>/</operator> <name><name>d</name><operator>-&gt;</operator><name>page_size</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pgno</name> <operator>&gt;</operator> <name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>=</operator> <name>pgno</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileWrite</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>amount</name></decl></parameter>,
			<parameter><decl><type><name>sqlite_int64</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>


	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>amount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Write to the actual temporary file. */</comment>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>temp</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Write to the actual database file. */</comment>
		<expr_stmt><expr><call><name>vfsDiskDatabaseTrackNumPages</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xWrite</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfsDiskFileWrite %s amount:%d rv:%d"</literal></expr></argument>, <argument><expr><literal type="string">"db"</literal></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator>
			    <call><name>vfsWalWrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>amount</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VFS__JOURNAL</name></expr>:</case>
			<comment type="block">/* Silently swallow writes to the journal */</comment>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_WRITE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileTruncate</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xTruncate</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalTruncate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR_TRUNCATE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileSync</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSync</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>SQLITE_IOERR_FSYNC</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>sqlite_int64</name> <modifier>*</modifier></type><name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileSize</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>VFS__WAL</name></expr>:</case>
			<comment type="block">/* TODO? here we assume that FileSize() is never invoked
			 * between a header write and a page write. */</comment>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vfsWalFileSize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>size</name> <operator>=</operator> <operator>(</operator><name>sqlite3_int64</name><operator>)</operator><name>n</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Locking a file is a no-op, since no other process has visibility on it,
 * unless the database resides on disk. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xLock</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Unlocking a file is a no-op, since no other process has visibility on it,
 * unless the database resides on disk. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileUnlock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xUnlock</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* We always report that a lock is held. This routine should be used only in
 * journal mode, so it doesn't matter.
 * TODO does this need to be treated differently in disk-mode?
 * */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileCheckReservedLock</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>file</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Handle pragma a pragma file control. See the xFileControl
 * docstring in sqlite.h.in for more details. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileControlPragma</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnctl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>fnctl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>fnctl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <name><name>fnctl</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>left</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="string">"page_size"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right</name></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>page_size</name> <init>= <expr><call><name>atoi</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* The first page_size pragma sets page_size member of the db
		 * and is called by dqlite based on the page_size configuration.
		 * Only used for on-disk databases.
		 * */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>fnctl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"no DB file found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>page_size</name> <operator>&gt;</operator> <name>UINT16_MAX</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>fnctl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"max page_size exceeded"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>page_size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xFileControl</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>SQLITE_FCNTL_PRAGMA</name></expr></argument>, <argument><expr><name>fnctl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>SQLITE_NOTFOUND</name> <operator>||</operator> <name>rv</name> <operator>==</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>page_size</name></name> <operator>=</operator> <operator>(</operator><name>uint16_t</name><operator>)</operator><name>page_size</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>rv</name></expr>;</return>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>uint16_t</name><operator>)</operator><name>page_size</name> <operator>!=</operator> <name><name>f</name><operator>-&gt;</operator><name>database</name><operator>-&gt;</operator><name>page_size</name></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>fnctl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"changing page size is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="string">"journal_mode"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* When the user executes 'PRAGMA journal_mode=x' we ensure
		 * that the desired mode is 'wal'. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcasecmp</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="string">"wal"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>fnctl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>sqlite3_mprintf</name><argument_list>(<argument><expr><literal type="string">"only WAL mode is supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_IOERR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We're returning NOTFOUND here to tell SQLite that we wish it to go on
	 * with its own handling as well. If we returned SQLITE_OK the page size
	 * of the journal mode wouldn't be effectively set, as the processing of
	 * the PRAGMA would stop here. */</comment>
	<return>return <expr><name>SQLITE_NOTFOUND</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileControl</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>VFS__DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>SQLITE_FCNTL_PRAGMA</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDiskFileControlPragma</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SQLITE_FCNTL_COMMIT_PHASETWO</name></expr>:</case>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsFileControlCommitPhaseTwo</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>SQLITE_FCNTL_PERSIST_WAL</name></expr>:</case>
			<comment type="block">/* This prevents SQLite from deleting the WAL after the
			 * last connection is closed. */</comment>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>arg</name><operator>)</operator> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_OK</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileSectorSize</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xSectorSize</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskFileDeviceCharacteristics</name><parameter_list>(<parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><call><name><name>f</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>pMethods</name><operator>-&gt;</operator><name>xDeviceCharacteristics</name></name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>sqlite3_io_methods</name></type> <name>vfsDiskFileMethods</name> <init>= <expr><block>{
    <expr><literal type="number">2</literal></expr>,                                 <comment type="line">// iVersion</comment>
    <expr><name>vfsDiskFileClose</name></expr>,                  <comment type="line">// xClose</comment>
    <expr><name>vfsDiskFileRead</name></expr>,                   <comment type="line">// xRead</comment>
    <expr><name>vfsDiskFileWrite</name></expr>,                  <comment type="line">// xWrite</comment>
    <expr><name>vfsDiskFileTruncate</name></expr>,               <comment type="line">// xTruncate</comment>
    <expr><name>vfsDiskFileSync</name></expr>,                   <comment type="line">// xSync</comment>
    <expr><name>vfsDiskFileSize</name></expr>,                   <comment type="line">// xFileSize</comment>
    <expr><name>vfsDiskFileLock</name></expr>,                   <comment type="line">// xLock</comment>
    <expr><name>vfsDiskFileUnlock</name></expr>,                 <comment type="line">// xUnlock</comment>
    <expr><name>vfsDiskFileCheckReservedLock</name></expr>,      <comment type="line">// xCheckReservedLock</comment>
    <expr><name>vfsDiskFileControl</name></expr>,                <comment type="line">// xFileControl</comment>
    <expr><name>vfsDiskFileSectorSize</name></expr>,             <comment type="line">// xSectorSize</comment>
    <expr><name>vfsDiskFileDeviceCharacteristics</name></expr>,  <comment type="line">// xDeviceCharacteristics</comment>
    <expr><name>vfsFileShmMap</name></expr>,                     <comment type="line">// xShmMap</comment>
    <expr><name>vfsFileShmLock</name></expr>,                    <comment type="line">// xShmLock</comment>
    <expr><name>vfsFileShmBarrier</name></expr>,                 <comment type="line">// xShmBarrier</comment>
    <expr><name>vfsFileShmUnmap</name></expr>,                   <comment type="line">// xShmUnmap</comment>
    <expr><literal type="number">0</literal></expr>,
    <expr><literal type="number">0</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskOpen</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
		   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
		   <parameter><decl><type><name>sqlite3_file</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
		   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>out_flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsFile</name></name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>enum</name> <name>vfsFileType</name></name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>exclusive</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_EXCLUSIVE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>create</name> <init>= <expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_CREATE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"filename:%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>out_flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>file</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* From sqlite3.h.in:
	 *
	 *   The SQLITE_OPEN_EXCLUSIVE flag is always used in conjunction with
	 *   the SQLITE_OPEN_CREATE flag, which are both directly analogous to
	 *   the O_EXCL and O_CREAT flags of the POSIX open() API.  The
	 *   SQLITE_OPEN_EXCLUSIVE flag, when paired with the
	 *   SQLITE_OPEN_CREATE, is used to indicate that file should always be
	 *   created, and that it is an error if it already exists.  It is not
	 *   used to indicate the file should be opened for exclusive access.
	 */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><operator>!</operator><name>exclusive</name> <operator>||</operator> <name>create</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>(</operator>struct <name>vfsFile</name> <operator>*</operator><operator>)</operator><name>file</name></expr>;</expr_stmt>

	<comment type="block">/* This tells SQLite to not call Close() in case we return an error. */</comment>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Save the flags */</comment>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>

	<comment type="block">/* From SQLite documentation:
	 *
	 * If the zFilename parameter to xOpen is a NULL pointer then xOpen
	 * must invent its own temporary name for the file. Whenever the
	 * xFilename parameter is NULL it will also be the case that the
	 * flags parameter will include SQLITE_OPEN_DELETEONCLOSE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>filename</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_DELETEONCLOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Open an actual temporary file. */</comment>
		<expr_stmt><expr><name>vfs</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>base_vfs</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>vfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>out_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>temp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>vfsDiskFileMethods</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>vfs</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Search if the database object exists already. */</comment>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>exists</name> <operator>=</operator> <name>database</name> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_DB</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VFS__DATABASE</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_MAIN_JOURNAL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VFS__JOURNAL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>SQLITE_OPEN_WAL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>type</name> <operator>=</operator> <name>VFS__WAL</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
		<return>return <expr><name>SQLITE_CANTOPEN</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If file exists, and the exclusive flag is on, return an error. */</comment>
	<if_stmt><if>if <condition>(<expr><name>exists</name> <operator>&amp;&amp;</operator> <name>exclusive</name> <operator>&amp;&amp;</operator> <name>create</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>VFS__DATABASE</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>EEXIST</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exists</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* When opening a WAL or journal file we expect the main
		 * database file to have already been created. */</comment>
		<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VFS__WAL</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>VFS__JOURNAL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> <operator>==</operator> <name>VFS__DATABASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check the create flag. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>create</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOENT</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsCreateDatabase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>error</name></name> <operator>=</operator> <name>ENOMEM</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>SQLITE_CANTOPEN</name></expr>;</expr_stmt>
			<goto>goto <name>err</name>;</goto>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>VFS__DATABASE</name> <operator>&amp;&amp;</operator> <name><name>v</name><operator>-&gt;</operator><name>disk</name></name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Open an actual database file. */</comment>
		<expr_stmt><expr><name>vfs</name> <operator>=</operator> <name><name>v</name><operator>-&gt;</operator><name>base_vfs</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <call><name>sqlite3_malloc</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>szOsFile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><name>SQLITE_NOMEM</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name><name>vfs</name><operator>-&gt;</operator><name>xOpen</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>out_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>sqlite3_free</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<return>return <expr><name>rc</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Populate the new file handle. */</comment>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>base</name><operator>.</operator><name>pMethods</name></name> <operator>=</operator> <operator>&amp;</operator><name>vfsDiskFileMethods</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>vfs</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>database</name></name> <operator>=</operator> <name>database</name></expr>;</expr_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>

<label><name>err</name>:</label>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>rc</name> <operator>!=</operator> <name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskDelete</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir_sync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>dir_sync</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-journal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-wal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>SQLITE_OK</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDeleteDatabase</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr> )</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>v</name><operator>-&gt;</operator><name>disk</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name><name>v</name><operator>-&gt;</operator><name>base_vfs</name><operator>-&gt;</operator><name>xDelete</name></name><argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>base_vfs</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>dir_sync</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskAccess</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
		     <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
		     <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
		     <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>flags</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>vfs</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* If the database object exists, we consider all associated files as
	 * existing and accessible. */</comment>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-journal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>vfsFilenameEndsWith</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-wal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* dqlite database object exists, now check if the regular SQLite file
		 * exists. */</comment>
		<return>return <expr><call><name><name>v</name><operator>-&gt;</operator><name>base_vfs</name><operator>-&gt;</operator><name>xAccess</name></name><argument_list>(<argument><expr><name>vfs</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>SQLITE_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsEnableDisk</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>sqlite3_vfs</name></name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>v</name><operator>-&gt;</operator><name>disk</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xOpen</name></name> <operator>=</operator> <name>vfsDiskOpen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDelete</name></name> <operator>=</operator> <name>vfsDiskDelete</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xAccess</name></name> <operator>=</operator> <name>vfsDiskAccess</name></expr>;</expr_stmt>
	<comment type="block">/* TODO check if below functions need alteration for on-disk case. */</comment>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xFullPathname</name></name> <operator>=</operator> <name>vfsFullPathname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlOpen</name></name> <operator>=</operator> <name>vfsDlOpen</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlError</name></name> <operator>=</operator> <name>vfsDlError</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlSym</name></name> <operator>=</operator> <name>vfsDlSym</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xDlClose</name></name> <operator>=</operator> <name>vfsDlClose</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xRandomness</name></name> <operator>=</operator> <name>vfsRandomness</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xSleep</name></name> <operator>=</operator> <name>vfsSleep</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xCurrentTime</name></name> <operator>=</operator> <name>vfsCurrentTime</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xGetLastError</name></name> <operator>=</operator> <name>vfsGetLastError</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vfs</name><operator>-&gt;</operator><name>xCurrentTimeInt64</name></name> <operator>=</operator> <name>vfsCurrentTimeInt64</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsDiskSnapshotWal</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Copy WAL to last buffer. */</comment>
	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>vfsWalFileSize</name><argument_list>(<argument><expr><name>wal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>sqlite3_malloc64</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* WAL can have 0 length! */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOMEM</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>vfsWalSnapshot</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsDiskSnapshotDb</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>sb</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_NOTFOUND</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* mmap the database file */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"failed to open %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>fstat</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fstat failed path:%s fd:%d"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* TODO database size limited to whatever fits in a size_t. Multiple
	 * mmap's needed. This limitation also exists in various other places
	 * throughout the codebase. */</comment>
	<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>mmap</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>sb</name><operator>.</operator><name>st_size</name></name></expr></argument>, <argument><expr><name>PROT_READ</name></expr></argument>, <argument><expr><name>MAP_SHARED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>MAP_FAILED</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>SQLITE_IOERR</name></expr>;</expr_stmt>
		<goto>goto <name>err</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name><name>sb</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>err</name>:</label>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>vfsDiskDatabaseRestore</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
			          <parameter><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
			          <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>sz</name></decl>;</decl_stmt> <comment type="block">/* rv of write */</comment>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n_pages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n_left</name></decl>;</decl_stmt> <comment type="block">/* amount of data left to write */</comment>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0600</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fopen failed filename:%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>n_left</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>n_left</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>n_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* sz == 0 should not be possible when writing a positive amount
		 * of bytes. */</comment>
		<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"fwrite failed n:%zd sz:%zd errno:%d"</literal></expr></argument>, <argument><expr><name>n_left</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>rv</name> <operator>=</operator> <name>DQLITE_ERROR</name></expr>;</expr_stmt>
			<goto>goto <name>out</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>n_left</name> <operator>-=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><name>sz</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsParsePageSize</name><argument_list>(<argument><expr><call><name>ByteGetBe16</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>page_size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Check that the page size of the snapshot is consistent with what we
	 * have here. */</comment>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n_pages</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>ByteGetBe32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>n_pages</name></name> <operator>=</operator> <name>n_pages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>page_size</name></name> <operator>=</operator> <name>page_size</name></expr>;</expr_stmt>

<label><name>out</name>:</label>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>rv</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>VfsDiskRestore</name><parameter_list>(<parameter><decl><type><name>sqlite3_vfs</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>,
	       <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
	       <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
	       <parameter><decl><type><name>size_t</name></type> <name>main_size</name></decl></parameter>,
	       <parameter><decl><type><name>size_t</name></type> <name>wal_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"vfs restore path %s main_size %zd wal_size %zd"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>main_size</name></expr></argument>, <argument><expr><name>wal_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfs</name></name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsDatabase</name></name> <modifier>*</modifier></type><name>database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>vfsWal</name></name> <modifier>*</modifier></type><name>wal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32_t</name></type> <name>page_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator>struct <name>vfs</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>vfs</name><operator>-&gt;</operator><name>pAppData</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>database</name> <operator>=</operator> <call><name>vfsDatabaseLookup</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>database</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>wal</name> <operator>=</operator> <operator>&amp;</operator><name><name>database</name><operator>-&gt;</operator><name>wal</name></name></expr>;</expr_stmt>

	<comment type="block">/* Truncate any existing content. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalTruncate</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal truncate failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Restore the content of the main database and of the WAL. */</comment>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsDiskDatabaseRestore</name><argument_list>(<argument><expr><name>database</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>main_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"database restore failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>page_size</name> <operator>=</operator> <call><name>vfsDatabaseGetPageSize</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>vfsWalRestore</name><argument_list>(<argument><expr><name>wal</name></expr></argument>, <argument><expr><name>data</name> <operator>+</operator> <name>main_size</name></expr></argument>, <argument><expr><name>wal_size</name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        	<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"wal restore failed %d"</literal></expr></argument>, <argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>rv</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

</unit>
