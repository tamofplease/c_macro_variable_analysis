<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" xmlns:omp="http://www.srcML.org/srcML/openmp" revision="1.0.0" language="C" filename="/cloned_projects/dqlite/test/lib/munit.c"><comment type="block">/* Copyright (c) 2013-2018 Evan Nemerson &lt;evan@nemerson.com&gt;
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use, copy,
 * modify, merge, publish, distribute, sublicense, and/or sell copies
 * of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */</comment>

<comment type="block" format="doxygen">/*** Configuration ***/</comment>

<comment type="block">/* This is just where the output from the test goes.  It's really just
 * meant to let you choose stdout or stderr, but if anyone really want
 * to direct it to a file let me know, it would be fairly easy to
 * support. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_OUTPUT_FILE</name></cpp:macro> <cpp:value>stdout</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* This is a bit more useful; it tells Âµnit how to format the seconds in
 * timed tests.  If your tests run for longer you might want to reduce
 * it, and if your computer is really fast and your tests are tiny you
 * can increase it. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_TEST_TIME_FORMAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_TEST_TIME_FORMAT</name></cpp:macro> <cpp:value>"0.8f"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If you have long test names you might want to consider bumping
 * this.  The result information takes 43 characters. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_TEST_NAME_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_TEST_NAME_LEN</name></cpp:macro> <cpp:value>37</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* If you don't like the timing information, you can disable it by
 * defining MUNIT_DISABLE_TIMING. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_DISABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_ENABLE_TIMING</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*** End configuration ***/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_C_SOURCE</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_POSIX_C_SOURCE</name> <operator>&lt;</operator> <literal type="number">200809L</literal><operator>)</operator></expr></cpp:if>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>_POSIX_C_SOURCE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_C_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>_POSIX_C_SOURCE</name></cpp:macro> <cpp:value>200809L</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Solaris freaks out if you try to use a POSIX or SUS standard without
 * the "right" C standard. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_XOPEN_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>_XOPEN_SOURCE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">201112L</literal></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro> <cpp:value>700</cpp:value></cpp:define>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal></expr></cpp:elif>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro> <cpp:value>600</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Because, according to Microsoft, POSIX is deprecated.  You've got
 * to appreciate the chutzpah. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_CRT_NONSTDC_NO_DEPRECATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>_CRT_NONSTDC_NO_DEPRECATE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">199901L</literal><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdbool.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<comment type="block">/* https://msdn.microsoft.com/en-us/library/tf4dy80a.aspx */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_NL_LANGINFO</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_NL_LANGINFO</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;locale.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;langinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;strings.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/wait.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>STDERR_FILENO</name></cpp:macro> <cpp:value>_fileno(stderr)</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"munit.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_STRINGIFY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>#x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_XSTRINGIFY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>MUNIT_STRINGIFY(x)</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__INTEL_COMPILER</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__SUNPRO_CC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__IBMCPP__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_THREAD_LOCAL</name></cpp:macro> <cpp:value>__thread</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">201102L</literal><operator>)</operator><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><specifier>_Thread_local</specifier></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_THREAD_LOCAL</name></cpp:macro> <cpp:value>_Thread_local</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_THREAD_LOCAL</name></cpp:macro> <cpp:value>__declspec(thread)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* MSVC 12.0 will emit a warning at /W4 for code like 'do { ... }
 * while (0)', or 'do { ... } while (true)'.  I'm pretty sure nobody
 * at Microsoft compiles with /W4. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_MSC_VER</name> <operator>&lt;=</operator> <literal type="number">1800</literal><operator>)</operator></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>warning</name><name>(</name><name>disable</name><name>:</name> <name>4127</name><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_NO_FORK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_NO_BUFFER</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*** Logging ***/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>MunitLogLevel</name></type> <name>munit_log_level_visible</name> <init>= <expr><name>MUNIT_LOG_INFO</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MunitLogLevel</name></type> <name>munit_log_level_fatal</name> <init>= <expr><name>MUNIT_LOG_ERROR</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_THREAD_LOCAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>MUNIT_THREAD_LOCAL</name> <name>bool</name></type> <name>munit_error_jmp_buf_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MUNIT_THREAD_LOCAL</name> <name>jmp_buf</name></type> <name>munit_error_jmp_buf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* At certain warning levels, mingw will trigger warnings about
 * suggesting the format attribute, which we've explicity *not* set
 * because it will then choke on our attempts to use the MS-specific
 * I64 modifier for size_t (which we have to use since MSVC doesn't
 * support the C99 z modifier). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>push</name></cpp:pragma>
<cpp:pragma>#  <cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>ignored</name> <cpp:literal>"-Wsuggest-attribute=format"</cpp:literal></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>MUNIT_PRINTF</name><argument_list>(<argument><literal type="number">5</literal></argument>,<argument><literal type="number">0</literal></argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_logf_exv</name><parameter_list>(<parameter><decl><type><name>MunitLogLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><name>va_list</name></type> <name>ap</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&lt;</operator> <name>munit_log_level_visible</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <switch>switch <condition>(<expr><name>level</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>MUNIT_LOG_DEBUG</name></expr>:</case>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Debug"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>MUNIT_LOG_INFO</name></expr>:</case>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Info"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>MUNIT_LOG_WARNING</name></expr>:</case>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Warning"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>MUNIT_LOG_ERROR</name></expr>:</case>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"Error"</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    <default>default:</default>
      <expr_stmt><expr><call><name>munit_logf_ex</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Invalid log level (%d)"</literal></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">": "</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>filename</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s:%d: "</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<macro><name>MUNIT_PRINTF</name><argument_list>(<argument><literal type="number">3</literal></argument>,<argument><literal type="number">4</literal></argument>)</argument_list></macro>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_logf_internal</name><parameter_list>(<parameter><decl><type><name>MunitLogLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>munit_logf_exv</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_log_internal</name><parameter_list>(<parameter><decl><type><name>MunitLogLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>message</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>munit_logf_ex</name><parameter_list>(<parameter><decl><type><name>MunitLogLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>munit_logf_exv</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>level</name> <operator>&gt;=</operator> <name>munit_log_level_fatal</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_THREAD_LOCAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><name>munit_error_jmp_buf_valid</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>munit_error_jmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>munit_errorf_ex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>munit_logf_exv</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_THREAD_LOCAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name>munit_error_jmp_buf_valid</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>longjmp</name><argument_list>(<argument><expr><name>munit_error_jmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW64__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>GCC</name> <name>diagnostic</name> <name>pop</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_STRERROR_LEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_STRERROR_LEN</name></cpp:macro> <cpp:value>80</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_log_errno</name><parameter_list>(<parameter><decl><type><name>MunitLogLevel</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>msg</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_STRERROR_R</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MINGW_HAS_SECURE_API</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
  <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s: %s (%d)"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>char</name></type> <name><name>munit_error_str</name><index>[<expr><name>MUNIT_STRERROR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>munit_error_str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>strerror_r</name><argument_list>(<argument><expr><name>errno</name></expr></argument>, <argument><expr><name>munit_error_str</name></expr></argument>, <argument><expr><name>MUNIT_STRERROR_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>strerror_s</name><argument_list>(<argument><expr><name>munit_error_str</name></expr></argument>, <argument><expr><name>MUNIT_STRERROR_LEN</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s: %s (%d)"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>munit_error_str</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** Memory allocation ***/</comment>

<function><type><name>void</name><modifier>*</modifier></type>
<name>munit_malloc_ex</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_logf_ex</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"Failed to allocate %"</literal> <name>MUNIT_SIZE_MODIFIER</name> <literal type="string">"u bytes."</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** Timer code ***/</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>psnip_uint64_t</name></cpp:macro> <cpp:value>munit_uint64_t</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>psnip_uint32_t</name></cpp:macro> <cpp:value>munit_uint32_t</cpp:value></cpp:define>

<comment type="block">/* Code copied from portable-snippets
 * &lt;https://github.com/nemequ/portable-snippets/&gt;.  If you need to
 * change something, please do it there so we can keep the code in
 * sync. */</comment>

<comment type="block">/* Clocks (v1)
 * Portable Snippets - https://gitub.com/nemequ/portable-snippets
 * Created by Evan Nemerson &lt;evan@nemerson.com&gt;
 *
 *   To the extent possible under law, the authors have waived all
 *   copyright and related or neighboring rights to this code.  For
 *   details, see the Creative Commons Zero 1.0 Universal license at
 *   https://creativecommons.org/publicdomain/zero/1.0/
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_H</name></cpp:macro></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>psnip_uint64_t</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>"../exact-int/exact-int.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_STATIC_INLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK__COMPILER_ATTRIBUTES</name></cpp:macro> <cpp:value>__attribute__((__unused__))</cpp:value></cpp:define>
<cpp:else>#  <cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK__COMPILER_ATTRIBUTES</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK__FUNCTION</name></cpp:macro> <cpp:value>PSNIP_CLOCK__COMPILER_ATTRIBUTES static</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<enum>enum <name>PsnipClockType</name> <block>{
  <comment type="block">/* This clock provides the current time, in units since 1970-01-01
   * 00:00:00 UTC not including leap seconds.  In other words, UNIX
   * time.  Keep in mind that this clock doesn't account for leap
   * seconds, and can go backwards (think NTP adjustments). */</comment>
  <decl><name>PSNIP_CLOCK_TYPE_WALL</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
  <comment type="block">/* The CPU time is a clock which increases only when the current
   * process is active (i.e., it doesn't increment while blocking on
   * I/O). */</comment>
  <decl><name>PSNIP_CLOCK_TYPE_CPU</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
  <comment type="block">/* Monotonic time is always running (unlike CPU time), but it only
     ever moves forward unless you reboot the system.  Things like NTP
     adjustments have no effect on this clock. */</comment>
  <decl><name>PSNIP_CLOCK_TYPE_MONOTONIC</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>
}</block>;</enum>

<struct>struct <name>PsnipClockTimespec</name> <block>{
  <decl_stmt><decl><type><name>psnip_uint64_t</name></type> <name>seconds</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>psnip_uint64_t</name></type> <name>nanoseconds</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Methods we support: */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></cpp:macro>                   <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_TIME</name></cpp:macro>                            <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</name></cpp:macro>                    <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER</name></cpp:macro>         <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</name></cpp:macro>              <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_CLOCK</name></cpp:macro>                           <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</name></cpp:macro>                 <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_GETRUSAGE</name></cpp:macro>                       <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_GETSYSTEMTIMEPRECISEASFILETIME</name></cpp:macro>  <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_METHOD_GETTICKCOUNT64</name></cpp:macro>                 <cpp:value>10</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HEDLEY_UNREACHABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_UNREACHABLE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>HEDLEY_UNREACHABLE()</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_UNREACHABLE</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>assert(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Choose an implementation */</comment>

<comment type="block">/* #undef PSNIP_CLOCK_WALL_METHOD */</comment>
<comment type="block">/* #undef PSNIP_CLOCK_CPU_METHOD */</comment>
<comment type="block">/* #undef PSNIP_CLOCK_MONOTONIC_METHOD */</comment>

<comment type="block">/* We want to be able to detect the libc implementation, so we include
   &lt;limits.h&gt; (&lt;features.h&gt; isn't available everywhere). */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__unix__</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__unix</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__linux__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_TIMERS</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_POSIX_TIMERS</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></cpp:if>
<comment type="block">/* These are known to work without librt.  If you know of others
 * please let us know so we can add them. */</comment>
<cpp:if>#  <cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GLIBC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GLIBC__</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>__GLIBC__</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>__GLIBC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">17</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>__FreeBSD__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_HAVE_CLOCK_GETTIME</name></cpp:macro></cpp:define>
<cpp:elif>#  <cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_NO_LIBRT</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_HAVE_CLOCK_GETTIME</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CPU_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MACH__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__gnu_hurd__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_HAVE_CLOCK_GETTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_REALTIME_PRECISE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_WALL_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_WALL</name></cpp:macro> <cpp:value>CLOCK_REALTIME_PRECISE</cpp:value></cpp:define>
<cpp:elif>#    <cpp:directive>elif</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__sun</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_WALL_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_WALL</name></cpp:macro> <cpp:value>CLOCK_REALTIME</cpp:value></cpp:define>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_CPUTIME</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_PROCESS_CPUTIME_ID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CPU_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_CPU</name></cpp:macro> <cpp:value>CLOCK_PROCESS_CPUTIME_ID</cpp:value></cpp:define>
<cpp:elif>#    <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_VIRTUAL</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CPU_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_CPU</name></cpp:macro> <cpp:value>CLOCK_VIRTUAL</cpp:value></cpp:define>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#    <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC_RAW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC</name></cpp:macro> <cpp:value>CLOCK_MONOTONIC</cpp:value></cpp:define>
<cpp:elif>#    <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC_PRECISE</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC</name></cpp:macro> <cpp:value>CLOCK_MONOTONIC_PRECISE</cpp:value></cpp:define>
<cpp:elif>#    <cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_MONOTONIC_CLOCK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CLOCK_MONOTONIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</cpp:value></cpp:define>
<cpp:define>#      <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC</name></cpp:macro> <cpp:value>CLOCK_MONOTONIC</cpp:value></cpp:define>
<cpp:endif>#    <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_POSIX_VERSION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_POSIX_VERSION</name> <operator>&gt;=</operator> <literal type="number">200112L</literal><operator>)</operator></expr></cpp:if>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_WALL_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</cpp:value></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_WALL_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_TIME</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_CPU_METHOD</name></cpp:macro> <cpp:value>PSNIP_CLOCK_METHOD_CLOCK</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Primarily here for testing. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_REQUIRE_MONOTONIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#  <cpp:directive>error</cpp:directive> No monotonic clock found.</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Implementations */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_TIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_TIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_TIME</name><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</name><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTICKCOUNT64</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTICKCOUNT64</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTICKCOUNT64</name><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETRUSAGE</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETRUSAGE</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETRUSAGE</name><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/resource.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</name><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;CoreServices/CoreServices.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach.h&gt;</cpp:file></cpp:include>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;mach/mach_time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/*** Implementations ***/</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PSNIP_CLOCK_NSEC_PER_SEC</name></cpp:macro> <cpp:value>((psnip_uint32_t) (1000000000ULL))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> \
  <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call>       <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_CPU_METHOD</name>       <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call>      <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_WALL_METHOD</name>      <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name><operator>)</operator><operator>)</operator> <operator>||</operator> \
  <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name><operator>)</operator><operator>)</operator></expr></cpp:if>
<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>psnip_uint32_t</name></type>
<name>psnip_clock__clock_getres</name> <parameter_list>(<parameter><decl><type><name>clockid_t</name></type> <name>clk_id</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>clock_getres</name><argument_list>(<argument><expr><name>clk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>r</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

  <return>return <expr><operator>(</operator><name>psnip_uint32_t</name><operator>)</operator> <operator>(</operator><name>PSNIP_CLOCK_NSEC_PER_SEC</name> <operator>/</operator> <name><name>res</name><operator>.</operator><name>tv_nsec</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>int</name></type>
<name>psnip_clock__clock_gettime</name> <parameter_list>(<parameter><decl><type><name>clockid_t</name></type> <name>clk_id</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name><name>struct</name> <name>timespec</name></name></type> <name>ts</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>clock_gettime</name><argument_list>(<argument><expr><name>clk_id</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ts</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">10</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <operator>(</operator><name>psnip_uint64_t</name><operator>)</operator> <operator>(</operator><name><name>ts</name><operator>.</operator><name>tv_sec</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <operator>(</operator><name>psnip_uint64_t</name><operator>)</operator> <operator>(</operator><name><name>ts</name><operator>.</operator><name>tv_nsec</name></name><operator>)</operator></expr>;</expr_stmt>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>psnip_uint32_t</name></type>
<name>psnip_clock_wall_get_precision</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_WALL_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></expr></cpp:elif>
  <return>return <expr><call><name>psnip_clock__clock_getres</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CLOCK_GETTIME_WALL</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_WALL_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</name></expr></cpp:elif>
  <return>return <expr><literal type="number">1000000</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_WALL_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_TIME</name></expr></cpp:elif>
  <return>return <expr><literal type="number">1</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>int</name></type>
<name>psnip_clock_wall_get_time</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_WALL_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></expr></cpp:elif>
  <return>return <expr><call><name>psnip_clock__clock_gettime</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CLOCK_GETTIME_WALL</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_WALL_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_TIME</name></expr></cpp:elif>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_WALL_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_WALL_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTIMEOFDAY</name></expr></cpp:elif>
  <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">6</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>psnip_uint32_t</name></type>
<name>psnip_clock_cpu_get_precision</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></expr></cpp:elif>
  <return>return <expr><call><name>psnip_clock__clock_getres</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CLOCK_GETTIME_CPU</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK</name></expr></cpp:elif>
  <return>return <expr><name>CLOCKS_PER_SEC</name></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</name></expr></cpp:elif>
  <return>return <expr><name>PSNIP_CLOCK_NSEC_PER_SEC</name> <operator>/</operator> <literal type="number">100</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>int</name></type>
<name>psnip_clock_cpu_get_time</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></expr></cpp:elif>
  <return>return <expr><call><name>psnip_clock__clock_gettime</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CLOCK_GETTIME_CPU</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK</name></expr></cpp:elif>
  <decl_stmt><decl><type><name>clock_t</name></type> <name>t</name> <init>= <expr><call><name>clock</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>t</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>clock_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">5</literal></expr>;</return></block_content></block></if></if_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name>t</name> <operator>/</operator> <name>CLOCKS_PER_SEC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <operator>(</operator><name>t</name> <operator>%</operator> <name>CLOCKS_PER_SEC</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>PSNIP_CLOCK_NSEC_PER_SEC</name> <operator>/</operator> <name>CLOCKS_PER_SEC</name><operator>)</operator></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CPU_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETPROCESSTIMES</name></expr></cpp:elif>
  <decl_stmt><decl><type><name>FILETIME</name></type> <name>CreationTime</name></decl>, <decl><type ref="prev"/><name>ExitTime</name></decl>, <decl><type ref="prev"/><name>KernelTime</name></decl>, <decl><type ref="prev"/><name>UserTime</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>date</name></decl>, <decl><type ref="prev"/><name>adjust</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>GetProcessTimes</name><argument_list>(<argument><expr><call><name>GetCurrentProcess</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>CreationTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ExitTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>KernelTime</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>UserTime</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">7</literal></expr>;</return></block_content></block></if></if_stmt>

  <comment type="block">/* http://www.frenk.com/2009/12/convert-filetime-to-unix-timestamp/ */</comment>
  <expr_stmt><expr><name><name>date</name><operator>.</operator><name>HighPart</name></name> <operator>=</operator> <name><name>UserTime</name><operator>.</operator><name>dwHighDateTime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name><operator>.</operator><name>LowPart</name></name> <operator>=</operator> <name><name>UserTime</name><operator>.</operator><name>dwLowDateTime</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>adjust</name><operator>.</operator><name>QuadPart</name></name> <operator>=</operator> <literal type="number">11644473600000</literal> <operator>*</operator> <literal type="number">10000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name><operator>.</operator><name>QuadPart</name></name> <operator>-=</operator> <name><name>adjust</name><operator>.</operator><name>QuadPart</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name><name>date</name><operator>.</operator><name>QuadPart</name></name> <operator>/</operator> <literal type="number">10000000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <operator>(</operator><name><name>date</name><operator>.</operator><name>QuadPart</name></name> <operator>%</operator> <literal type="number">10000000</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>PSNIP_CLOCK_NSEC_PER_SEC</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>PSNIP_CLOCK_CPU_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETRUSAGE</name></expr></cpp:elif>
  <decl_stmt><decl><type><name><name>struct</name> <name>rusage</name></name></type> <name>usage</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>getrusage</name><argument_list>(<argument><expr><name>RUSAGE_SELF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usage</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">8</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name><name>usage</name><operator>.</operator><name>ru_utime</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>psnip_uint32_t</name></type>
<name>psnip_clock_monotonic_get_precision</name> <parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></expr></cpp:elif>
  <return>return <expr><call><name>psnip_clock__clock_getres</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</name></expr></cpp:elif>
  <decl_stmt><decl><type><specifier>static</specifier> <name>mach_timebase_info_data_t</name></type> <name>tbi</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, }</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tbi</name><operator>.</operator><name>denom</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mach_timebase_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <return>return <expr><operator>(</operator><name>psnip_uint32_t</name><operator>)</operator> <operator>(</operator><name><name>tbi</name><operator>.</operator><name>numer</name></name> <operator>/</operator> <name><name>tbi</name><operator>.</operator><name>denom</name></name><operator>)</operator></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTICKCOUNT64</name></expr></cpp:elif>
  <return>return <expr><literal type="number">1000</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER</name></expr></cpp:elif>
  <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>Frequency</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Frequency</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><operator>(</operator><name>psnip_uint32_t</name><operator>)</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>Frequency</name><operator>.</operator><name>QuadPart</name></name> <operator>&gt;</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name><operator>)</operator></expr> ?</condition><then> <expr><name>PSNIP_CLOCK_NSEC_PER_SEC</name></expr> </then><else>: <expr><name><name>Frequency</name><operator>.</operator><name>QuadPart</name></name></expr></else></ternary><operator>)</operator></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>int</name></type>
<name>psnip_clock_monotonic_get_time</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>res</name></expr>;</expr_stmt>
  <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_CLOCK_GETTIME</name></expr></cpp:elif>
  <return>return <expr><call><name>psnip_clock__clock_gettime</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_CLOCK_GETTIME_MONOTONIC</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_MACH_ABSOLUTE_TIME</name></expr></cpp:elif>
  <decl_stmt><decl><type><name>psnip_uint64_t</name></type> <name>nsec</name> <init>= <expr><call><name>mach_absolute_time</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>static</specifier> <name>mach_timebase_info_data_t</name></type> <name>tbi</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, }</block></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>tbi</name><operator>.</operator><name>denom</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>mach_timebase_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tbi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
  <expr_stmt><expr><name>nsec</name> <operator>*=</operator> <operator>(</operator><operator>(</operator><name>psnip_uint64_t</name><operator>)</operator> <name><name>tbi</name><operator>.</operator><name>numer</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>psnip_uint64_t</name><operator>)</operator> <name><name>tbi</name><operator>.</operator><name>denom</name></name><operator>)</operator></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name>nsec</name> <operator>/</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <name>nsec</name> <operator>%</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name></expr>;</expr_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_QUERYPERFORMANCECOUNTER</name></expr></cpp:elif>
  <decl_stmt><decl><type><name>LARGE_INTEGER</name></type> <name>t</name></decl>, <decl><type ref="prev"/><name>f</name></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>QueryPerformanceCounter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><operator>-</operator><literal type="number">12</literal></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>QueryPerformanceFrequency</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>QuadPart</name></name> <operator>/</operator> <name><name>f</name><operator>.</operator><name>QuadPart</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <name><name>t</name><operator>.</operator><name>QuadPart</name></name> <operator>%</operator> <name><name>f</name><operator>.</operator><name>QuadPart</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>f</name><operator>.</operator><name>QuadPart</name></name> <operator>&gt;</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>/=</operator> <name><name>f</name><operator>.</operator><name>QuadPart</name></name> <operator>/</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>*=</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name> <operator>/</operator> <name><name>f</name><operator>.</operator><name>QuadPart</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_MONOTONIC_METHOD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>PSNIP_CLOCK_MONOTONIC_METHOD</name> <operator>==</operator> <name>PSNIP_CLOCK_METHOD_GETTICKCOUNT64</name></expr></cpp:elif>
  <decl_stmt><decl><type><specifier>const</specifier> <name>ULONGLONG</name></type> <name>msec</name> <init>= <expr><call><name>GetTickCount64</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>seconds</name></name> <operator>=</operator> <name>msec</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>=</operator> <name>sec</name> <operator>%</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Returns the number of ticks per second for the specified clock.
 * For example, a clock with millisecond precision would return 1000,
 * and a clock with 1 second (such as the time() function) would
 * return 1.
 *
 * If the requested clock isn't available, it will return 0.
 * Hopefully this will be rare, but if it happens to you please let us
 * know so we can work on finding a way to support your system.
 *
 * Note that different clocks on the same system often have a
 * different precisions.
 */</comment>
<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>psnip_uint32_t</name></type>
<name>psnip_clock_get_precision</name> <parameter_list>(<parameter><decl><type><name><name>enum</name> <name>PsnipClockType</name></name></type> <name>clock_type</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>clock_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>PSNIP_CLOCK_TYPE_MONOTONIC</name></expr>:</case>
      <return>return <expr><call><name>psnip_clock_monotonic_get_precision</name> <argument_list>()</argument_list></call></expr>;</return>
    <case>case <expr><name>PSNIP_CLOCK_TYPE_CPU</name></expr>:</case>
      <return>return <expr><call><name>psnip_clock_cpu_get_precision</name> <argument_list>()</argument_list></call></expr>;</return>
    <case>case <expr><name>PSNIP_CLOCK_TYPE_WALL</name></expr>:</case>
      <return>return <expr><call><name>psnip_clock_wall_get_precision</name> <argument_list>()</argument_list></call></expr>;</return>
  </block_content>}</block></switch>

  <expr_stmt><expr><call><name>PSNIP_CLOCK_UNREACHABLE</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Set the provided timespec to the requested time.  Returns 0 on
 * success, or a negative value on failure. */</comment>
<function><type><name>PSNIP_CLOCK__FUNCTION</name> <name>int</name></type>
<name>psnip_clock_get_time</name> <parameter_list>(<parameter><decl><type><name><name>enum</name> <name>PsnipClockType</name></name></type> <name>clock_type</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>res</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>clock_type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>PSNIP_CLOCK_TYPE_MONOTONIC</name></expr>:</case>
      <return>return <expr><call><name>psnip_clock_monotonic_get_time</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>PSNIP_CLOCK_TYPE_CPU</name></expr>:</case>
      <return>return <expr><call><name>psnip_clock_cpu_get_time</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
    <case>case <expr><name>PSNIP_CLOCK_TYPE_WALL</name></expr>:</case>
      <return>return <expr><call><name>psnip_clock_wall_get_time</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></switch>

  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(PSNIP_CLOCK_H) */</comment>

<function><type><specifier>static</specifier> <name>psnip_uint64_t</name></type>
<name>munit_clock_get_elapsed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>start</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name><modifier>*</modifier></type> <name>end</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>psnip_uint64_t</name></type> <name>r</name> <init>= <expr><operator>(</operator><name><name>end</name><operator>-&gt;</operator><name>seconds</name></name> <operator>-</operator> <name><name>start</name><operator>-&gt;</operator><name>seconds</name></name><operator>)</operator> <operator>*</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name><name>end</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>&lt;</operator> <name><name>start</name><operator>-&gt;</operator><name>nanoseconds</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>-=</operator> <operator>(</operator><name><name>start</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>-</operator> <name><name>end</name><operator>-&gt;</operator><name>nanoseconds</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>r</name> <operator>+=</operator> <operator>(</operator><name><name>end</name><operator>-&gt;</operator><name>nanoseconds</name></name> <operator>-</operator> <name><name>start</name><operator>-&gt;</operator><name>nanoseconds</name></name><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>
  <return>return <expr><name>r</name></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* defined(MUNIT_ENABLE_TIMING) */</comment>

<comment type="block" format="doxygen">/*** PRNG stuff ***/</comment>

<comment type="block">/* This is (unless I screwed up, which is entirely possible) the
 * version of PCG with 32-bit state.  It was chosen because it has a
 * small enough state that we should reliably be able to use CAS
 * instead of requiring a lock for thread-safety.
 *
 * If I did screw up, I probably will not bother changing it unless
 * there is a significant bias.  It's really not important this be
 * particularly strong, as long as it is fairly random it's much more
 * important that it be reproducible, so bug reports have a better
 * chance of being reproducible. */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_VERSION__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__STDC_VERSION__</name> <operator>&gt;=</operator> <literal type="number">201112L</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__STDC_NO_ATOMICS__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__EMSCRIPTEN__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC_MINOR__</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>__GNUC_MINOR__</name> <operator>&gt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_STDATOMIC</name></cpp:macro></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>__has_extension</name><argument_list>(<argument><expr><name>c_atomic</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#    <cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_CLANG_ATOMICS</name></cpp:macro></cpp:define>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Workaround for http://llvm.org/bugs/show_bug.cgi?id=26911 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__clang__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#  <cpp:directive>undef</cpp:directive> <name>HAVE_STDATOMIC</name></cpp:undef>
<cpp:if>#  <cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__c2__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#    <cpp:directive>undef</cpp:directive> <name>HAVE_CLANG_ATOMICS</name></cpp:undef>
<cpp:endif>#  <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_OPENMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_T</name></cpp:macro> <cpp:value>uint32_t</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDATOMIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#  <cpp:directive>include</cpp:directive> <cpp:file>&lt;stdatomic.h&gt;</cpp:file></cpp:include>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_T</name></cpp:macro> <cpp:value>_Atomic uint32_t</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ATOMIC_VAR_INIT(x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLANG_ATOMICS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_T</name></cpp:macro> <cpp:value>_Atomic uint32_t</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_T</name></cpp:macro> <cpp:value>volatile LONG</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_T</name></cpp:macro> <cpp:value>volatile uint32_t</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ATOMIC_UINT32_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(x)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>ATOMIC_UINT32_T</name></type> <name>munit_rand_state</name> <init>= <expr><call><name>ATOMIC_UINT32_INIT</name><argument_list>(<argument><expr><literal type="number">42</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_OPENMP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>munit_atomic_store</name><parameter_list>(<parameter><decl><type><name>ATOMIC_UINT32_T</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>ATOMIC_UINT32_T</name></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name> <omp:argument_list>(<omp:argument><omp:expr>munit_atomics</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
  <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type>
<name>munit_atomic_load</name><parameter_list>(<parameter><decl><type><name>ATOMIC_UINT32_T</name><modifier>*</modifier></type> <name>src</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name> <omp:argument_list>(<omp:argument><omp:expr>munit_atomics</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
  <expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>
  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>uint32_t</name></type>
<name>munit_atomic_cas</name><parameter_list>(<parameter><decl><type><name>ATOMIC_UINT32_T</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>ATOMIC_UINT32_T</name><modifier>*</modifier></type> <name>expected</name></decl></parameter>, <parameter><decl><type><name>ATOMIC_UINT32_T</name></type> <name>desired</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <omp:directive>omp <omp:clause><omp:name>critical</omp:name> <omp:argument_list>(<omp:argument><omp:expr>munit_atomics</omp:expr></omp:argument>)</omp:argument_list></omp:clause></omp:directive></cpp:pragma>
  <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dest</name> <operator>==</operator> <operator>*</operator><name>expected</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>desired</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block>

  <return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDATOMIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_store</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>atomic_store(dest, value)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_load</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro>                  <cpp:value>atomic_load(src)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_cas</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>atomic_compare_exchange_weak(dest, expected, value)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_CLANG_ATOMICS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_store</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>__c11_atomic_store(dest, value, __ATOMIC_SEQ_CST)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_load</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro>                  <cpp:value>__c11_atomic_load(src, __ATOMIC_SEQ_CST)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_cas</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__c11_atomic_compare_exchange_weak(dest, expected, value, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>__GNUC__</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <name>__GNUC_MINOR__</name> <operator>&gt;=</operator> <literal type="number">7</literal><operator>)</operator></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_store</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>__atomic_store_n(dest, value, __ATOMIC_SEQ_CST)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_load</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro>                  <cpp:value>__atomic_load_n(src, __ATOMIC_SEQ_CST)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_cas</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__atomic_compare_exchange_n(dest, expected, value, true, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__GNUC__</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>__GNUC__</name> <operator>&gt;=</operator> <literal type="number">4</literal><operator>)</operator></expr></cpp:elif>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_store</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>do { *(dest) = (value); } while (0)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_load</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro>                  <cpp:value>(*(src))</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_cas</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>__sync_bool_compare_and_swap(dest, *expected, value)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif> <comment type="block">/* Untested */</comment>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_store</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>,<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>          <cpp:value>do { *(dest) = (value); } while (0)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_load</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro>                  <cpp:value>(*(src))</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_cas</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>expected</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>InterlockedCompareExchange((dest), (value), *(expected))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:warning>#  <cpp:directive>warning</cpp:directive> No atomic implementation, PRNG will not be thread-safe</cpp:warning>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_store</name><parameter_list>(<parameter><type><name>dest</name></type></parameter>, <parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro>         <cpp:value>do { *(dest) = (value); } while (0)</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>munit_atomic_load</name><parameter_list>(<parameter><type><name>src</name></type></parameter>)</parameter_list></cpp:macro>                  <cpp:value>(*(src))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>munit_atomic_cas</name><parameter_list>(<parameter><decl><type><name>ATOMIC_UINT32_T</name><modifier>*</modifier></type> <name>dest</name></decl></parameter>, <parameter><decl><type><name>ATOMIC_UINT32_T</name><modifier>*</modifier></type> <name>expected</name></decl></parameter>, <parameter><decl><type><name>ATOMIC_UINT32_T</name></type> <name>desired</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dest</name> <operator>==</operator> <operator>*</operator><name>expected</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>desired</name></expr>;</expr_stmt>
    <return>return <expr><name>true</name></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><name>false</name></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_PRNG_MULTIPLIER</name></cpp:macro> <cpp:value>(747796405U)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_PRNG_INCREMENT</name></cpp:macro>  <cpp:value>(1729U)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_rand_next_state</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><name>state</name> <operator>*</operator> <name>MUNIT_PRNG_MULTIPLIER</name> <operator>+</operator> <name>MUNIT_PRNG_INCREMENT</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_rand_from_state</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>res</name> <init>= <expr><operator>(</operator><operator>(</operator><name>state</name> <operator>&gt;&gt;</operator> <operator>(</operator><operator>(</operator><name>state</name> <operator>&gt;&gt;</operator> <literal type="number">28</literal><operator>)</operator> <operator>+</operator> <literal type="number">4</literal><operator>)</operator><operator>)</operator> <operator>^</operator> <name>state</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">277803737U</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name>res</name> <operator>^=</operator> <name>res</name> <operator>&gt;&gt;</operator> <literal type="number">22</literal></expr>;</expr_stmt>
  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>munit_rand_seed</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name></type> <name>seed</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>state</name> <init>= <expr><call><name>munit_rand_next_state</name><argument_list>(<argument><expr><name>seed</name> <operator>+</operator> <name>MUNIT_PRNG_INCREMENT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>munit_atomic_store</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_rand_generate_seed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>seed</name></decl>, <decl><type ref="prev"/><name>state</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name></type> <name>wc</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>psnip_clock_get_time</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_TYPE_WALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>seed</name> <operator>=</operator> <operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <name><name>wc</name><operator>.</operator><name>nanoseconds</name></name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name>seed</name> <operator>=</operator> <operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>munit_rand_next_state</name><argument_list>(<argument><expr><name>seed</name> <operator>+</operator> <name>MUNIT_PRNG_INCREMENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>munit_rand_from_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_rand_state_uint32</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>munit_uint32_t</name></type> <name>old</name> <init>= <expr><operator>*</operator><name>state</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><operator>*</operator><name>state</name> <operator>=</operator> <call><name>munit_rand_next_state</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>munit_rand_from_state</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>munit_uint32_t</name></type>
<name>munit_rand_uint32</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>old</name></decl>, <decl><type ref="prev"/><name>state</name></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>old</name> <operator>=</operator> <call><name>munit_atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>munit_rand_next_state</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>munit_atomic_cas</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <return>return <expr><call><name>munit_rand_from_state</name><argument_list>(<argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_rand_state_memory</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>munit_uint8_t</name></type> <name><name>data</name><index>[<expr><call><name>MUNIT_ARRAY_PARAM</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>members_remaining</name> <init>= <expr><name>size</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>munit_uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>bytes_remaining</name> <init>= <expr><name>size</name> <operator>%</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>munit_uint32_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint8_t</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>rv</name></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>members_remaining</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>munit_rand_state_uint32</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rv</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>munit_uint32_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>munit_uint32_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  </block_content>}</block></while>
  <if_stmt><if>if <condition>(<expr><name>bytes_remaining</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>munit_rand_state_uint32</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rv</name></expr></argument>, <argument><expr><name>bytes_remaining</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>munit_rand_memory</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>munit_uint8_t</name></type> <name><name>data</name><index>[<expr><call><name>MUNIT_ARRAY_PARAM</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>old</name></decl>, <decl><type ref="prev"/><name>state</name></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>old</name> <operator>=</operator> <call><name>munit_atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_rand_state_memory</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>munit_atomic_cas</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_rand_state_at_most</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name><modifier>*</modifier></type> <name>state</name></decl></parameter>, <parameter><decl><type><name>munit_uint32_t</name></type> <name>salt</name></decl></parameter>, <parameter><decl><type><name>munit_uint32_t</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <comment type="block">/* We want (UINT32_MAX + 1) % max, which in unsigned arithmetic is the same
   * as (UINT32_MAX + 1 - max) % max = -max % max. We compute -max using not
   * to avoid compiler warnings.
   */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>munit_uint32_t</name></type> <name>min</name> <init>= <expr><operator>(</operator><operator>~</operator><name>max</name> <operator>+</operator> <literal type="number">1U</literal><operator>)</operator> <operator>%</operator> <name>max</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>x</name></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>max</name> <operator>==</operator> <operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <literal type="number">0U</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>munit_rand_state_uint32</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>^</operator> <name>salt</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><name>max</name><operator>++</operator></expr>;</expr_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>munit_rand_state_uint32</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call> <operator>^</operator> <name>salt</name></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><name>x</name> <operator>&lt;</operator> <name>min</name></expr>)</condition>;</do>

  <return>return <expr><name>x</name> <operator>%</operator> <name>max</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_rand_at_most</name><parameter_list>(<parameter><decl><type><name>munit_uint32_t</name></type> <name>salt</name></decl></parameter>, <parameter><decl><type><name>munit_uint32_t</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>old</name></decl>, <decl><type ref="prev"/><name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>retval</name></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>old</name> <operator>=</operator> <call><name>munit_atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>munit_rand_state_at_most</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>salt</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>munit_atomic_cas</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>munit_rand_int_range</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>min</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint64_t</name></type> <name>range</name> <init>= <expr><operator>(</operator><name>munit_uint64_t</name><operator>)</operator> <name>max</name> <operator>-</operator> <operator>(</operator><name>munit_uint64_t</name><operator>)</operator> <name>min</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name>max</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><call><name>munit_rand_int_range</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr><name>min</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>range</name> <operator>&gt;</operator> <operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <literal type="number">0U</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>range</name> <operator>=</operator> <operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <literal type="number">0U</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>min</name> <operator>+</operator> <call><name>munit_rand_at_most</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <name>range</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>double</name></type>
<name>munit_rand_double</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>old</name></decl>, <decl><type ref="prev"/><name>state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>retval</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

  <do>do <block>{<block_content>
    <expr_stmt><expr><name>state</name> <operator>=</operator> <name>old</name> <operator>=</operator> <call><name>munit_atomic_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* See http://mumble.net/~campbell/tmp/random_real.c for how to do
     * this right.  Patches welcome if you feel that this is too
     * biased. */</comment>
    <expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>munit_rand_state_uint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <literal type="number">0U</literal><operator>)</operator><operator>)</operator> <operator>+</operator> <literal type="number">1.0</literal><operator>)</operator></expr>;</expr_stmt>
  </block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>munit_atomic_cas</name><argument_list>(<argument><expr><operator>&amp;</operator><name>munit_rand_state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>old</name></expr></argument>, <argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

  <return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*** Test suite handling ***/</comment>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>successful</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>skipped</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>failed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>errored</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>munit_uint64_t</name></type> <name>cpu_clock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint64_t</name></type> <name>wall_clock</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>MunitReport</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>suite</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>tests</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>seed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iterations</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name>parameters</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>single_parameter_mode</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>user_data</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitReport</name></type> <name>report</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>colorize</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>fork</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>show_stderr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>fatal_failures</name></decl>;</decl_stmt>
}</block></struct></type> <name>MunitTestRunner</name>;</typedef>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>munit_parameters_get</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitParameter</name></type> <name><name>params</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameter</name><modifier>*</modifier></type> <name>param</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>param</name> <operator>=</operator> <name>params</name></expr> ;</init> <condition><expr><name>param</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>param</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>param</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>param</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name><name>param</name><operator>-&gt;</operator><name>value</name></name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>
  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_print_time</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>fp</name></decl></parameter>, <parameter><decl><type><name>munit_uint64_t</name></type> <name>nanoseconds</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%"</literal> <name>MUNIT_TEST_TIME_FORMAT</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>nanoseconds</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>PSNIP_CLOCK_NSEC_PER_SEC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Add a paramter to an array of parameters. */</comment>
<function><type><specifier>static</specifier> <name>MunitResult</name></type>
<name>munit_parameters_add</name><parameter_list>(<parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>params_size</name></decl></parameter>, <parameter><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name><name>params</name><index>[<expr><call><name>MUNIT_ARRAY_PARAM</name><argument_list>(<argument><expr><operator>*</operator><name>params_size</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><operator>*</operator><name>params</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><operator>*</operator><name>params</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MunitParameter</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><operator>*</operator><name>params_size</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>*</operator><name>params</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return <expr><name>MUNIT_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>params</name><operator>)</operator><index>[<expr><operator>*</operator><name>params_size</name></expr>]</index><operator>.</operator><name>name</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>params</name><operator>)</operator><index>[<expr><operator>*</operator><name>params_size</name></expr>]</index><operator>.</operator><name>value</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>params_size</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>params</name><operator>)</operator><index>[<expr><operator>*</operator><name>params_size</name></expr>]</index><operator>.</operator><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><operator>(</operator><operator>*</operator><name>params</name><operator>)</operator><index>[<expr><operator>*</operator><name>params_size</name></expr>]</index><operator>.</operator><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Concatenate two strings, but just return one of the components
 * unaltered if the other is NULL or "". */</comment>
<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>munit_maybe_concat</name><parameter_list>(<parameter><decl><type><name>size_t</name><modifier>*</modifier></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>suffix</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>res_l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>prefix_l</name> <init>= <expr><ternary><condition><expr><name>prefix</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>suffix_l</name> <init>= <expr><ternary><condition><expr><name>suffix</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>prefix_l</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>suffix_l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res_l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prefix_l</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>suffix_l</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>suffix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res_l</name> <operator>=</operator> <name>suffix_l</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>prefix_l</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>suffix_l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <name>prefix</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res_l</name> <operator>=</operator> <name>prefix_l</name></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><name>res_l</name> <operator>=</operator> <name>prefix_l</name> <operator>+</operator> <name>suffix_l</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>res_l</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name> <operator>+</operator> <name>prefix_l</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>suffix_l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>res</name><index>[<expr><name>res_l</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>res_l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Possbily free a string returned by munit_maybe_concat. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_maybe_free_concat</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>suffix</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>!=</operator> <name>s</name> <operator>&amp;&amp;</operator> <name>suffix</name> <operator>!=</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* Cheap string hash function, just used to salt the PRNG. */</comment>
<function><type><specifier>static</specifier> <name>munit_uint32_t</name></type>
<name>munit_str_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>munit_uint32_t</name></type> <name>h</name> <init>= <expr><literal type="number">5381U</literal></expr></init></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <name>h</name> <operator>+</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></for>

  <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_splice</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>munit_uint8_t</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_written</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>write_res</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>bytes_written</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>write_res</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <do>do <block>{<block_content>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>bytes_written</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      <do>do <block>{<block_content>
        <expr_stmt><expr><name>write_res</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>bytes_written</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>write_res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>bytes_written</name> <operator>+=</operator> <name>write_res</name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><name>bytes_written</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>;</do>
    </block_content>}</block></if>
    <else>else<block type="pseudo"><block_content>
      <break>break;</break></block_content></block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><name>true</name></expr>)</condition>;</do>
</block_content>}</block></function>

<comment type="block">/* This is the part that should be handled in the child process */</comment>
<function><type><specifier>static</specifier> <name>MunitResult</name></type>
<name>munit_test_runner_exec</name><parameter_list>(<parameter><decl><type><name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MunitTest</name><modifier>*</modifier></type> <name>test</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MunitParameter</name></type> <name><name>params</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>MunitReport</name><modifier>*</modifier></type> <name>report</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>iterations</name> <init>= <expr><name><name>runner</name><operator>-&gt;</operator><name>iterations</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitResult</name></type> <name>result</name> <init>= <expr><name>MUNIT_FAIL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name></type> <name>wall_clock_begin</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name>wall_clock_end</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name><name>struct</name> <name>PsnipClockTimespec</name></name></type> <name>cpu_clock_begin</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>, <decl><type ref="prev"/><name>cpu_clock_end</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>test</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>MUNIT_TEST_OPTION_SINGLE_ITERATION</name><operator>)</operator> <operator>==</operator> <name>MUNIT_TEST_OPTION_SINGLE_ITERATION</name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>iterations</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
  <if type="elseif">else if <condition>(<expr><name>iterations</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><name>iterations</name> <operator>=</operator> <name><name>runner</name><operator>-&gt;</operator><name>suite</name><operator>-&gt;</operator><name>iterations</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

  <expr_stmt><expr><call><name>munit_rand_seed</name><argument_list>(<argument><expr><name><name>runner</name><operator>-&gt;</operator><name>seed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <do>do <block>{<block_content>
    <decl_stmt><decl><type><name>void</name><modifier>*</modifier></type> <name>data</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>test</name><operator>-&gt;</operator><name>setup</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>runner</name><operator>-&gt;</operator><name>user_data</name></name></expr> </then><else>: <expr><call><name><name>test</name><operator>-&gt;</operator><name>setup</name></name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name><name>runner</name><operator>-&gt;</operator><name>user_data</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>psnip_clock_get_time</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_TYPE_WALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wall_clock_begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>psnip_clock_get_time</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_TYPE_CPU</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpu_clock_begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>test</name><operator>-&gt;</operator><name>test</name></name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>psnip_clock_get_time</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_TYPE_WALL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wall_clock_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>psnip_clock_get_time</name><argument_list>(<argument><expr><name>PSNIP_CLOCK_TYPE_CPU</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpu_clock_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>tear_down</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name><name>test</name><operator>-&gt;</operator><name>tear_down</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>MUNIT_LIKELY</name><argument_list>(<argument><expr><name>result</name> <operator>==</operator> <name>MUNIT_OK</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name><name>report</name><operator>-&gt;</operator><name>successful</name></name><operator>++</operator></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <expr_stmt><expr><name><name>report</name><operator>-&gt;</operator><name>wall_clock</name></name> <operator>+=</operator> <call><name>munit_clock_get_elapsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wall_clock_begin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wall_clock_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>report</name><operator>-&gt;</operator><name>cpu_clock</name></name> <operator>+=</operator> <call><name>munit_clock_get_elapsed</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpu_clock_begin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpu_clock_end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <switch>switch <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>result</name></expr>)</condition> <block>{<block_content>
        <case>case <expr><name>MUNIT_SKIP</name></expr>:</case>
          <expr_stmt><expr><name><name>report</name><operator>-&gt;</operator><name>skipped</name></name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>MUNIT_FAIL</name></expr>:</case>
          <expr_stmt><expr><name><name>report</name><operator>-&gt;</operator><name>failed</name></name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <case>case <expr><name>MUNIT_ERROR</name></expr>:</case>
          <expr_stmt><expr><name><name>report</name><operator>-&gt;</operator><name>errored</name></name><operator>++</operator></expr>;</expr_stmt>
          <break>break;</break>
        <default>default:</default>
          <break>break;</break>
      </block_content>}</block></switch>
      <break>break;</break>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block> while <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>iterations</name></expr>)</condition>;</do>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_EMOTICON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_OK</name></cpp:macro>    <cpp:value>":)"</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_SKIP</name></cpp:macro>  <cpp:value>":|"</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_FAIL</name></cpp:macro>  <cpp:value>":("</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_ERROR</name></cpp:macro> <cpp:value>":o"</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_TODO</name></cpp:macro>  <cpp:value>":/"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_OK</name></cpp:macro>    <cpp:value>"OK   "</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_SKIP</name></cpp:macro>  <cpp:value>"SKIP "</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_FAIL</name></cpp:macro>  <cpp:value>"FAIL "</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_ERROR</name></cpp:macro> <cpp:value>"ERROR"</cpp:value></cpp:define>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>MUNIT_RESULT_STRING_TODO</name></cpp:macro>  <cpp:value>"TODO "</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_test_runner_print_color</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>string</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>color</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>colorize</name></name></expr>)</condition><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><literal type="string">"\x1b[3%cm%s\x1b[39m"</literal></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
  <else>else<block type="pseudo"><block_content>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_BUFFER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>munit_replace_stderr</name><parameter_list>(<parameter><decl><type><name>FILE</name><modifier>*</modifier></type> <name>stderr_buf</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>stderr_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>orig_stderr</name> <init>= <expr><call><name>dup</name><argument_list>(<argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>errfd</name> <init>= <expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><name>errfd</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name>errfd</name></expr></argument>, <argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>orig_stderr</name></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_restore_stderr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>orig_stderr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <if_stmt><if>if <condition>(<expr><name>orig_stderr</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>dup2</name><argument_list>(<argument><expr><name>orig_stderr</name></expr></argument>, <argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>orig_stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* !defined(MUNIT_NO_BUFFER) */</comment>

<comment type="block">/* Run a test with the specified parameters. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_test_runner_run_test_with_params</name><parameter_list>(<parameter><decl><type><name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MunitTest</name><modifier>*</modifier></type> <name>test</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MunitParameter</name></type> <name><name>params</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>MunitResult</name></type> <name>result</name> <init>= <expr><name>MUNIT_OK</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitReport</name></type> <name>report</name> <init>= <expr><block>{
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>output_l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameter</name><modifier>*</modifier></type> <name>param</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>FILE</name><modifier>*</modifier></type> <name>stderr_buf</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>int</name></type> <name><name>pipefd</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pid_t</name></type> <name>fork_pid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_written</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>write_res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>bytes_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ssize_t</name></type> <name>read_res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>pid_t</name></type> <name>changed_pid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><name>params</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>output_l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"  "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>param</name> <operator>=</operator> <name>params</name></expr> ;</init> <condition><expr><name>param</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>param</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>param</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><operator>!</operator><name>first</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>output_l</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><name>output_l</name> <operator>+=</operator> <call><name>fprintf</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
    <while>while <condition>(<expr><name>output_l</name><operator>++</operator> <operator>&lt;</operator> <name>MUNIT_TEST_NAME_LEN</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>stderr_buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name>stderr_buf</name> <operator>=</operator> <call><name>tmpfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>tmpfile_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stderr_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <if_stmt><if>if <condition>(<expr><name>stderr_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_log_errno</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unable to create buffer for stderr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_ERROR</name></expr>;</expr_stmt>
    <goto>goto <name>print_result</name>;</goto>
  </block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>fork</name></name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>pipefd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>munit_log_errno</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unable to create pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_ERROR</name></expr>;</expr_stmt>
      <goto>goto <name>print_result</name>;</goto>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>fork_pid</name> <operator>=</operator> <call><name>fork</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>fork_pid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <decl_stmt><decl><type><name>int</name></type> <name>orig_stderr</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>orig_stderr</name> <operator>=</operator> <call><name>munit_replace_stderr</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>munit_test_runner_exec</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Note that we don't restore stderr.  This is so we can buffer
       * things written to stderr later on (such as by
       * asan/tsan/ubsan, valgrind, etc.) */</comment>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>orig_stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <do>do <block>{<block_content>
        <expr_stmt><expr><name>write_res</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>munit_uint8_t</name><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>report</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>bytes_written</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>bytes_written</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>write_res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>stderr_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
            <expr_stmt><expr><call><name>munit_log_errno</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unable to write to pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></if></if_stmt>
          <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_FAILURE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>bytes_written</name> <operator>+=</operator> <name>write_res</name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>bytes_written</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></sizeof></expr>)</condition>;</do>

      <if_stmt><if>if <condition>(<expr><name>stderr_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><name>EXIT_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fork_pid</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>stderr_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>munit_log_errno</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unable to fork"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>report</name><operator>.</operator><name>errored</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <do>do <block>{<block_content>
        <expr_stmt><expr><name>read_res</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>munit_uint8_t</name><operator>*</operator><operator>)</operator> <operator>(</operator><operator>&amp;</operator><name>report</name><operator>)</operator><operator>)</operator> <operator>+</operator> <name>bytes_read</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>bytes_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>read_res</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
          <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>bytes_read</name> <operator>+=</operator> <name>read_res</name></expr>;</expr_stmt>
      </block_content>}</block> while <condition>(<expr><name>bytes_read</name> <operator>&lt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></sizeof></expr>)</condition>;</do>

      <expr_stmt><expr><name>changed_pid</name> <operator>=</operator> <call><name>waitpid</name><argument_list>(<argument><expr><name>fork_pid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if_stmt><if>if <condition>(<expr><call><name>MUNIT_LIKELY</name><argument_list>(<argument><expr><name>changed_pid</name> <operator>==</operator> <name>fork_pid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>MUNIT_LIKELY</name><argument_list>(<argument><expr><call><name>WIFEXITED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>bytes_read</name> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>report</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr_buf</name></expr></argument>, <argument><expr><literal type="string">"child exited unexpectedly with status %d"</literal></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>report</name><operator>.</operator><name>errored</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EXIT_SUCCESS</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr_buf</name></expr></argument>, <argument><expr><literal type="string">"child exited with status %d"</literal></expr></argument>, <argument><expr><call><name>WEXITSTATUS</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>report</name><operator>.</operator><name>errored</name></name><operator>++</operator></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>WIFSIGNALED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_XOPEN_VERSION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>_XOPEN_VERSION</name> <operator>&gt;=</operator> <literal type="number">700</literal><operator>)</operator></expr></cpp:if>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr_buf</name></expr></argument>, <argument><expr><literal type="string">"child killed by signal %d (%s)"</literal></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>strsignal</name><argument_list>(<argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr_buf</name></expr></argument>, <argument><expr><literal type="string">"child killed by signal %d"</literal></expr></argument>, <argument><expr><call><name>WTERMSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
        </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>WIFSTOPPED</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr_buf</name></expr></argument>, <argument><expr><literal type="string">"child stopped by signal %d"</literal></expr></argument>, <argument><expr><call><name>WSTOPSIG</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>report</name><operator>.</operator><name>errored</name></name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>pipefd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>waitpid</name><argument_list>(<argument><expr><name>fork_pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_BUFFER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <decl_stmt><decl><type><specifier>const</specifier> <specifier>volatile</specifier> <name>int</name></type> <name>orig_stderr</name> <init>= <expr><call><name>munit_replace_stderr</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_THREAD_LOCAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>setjmp</name><argument_list>(<argument><expr><name>munit_error_jmp_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_FAIL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>report</name><operator>.</operator><name>failed</name></name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>munit_error_jmp_buf_valid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>munit_test_runner_exec</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>munit_test_runner_exec</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>report</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_BUFFER</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>munit_restore_stderr</name><argument_list>(<argument><expr><name>orig_stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <comment type="block">/* Here just so that the label is used on Windows and we don't get
     * a warning */</comment>
    <goto>goto <name>print_result</name>;</goto>
  </block_content>}</block></else></if_stmt>

 <label><name>print_result</name>:</label>

  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">"[ "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>test</name><operator>-&gt;</operator><name>options</name></name> <operator>&amp;</operator> <name>MUNIT_TEST_OPTION_TODO</name><operator>)</operator> <operator>==</operator> <name>MUNIT_TEST_OPTION_TODO</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>report</name><operator>.</operator><name>failed</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>report</name><operator>.</operator><name>errored</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>report</name><operator>.</operator><name>skipped</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_TODO</name></expr></argument>, <argument><expr><literal type="char">'3'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_OK</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_ERROR</name></expr></argument>, <argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><call><name>MUNIT_LIKELY</name><argument_list>(<argument><expr><name>stderr_buf</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>munit_log_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr_buf</name></expr></argument>, <argument><expr><literal type="string">"Test marked TODO, but was successful."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
      <expr_stmt><expr><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>failed</name></name><operator>++</operator></expr>;</expr_stmt>
      <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_ERROR</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>report</name><operator>.</operator><name>failed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_FAIL</name></expr></argument>, <argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>failed</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_FAIL</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>report</name><operator>.</operator><name>errored</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_ERROR</name></expr></argument>, <argument><expr><literal type="char">'1'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>errored</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_ERROR</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>report</name><operator>.</operator><name>skipped</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_SKIP</name></expr></argument>, <argument><expr><literal type="char">'3'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>skipped</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_SKIP</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>report</name><operator>.</operator><name>successful</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_OK</name></expr></argument>, <argument><expr><literal type="char">'2'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" ] [ "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_print_time</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><name><name>report</name><operator>.</operator><name>wall_clock</name></name> <operator>/</operator> <name><name>report</name><operator>.</operator><name>successful</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" / "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_print_time</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><name><name>report</name><operator>.</operator><name>cpu_clock</name></name> <operator>/</operator> <name><name>report</name><operator>.</operator><name>successful</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><literal type="string">" CPU ]\n  %-"</literal> <call><name>MUNIT_XSTRINGIFY</name><argument_list>(<argument><expr><name>MUNIT_TEST_NAME_LEN</name></expr></argument>)</argument_list></call> <literal type="string">"s Total: [ "</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_print_time</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><name><name>report</name><operator>.</operator><name>wall_clock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" / "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_print_time</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><name><name>report</name><operator>.</operator><name>cpu_clock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" CPU"</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>successful</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>report</name><operator>.</operator><name>successful</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_test_runner_print_color</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>MUNIT_RESULT_STRING_OK</name></expr></argument>, <argument><expr><literal type="char">'2'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" ] [ "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_print_time</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><name><name>report</name><operator>.</operator><name>wall_clock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" / "</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>munit_print_time</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><name><name>report</name><operator>.</operator><name>cpu_clock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" CPU"</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>successful</name></name><operator>++</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>MUNIT_OK</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">" ]\n"</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name>stderr_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>MUNIT_FAIL</name> <operator>||</operator> <name>result</name> <operator>==</operator> <name>MUNIT_ERROR</name> <operator>||</operator> <name><name>runner</name><operator>-&gt;</operator><name>show_stderr</name></name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>rewind</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>munit_splice</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>STDERR_FILENO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>stderr_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_test_runner_run_test_wild</name><parameter_list>(<parameter><decl><type><name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>MunitTest</name><modifier>*</modifier></type> <name>test</name></decl></parameter>,
                                <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>test_name</name></decl></parameter>,
                                <parameter><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name>params</name></decl></parameter>,
                                <parameter><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name>p</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameterEnum</name><modifier>*</modifier></type> <name>pe</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>values</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name>next</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>pe</name> <operator>=</operator> <name><name>test</name><operator>-&gt;</operator><name>parameters</name></name></expr> ;</init> <condition><expr><name>pe</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pe</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>pe</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name>pe</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
    <return>return;</return></block_content></block></if></if_stmt>

  <for>for <control>(<init><expr><name>values</name> <operator>=</operator> <name><name>pe</name><operator>-&gt;</operator><name>values</name></name></expr> ;</init> <condition><expr><operator>*</operator><name>values</name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>values</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><name>next</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <operator>*</operator><name>values</name></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>next</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><call><name>munit_test_runner_run_test_with_params</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>munit_test_runner_run_test_wild</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>test_name</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>fatal_failures</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>failed</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>errored</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
      <break>break;</break></block_content></block></if></if_stmt>
  </block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* Run a single test, with every combination of parameters
 * requested. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_test_runner_run_test</name><parameter_list>(<parameter><decl><type><name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>MunitTest</name><modifier>*</modifier></type> <name>test</name></decl></parameter>,
                           <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>test_name</name> <init>= <expr><call><name>munit_maybe_concat</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>prefix</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>test</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <comment type="block">/* The array of parameters to pass to
   * munit_test_runner_run_test_with_params */</comment>
  <decl_stmt><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name>params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>params_l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Wildcard parameters are parameters which have possible values
   * specified in the test, but no specific value was passed to the
   * CLI.  That means we want to run the test once for every
   * possible combination of parameter values or, if --single was
   * passed to the CLI, a single time with a random set of
   * parameters. */</comment>
  <decl_stmt><decl><type><name>MunitParameter</name><modifier>*</modifier></type> <name>wild_params</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>wild_params_l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameterEnum</name><modifier>*</modifier></type> <name>pe</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameter</name><modifier>*</modifier></type> <name>cli_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>filled</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>possible</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>vals</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>first_wild</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameter</name><modifier>*</modifier></type> <name>wp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pidx</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>munit_rand_seed</name><argument_list>(<argument><expr><name><name>runner</name><operator>-&gt;</operator><name>seed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><literal type="string">"%-"</literal> <call><name>MUNIT_XSTRINGIFY</name><argument_list>(<argument><expr><name>MUNIT_TEST_NAME_LEN</name></expr></argument>)</argument_list></call> <literal type="string">"s"</literal></expr></argument>, <argument><expr><name>test_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>test</name><operator>-&gt;</operator><name>parameters</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
    <comment type="block">/* No parameters.  Simple, nice. */</comment>
    <expr_stmt><expr><call><name>munit_test_runner_run_test_with_params</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <for>for <control>(<init><expr><name>pe</name> <operator>=</operator> <name><name>test</name><operator>-&gt;</operator><name>parameters</name></name></expr> ;</init> <condition><expr><name>pe</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pe</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>pe</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
      <comment type="block">/* Did we received a value for this parameter from the CLI? */</comment>
      <expr_stmt><expr><name>filled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>cli_p</name> <operator>=</operator> <name><name>runner</name><operator>-&gt;</operator><name>parameters</name></name></expr> ;</init> <condition><expr><name>cli_p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>cli_p</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>cli_p</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cli_p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>munit_parameters_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params_l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>cli_p</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MUNIT_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
          <expr_stmt><expr><name>filled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
      <if_stmt><if>if <condition>(<expr><name>filled</name></expr>)</condition><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* Nothing from CLI, is the enum NULL/empty?  We're not a
       * fuzzerâ¦ */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>pe</name><operator>-&gt;</operator><name>values</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pe</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <continue>continue;</continue></block_content></block></if></if_stmt>

      <comment type="block">/* If --single was passed to the CLI, choose a value from the
       * list of possibilities randomly. */</comment>
      <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>single_parameter_mode</name></name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>possible</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <for>for <control>(<init><expr><name>vals</name> <operator>=</operator> <name><name>pe</name><operator>-&gt;</operator><name>values</name></name></expr> ;</init> <condition><expr><operator>*</operator><name>vals</name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>vals</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
          <expr_stmt><expr><name>possible</name><operator>++</operator></expr>;</expr_stmt></block_content></block></for>
        <comment type="block">/* We want the tests to be reproducible, even if you're only
         * running a single test, but we don't want every test with
         * the same number of parameters to choose the same parameter
         * number, so use the test name as a primitive salt. */</comment>
        <expr_stmt><expr><name>pidx</name> <operator>=</operator> <call><name>munit_rand_at_most</name><argument_list>(<argument><expr><call><name>munit_str_hash</name><argument_list>(<argument><expr><name>test_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>possible</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>munit_parameters_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params_l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>pidx</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MUNIT_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <comment type="block">/* We want to try every permutation.  Put in a placeholder
         * entry, we'll iterate through them later. */</comment>
        <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>munit_parameters_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wild_params_l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wild_params</name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MUNIT_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>

    <if_stmt><if>if <condition>(<expr><name>wild_params_l</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <expr_stmt><expr><name>first_wild</name> <operator>=</operator> <name>params_l</name></expr>;</expr_stmt>
      <for>for <control>(<init><expr><name>wp</name> <operator>=</operator> <name>wild_params</name></expr> ;</init> <condition><expr><name>wp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>wp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <for>for <control>(<init><expr><name>pe</name> <operator>=</operator> <name><name>test</name><operator>-&gt;</operator><name>parameters</name></name></expr> ;</init> <condition><expr><name>pe</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pe</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>pe</name><operator>-&gt;</operator><name>values</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>pe</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><call><name>MUNIT_UNLIKELY</name><argument_list>(<argument><expr><call><name>munit_parameters_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name>params_l</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>params</name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>pe</name><operator>-&gt;</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>MUNIT_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
              <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
          </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>
      </block_content>}</block></for>

      <expr_stmt><expr><call><name>munit_test_runner_run_test_wild</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>test_name</name></expr></argument>, <argument><expr><name>params</name></expr></argument>, <argument><expr><name>params</name> <operator>+</operator> <name>first_wild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><call><name>munit_test_runner_run_test_with_params</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

  <label><name>cleanup</name>:</label>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>wild_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <expr_stmt><expr><call><name>munit_maybe_free_concat</name><argument_list>(<argument><expr><name>test_name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>test</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Recurse through the suite and run all the tests.  If a list of
 * tests to run was provied on the command line, run only those
 * tests.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_test_runner_run_suite</name><parameter_list>(<parameter><decl><type><name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>suite</name></decl></parameter>,
                            <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pre_l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pre</name> <init>= <expr><call><name>munit_maybe_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pre_l</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>prefix</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>suite</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitTest</name><modifier>*</modifier></type> <name>test</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>test_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>child_suite</name></decl>;</decl_stmt>

  <comment type="block">/* Run the tests. */</comment>
  <for>for <control>(<init><expr><name>test</name> <operator>=</operator> <name><name>suite</name><operator>-&gt;</operator><name>tests</name></name></expr> ;</init> <condition><expr><name>test</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>test</name><operator>-&gt;</operator><name>test</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>test</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>tests</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content> <comment type="block">/* Specific tests were requested on the CLI */</comment>
      <for>for <control>(<init><expr><name>test_name</name> <operator>=</operator> <name><name>runner</name><operator>-&gt;</operator><name>tests</name></name></expr> ;</init> <condition><expr><name>test_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>test_name</name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>test_name</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>pre_l</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name>pre</name></expr></argument>, <argument><expr><operator>*</operator><name>test_name</name></expr></argument>, <argument><expr><name>pre_l</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator>
            <call><name>strncmp</name><argument_list>(<argument><expr><name><name>test</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name>test_name</name> <operator>+</operator> <name>pre_l</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name>test_name</name> <operator>+</operator> <name>pre_l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_test_runner_run_test</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>fatal_failures</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>failed</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>errored</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
            <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* Run all tests */</comment>
      <expr_stmt><expr><call><name>munit_test_runner_run_test</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>test</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>-&gt;</operator><name>fatal_failures</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>failed</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>runner</name><operator>-&gt;</operator><name>report</name><operator>.</operator><name>errored</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
    <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

  <comment type="block">/* Run any child suites. */</comment>
  <for>for <control>(<init><expr><name>child_suite</name> <operator>=</operator> <name><name>suite</name><operator>-&gt;</operator><name>suites</name></name></expr> ;</init> <condition><expr><name>child_suite</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>child_suite</name><operator>-&gt;</operator><name>prefix</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>child_suite</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_test_runner_run_suite</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name>child_suite</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

 <label><name>cleanup</name>:</label>

  <expr_stmt><expr><call><name>munit_maybe_free_concat</name><argument_list>(<argument><expr><name>pre</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>suite</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_test_runner_run</name><parameter_list>(<parameter><decl><type><name>MunitTestRunner</name><modifier>*</modifier></type> <name>runner</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <expr_stmt><expr><call><name>munit_test_runner_run_suite</name><argument_list>(<argument><expr><name>runner</name></expr></argument>, <argument><expr><name><name>runner</name><operator>-&gt;</operator><name>suite</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_print_help</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>argv</name><index>[<expr><call><name>MUNIT_ARRAY_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>user_data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>MunitArgument</name></type> <name><name>arguments</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitArgument</name><modifier>*</modifier></type> <name>arg</name></decl>;</decl_stmt>
  <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>argc</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"USAGE: %s [OPTIONS...] [TEST...]\n\n"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">" --seed SEED\n"</literal>
       <literal type="string">"           Value used to seed the PRNG.  Must be a 32-bit integer in decimal\n"</literal>
       <literal type="string">"           notation with no separators (commas, decimals, spaces, etc.), or\n"</literal>
       <literal type="string">"           hexidecimal prefixed by \"0x\".\n"</literal>
       <literal type="string">" --iterations N\n"</literal>
       <literal type="string">"           Run each test N times.  0 means the default number.\n"</literal>
       <literal type="string">" --param name value\n"</literal>
       <literal type="string">"           A parameter key/value pair which will be passed to any test with\n"</literal>
       <literal type="string">"           takes a parameter of that name.  If not provided, the test will be\n"</literal>
       <literal type="string">"           run once for each possible parameter value.\n"</literal>
       <literal type="string">" --list    Write a list of all available tests.\n"</literal>
       <literal type="string">" --list-params\n"</literal>
       <literal type="string">"           Write a list of all available tests and their possible parameters.\n"</literal>
       <literal type="string">" --single  Run each parameterized test in a single configuration instead of\n"</literal>
       <literal type="string">"           every possible combination\n"</literal>
       <literal type="string">" --log-visible debug|info|warning|error\n"</literal>
       <literal type="string">" --log-fatal debug|info|warning|error\n"</literal>
       <literal type="string">"           Set the level at which messages of different severities are visible,\n"</literal>
       <literal type="string">"           or cause the test to terminate.\n"</literal>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NO_FORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
       <literal type="string">" --no-fork Do not execute tests in a child process.  If this option is supplied\n"</literal>
       <literal type="string">"           and a test crashes (including by failing an assertion), no further\n"</literal>
       <literal type="string">"           tests will be performed.\n"</literal>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
       <literal type="string">" --fatal-failures\n"</literal>
       <literal type="string">"           Stop executing tests as soon as a failure is found.\n"</literal>
       <literal type="string">" --show-stderr\n"</literal>
       <literal type="string">"           Show data written to stderr by the tests, even if the test succeeds.\n"</literal>
       <literal type="string">" --color auto|always|never\n"</literal>
       <literal type="string">"           Colorize (or don't) the output.\n"</literal>
     <comment type="block">/* 12345678901234567890123456789012345678901234567890123456789012345678901234567890 */</comment>
       <literal type="string">" --help    Print this help message and exit.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_NL_LANGINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><call><name>setlocale</name><argument_list>(<argument><expr><name>LC_ALL</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><call><name>strcasecmp</name><argument_list>(<argument><expr><literal type="string">"UTF-8"</literal></expr></argument>, <argument><expr><call><name>nl_langinfo</name><argument_list>(<argument><expr><name>CODESET</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"Âµnit"</literal></expr> </then><else>: <expr><literal type="string">"munit"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"munit"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">" %d.%d.%d\n"</literal>
         <literal type="string">"Full documentation at: https://nemequ.github.io/munit/\n"</literal></expr></argument>,
         <argument><expr><operator>(</operator><name>MUNIT_CURRENT_VERSION</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>,
         <argument><expr><operator>(</operator><name>MUNIT_CURRENT_VERSION</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>,
         <argument><expr><operator>(</operator><name>MUNIT_CURRENT_VERSION</name> <operator>&gt;&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name>arguments</name></expr> ;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>arg</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>arg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <expr_stmt><expr><call><name><name>arg</name><operator>-&gt;</operator><name>write_help</name></name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>MunitArgument</name><modifier>*</modifier></type>
<name>munit_arguments_find</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitArgument</name></type> <name><name>arguments</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitArgument</name><modifier>*</modifier></type> <name>arg</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <name>arguments</name></expr> ;</init> <condition><expr><name>arg</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>arg</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>arg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>arg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
      <return>return <expr><name>arg</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

  <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>munit_suite_list_tests</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>suite</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>show_params</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>pre_l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>pre</name> <init>= <expr><call><name>munit_maybe_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pre_l</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>prefix</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>suite</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitTest</name><modifier>*</modifier></type> <name>test</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitParameterEnum</name><modifier>*</modifier></type> <name>params</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>bool</name></type> <name>first</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>child_suite</name></decl>;</decl_stmt>

  <for>for <control>(<init><expr><name>test</name> <operator>=</operator> <name><name>suite</name><operator>-&gt;</operator><name>tests</name></name></expr> ;</init>
       <condition><expr><name>test</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>test</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition>
       <incr><expr><name>test</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>pre</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
      <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>pre</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><name><name>test</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>show_params</name></expr>)</condition> <block>{<block_content>
      <for>for <control>(<init><expr><name>params</name> <operator>=</operator> <name><name>test</name><operator>-&gt;</operator><name>parameters</name></name></expr> ;</init>
           <condition><expr><name>params</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>params</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition>
           <incr><expr><name>params</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
        <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr><literal type="string">" - %s: "</literal></expr></argument>, <argument><expr><name><name>params</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>params</name><operator>-&gt;</operator><name>values</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><literal type="string">"Any"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
          <for>for <control>(<init><expr><name>val</name> <operator>=</operator> <name><name>params</name><operator>-&gt;</operator><name>values</name></name></expr> ;</init>
               <condition><expr><operator>*</operator><name>val</name> <operator>!=</operator> <name>NULL</name></expr> ;</condition>
               <incr><expr><name>val</name><operator>++</operator></expr></incr> )</control> <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><operator>!</operator><name>first</name></expr>)</condition> <block>{<block_content>
              <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><literal type="string">", "</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></if> <else>else <block>{<block_content>
              <expr_stmt><expr><name>first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
            <expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><operator>*</operator><name>val</name></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          </block_content>}</block></for>
          <expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
  </block_content>}</block></for>

  <for>for <control>(<init><expr><name>child_suite</name> <operator>=</operator> <name><name>suite</name><operator>-&gt;</operator><name>suites</name></name></expr> ;</init> <condition><expr><name>child_suite</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>child_suite</name><operator>-&gt;</operator><name>prefix</name></name> <operator>!=</operator> <name>NULL</name></expr> ;</condition> <incr><expr><name>child_suite</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <expr_stmt><expr><call><name>munit_suite_list_tests</name><argument_list>(<argument><expr><name>child_suite</name></expr></argument>, <argument><expr><name>show_params</name></expr></argument>, <argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>munit_maybe_free_concat</name><argument_list>(<argument><expr><name>pre</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>suite</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>munit_stream_supports_ansi</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <return>return <expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <decl_stmt><decl><type><name>size_t</name></type> <name>ansicon_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <if_stmt><if>if <condition>(<expr><call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
    <expr_stmt><expr><call><name>getenv_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ansicon_size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"ANSICON"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>ansicon_size</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
    <return>return <expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"ANSICON"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><name>false</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>munit_suite_main_custom</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>suite</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>user_data</name></decl></parameter>,
                        <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>argv</name><index>[<expr><call><name>MUNIT_ARRAY_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>,
                        <parameter><decl><type><specifier>const</specifier> <name>MunitArgument</name></type> <name><name>arguments</name><index>[]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>EXIT_FAILURE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitTestRunner</name></type> <name>runner</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>parameters_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>size_t</name></type> <name>tests_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>envptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>endptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>iterations</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>MunitLogLevel</name></type> <name>level</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>MunitArgument</name><modifier>*</modifier></type> <name>argument</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>runner_tests</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tests_run</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tests_total</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>prefix</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>suite</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>tests</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>seed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>iterations</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>parameters</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>single_parameter_mode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>user_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>successful</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>skipped</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>failed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>errored</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MUNIT_ENABLE_TIMING</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>cpu_clock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>wall_clock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>colorize</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>fork</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>fork</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>show_stderr</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>fatal_failures</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>suite</name></name> <operator>=</operator> <name>suite</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>user_data</name></name> <operator>=</operator> <name>user_data</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>seed</name></name> <operator>=</operator> <call><name>munit_rand_generate_seed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>colorize</name></name> <operator>=</operator> <call><name>munit_stream_supports_ansi</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for <control>(<init><expr><name>arg</name> <operator>=</operator> <literal type="number">1</literal></expr> ;</init> <condition><expr><name>arg</name> <operator>&lt;</operator> <name>argc</name></expr> ;</condition> <incr><expr><name>arg</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><literal type="string">"--"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"seed"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s requires an argument"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>envptr</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>ts</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>envptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>envptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>ts</name> <operator>&gt;</operator> <operator>(</operator><operator>~</operator><operator>(</operator><operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <literal type="number">0U</literal><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid value ('%s') passed to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>seed</name></name> <operator>=</operator> <operator>(</operator><name>munit_uint32_t</name><operator>)</operator> <name>ts</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"iterations"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s requires an argument"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>endptr</name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>iterations</name> <operator>=</operator> <call><name>strtoul</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name>iterations</name> <operator>&gt;</operator> <name>UINT_MAX</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid value ('%s') passed to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>iterations</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name>iterations</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"param"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s requires two arguments"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>parameters</name></name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name><name>runner</name><operator>.</operator><name>parameters</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>MunitParameter</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>parameters_size</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>.</operator><name>parameters</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_log_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>parameters</name><index>[<expr><name>parameters_size</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>parameters</name><index>[<expr><name>parameters_size</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>parameters_size</name><operator>++</operator></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>parameters</name><index>[<expr><name>parameters_size</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>parameters</name><index>[<expr><name>parameters_size</name></expr>]</index></name><operator>.</operator><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>arg</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"color"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s requires an argument"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"always"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>colorize</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"never"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>colorize</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"auto"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>colorize</name></name> <operator>=</operator> <call><name>munit_stream_supports_ansi</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid value ('%s') passed to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"help"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>munit_print_help</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>, <argument><expr><name>arguments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"single"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>single_parameter_mode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"show-stderr"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>show_stderr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"no-fork"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>fork</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"fatal-failures"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>fatal_failures</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"log-visible"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
                 <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"log-fatal"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>argc</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s requires an argument"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"debug"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>level</name> <operator>=</operator> <name>MUNIT_LOG_DEBUG</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"info"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>level</name> <operator>=</operator> <name>MUNIT_LOG_INFO</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"warning"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>level</name> <operator>=</operator> <name>MUNIT_LOG_WARNING</name></expr>;</expr_stmt></block_content></block></if>
        <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>level</name> <operator>=</operator> <name>MUNIT_LOG_ERROR</name></expr>;</expr_stmt></block_content></block></if>
        <else>else <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"invalid value ('%s') passed to %s"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></else></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"log-visible"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
          <expr_stmt><expr><name>munit_log_level_visible</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt></block_content></block></if>
        <else>else<block type="pseudo"><block_content>
          <expr_stmt><expr><name>munit_log_level_fatal</name> <operator>=</operator> <name>level</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>munit_suite_list_tests</name><argument_list>(<argument><expr><name>suite</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"list-params"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>munit_suite_list_tests</name><argument_list>(<argument><expr><name>suite</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>argument</name> <operator>=</operator> <call><name>munit_arguments_find</name><argument_list>(<argument><expr><name>arguments</name></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name>argument</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
          <expr_stmt><expr><call><name>munit_logf_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"unknown argument ('%s')"</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <goto>goto <name>cleanup</name>;</goto>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>argument</name><operator>-&gt;</operator><name>parse_argument</name></name><argument_list>(<argument><expr><name>suite</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
          <goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <expr_stmt><expr><name>runner_tests</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name><name>runner</name><operator>.</operator><name>tests</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>tests_size</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if_stmt><if>if <condition>(<expr><name>runner_tests</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>munit_log_internal</name><argument_list>(<argument><expr><name>MUNIT_LOG_ERROR</name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"failed to allocate memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <goto>goto <name>cleanup</name>;</goto>
      </block_content>}</block></if></if_stmt>
      <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>tests</name></name> <operator>=</operator> <name>runner_tests</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>tests</name><index>[<expr><name>tests_size</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>argv</name><index>[<expr><name>arg</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>runner</name><operator>.</operator><name>tests</name><index>[<expr><name>tests_size</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></for>

  <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><literal type="string">"Running test suite with seed 0x%08"</literal> <name>PRIx32</name> <literal type="string">"...\n"</literal></expr></argument>, <argument><expr><name><name>runner</name><operator>.</operator><name>seed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>munit_test_runner_run</name><argument_list>(<argument><expr><operator>&amp;</operator><name>runner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>tests_run</name> <operator>=</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>successful</name></name> <operator>+</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>failed</name></name> <operator>+</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>errored</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>tests_total</name> <operator>=</operator> <name>tests_run</name> <operator>+</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>skipped</name></name></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>tests_run</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"No tests run, %d (100%%) skipped.\n"</literal></expr></argument>, <argument><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>skipped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>MUNIT_OUTPUT_FILE</name></expr></argument>, <argument><expr><literal type="string">"%d of %d (%0.0f%%) tests successful, %d (%0.0f%%) test skipped.\n"</literal></expr></argument>,
            <argument><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>successful</name></name></expr></argument>, <argument><expr><name>tests_run</name></expr></argument>,
            <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>successful</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>tests_run</name><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">100.0</literal></expr></argument>,
            <argument><expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>skipped</name></name></expr></argument>,
            <argument><expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>skipped</name></name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>tests_total</name><operator>)</operator><operator>)</operator> <operator>*</operator> <literal type="number">100.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></else></if_stmt>

  <if_stmt><if>if <condition>(<expr><name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>failed</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>runner</name><operator>.</operator><name>report</name><operator>.</operator><name>errored</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><name>result</name> <operator>=</operator> <name>EXIT_SUCCESS</name></expr>;</expr_stmt>
  </block_content>}</block></if></if_stmt>

 <label><name>cleanup</name>:</label>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>runner</name><operator>.</operator><name>parameters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name><operator>*</operator><operator>)</operator> <name><name>runner</name><operator>.</operator><name>tests</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>munit_suite_main</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitSuite</name><modifier>*</modifier></type> <name>suite</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>user_data</name></decl></parameter>,
                 <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier> <specifier>const</specifier></type> <name><name>argv</name><index>[<expr><call><name>MUNIT_ARRAY_PARAM</name><argument_list>(<argument><expr><name>argc</name></expr></argument>)</argument_list></call></expr>]</index></name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>munit_suite_main_custom</name><argument_list>(<argument><expr><name>suite</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
