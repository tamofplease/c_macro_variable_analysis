<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/dqlite/test/integration/test_vfs.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;raft.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../lib/fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../lib/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../lib/runner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../lib/sqlite.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../include/dqlite.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/mman.h&gt;</cpp:file></cpp:include>

<expr_stmt><expr><call><name>SUITE</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>N_VFS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type> <name><name>bools</name><index>[]</index></name> <init>= <expr><block>{
    <expr><literal type="string">"0"</literal></expr>, <expr><literal type="string">"1"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_SHALLOW_PARAM</name></cpp:macro> <cpp:value>"snapshot-shallow-param"</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>MunitParameterEnum</name></type> <name><name>vfs_params</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><name>SNAPSHOT_SHALLOW_PARAM</name></expr>, <expr><name>bools</name></expr>}</block></expr>,
	<expr><block>{ <expr><literal type="string">"disk_mode"</literal></expr>, <expr><name>bools</name></expr> }</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>


<struct>struct <name>fixture</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>sqlite3_vfs</name></name></type> <name><name>vfs</name><index>[<expr><name>N_VFS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* A "cluster" of VFS objects. */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>names</name><index>[<expr><literal type="number">8</literal></expr>]</index><index>[<expr><name>N_VFS</name></expr>]</index></name></decl>;</decl_stmt>          <comment type="block">/* Registration names */</comment>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>dirs</name><index>[<expr><name>N_VFS</name></expr>]</index></name></decl>;</decl_stmt>             <comment type="block">/* For the disk vfs. */</comment>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>setUp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>MunitParameter</name></type> <name><name>params</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fixture</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>munit_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>SETUP_HEAP</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>SETUP_SQLITE</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N_VFS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dqlite_vfs_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>disk_mode_param</name> <init>= <expr><call><name>munit_parameters_get</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><literal type="string">"disk_mode"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>disk_mode_param</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type> <name>disk_mode</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator><call><name>atoi</name><argument_list>(<argument><expr><name>disk_mode_param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>disk_mode</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>test_dir_setup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>dqlite_vfs_enable_disk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_vfs_register</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>f</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tearDown</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>fixture</name></name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>N_VFS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_vfs_unregister</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dqlite_vfs_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>f</name><operator>-&gt;</operator><name>vfs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>test_dir_tear_down</name><argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>TEAR_DOWN_SQLITE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>TEAR_DOWN_HEAP</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>extern</specifier> <name>unsigned</name></type> <name>dq_sqlite_pending_byte</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tearDownRestorePendingByte</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_PENDING_BYTE</name></expr></argument>, <argument><expr><literal type="number">0x40000000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dq_sqlite_pending_byte</name> <operator>=</operator> <literal type="number">0x40000000</literal></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tearDown</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGE_SIZE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRAGMA</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>, <parameter><type><name>COMMAND</name></type></parameter>)</parameter_list></cpp:macro>                                          \
	<cpp:value>_rv = sqlite3_exec(DB, "PRAGMA " COMMAND, NULL, NULL, NULL); \
	if (_rv != SQLITE_OK) {                                      \
		munit_errorf("PRAGMA " COMMAND ": %s (%d)",          \
			     sqlite3_errmsg(DB), _rv);               \
	}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VFS_PATH_SZ</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>void</name></type> <name>vfsFillDbPath</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>fixture</name></name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>vfs</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	    <decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>dirs</name><index>[<expr><call><name>atoi</name><argument_list>(<argument><expr><name>vfs</name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
	    <if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>VFS_PATH_SZ</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if> <else>else <block>{<block_content>
		    <expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>VFS_PATH_SZ</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	    <expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>&gt;</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>&lt;</operator></expr></argument>, <argument><expr><name>VFS_PATH_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Open a new database connection on the given VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPEN</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>DB</name></type></parameter>)</parameter_list></cpp:macro>                                                         \
	<cpp:value>do {                                                                  \
		int _flags = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE;      \
		int _rv;                                                      \
		char path[VFS_PATH_SZ];                                       \
		struct fixture *f = data;                                     \
		vfsFillDbPath(f, VFS, "test.db", path);                       \
		_rv = sqlite3_open_v2(path, &amp;DB, _flags, VFS);           \
		munit_assert_int(_rv, ==, SQLITE_OK);                         \
		_rv = sqlite3_extended_result_codes(DB, 1);                   \
		munit_assert_int(_rv, ==, SQLITE_OK);                         \
		PRAGMA(DB, "page_size=512");                                  \
		PRAGMA(DB, "synchronous=OFF");                                \
		PRAGMA(DB, "journal_mode=WAL");                               \
		PRAGMA(DB, "cache_size=1");                                   \
		_rv = sqlite3_db_config(DB, SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE, \
					1, NULL);                             \
		munit_assert_int(_rv, ==, SQLITE_OK);                         \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Close a database connection. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOSE</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>)</parameter_list></cpp:macro>                                     \
	<cpp:value>do {                                          \
		int _rv;                              \
		_rv = sqlite3_close(DB);              \
		munit_assert_int(_rv, ==, SQLITE_OK); \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Prepare a statement. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREPARE</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>, <parameter><type><name>STMT</name></type></parameter>, <parameter><type><name>SQL</name></type></parameter>)</parameter_list></cpp:macro>                                      \
	<cpp:value>do {                                                        \
		int _rv;                                            \
		_rv = sqlite3_prepare_v2(DB, SQL, -1, &amp;STMT, NULL); \
		if (_rv != SQLITE_OK) {                             \
			munit_errorf("prepare '%s': %s (%d)", SQL,  \
				     sqlite3_errmsg(DB), _rv);      \
		}                                                   \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Reset a statement. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESET</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>, <parameter><type><name>RV</name></type></parameter>)</parameter_list></cpp:macro>                        \
	<cpp:value>do {                                   \
		int _rv;                       \
		_rv = sqlite3_reset(STMT);     \
		munit_assert_int(_rv, ==, RV); \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Finalize a statement. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FINALIZE</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>)</parameter_list></cpp:macro>                                \
	<cpp:value>do {                                          \
		int _rv;                              \
		_rv = sqlite3_finalize(STMT);         \
		munit_assert_int(_rv, ==, SQLITE_OK); \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Shortcut for PREPARE, STEP, FINALIZE. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>, <parameter><type><name>SQL</name></type></parameter>)</parameter_list></cpp:macro>                     \
	<cpp:value>do {                              \
		sqlite3_stmt *_stmt;      \
		PREPARE(DB, _stmt, SQL);  \
		STEP(_stmt, SQLITE_DONE); \
		FINALIZE(_stmt);          \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Step through a statement and assert that the given value is returned. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STEP</name><parameter_list>(<parameter><type><name>STMT</name></type></parameter>, <parameter><type><name>RV</name></type></parameter>)</parameter_list></cpp:macro>                                                        \
	<cpp:value>do {                                                                  \
		int _rv;                                                      \
		_rv = sqlite3_step(STMT);                                     \
		if (_rv != RV) {                                              \
			munit_errorf("step: %s (%d)",                         \
				     sqlite3_errmsg(sqlite3_db_handle(STMT)), \
				     _rv);                                    \
		}                                                             \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Hold WAL replication information about a single transaction. */</comment>
<struct>struct <name>tx</name>
<block>{
	<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>page_numbers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>frames</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Poll the given VFS object and serialize the transaction data into the given
 * tx object. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POLL</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>TX</name></type></parameter>)</parameter_list></cpp:macro>                                                      \
	<cpp:value>do {                                                               \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS);                  \
		dqlite_vfs_frame *_frames;                                 \
		unsigned _i;                                               \
		int _rv;                                                   \
		memset(&amp;TX, 0, sizeof TX);                                 \
		char path[VFS_PATH_SZ];                                    \
		struct fixture *f = data;                                  \
		vfsFillDbPath(f, VFS, "test.db", path);                    \
		_rv = dqlite_vfs_poll(vfs, path, &amp;_frames, &amp;TX.n);         \
		munit_assert_int(_rv, ==, 0);                              \
		if (_frames != NULL) {                                     \
			TX.page_numbers =                                  \
			    munit_malloc(sizeof *TX.page_numbers * TX.n);  \
			TX.frames = munit_malloc(PAGE_SIZE * TX.n);        \
			for (_i = 0; _i &lt; TX.n; _i++) {                    \
				dqlite_vfs_frame *_frame = &amp;_frames[_i];   \
				TX.page_numbers[_i] = _frame-&gt;page_number; \
				memcpy(TX.frames + _i * PAGE_SIZE,         \
				       _frame-&gt;data, PAGE_SIZE);           \
				sqlite3_free(_frame-&gt;data);                \
			}                                                  \
			sqlite3_free(_frames);                             \
		}                                                          \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Apply WAL frames to the given VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APPLY</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>TX</name></type></parameter>)</parameter_list></cpp:macro>                                                        \
	<cpp:value>do {                                                                  \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS);                     \
		int _rv;                                                      \
		char path[VFS_PATH_SZ];                                       \
		struct fixture *f = data;                                     \
		vfsFillDbPath(f, VFS, "test.db", path);                       \
		_rv = dqlite_vfs_apply(vfs, path, TX.n, TX.page_numbers,      \
				       TX.frames);                 \
		munit_assert_int(_rv, ==, 0);                                 \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Abort a transaction on the given VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABORT</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>)</parameter_list></cpp:macro>                                        \
	<cpp:value>do {                                              \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS); \
		int _rv;                                  \
		char path[VFS_PATH_SZ];                   \
		struct fixture *f = data;                 \
		vfsFillDbPath(f, VFS, "test.db", path);   \
		_rv = dqlite_vfs_abort(vfs, path);        \
		munit_assert_int(_rv, ==, 0);             \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Release all memory used by a struct tx object. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DONE</name><parameter_list>(<parameter><type><name>TX</name></type></parameter>)</parameter_list></cpp:macro>                       \
	<cpp:value>do {                           \
		free(TX.frames);       \
		free(TX.page_numbers); \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Peform a full checkpoint on the given database. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKPOINT</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>)</parameter_list></cpp:macro>                                                       \
	<cpp:value>do {                                                                 \
		int _size;                                                   \
		int _ckpt;                                                   \
		int _rv;                                                     \
		_rv = sqlite3_wal_checkpoint_v2(                             \
		    DB, "main", SQLITE_CHECKPOINT_TRUNCATE, &amp;_size, &amp;_ckpt); \
		if (_rv != SQLITE_OK) {                                      \
			munit_errorf("checkpoint: %s (%d)",                  \
				     sqlite3_errmsg(DB), _rv);               \
		}                                                            \
		munit_assert_int(_size, ==, 0);                              \
		munit_assert_int(_ckpt, ==, 0);                              \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Perform a full checkpoint on a fresh connection, mimicking dqlite's
 * checkpoint behavior. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKPOINT_FRESH</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>)</parameter_list></cpp:macro>                                                \
	<cpp:value>do {                                                                 \
		sqlite3 *_db;                                                \
		OPEN(VFS, _db);                                              \
		CHECKPOINT(_db);                                             \
		CLOSE(_db);                                                  \
	} while(0)</cpp:value></cpp:define>

<comment type="block">/* Attempt to perform a full checkpoint on the given database, but fail. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECKPOINT_FAIL</name><parameter_list>(<parameter><type><name>DB</name></type></parameter>, <parameter><type><name>RV</name></type></parameter>)</parameter_list></cpp:macro>                                              \
	<cpp:value>do {                                                                 \
		int _size;                                                   \
		int _ckpt;                                                   \
		int _rv;                                                     \
		_rv = sqlite3_wal_checkpoint_v2(                             \
		    DB, "main", SQLITE_CHECKPOINT_TRUNCATE, &amp;_size, &amp;_ckpt); \
		munit_assert_int(_rv, ==, RV);                               \
	} while (0)</cpp:value></cpp:define>

<struct>struct <name>snapshot</name>
<block>{
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>main_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>wal_size</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Copies n dqlite_buffers to a single dqlite buffer */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>dqlite_buffer</name></name></type> <name>n_bufs_to_buf</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name></type> <name><name>bufs</name><index>[]</index></name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>cursor</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>dqlite_buffer</name></name></type> <name>buf</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Allocate a suitable buffer */</comment>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>tracef</name><argument_list>(<argument><expr><literal type="string">"buf.len %zu"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>buf</name><operator>.</operator><name>base</name></name> <operator>=</operator> <call><name>raft_malloc</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_ptr_not_null</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy all data */</comment>
	<expr_stmt><expr><name>cursor</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>base</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>unsigned</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
	    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base</name></expr></argument>, <argument><expr><name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name><name>bufs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>munit_assert_ullong</name><argument_list>(<argument><expr><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><name>cursor</name> <operator>-</operator> <operator>(</operator><name>uint8_t</name><operator>*</operator><operator>)</operator><name><name>buf</name><operator>.</operator><name>base</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_DISK</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>SNAPSHOT</name></type></parameter>)</parameter_list></cpp:macro>                             \
	<cpp:value>do {                                                     \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS);        \
		int _rv;                                         \
		unsigned _n;                                     \
		struct dqlite_buffer *_bufs;                     \
		struct dqlite_buffer _all_data;                  \
		_n = 2;	                                         \
		_bufs = sqlite3_malloc64(_n * sizeof(*_bufs));   \
		char path[VFS_PATH_SZ];                          \
		struct fixture *f = data;                        \
		vfsFillDbPath(f, VFS, "test.db", path);          \
		_rv = dqlite_vfs_snapshot_disk(vfs, path, _bufs, \
					  _n);                   \
		munit_assert_int(_rv, ==, 0);                    \
		_all_data = n_bufs_to_buf(_bufs, _n);            \
		<comment type="block">/* Free WAL buffer after copy. */</comment>                \
		SNAPSHOT.main_size = _bufs[0].len; \
		SNAPSHOT.wal_size = _bufs[1].len; \
		sqlite3_free(_bufs[1].base);                     \
		munmap(_bufs[0].base, _bufs[0].len);             \
		sqlite3_free(_bufs);                             \
		SNAPSHOT.data = _all_data.base;                  \
		SNAPSHOT.n = _all_data.len;                      \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Take a snapshot of the database on the given VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_DEEP</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>SNAPSHOT</name></type></parameter>)</parameter_list></cpp:macro>                                      \
	<cpp:value>do {                                                              \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS);                 \
		int _rv;                                                  \
		_rv = dqlite_vfs_snapshot(vfs, "test.db", &amp;SNAPSHOT.data, \
					  &amp;SNAPSHOT.n);                   \
		munit_assert_int(_rv, ==, 0);                             \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Take a shallow snapshot of the database on the given VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT_SHALLOW</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>SNAPSHOT</name></type></parameter>)</parameter_list></cpp:macro>                                       \
	<cpp:value>do {                                                                  \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS);                     \
		int _rv;                                                      \
		unsigned _n;                                                  \
		unsigned _n_pages;                                            \
		struct dqlite_buffer *_bufs;                                  \
		struct dqlite_buffer _all_data;                               \
		_rv = dqlite_vfs_num_pages(vfs, "test.db", &amp;_n_pages);        \
		munit_assert_int(_rv, ==, 0);                                 \
		_n = _n_pages + 1; <comment type="block">/* + 1 for WAL */</comment>                          \
		_bufs = sqlite3_malloc64(_n * sizeof(*_bufs));                \
		_rv = dqlite_vfs_shallow_snapshot(vfs, "test.db", _bufs, _n); \
		munit_assert_int(_rv, ==, 0);                                 \
		_all_data = n_bufs_to_buf(_bufs, _n);                         \
		<comment type="block">/* Free WAL buffer after copy. */</comment>                             \
		sqlite3_free(_bufs[_n - 1].base);                             \
		sqlite3_free(_bufs);                                          \
		SNAPSHOT.data = _all_data.base;                               \
		SNAPSHOT.n = _all_data.len;                                   \
	} while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAPSHOT</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>SNAPSHOT</name></type></parameter>)</parameter_list></cpp:macro>                                                                \
	<cpp:value>do {                                                                                   \
		bool _shallow = false;                                                         \
		bool _disk_mode = false; \
		if (munit_parameters_get(params, SNAPSHOT_SHALLOW_PARAM) != NULL) {            \
			_shallow = atoi(munit_parameters_get(params, SNAPSHOT_SHALLOW_PARAM)); \
		}                                                                              \
		if (munit_parameters_get(params, "disk_mode") != NULL) {            \
			_disk_mode = atoi(munit_parameters_get(params, "disk_mode")); \
		}                                                                              \
		if (_shallow &amp;&amp; !_disk_mode) {                                                                \
			SNAPSHOT_SHALLOW(VFS, SNAPSHOT);                                       \
		} else if (!_shallow &amp;&amp; !_disk_mode) {                                                                       \
			SNAPSHOT_DEEP(VFS, SNAPSHOT);                                          \
		} else { \
			SNAPSHOT_DISK(VFS, SNAPSHOT);                                          \
		}                                                                              \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Restore a snapshot onto the given VFS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESTORE</name><parameter_list>(<parameter><type><name>VFS</name></type></parameter>, <parameter><type><name>SNAPSHOT</name></type></parameter>)</parameter_list></cpp:macro>                                          \
	<cpp:value>do {                                                            \
		bool _disk_mode = false; \
		if (munit_parameters_get(params, "disk_mode") != NULL) {            \
			_disk_mode = atoi(munit_parameters_get(params, "disk_mode")); \
		}                                                                              \
		sqlite3_vfs *vfs = sqlite3_vfs_find(VFS);               \
		int _rv;                                                \
		char path[VFS_PATH_SZ];                                       \
		struct fixture *f = data;                                     \
		vfsFillDbPath(f, VFS, "test.db", path);                       \
		if (_disk_mode) {\
			_rv = dqlite_vfs_restore_disk(vfs, path, SNAPSHOT.data, SNAPSHOT.main_size, SNAPSHOT.wal_size);\
		} else {\
			_rv = dqlite_vfs_restore(vfs, path, SNAPSHOT.data, \
					 SNAPSHOT.n);                   \
		}\
		munit_assert_int(_rv, ==, 0);                           \
	} while (0)</cpp:value></cpp:define>

<comment type="block">/* Open and close a new connection using the dqlite VFS. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>open</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* New frames appended to the WAL file by a sqlite3_step() call that has
 * triggered a write transactions are not immediately visible to other
 * connections after sqlite3_step() has returned. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>writeTransactionNotImmediatelyVisible</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_prepare_v2</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>stmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>SQLITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_string_equal</name><argument_list>(<argument><expr><call><name>sqlite3_errmsg</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"no such table: test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Invoking dqlite_vfs_poll() after a call to sqlite3_step() has triggered a
 * write transaction returns the newly appended WAL frames. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>pollAfterWriteTransaction</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_ptr_not_null</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>frames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tx</name><operator>.</operator><name>n</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>page_numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Invoking dqlite_vfs_poll() after a call to sqlite3_step() has triggered a
 * write transaction sets a write lock on the WAL, so calls to sqlite3_step()
 * from other connections return SQLITE_BUSY if they try to start a write
 * transaction. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>pollAcquireWriteLock</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><name>stmt1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><name>stmt2</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test2(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt1</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt2</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESET</name><argument_list>(<argument><expr><name>stmt2</name></expr></argument>, <argument><expr><name>SQLITE_BUSY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* If the page cache limit is exceeded during a call to sqlite3_step() that has
 * triggered a write transaction, some WAL frames will be written and then
 * overwritten before the final commit. Only the final version of the frame is
 * included in the set returned by dqlite_vfs_poll(). */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>pollAfterPageStress</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">163</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(%d)"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">163</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"UPDATE test SET n=%d WHERE n=%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Five frames were replicated and the first frame actually contains a
	 * spill of the third page. */</comment>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>page_numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>page_numbers</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>page_numbers</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>page_numbers</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>page_numbers</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All records have been inserted. */</comment>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">163</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Set the SQLite PENDING_BYTE at the start of the second page and make sure
 * all data entry is successful.
 */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>adaptPendingByte</argument>, <argument>setUp</argument>, <argument>tearDownRestorePendingByte</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

        <comment type="block">/* Set the pending byte at the start of the second page */</comment>
        <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name></type> <name>new_pending_byte</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>dq_sqlite_pending_byte</name> <operator>=</operator> <name>new_pending_byte</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>sqlite3_test_control</name><argument_list>(<argument><expr><name>SQLITE_TESTCTRL_PENDING_BYTE</name></expr></argument>, <argument><expr><name>new_pending_byte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">65536</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(%d)"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_uint</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* All records have been inserted. */</comment>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to actually modify the WAL after a write transaction
 * was triggered by a call to sqlite3_step(), then perform a read transaction
 * and check that it can see the transaction changes. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>applyMakesTransactionVisible</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to actually modify the WAL after a write transaction
 * was triggered by an explicit "COMMIT" statement and check that changes are
 * visible. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>applyExplicitTransaction</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"COMMIT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Perform two consecutive full write transactions using sqlite3_step(),
 * dqlite_vfs_poll() and dqlite_vfs_apply(), then run a read transaction and
 * check that it can see all committed changes. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>consecutiveWriteTransactions</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Perform three consecutive write transactions, then re-open the database and
 * finally run a read transaction and check that it can see all committed
 * changes. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>reopenAfterConsecutiveWriteTransactions</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE foo(id INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE bar (id INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO foo(id) VALUES(1)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM sqlite_master"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to actually modify the WAL after a write transaction
 * was triggered by sqlite3_step(), and verify that the transaction is visible
 * from another existing connection. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>transactionIsVisibleFromExistingConnection</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to actually modify the WAL after a write transaction
 * was triggered by sqlite3_step(), and verify that the transaction is visible
 * from a brand new connection. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>transactionIsVisibleFromNewConnection</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to actually modify the WAL after a write transaction
 * was triggered by sqlite3_step(), then close the connection and open a new
 * one. A read transaction started in the new connection can see the changes
 * committed by the first one. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>transactionIsVisibleFromReopenedConnection</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to replicate the very first write transaction on a
 * different VFS than the one that initially generated it. In that case it's
 * necessary to initialize the database file on the other VFS by opening and
 * closing a connection. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>firstApplyOnDifferentVfs</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to replicate a second write transaction on a different
 * VFS than the one that initially generated it. In that case it's not necessary
 * to do anything special before calling dqlite_vfs_apply(). */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>secondApplyOnDifferentVfs</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Use dqlite_vfs_apply() to replicate a second write transaction on a different
 * VFS than the one that initially generated it and that has an open connection
 * which has built the WAL index header by preparing a statement. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>applyOnDifferentVfsWithOpenConnection</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA cache_size=-5000"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* A write transaction that gets replicated to a different VFS is visible to a
 * new connection opened on that VFS. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>transactionVisibleOnDifferentVfs</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Calling dqlite_vfs_abort() to cancel a transaction releases the write
 * lock on the WAL. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>abort</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><name>stmt1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>, <argument><expr><name>stmt2</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test2(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt1</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ABORT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt2</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Perform a checkpoint after a write transaction has completed, then perform
 * another write transaction and check that changes both before and after the
 * checkpoint are visible. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>checkpoint</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(456)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Replicate a write transaction that happens after a checkpoint. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>applyOnDifferentVfsAfterCheckpoint</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx3</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKPOINT</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(456)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test ORDER BY n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Replicate a write transaction that happens after a checkpoint, without
 * performing the checkpoint on the replicated DB. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>applyOnDifferentVfsAfterCheckpointOtherVfsNoCheckpoint</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx4</name></decl>;</decl_stmt>

	<comment type="block">/* Create transactions and checkpoint the DB after every transaction */</comment>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test2(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test2(n) VALUES(456)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a second VFS and Apply the transactions without checkpointing
	 * the DB in between. */</comment>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure data is there. */</comment>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test ORDER BY n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test2 ORDER BY n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure checkpoint succeeds */</comment>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Replicate a write transaction that happens before a checkpoint, and is
 * replicated on a DB that has been checkpointed. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>applyOnDifferentVfsExtraCheckpointsOnOtherVfs</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx3</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx4</name></decl>;</decl_stmt>

	<comment type="block">/* Create transactions */</comment>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test2(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test2(n) VALUES(456)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create a second VFS and Apply the transactions while checkpointing
	 * after every transaction. */</comment>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Ensure all the data is there. */</comment>
	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test ORDER BY n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test2 ORDER BY n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>sqlite3_column_int</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">456</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx4</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Replicate to another VFS a series of changes including a checkpoint, then
 * perform a new write transaction on that other VFS. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>checkpointThenPerformTransaction</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx3</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(123)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKPOINT</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(456)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKPOINT_FRESH</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db1</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(789)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>


<comment type="block">/* Rollback a transaction that didn't hit the page cache limit and hence didn't
 * perform any pre-commit WAL writes. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>rollbackTransactionWithoutPageStress</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(1)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESET</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(1)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Rollback a transaction that hit the page cache limit and hence performed some
 * pre-commit WAL writes. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>rollbackTransactionWithPageStress</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">163</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(%d)"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"ROLLBACK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>RESET</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(1)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_ROW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Try and fail to checkpoint a WAL that performed some pre-commit WAL writes. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>checkpointTransactionWithPageStress</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"BEGIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">163</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name><name>sql</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>sql</name></expr></argument>, <argument><expr><literal type="string">"INSERT INTO test(n) VALUES(%d)"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>tx</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>CHECKPOINT_FAIL</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>SQLITE_LOCKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>


<comment type="block">/* A snapshot of a brand new database that has been just initialized contains
 * just the first page of the main database file. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>snapshotInitialDatabase</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshot</name></name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>page_size</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>           <comment type="block">/* Big-endian page size */</comment>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>database_size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* Big-endian database size */</comment>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SNAPSHOT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>snapshot</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>database_size</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* A snapshot of a database after the first write transaction gets applied
 * contains the first page of the database plus the WAL file containing the
 * transaction frames. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>snapshotAfterFirstTransaction</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshot</name></name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>page_size</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>           <comment type="block">/* Big-endian page size */</comment>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>database_size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* Big-endian database size */</comment>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SNAPSHOT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>PAGE_SIZE</name> <operator>+</operator> <literal type="number">32</literal> <operator>+</operator> <operator>(</operator><literal type="number">24</literal> <operator>+</operator> <name>PAGE_SIZE</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>snapshot</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>database_size</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* A snapshot of a database after a checkpoint contains all checkpointed pages
 * and no WAL frames. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>snapshotAfterCheckpoint</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshot</name></name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>page_size</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>           <comment type="block">/* Big-endian page size */</comment>
	<decl_stmt><decl><type><name>uint8_t</name></type> <name><name>database_size</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr></init></decl>;</decl_stmt> <comment type="block">/* Big-endian database size */</comment>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKPOINT</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SNAPSHOT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>n</name></name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><name>PAGE_SIZE</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>page</name> <operator>=</operator> <name><name>snapshot</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></expr></argument>, <argument><expr><name>page_size</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>page</name><index>[<expr><literal type="number">28</literal></expr>]</index></name></expr></argument>, <argument><expr><name>database_size</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Restore a snapshot taken after a brand new database has been just
 * initialized. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>restoreInitialDatabase</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshot</name></name></type> <name>snapshot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SNAPSHOT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESTORE</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Restore a snapshot of a database taken after the first write transaction gets
 * applied. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>restoreAfterFirstTransaction</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshot</name></name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SNAPSHOT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESTORE</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Restore a snapshot of a database while a connection is open. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>restoreWithOpenConnection</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>sqlite3_stmt</name> <modifier>*</modifier></type><name>stmt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>snapshot</name></name></type> <name>snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>tx</name></name></type> <name>tx</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXEC</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"CREATE TABLE test(n INT)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>POLL</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>APPLY</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DONE</name><argument_list>(<argument><expr><name>tx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SNAPSHOT</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RESTORE</name><argument_list>(<argument><expr><literal type="string">"2"</literal></expr></argument>, <argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PREPARE</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>, <argument><expr><literal type="string">"SELECT * FROM test"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>STEP</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>SQLITE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FINALIZE</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>raft_free</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Changing page_size to non-default value fails. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>changePageSize</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA page_size=1024"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>!=</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>

<comment type="block">/* Changing page_size to current value succeeds. */</comment>
<macro><name>TEST</name><argument_list>(<argument>vfs</argument>, <argument>changePageSizeSameValue</argument>, <argument>setUp</argument>, <argument>tearDown</argument>, <argument><literal type="number">0</literal></argument>, <argument>vfs_params</argument>)</argument_list></macro>
<block>{<block_content>
	<decl_stmt><decl><type><name>sqlite3</name> <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>OPEN</name><argument_list>(<argument><expr><literal type="string">"1"</literal></expr></argument>, <argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>sqlite3_exec</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><literal type="string">"PRAGMA page_size=512"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>munit_assert_int</name><argument_list>(<argument><expr><name>rv</name></expr></argument>, <argument><expr><operator>==</operator></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLOSE</name><argument_list>(<argument><expr><name>db</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>MUNIT_OK</name></expr>;</return>
</block_content>}</block>
</unit>
