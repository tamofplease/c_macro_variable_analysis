<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/workspace/acl/lib_tls/tls/tls_server.c"><comment type="block">/*++
 * NAME
 *	tls_server 3
 * SUMMARY
 *	server-side TLS engine
 * SYNOPSIS
 *	#include &lt;tls.h&gt;
 *
 *	TLS_APPL_STATE *tls_server_init(props)
 *	const TLS_SERVER_INIT_PROPS *props;
 *
 *	TLS_SESS_STATE *tls_server_start(props)
 *	const TLS_SERVER_START_PROPS *props;
 *
 *	void	tls_server_stop(app_ctx, stream, failure, TLScontext)
 *	TLS_APPL_STATE *app_ctx;
 *	VSTREAM	*stream;
 *	int	failure;
 *	TLS_SESS_STATE *TLScontext;
 * DESCRIPTION
 *	This module is the interface between Postfix TLS servers,
 *	the OpenSSL library, and the TLS entropy and cache manager.
 *
 *	tls_server_init() is called once when the SMTP server
 *	initializes.
 *	Certificate details are also decided during this phase,
 *	so that peer-specific behavior is not possible.
 *
 *	tls_server_start() activates the TLS feature for the VSTREAM
 *	passed as argument. We assume that network buffers are flushed
 *	and the TLS handshake can begin	immediately.
 *
 *	tls_server_stop() sends the "close notify" alert via
 *	SSL_shutdown() to the peer and resets all connection specific
 *	TLS data. As RFC2487 does not specify a separate shutdown, it
 *	is assumed that the underlying TCP connection is shut down
 *	immediately afterwards. Any further writes to the channel will
 *	be discarded, and any further reads will report end-of-file.
 *	If the failure flag is set, no SSL_shutdown() handshake is performed.
 *
 *	Once the TLS connection is initiated, information about the TLS
 *	state is available via the TLScontext structure:
 * .IP TLScontext-&gt;protocol
 *	the protocol name (SSLv2, SSLv3, TLSv1),
 * .IP TLScontext-&gt;cipher_name
 *	the cipher name (e.g. RC4/MD5),
 * .IP TLScontext-&gt;cipher_usebits
 *	the number of bits actually used (e.g. 40),
 * .IP TLScontext-&gt;cipher_algbits
 *	the number of bits the algorithm is based on (e.g. 128).
 * .PP
 *	The last two values may differ from each other when export-strength
 *	encryption is used.
 *
 *	If the peer offered a certificate, part of the certificate data are
 *	available as:
 * .IP TLScontext-&gt;peer_status
 *	A bitmask field that records the status of the peer certificate
 *	verification. One or more of TLS_CERT_FLAG_PRESENT and
 *	TLS_CERT_FLAG_TRUSTED.
 * .IP TLScontext-&gt;peer_CN
 *	Extracted CommonName of the peer, or zero-length string
 *	when information could not be extracted.
 * .IP TLScontext-&gt;issuer_CN
 *	Extracted CommonName of the issuer, or zero-length string
 *	when information could not be extracted.
 * .IP TLScontext-&gt;peer_fingerprint
 *	Fingerprint of the certificate, or zero-length string when no peer
 *	certificate is available.
 * .PP
 *	If no peer certificate is presented the peer_status is set to 0.
 * LICENSE
 * .ad
 * .fi
 *	This software is free. You can do with it whatever you want.
 *	The original author kindly requests that you acknowledge
 *	the use of his software.
 * AUTHOR(S)
 *	Originally written by:
 *	Lutz Jaenicke
 *	BTU Cottbus
 *	Allgemeine Elektrotechnik
 *	Universitaetsplatz 3-4
 *	D-03044 Cottbus, Germany
 *
 *	Updated by:
 *	Wietse Venema
 *	IBM T.J. Watson Research
 *	P.O. Box 704
 *	Yorktown Heights, NY 10598, USA
 *
 *	Victor Duchovni
 *	Morgan Stanley
 *--*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StdAfx.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TLS</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>ACL_UNIX</name></cpp:ifdef>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dict.h"</cpp:file></cpp:include>

<comment type="block">/* Global library. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_params.h"</cpp:file></cpp:include>

<comment type="block">/* TLS library. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_mgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_private.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>acl_vstring_str(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>ACL_VSTRING_LEN(x)</cpp:value></cpp:define>

<comment type="block">/* Application-specific. */</comment>

 <comment type="block">/*
  * The session_id_context indentifies the service that created a session.
  * This information is used to distinguish between multiple TLS-based
  * servers running on the same server. We use the name of the mail system.
  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>server_session_id_context</name><index>[]</index></name> <init>= <expr><literal type="string">"Postfix/TLS"</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GEN_CACHE_ID</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>id</name></type></parameter>, <parameter><type><name>len</name></type></parameter>, <parameter><type><name>service</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do { \
	buf = acl_vstring_alloc(2 * (len) + 1 + strlen(service) + 3); \
	acl_hex_encode(buf, (char *) (id), (len)); \
    	acl_vstring_sprintf_append(buf, "&amp;s=%s", (service)); \
    } while (0)</cpp:value></cpp:define>

<comment type="block">/* get_server_session_cb - callback to retrieve session from server cache */</comment>

<function><type><specifier>static</specifier> <name>SSL_SESSION</name> <modifier>*</modifier></type><name>get_server_session_cb</name><parameter_list>(<parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>session_id</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>session_id_length</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier><name>unused_copy</name></type> <name>acl_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"get_server_session_cb"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>cache_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>session_data</name> <init>= <expr><call><name>acl_vstring_alloc</name><argument_list>(<argument><expr><literal type="number">2048</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_SESSION</name> <modifier>*</modifier></type><name>session</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>TLScontext</name> <operator>=</operator> <call><name>SSL_get_ex_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>TLScontext_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"%s: null TLScontext in session lookup callback"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GEN_CACHE_ID</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name>session_id</name></expr></argument>, <argument><expr><name>session_id_length</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: looking up session %s in %s cache"</literal></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>,
		 <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Load the session from cache and decode it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tls_mgr_lookup</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>,
		       <argument><expr><name>session_data</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TLS_MGR_STAT_OK</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>session</name> <operator>=</operator> <call><name>tls_session_activate</name><argument_list>(<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>session_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>LEN</name><argument_list>(<argument><expr><name>session_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>session</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>TLScontext</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: reloaded session %s from %s cache"</literal></expr></argument>,
		     <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Clean up.
     */</comment>
    <expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>session_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>session</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<comment type="block">/* uncache_session - remove session from internal &amp; external cache */</comment>

static void uncache_session(SSL_CTX *ctx, TLS_SESS_STATE *TLScontext)
{
    ACL_VSTRING *cache_id;
    SSL_SESSION *session = SSL_get_session(TLScontext-&gt;con);

    SSL_CTX_remove_session(ctx, session);

    if (TLScontext-&gt;cache_type == 0)
	return;

    GEN_CACHE_ID(cache_id, session-&gt;session_id, session-&gt;session_id_length,
		 TLScontext-&gt;serverid);

    if (TLScontext-&gt;log_level &gt;= 2)
	acl_msg_info("%s: remove session %s from %s cache", TLScontext-&gt;namaddr,
		 STR(cache_id), TLScontext-&gt;cache_type);

    tls_mgr_delete(TLScontext-&gt;cache_type, STR(cache_id));
    acl_vstring_free(cache_id);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* new_server_session_cb - callback to save session to server cache */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>new_server_session_cb</name><parameter_list>(<parameter><decl><type><name>SSL</name> <modifier>*</modifier></type><name>ssl</name></decl></parameter>, <parameter><decl><type><name>SSL_SESSION</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"new_server_session_cb"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>cache_id</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>session_data</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>TLScontext</name> <operator>=</operator> <call><name>SSL_get_ex_data</name><argument_list>(<argument><expr><name>ssl</name></expr></argument>, <argument><expr><name>TLScontext_index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"%s: null TLScontext in new session callback"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>GEN_CACHE_ID</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name><name>session</name><operator>-&gt;</operator><name>session_id</name></name></expr></argument>, <argument><expr><name><name>session</name><operator>-&gt;</operator><name>session_id_length</name></name></expr></argument>,
		 <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: save session %s to %s cache"</literal></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>,
		 <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Passivate and save the session state.
     */</comment>
    <expr_stmt><expr><name>session_data</name> <operator>=</operator> <call><name>tls_session_passivate</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>session_data</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>tls_mgr_update</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>,
			<argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>session_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>LEN</name><argument_list>(<argument><expr><name>session_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up.
	 */</comment>
	<expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>session_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SSL_SESSION_free</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>			<comment type="block">/* 200502 */</comment>

    <return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_server_int - initialize the server-side TLS engine */</comment>

<function><type><name>void</name></type> <name>tls_server_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tls_params_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>var_tlsmgr_stand_alone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>tlsmgr_local_start</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>tls_threads_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_server_setup - setup the server-side TLS engine */</comment>

<function><type><name>int</name></type> <name>tls_server_setup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TLS_SERVER_INIT_PROPS</name> <modifier>*</modifier></type><name>props</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_server_setup"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>md_alg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>md_len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"initializing the server-side TLS engine"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Detect mismatch between compile-time headers and run-time library.
     */</comment>
    <expr_stmt><expr><call><name>tls_check_version</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Initialize the OpenSSL library by the book! To start with, we must
     * initialize the algorithms. We want cleartext error messages instead of
     * just error codes, so we load the error_strings.
     */</comment>
    <expr_stmt><expr><call><name>SSL_load_error_strings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>OpenSSL_add_ssl_algorithms</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Create an application data index for SSL objects, so that we can
     * attach TLScontext information; this information is needed inside
     * tls_verify_certificate_callback().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>TLScontext_index</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>TLScontext_index</name> <operator>=</operator> <call><name>SSL_get_ex_new_index</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Cannot allocate SSL application data index: "</literal>
		     <literal type="string">"disabling TLS support"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If the administrator specifies an unsupported digest algorithm, fail
     * now, rather than in the middle of a TLS handshake.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>md_alg</name> <operator>=</operator> <call><name>EVP_get_digestbyname</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>fpt_dgst</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Digest algorithm \"%s\" not found: disabling TLS support"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>fpt_dgst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Sanity check: Newer shared libraries may use larger digests.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>md_len</name> <operator>=</operator> <call><name>EVP_MD_size</name><argument_list>(<argument><expr><name>md_alg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <name>EVP_MAX_MD_SIZE</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Digest algorithm \"%s\" output size %u too large:"</literal>
		 <literal type="string">" disabling TLS support"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>fpt_dgst</name></name></expr></argument>, <argument><expr><name>md_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Initialize the PRNG (Pseudo Random Number Generator) with some seed
     * from external and internal sources. Don't enable TLS without some real
     * entropy.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>var_tls_daemon_rand_bytes</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>tls_ext_seed</name><argument_list>(<argument><expr><name>var_tls_daemon_rand_bytes</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: no entropy for TLS key generation: disabling TLS support"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>tls_int_seed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>tls_server_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TLS_SERVER_INIT_PROPS</name> <modifier>*</modifier></type><name>props</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_server_create"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>server_ctx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>long</name></type>    <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>verify_flags</name> <init>= <expr><name>SSL_VERIFY_NONE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>cachable</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>protomask</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>app_ctx</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>tls_mgr_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * First validate the protocols. If these are invalid, we can't continue.
     */</comment>
    <expr_stmt><expr><name>protomask</name> <operator>=</operator> <call><name>tls_protocol_mask</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>protocols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>protomask</name> <operator>==</operator> <name>TLS_PROTOCOL_INVALID</name></expr>)</condition> <block>{<block_content>
	<comment type="block">/* tls_protocol_mask() logs no warning. */</comment>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Invalid TLS protocol list \"%s\": disabling TLS support"</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>,  <argument><expr><name><name>props</name><operator>-&gt;</operator><name>protocols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The SSL/TLS specifications require the client to send a message in the
     * oldest specification it understands with the highest level it
     * understands in the message. Netscape communicator can still
     * communicate with SSLv2 servers, so it sends out a SSLv2 client hello.
     * To deal with it, our server must be SSLv2 aware (even if we don't like
     * SSLv2), so we need to have the SSLv23 server here. If we want to limit
     * the protocol level, we can add an option to not use SSLv2/v3/TLSv1
     * later.
     */</comment>
    <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>server_ctx</name> <operator>=</operator> <call><name>SSL_CTX_new</name><argument_list>(<argument><expr><call><name>SSLv23_server_method</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: cannot allocate server SSL_CTX: disabling TLS support"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * See the verify callback in tls_verify.c
     */</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_verify_depth</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>verifydepth</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Protocol work-arounds, OpenSSL version dependent.
     */</comment>
    <expr_stmt><expr><name>off</name> <operator>|=</operator> <call><name>tls_bug_bits</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Global protocol selection.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>protomask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>SSL_CTX_set_options</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>,
		<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>protomask</name> <operator>&amp;</operator> <name>TLS_PROTOCOL_TLSv1</name><operator>)</operator></expr> ?</condition><then> <expr><name>SSL_OP_NO_TLSv1</name></expr> </then><else>: <expr><literal type="number">0L</literal></expr></else></ternary><operator>)</operator>
		<operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>protomask</name> <operator>&amp;</operator> <name>TLS_PROTOCOL_SSLv3</name><operator>)</operator></expr> ?</condition><then> <expr><name>SSL_OP_NO_SSLv3</name></expr> </then><else>: <expr><literal type="number">0L</literal></expr></else></ternary><operator>)</operator>
		<operator>|</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name>protomask</name> <operator>&amp;</operator> <name>TLS_PROTOCOL_SSLv2</name><operator>)</operator></expr> ?</condition><then> <expr><name>SSL_OP_NO_SSLv2</name></expr> </then><else>: <expr><literal type="number">0L</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Set the call-back routine to debug handshake progress.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>SSL_CTX_set_info_callback</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>tls_info_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Load the CA public key certificates for both the server cert and for
     * the verification of client certificates. As provided by OpenSSL we
     * support two types of CA certificate handling: One possibility is to
     * add all CA certificates to one large CAfile, the other possibility is
     * a directory pointed to by CApath, containing separate files for each
     * CA with softlinks named after the hash values of the certificate. The
     * first alternative has the advantage that the file is opened and read
     * at startup time, so that you don't have the hassle to maintain another
     * copy of the CApath directory for chroot-jail.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tls_set_ca_certificate_info</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>CAfile</name></name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>CApath</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<comment type="block">/* tls_set_ca_certificate_info() already logs a warning. */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* 200411 */</comment>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Load the server public key certificate and private key from file and
     * check whether the cert matches the key. We can use RSA certificates
     * ("cert") DSA certificates ("dcert") or ECDSA certificates ("eccert").
     * All three can be made available at the same time. The CA certificates
     * for all three are handled in the same setup already finished. Which
     * one is used depends on the cipher negotiated (that is: the first
     * cipher listed by the client which does match the server). A client
     * with RSA only (e.g. Netscape) will use the RSA certificate only. A
     * client with openssl-library will use RSA first if not especially
     * changed in the cipher setup.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tls_set_my_certificate_key_info</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>,
					<argument><expr><name><name>props</name><operator>-&gt;</operator><name>cert_file</name></name></expr></argument>,
					<argument><expr><name><name>props</name><operator>-&gt;</operator><name>key_file</name></name></expr></argument>,
					<argument><expr><name><name>props</name><operator>-&gt;</operator><name>dcert_file</name></name></expr></argument>,
					<argument><expr><name><name>props</name><operator>-&gt;</operator><name>dkey_file</name></name></expr></argument>,
					<argument><expr><name><name>props</name><operator>-&gt;</operator><name>eccert_file</name></name></expr></argument>,
					<argument><expr><name><name>props</name><operator>-&gt;</operator><name>eckey_file</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<comment type="block">/* tls_set_my_certificate_key_info() already logs a warning. */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* 200411 */</comment>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * According to the OpenSSL documentation, temporary RSA key is needed
     * export ciphers are in use. We have to provide one, so well, we just do
     * it.
     */</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_tmp_rsa_callback</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>tls_tmp_rsa_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Diffie-Hellman key generation parameters can either be loaded from
     * files (preferred) or taken from compiled in values. First, set the
     * callback that will select the values when requested, then load the
     * (possibly) available DH parameters from files. We are generous with
     * the error handling, since we do have default values compiled in, so we
     * will not abort but just log the error message.
     */</comment>
    <expr_stmt><expr><call><name>SSL_CTX_set_tmp_dh_callback</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>tls_tmp_dh_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>props</name><operator>-&gt;</operator><name>dh1024_param_file</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>tls_set_dh_from_file</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>dh1024_param_file</name></name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>props</name><operator>-&gt;</operator><name>dh512_param_file</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>tls_set_dh_from_file</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>dh512_param_file</name></name></expr></argument>, <argument><expr><literal type="number">512</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Enable EECDH if available, errors are not fatal, we just keep going
     * with any remaining key-exchange algorithms.
     */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>tls_set_eecdh_curve</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>eecdh_grade</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If we want to check client certificates, we have to indicate it in
     * advance. By now we only allow to decide on a global basis. If we want
     * to allow certificate based relaying, we must ask the client to provide
     * one with SSL_VERIFY_PEER. The client now can decide, whether it
     * provides one or not. We can enforce a failure of the negotiation with
     * SSL_VERIFY_FAIL_IF_NO_PEER_CERT, if we do not allow a connection
     * without one. In the "server hello" following the initialization by the
     * "client hello" the server must provide a list of CAs it is willing to
     * accept. Some clever clients will then select one from the list of
     * available certificates matching these CAs. Netscape Communicator will
     * present the list of certificates for selecting the one to be sent, or
     * it will issue a warning, if there is no certificate matching the
     * available CAs.
     * 
     * With regard to the purpose of the certificate for relaying, we might like
     * a later negotiation, maybe relaying would already be allowed for other
     * reasons, but this would involve severe changes in the internal postfix
     * logic, so we have to live with it the way it is.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>ask_ccert</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>verify_flags</name> <operator>=</operator> <name>SSL_VERIFY_PEER</name> <operator>|</operator> <name>SSL_VERIFY_CLIENT_ONCE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>SSL_CTX_set_verify</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>verify_flags</name></expr></argument>,
		       <argument><expr><name>tls_verify_certificate_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>props</name><operator>-&gt;</operator><name>CAfile</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>SSL_CTX_set_client_CA_list</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><call><name>SSL_load_client_CA_file</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>CAfile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Initialize our own TLS server handle, before diving into the details
     * of TLS session cache management.
     */</comment>
    <expr_stmt><expr><name>app_ctx</name> <operator>=</operator> <call><name>tls_alloc_app_context</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The session cache is implemented by the tlsmgr(8) server.
     * 
     * XXX 200502 Surprise: when OpenSSL purges an entry from the in-memory
     * cache, it also attempts to purge the entry from the on-disk cache.
     * This is undesirable, especially when we set the in-memory cache size
     * to 1. For this reason we don't allow OpenSSL to purge on-disk cache
     * entries, and leave it up to the tlsmgr process instead. Found by
     * Victor Duchovni.
     */</comment>

    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>cache_type</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>tls_mgr_policy</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cachable</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TLS_MGR_STAT_OK</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>cachable</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>cachable</name> <operator>||</operator> <name><name>props</name><operator>-&gt;</operator><name>set_sessid</name></name></expr>)</condition> <block>{<block_content>

	<comment type="block">/*
	 * Initialize the session cache.
	 * 
	 * With a large number of concurrent smtpd(8) processes, it is not a
	 * good idea to cache multiple large session objects in each process.
	 * We set the internal cache size to 1, and don't register a
	 * "remove_cb" so as to avoid deleting good sessions from the
	 * external cache prematurely (when the internal cache is full,
	 * OpenSSL removes sessions from the external cache also)!
	 * 
	 * This makes SSL_CTX_remove_session() not useful for flushing broken
	 * sessions from the external cache, so we must delete them directly
	 * (not via a callback).
	 * 
	 * Set a session id context to identify to what type of server process
	 * created a session. In our case, the context is simply the name of
	 * the mail system: "Postfix/TLS".
	 */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_sess_set_cache_size</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SSL_CTX_set_session_id_context</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>,
				       <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>server_session_id_context</name></expr></argument>,
				       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>server_session_id_context</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SSL_CTX_set_session_cache_mode</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>,
				       <argument><expr><name>SSL_SESS_CACHE_SERVER</name> <operator>|</operator>
				       <name>SSL_SESS_CACHE_NO_AUTO_CLEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cachable</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cache_type</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	    <expr_stmt><expr><call><name>SSL_CTX_sess_set_get_cb</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>get_server_session_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>SSL_CTX_sess_set_new_cb</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>new_server_session_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OpenSSL ignores timed-out sessions. We need to set the internal
	 * cache timeout at least as high as the external cache timeout. This
	 * applies even if no internal cache is used.
	 */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_set_timeout</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>scache_timeout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>

	<comment type="block">/*
	 * If we have no external cache, disable all caching. No use wasting
	 * server memory resources with sessions they are unlikely to be able
	 * to reuse.
	 */</comment>
	<expr_stmt><expr><call><name>SSL_CTX_set_session_cache_mode</name><argument_list>(<argument><expr><name>server_ctx</name></expr></argument>, <argument><expr><name>SSL_SESS_CACHE_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <return>return <expr><operator>(</operator><name>app_ctx</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

 <comment type="block">/*
  * This is the actual startup routine for a new connection. We expect that
  * the SMTP buffers are flushed and the "220 Ready to start TLS" was sent to
  * the client, so that we can immediately start the TLS handshake process.
  */</comment>
<function><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>tls_server_start</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TLS_SERVER_START_PROPS</name> <modifier>*</modifier></type><name>props</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_server_start"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>sts</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL_CIPHER</name> <modifier>*</modifier></type><name>cipher</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name>   <modifier>*</modifier></type><name>peer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>buf</name><index>[<expr><name>CCERT_BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cipher_list</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>app_ctx</name> <init>= <expr><name><name>props</name><operator>-&gt;</operator><name>ctx</name></name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: setting up TLS connection from %s"</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>cipher_list</name> <operator>=</operator> <call><name>tls_set_ciphers</name><argument_list>(<argument><expr><name>app_ctx</name></expr></argument>, <argument><expr><literal type="string">"TLS"</literal></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>cipher_grade</name></name></expr></argument>,
				  <argument><expr><name><name>props</name><operator>-&gt;</operator><name>cipher_exclusions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>cipher_list</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: %s: aborting TLS session"</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><call><name>acl_vstring_str</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: %s: TLS cipher list \"%s\""</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>cipher_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Allocate a new TLScontext for the new connection and get an SSL
     * structure. Add the location of TLScontext to the SSL to later retrieve
     * the information inside the tls_verify_certificate_callback().
     */</comment>
    <expr_stmt><expr><name>TLScontext</name> <operator>=</operator> <call><name>tls_alloc_sess_context</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name> <operator>=</operator> <name><name>app_ctx</name><operator>-&gt;</operator><name>cache_type</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>am_server</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <operator>(</operator><name>SSL</name> <operator>*</operator><operator>)</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Could not allocate 'TLScontext-&gt;con' with SSL_new()"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_free_context</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SSL_set_ex_data</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name>TLScontext_index</name></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Could not set application data for 'TLScontext-&gt;con'"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_free_context</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * The TLS connection is realized by a BIO_pair, so obtain the pair.
     * 
     * XXX There is no need to store the internal_bio handle in the TLScontext
     * structure. It will be attached to and destroyed with TLScontext-&gt;con.
     * The network_bio, however, needs to be freed explicitly, so we need to
     * store its handle in TLScontext.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BIO_new_bio_pair</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>TLScontext</name><operator>-&gt;</operator><name>internal_bio</name></name></expr></argument>, <argument><expr><name>TLS_BIO_BUFSIZE</name></expr></argument>,
			  <argument><expr><operator>&amp;</operator><name><name>TLScontext</name><operator>-&gt;</operator><name>network_bio</name></name></expr></argument>, <argument><expr><name>TLS_BIO_BUFSIZE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: Could not obtain BIO_pair"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_free_context</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Before really starting anything, try to seed the PRNG a little bit
     * more.
     */</comment>
    <expr_stmt><expr><call><name>tls_int_seed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>var_tls_daemon_rand_bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>tls_ext_seed</name><argument_list>(<argument><expr><name>var_tls_daemon_rand_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Initialize the SSL connection to accept state. This should not be
     * necessary anymore since 0.9.3, but the call is still in the library
     * and maintaining compatibility never hurts.
     */</comment>
    <expr_stmt><expr><call><name>SSL_set_accept_state</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Connect the SSL connection with the Postfix side of the BIO-pair for
     * reading and writing.
     */</comment>
    <expr_stmt><expr><call><name>SSL_set_bio</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>internal_bio</name></name></expr></argument>,
		<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>internal_bio</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If the debug level selected is high enough, all of the data is dumped:
     * 3 will dump the SSL negotiation, 4 will dump everything.
     * 
     * We do have an SSL_set_fd() and now suddenly a BIO_ routine is called?
     * Well there is a BIO below the SSL routines that is automatically
     * created for us, so we can use it for debugging purposes.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>BIO_set_callback</name><argument_list>(<argument><expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>tls_bio_dump_cb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Start TLS negotiations. This process is a black box that invokes our
     * call-backs for session caching and certificate verification.
     * 
     * Error handling: If the SSL handhake fails, we print out an error message
     * and remove all TLS state concerning this session.
     */</comment>
    <expr_stmt><expr><name>sts</name> <operator>=</operator> <call><name>tls_bio_accept</name><argument_list>(<argument><expr><call><name>ACL_VSTREAM_SOCK</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>timeout</name></name></expr></argument>,
			 <argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>sts</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"SSL_accept error from %s: %d"</literal></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_free_context</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <comment type="block">/* Only loglevel==4 dumps everything */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>BIO_set_callback</name><argument_list>(<argument><expr><call><name>SSL_get_rbio</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * The caller may want to know if this session was reused or if a new
     * session was negotiated.
     */</comment>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>session_reused</name></name> <operator>=</operator> <call><name>SSL_session_reused</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>TLScontext</name><operator>-&gt;</operator><name>session_reused</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: Reusing old session"</literal></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Let's see whether a peer certificate is available and what is the
     * actual information. We want to save it for later use.
     */</comment>
    <expr_stmt><expr><name>peer</name> <operator>=</operator> <call><name>SSL_get_peer_certificate</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>peer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_status</name></name> <operator>|=</operator> <name>TLS_CERT_FLAG_PRESENT</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>SSL_get_verify_result</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>X509_V_OK</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_status</name></name> <operator>|=</operator> <name>TLS_CERT_FLAG_TRUSTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"subject=%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr></argument>,
			      <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"issuer=%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_CN</name></name> <operator>=</operator> <call><name>tls_peer_CN</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>issuer_CN</name></name> <operator>=</operator> <call><name>tls_issuer_CN</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_fingerprint</name></name> <operator>=</operator> <call><name>tls_fingerprint</name><argument_list>(<argument><expr><name>peer</name></expr></argument>, <argument><expr><name><name>props</name><operator>-&gt;</operator><name>fpt_dgst</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: %s: subject_CN=%s, issuer=%s, fingerprint=%s"</literal></expr></argument>,
		     <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>,
		  <argument><expr><ternary><condition><expr><call><name>TLS_CERT_IS_TRUSTED</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Trusted"</literal></expr> </then><else>: <expr><literal type="string">"Untrusted"</literal></expr></else></ternary></expr></argument>,
		     <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_CN</name></name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>issuer_CN</name></name></expr></argument>,
		     <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_fingerprint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>X509_free</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_CN</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>issuer_CN</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_fingerprint</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Finally, collect information about protocol and cipher for logging
     */</comment>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>protocol</name></name> <operator>=</operator> <call><name>SSL_get_version</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cipher</name> <operator>=</operator> <call><name>SSL_get_current_cipher</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_name</name></name> <operator>=</operator> <call><name>SSL_CIPHER_get_name</name><argument_list>(<argument><expr><name>cipher</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_usebits</name></name> <operator>=</operator> <call><name>SSL_CIPHER_get_bits</name><argument_list>(<argument><expr><name>cipher</name></expr></argument>,
					     <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_algbits</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The TLS engine is active. Switch to the tls_timed_read/write()
     * functions and make the TLScontext available to those functions.
     */</comment>
    <expr_stmt><expr><call><name>tls_stream_start</name><argument_list>(<argument><expr><name><name>props</name><operator>-&gt;</operator><name>stream</name></name></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * All the key facts in a single log entry.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>props</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s TLS connection established from %s: %s with cipher %s "</literal>
	      <literal type="string">"(%d/%d bits)"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>!</operator><call><name>TLS_CERT_IS_PRESENT</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Anonymous"</literal></expr>
		 </then><else>: <expr><ternary><condition><expr><call><name>TLS_CERT_IS_TRUSTED</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Trusted"</literal></expr> </then><else>: <expr><literal type="string">"Untrusted"</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
	      <argument><expr><name><name>props</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>protocol</name></name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_name</name></name></expr></argument>,
		 <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_usebits</name></name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_algbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>tls_int_seed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>TLScontext</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>					<comment type="block">/* USE_TLS */</comment>
</unit>
