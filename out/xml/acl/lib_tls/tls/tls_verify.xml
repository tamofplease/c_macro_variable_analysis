<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/acl/lib_tls/tls/tls_verify.c"><comment type="block">/*++
 * NAME
 *	tls_verify 3
 * SUMMARY
 *	peer name and peer certificate verification
 * SYNOPSIS
 *	#include &lt;tls.h&gt;
 *	#include &lt;tls_private.h&gt;
 *
 *	char *tls_peer_CN(peercert, TLScontext)
 *	X509   *peercert;
 *	TLS_SESS_STATE *TLScontext;
 *
 *	char *tls_issuer_CN(peercert, TLScontext)
 *	X509   *peercert;
 *	TLS_SESS_STATE *TLScontext;
 *
 *	const char *tls_dns_name(gn, TLScontext)
 *	const GENERAL_NAME *gn;
 *	TLS_SESS_STATE *TLScontext;
 *
 *	char *tls_fingerprint(peercert, dgst)
 *	X509   *peercert;
 *	const char *dgst;
 *
 *	int	tls_verify_certificate_callback(ok, ctx)
 *	int	ok;
 *	X509_STORE_CTX *ctx;
 * DESCRIPTION
 *	tls_peer_CN() returns the text CommonName for the peer
 *	certificate subject, or an empty string if no CommonName was
 *	found. The result is allocated with acl_mymalloc() and must be
 *	freed by the caller; it contains UTF-8 without non-printable
 *	ASCII characters.
 *
 *	tls_issuer_CN() returns the text CommonName for the peer
 *	certificate issuer, or an empty string if no CommonName was
 *	found. The result is allocated with acl_mymalloc() and must be
 *	freed by the caller; it contains UTF-8 without non-printable
 *	ASCII characters.
 *
 *	tls_dns_name() returns the string value of a GENERAL_NAME
 *	from a DNS subjectAltName extension. If non-printable characters
 *	are found, a null string is returned instead. Further sanity
 *	checks may be added if the need arises.
 *
 * 	tls_fingerprint() returns a fingerprint of the the given
 *	certificate using the requested message digest. Panics if the
 *	(previously verified) digest algorithm is not found. The return
 *	value is dynamically allocated with acl_mymalloc(), and the caller
 *	must eventually free it with acl_myfree().
 *
 *	tls_verify_callback() is called several times (directly or
 *	indirectly) from crypto/x509/x509_vfy.c. It is called as
 *	a final check, and if it returns "0", the handshake is
 *	immediately shut down and the connection fails.
 *
 *	Postfix/TLS has two modes, the "opportunistic" mode and
 *	the "enforce" mode:
 *
 *	In the "opportunistic" mode we never want the connection
 *	to fail just because there is something wrong with the
 *	peer's certificate. After all, we would have sent or received
 *	the mail even if TLS weren't available.  Therefore the
 *	return value is always "1".
 *
 *	The SMTP client or server may require TLS (e.g. to protect
 *	passwords), while peer certificates are optional.  In this
 *	case we must return "1" even when we are unhappy with the
 *	peer certificate.  Only when peer certificates are required,
 *      certificate verification failure will result in immediate
 *	termination (return 0).
 *
 *	The only error condition not handled inside the OpenSSL
 *	library is the case of a too-long certificate chain. We
 *	test for this condition only if "ok = 1", that is, if
 *	verification didn't fail because of some earlier problem.
 *
 *	Arguments:
 * .IP ok
 *	Result of prior verification: non-zero means success.  In
 *	order to reduce the noise level, some tests or error reports
 *	are disabled when verification failed because of some
 *	earlier problem.
 * .IP ctx
 *	SSL application context. This links to the Postfix TLScontext
 *	with enforcement and logging options.
 * .IP gn
 *	An OpenSSL GENERAL_NAME structure holding a DNS subjectAltName
 *	to be decoded and checked for validity.
 * .IP peercert
 *	Server or client X.509 certificate.
 * .IP dgst
 *	Name of a message digest algorithm suitable for computing secure
 *	(1st pre-image resistant) message digests of certificates. For now,
 *	md5, sha1, or member of SHA-2 family if supported by OpenSSL.
 * .IP TLScontext
 *	Server or client context for warning messages.
 * DIAGNOSTICS
 *	tls_peer_CN(), tls_issuer_CN() and tls_dns_name() log a warning
 *	when 1) the requested information is not available in the specified
 *	certificate, 2) the result exceeds a fixed limit, 3) the result
 *	contains NUL characters or the result contains non-printable or
 *	non-ASCII characters.
 * LICENSE
 * .ad
 * .fi
 *	This software is free. You can do with it whatever you want.
 *	The original author kindly requests that you acknowledge
 *	the use of his software.
 * AUTHOR(S)
 *	Originally written by:
 *	Lutz Jaenicke
 *	BTU Cottbus
 *	Allgemeine Elektrotechnik
 *	Universitaetsplatz 3-4
 *	D-03044 Cottbus, Germany
 *
 *	Updated by:
 *	Wietse Venema
 *	IBM T.J. Watson Research
 *	P.O. Box 704
 *	Yorktown Heights, NY 10598, USA
 *
 *	Victor Duchovni
 *	Morgan Stanley
 *--*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StdAfx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../util/stringops.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TLS</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<comment type="block">/* TLS library. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_private.h"</cpp:file></cpp:include>

<comment type="block">/* Application-specific. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hexcodes</name><index>[]</index></name> <init>= <expr><literal type="string">"0123456789ABCDEF"</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* tls_verify_certificate_callback - verify peer certificate info */</comment>

<function><type><name>int</name></type>     <name>tls_verify_certificate_callback</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ok</name></decl></parameter>, <parameter><decl><type><name>X509_STORE_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>buf</name><index>[<expr><name>CCERT_BUFSIZ</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509</name>   <modifier>*</modifier></type><name>cert</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>depth</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>SSL</name>    <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>depth</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_error_depth</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>cert</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_current_cert</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>con</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_ex_data</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><call><name>SSL_get_ex_data_X509_STORE_CTX_idx</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>TLScontext</name> <operator>=</operator> <call><name>SSL_get_ex_data</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>TLScontext_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * The callback function is called repeatedly, first with the root
     * certificate, and then with each intermediate certificate ending with
     * the peer certificate.
     * 
     * With each call, the validity of the current certificate (usage bits,
     * attributes, expiration, ... checked by the OpenSSL library) is
     * available in the "ok" argument. Error details are available via
     * X509_STORE_CTX API.
     * 
     * We never terminate the SSL handshake in the verification callback, rather
     * we allow the TLS handshake to continue, but mark the session as
     * unverified. The application is responsible for closing any sessions
     * with unverified credentials.
     * 
     * Certificate chain depth limit violations are mis-reported by the OpenSSL
     * library, from SSL_CTX_set_verify(3):
     * 
     * The certificate verification depth set with SSL[_CTX]_verify_depth()
     * stops the verification at a certain depth. The error message produced
     * will be that of an incomplete certificate chain and not
     * X509_V_ERR_CERT_CHAIN_TOO_LONG as may be expected.
     * 
     * We set a limit that is one higher than the user requested limit. If this
     * higher limit is reached, we raise an error even a trusted root CA is
     * present at this depth. This disambiguates trust chain truncation from
     * an incomplete trust chain.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <call><name>SSL_get_verify_depth</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>ok</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>X509_STORE_CTX_set_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>X509_V_ERR_CERT_CHAIN_TOO_LONG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>log_level</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>cert</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: certificate verification depth=%d verify=%d subject=%s"</literal></expr></argument>,
		 <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>ok</name></expr></argument>, <argument><expr><call><name>printable</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * If no errors, or we are not logging verification errors, we are done.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>ok</name> <operator>||</operator> <operator>(</operator><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_status</name></name> <operator>&amp;</operator> <name>TLS_CERT_FLAG_LOGGED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * One counter-example is enough.
     */</comment>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_status</name></name> <operator>|=</operator> <name>TLS_CERT_FLAG_LOGGED</name></expr>;</expr_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PURPOSE</name></cpp:macro> <cpp:value>((depth&gt;0) ? "CA": TLScontext-&gt;am_server ? "client": "server")</cpp:value></cpp:define>

    <comment type="block">/*
     * Specific causes for verification failure.
     */</comment>
    <switch>switch <condition>(<expr><name>err</name> <operator>=</operator> <call><name>X509_STORE_CTX_get_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"certificate verification failed for %s: "</literal>
		 <literal type="string">"self-signed certificate"</literal></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY</name></expr>:</case>
    <case>case <expr><name>X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN</name></expr>:</case>

	<comment type="block">/*
	 * There is no difference between issuing cert not provided and
	 * provided, but not found in CAfile/CApath. Either way, we don't
	 * trust it.
	 */</comment>
	<expr_stmt><expr><call><name>X509_NAME_oneline</name><argument_list>(<argument><expr><call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>current_cert</name></name></expr></argument>)</argument_list></call></expr></argument>,
			  <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"certificate verification failed for %s: untrusted issuer %s"</literal></expr></argument>,
		 <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><call><name>printable</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>X509_V_ERR_CERT_NOT_YET_VALID</name></expr>:</case>
    <case>case <expr><name>X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s certificate verification failed for %s: certificate not"</literal>
		 <literal type="string">" yet valid"</literal></expr></argument>, <argument><expr><name>PURPOSE</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>X509_V_ERR_CERT_HAS_EXPIRED</name></expr>:</case>
    <case>case <expr><name>X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s certificate verification failed for %s: certificate has"</literal>
		 <literal type="string">" expired"</literal></expr></argument>, <argument><expr><name>PURPOSE</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>X509_V_ERR_INVALID_PURPOSE</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"certificate verification failed for %s: not designated for "</literal>
		 <literal type="string">"use as a %s certificate"</literal></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>PURPOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>X509_V_ERR_CERT_CHAIN_TOO_LONG</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"certificate verification failed for %s: "</literal>
		 <literal type="string">"certificate chain longer than limit(%d)"</literal></expr></argument>,
		 <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><call><name>SSL_get_verify_depth</name><argument_list>(<argument><expr><name>con</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <default>default:</default>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s certificate verification failed for %s: num=%d:%s"</literal></expr></argument>,
		 <argument><expr><name>PURPOSE</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
		 <argument><expr><call><name>X509_verify_cert_error_string</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    </block_content>}</block></switch>

    <return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DONT_GRIPE</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DONT_GRIPE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_GRIPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* tls_text_name - extract certificate property value by name */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_text_name</name><parameter_list>(<parameter><decl><type><name>X509_NAME</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>,
        <parameter><decl><type><specifier>const</specifier> <name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>gripe</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_text_name"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>pos</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>X509_NAME_ENTRY</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ASN1_STRING</name> <modifier>*</modifier></type><name>entry_str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>asn1_type</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>utf8_length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>utf8_value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>ch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>pos</name> <operator>=</operator> <call><name>X509_NAME_get_index_by_NID</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>nid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>gripe</name> <operator>!=</operator> <name>DONT_GRIPE</name></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: peer certificate has no %s"</literal></expr></argument>,
		     <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

    <comment type="block">/*
     * If the match is required unambiguous, insist that that no other values
     * be present.
     */</comment>
    if (X509_NAME_get_index_by_NID(name, nid, pos) &gt;= 0) {
	acl_msg_warn("%s: %s: multiple %ss in peer certificate",
		 myname, TLScontext-&gt;namaddr, label);
	return (0);
    }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>X509_NAME_get_entry</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<comment type="block">/* This should not happen */</comment>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: error reading peer certificate %s entry"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>entry_str</name> <operator>=</operator> <call><name>X509_NAME_ENTRY_get_data</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<comment type="block">/* This should not happen */</comment>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: error reading peer certificate %s data"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * XXX Convert everything into UTF-8. This is a super-set of ASCII, so we
     * don't have to bother with separate code paths for ASCII-like content.
     * If the payload is ASCII then we won't waste lots of CPU cycles
     * converting it into UTF-8. It's up to OpenSSL to do something
     * reasonable when converting ASCII formats that contain non-ASCII
     * content.
     * 
     * XXX Don't bother optimizing the string length error check. It is not
     * worth the complexity.
     */</comment>
    <expr_stmt><expr><name>asn1_type</name> <operator>=</operator> <call><name>ASN1_STRING_type</name><argument_list>(<argument><expr><name>entry_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>utf8_length</name> <operator>=</operator> <call><name>ASN1_STRING_to_UTF8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>utf8_value</name></expr></argument>, <argument><expr><name>entry_str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: error decoding peer %s of ASN.1 type=%d"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>asn1_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * No returns without cleaning up. A good optimizer will replace multiple
     * blocks of identical code by jumps to just one such block.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TLS_TEXT_NAME_RETURN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
	char *__tls_text_name_temp = (x); \
	OPENSSL_free(utf8_value); \
	return (__tls_text_name_temp); \
    } while (0)</cpp:value></cpp:define>

    <comment type="block">/*
     * Remove trailing null characters. They would give false alarms with the
     * length check and with the embedded null check.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRIM0</name><parameter_list>(<parameter><type><name>s</name></type></parameter>, <parameter><type><name>l</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { while ((l) &gt; 0 &amp;&amp; (s)[(l)-1] == 0) --(l); } while (0)</cpp:value></cpp:define>

    <expr_stmt><expr><call><name>TRIM0</name><argument_list>(<argument><expr><name>utf8_value</name></expr></argument>, <argument><expr><name>utf8_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Enforce the length limit, because the caller will copy the result into
     * a fixed-length buffer.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>utf8_length</name> <operator>&gt;=</operator> <name>CCERT_BUFSIZ</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: peer %s too long: %d"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>utf8_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TLS_TEXT_NAME_RETURN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Reject embedded nulls in ASCII or UTF-8 names. OpenSSL is responsible
     * for producing properly-formatted UTF-8.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>utf8_length</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>utf8_value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: NULL character in peer %s"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TLS_TEXT_NAME_RETURN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Reject non-printable ASCII characters in UTF-8 content.
     * 
     * Note: the code below does not find control characters in illegal UTF-8
     * sequences. It's OpenSSL's job to produce valid UTF-8, and reportedly,
     * it does validation.
     */</comment>
    <for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <name>utf8_value</name></expr>;</init> <condition><expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name>cp</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ACL_ISASCII</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ACL_ISPRINT</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: non-printable content in peer %s"</literal></expr></argument>,
		     <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <expr_stmt><expr><call><name>TLS_TEXT_NAME_RETURN</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><call><name>TLS_TEXT_NAME_RETURN</name><argument_list>(<argument><expr><call><name>acl_mystrdup</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>utf8_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_dns_name - Extract valid DNS name from subjectAltName value */</comment>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_dns_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>GENERAL_NAME</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_dns_name"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dnsname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>len</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Peername checks are security sensitive, carefully scrutinize the
     * input!
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>gn</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>GEN_DNS</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"%s: Non DNS input argument"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * We expect the OpenSSL library to construct GEN_DNS extesion objects as
     * ASN1_IA5STRING values. Check we got the right union member.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ASN1_STRING_type</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>ia5</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>V_ASN1_IA5STRING</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: invalid ASN1 value type in subjectAltName"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Safe to treat as an ASCII string possibly holding a DNS name
     */</comment>
    <expr_stmt><expr><name>dnsname</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>ASN1_STRING_data</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>ia5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ASN1_STRING_length</name><argument_list>(<argument><expr><name><name>gn</name><operator>-&gt;</operator><name>d</name><operator>.</operator><name>ia5</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>TRIM0</name><argument_list>(<argument><expr><name>dnsname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Per Dr. Steven Henson of the OpenSSL development team, ASN1_IA5STRING
     * values can have internal ASCII NUL values in this context because
     * their length is taken from the decoded ASN1 buffer, a trailing NUL is
     * always appended to make sure that the string is terminated, but the
     * ASN.1 length may differ from strlen().
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>dnsname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: internal NUL in subjectAltName"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * XXX: Should we be more strict and call valid_hostname()? So long as
     * the name is safe to handle, if it is not a valid hostname, it will not
     * compare equal to the expected peername, so being more strict than
     * "printable" is likely excessive...
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>dnsname</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>allprint</name><argument_list>(<argument><expr><name>dnsname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>dnsname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s: non-printable characters in subjectAltName: %.100s"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>, <argument><expr><call><name>printable</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>dnsname</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_peer_CN - extract peer common name from certificate */</comment>

<function><type><name>char</name>   <modifier>*</modifier></type><name>tls_peer_CN</name><parameter_list>(<parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>peercert</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>cn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cn</name> <operator>=</operator> <call><name>tls_text_name</name><argument_list>(<argument><expr><call><name>X509_get_subject_name</name><argument_list>(<argument><expr><name>peercert</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NID_commonName</name></expr></argument>,
		       <argument><expr><literal type="string">"subject CN"</literal></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>, <argument><expr><name>DO_GRIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>cn</name></expr> ?</condition><then> <expr><name>cn</name></expr> </then><else>: <expr><call><name>acl_mystrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_issuer_CN - extract issuer common name from certificate */</comment>

<function><type><name>char</name>   <modifier>*</modifier></type><name>tls_issuer_CN</name><parameter_list>(<parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>peer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>X509_NAME</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>cn</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>X509_get_issuer_name</name><argument_list>(<argument><expr><name>peer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * If no issuer CN field, use Organization instead. CA certs without a CN
     * are common, so we only complain if the organization is also missing.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>cn</name> <operator>=</operator> <call><name>tls_text_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NID_commonName</name></expr></argument>,
			    <argument><expr><literal type="string">"issuer CN"</literal></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>, <argument><expr><name>DONT_GRIPE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>cn</name> <operator>=</operator> <call><name>tls_text_name</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NID_organizationName</name></expr></argument>,
			   <argument><expr><literal type="string">"issuer Organization"</literal></expr></argument>, <argument><expr><name>TLScontext</name></expr></argument>, <argument><expr><name>DO_GRIPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>cn</name></expr> ?</condition><then> <expr><name>cn</name></expr> </then><else>: <expr><call><name>acl_mystrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_fingerprint - extract fingerprint from certificate */</comment>

<function><type><name>char</name>   <modifier>*</modifier></type><name>tls_fingerprint</name><parameter_list>(<parameter><decl><type><name>X509</name> <modifier>*</modifier></type><name>peercert</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dgst</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_fingerprint"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>EVP_MD</name> <modifier>*</modifier></type><name>md_alg</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>md_buf</name><index>[<expr><name>EVP_MAX_MD_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>md_len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Previously available in "init" routine. */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>md_alg</name> <operator>=</operator> <call><name>EVP_get_digestbyname</name><argument_list>(<argument><expr><name>dgst</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"%s: digest algorithm \"%s\" not found"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dgst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Fails when serialization to ASN.1 runs out of memory */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>X509_digest</name><argument_list>(<argument><expr><name>peercert</name></expr></argument>, <argument><expr><name>md_alg</name></expr></argument>, <argument><expr><name>md_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>md_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: error computing certificate %s digest (out of memory?)"</literal></expr></argument>,
		  <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dgst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/* Check for OpenSSL contract violation */</comment>
    <if_stmt><if>if <condition>(<expr><name>md_len</name> <operator>&gt;</operator> <name>EVP_MAX_MD_SIZE</name> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>md_len</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"%s: unexpectedly large %s digest size: %u"</literal></expr></argument>,
		  <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dgst</name></expr></argument>, <argument><expr><name>md_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>md_len</name> <operator>*</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>md_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>hexcodes</name><index>[<expr><operator>(</operator><name><name>md_buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf0</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">4U</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>hexcodes</name><index>[<expr><operator>(</operator><name><name>md_buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><index>[<expr><operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>!=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>md_len</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">':'</literal></expr> </then><else>: <expr><literal type="char">'\0'</literal></expr></else></ternary></expr>;</expr_stmt>
    </block_content>}</block></for>
    <return>return <expr><operator>(</operator><name>result</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
