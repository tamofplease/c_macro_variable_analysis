<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/acl/lib_tls/tls/tls_misc.c"><comment type="block">/*++
 * NAME
 *	tls_misc 3
 * SUMMARY
 *	miscellaneous TLS support routines
 * SYNOPSIS
 *	#include &lt;tls.h&gt;
 *	#include &lt;tls_private.h&gt;
 *
 *	char	*var_tls_high_clist;
 *	char	*var_tls_medium_clist;
 *	char	*var_tls_low_clist;
 *	char	*var_tls_export_clist;
 *	char	*var_tls_null_clist;
 *	char	*var_tls_eecdh_strong;
 *	char	*var_tls_eecdh_ultra;
 *	int	var_tls_daemon_rand_bytes;
 *
 *	TLS_APPL_STATE *tls_alloc_app_context(ssl_ctx)
 *	SSL_CTX	*ssl_ctx;
 *
 *	void	tls_free_app_context(app_ctx)
 *	void	*app_ctx;
 *
 *	TLS_SESS_STATE *tls_alloc_sess_context(log_level, namaddr)
 *	int	log_level;
 *	const char *namaddr;
 *
 *	void	tls_free_context(TLScontext)
 *	TLS_SESS_STATE *TLScontext;
 *
 *	void	tls_check_version()
 *
 *	long	tls_bug_bits()
 *
 *	void	tls_param_init()
 *
 *	int	tls_protocol_mask(plist)
 *	const char *plist;
 *
 *	int	tls_cipher_grade(name)
 *	const char *name;
 *
 *	const char *str_tls_cipher_grade(grade)
 *	int	grade;
 *
 *	const char *tls_set_ciphers(app_ctx, context, grade, exclusions)
 *	TLS_APPL_STATE *app_ctx;
 *	const char *context;
 *	int	grade;
 *	const char *exclusions;
 *
 *	void	tls_print_errors()
 *
 *	void	tls_info_callback(ssl, where, ret)
 *	const SSL *ssl; #unused 
 *	int	where;
 *	int	ret;
 *
 *	long	tls_bio_dump_cb(bio, cmd, argp, argi, argl, ret)
 *	BIO	*bio;
 *	int	cmd;
 *	const char *argp;
 *	int	argi;
 *	long	argl; #unused
 *	long	ret;
 * DESCRIPTION
 *	This module implements routines that support the TLS client
 *	and server internals.
 *
 *	tls_alloc_app_context() creates an application context that
 *	holds the SSL context for the application and related cached state.
 *
 *	tls_free_app_context() deallocates the application context and its
 *	contents (the application context is stored outside the TLS library).
 *
 *	tls_alloc_sess_context() creates an initialized TLS session context
 *	structure with the specified log mask and peer name[addr].
 *
 *	tls_free_context() destroys a TLScontext structure
 *	together with OpenSSL structures that are attached to it.
 *
 *	tls_check_version() logs a warning when the run-time OpenSSL
 *	library differs in its major, minor or micro number from
 *	the compile-time OpenSSL headers.
 *
 *	tls_bug_bits() returns the bug compatibility mask appropriate
 *	for the run-time library. Some of the bug work-arounds are
 *	not appropriate for some library versions.
 *
 *	tls_param_init() loads main.cf parameters used internally in
 *	TLS library. Any errors are fatal.
 *
 *	tls_protocol_mask() returns a bitmask of excluded protocols, given
 *	a list (plist) of protocols to include or (preceded by a '!') exclude.
 *	If "plist" contains invalid protocol names, TLS_PROTOCOL_INVALID is
 *	returned and no warning is logged.
 *
 *	tls_cipher_grade() converts a case-insensitive cipher grade
 *	name (high, medium, low, export, null) to the corresponding
 *	TLS_CIPHER_ constant.  When the input specifies an unrecognized
 *	grade, tls_cipher_grade() logs no warning, and returns
 *	TLS_CIPHER_NONE.
 *
 *	str_tls_cipher_grade() converts a cipher grade to a name.
 *	When the input specifies an undefined grade, str_tls_cipher_grade()
 *	logs no warning, returns a null pointer.
 *
 *	tls_set_ciphers() generates a cipher list from the specified
 *	grade, minus any ciphers specified via a list of exclusions.
 *	The cipherlist is applied to the supplied SSL context if it
 *	is different from the most recently applied value. The return
 *	value is the cipherlist used and is overwritten upon each call.
 *	When the input is invalid, tls_set_ciphers() logs a warning with
 *	the specified context, and returns a null pointer result.
 *
 *	tls_print_errors() queries the OpenSSL error stack,
 *	logs the error messages, and clears the error stack.
 *
 *	tls_info_callback() is a call-back routine for the
 *	SSL_CTX_set_info_callback() routine. It logs SSL events
 *	to the Postfix logfile.
 *
 *	tls_bio_dump_cb() is a call-back routine for the
 *	BIO_set_callback() routine. It logs SSL content to the
 *	Postfix logfile.
 * LICENSE
 * .ad
 * .fi
 *	This software is free. You can do with it whatever you want.
 *	The original author kindly requests that you acknowledge
 *	the use of his software.
 * AUTHOR(S)
 *	Originally written by:
 *	Lutz Jaenicke
 *	BTU Cottbus
 *	Allgemeine Elektrotechnik
 *	Universitaetsplatz 3-4
 *	D-03044 Cottbus, Germany
 *
 *	Updated by:
 *	Wietse Venema
 *	IBM T.J. Watson Research
 *	P.O. Box 704
 *	Yorktown Heights, NY 10598, USA
 *
 *	Victor Duchovni
 *	Morgan Stanley
 *--*/</comment>

<comment type="block">/* System library. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StdAfx.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TLS</name></cpp:ifdef>

 <comment type="block">/*
  * TLS library.
  */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_params.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_private.h"</cpp:file></cpp:include>

 <comment type="block">/* Application-specific. */</comment>

 <comment type="block">/*
  * Index to attach TLScontext pointers to SSL objects, so that they can be
  * accessed by call-back routines.
  */</comment>
<decl_stmt><decl><type><name>int</name></type>     <name>TLScontext_index</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

 <comment type="block">/*
  * Protocol name &lt;=&gt; mask conversion.
  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>NAME_CODE</name></type> <name><name>protocol_table</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><name>SSL_TXT_SSLV2</name></expr>, <expr><name>TLS_PROTOCOL_SSLv2</name></expr> }</block></expr>,
    <expr><block>{ <expr><name>SSL_TXT_SSLV3</name></expr>, <expr><name>TLS_PROTOCOL_SSLv3</name></expr> }</block></expr>,
    <expr><block>{ <expr><name>SSL_TXT_TLSV1</name></expr>, <expr><name>TLS_PROTOCOL_TLSv1</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>TLS_PROTOCOL_INVALID</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

 <comment type="block">/*
  * Ciphersuite name &lt;=&gt; code conversion.
  */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>NAME_CODE</name></type> <name><name>tls_cipher_grade_table</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"high"</literal></expr>, <expr><name>TLS_CIPHER_HIGH</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"medium"</literal></expr>, <expr><name>TLS_CIPHER_MEDIUM</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"low"</literal></expr>, <expr><name>TLS_CIPHER_LOW</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"export"</literal></expr>, <expr><name>TLS_CIPHER_EXPORT</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"null"</literal></expr>, <expr><name>TLS_CIPHER_NULL</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"invalid"</literal></expr>, <expr><name>TLS_CIPHER_NONE</name></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><name>TLS_CIPHER_NONE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

 <comment type="block">/*
  * Parsed OpenSSL version number.
  */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>int</name></type>     <name>major</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>minor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>micro</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>patch</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>status</name></decl>;</decl_stmt>
}</block></struct></type> <name>TLS_VINFO</name>;</typedef>

 <comment type="block">/*
  * OpenSSL adopted the cipher selection patch, so we don't expect any more
  * broken ciphers other than AES and CAMELLIA.
  */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ssl_name</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>alg_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>evp_name</name></decl>;</decl_stmt>
}</block></struct></type> <name>cipher_probe_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>cipher_probe_t</name></type> <name><name>cipher_probes</name><index>[]</index></name> <init>= <expr><block>{
    <expr><block>{ <expr><literal type="string">"AES"</literal></expr>, <expr><literal type="number">256</literal></expr>, <expr><literal type="string">"AES-256-CBC"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="string">"CAMELLIA"</literal></expr>, <expr><literal type="number">256</literal></expr>, <expr><literal type="string">"CAMELLIA-256-CBC"</literal></expr> }</block></expr>,
    <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_argv_fn</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ACL_ARGV</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><operator>(</operator><name>ACL_ARGV</name><operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>acl_argv_free</name><argument_list>(<argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_exclude_missing - Append exclusions for missing ciphers */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_exclude_missing</name><parameter_list>(<parameter><decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_exclude_missing"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>__thread</name> <name>ACL_ARGV</name> <modifier>*</modifier></type><name>exclude</name></decl>;</decl_stmt>		<comment type="block">/* Cached */</comment>
    <decl_stmt><decl><type><name>SSL</name>    <modifier>*</modifier></type><name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>SSL_CIPHER</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>ciphers</name></expr>;</expr_stmt>
    <decl_stmt><decl><type><name>SSL_CIPHER</name> <modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>cipher_probe_t</name> <modifier>*</modifier></type><name>probe</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>alg_bits</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>num</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>i</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Process a list of probes which specify:
     * 
     * An SSL cipher-suite name for a family of ciphers that use the same
     * symmetric algorithm at two or more key sizes, typically 128/256 bits.
     * 
     * The key size (typically 256) that OpenSSL fails to check, and assumes
     * available when another key size (typically 128) is usable.
     * 
     * The OpenSSL name of the symmetric algorithm associated with the SSL
     * cipher-suite. Typically, this is MUMBLE-256-CBC, where "MUMBLE" is the
     * name of the SSL cipher-suite that use the MUMBLE symmetric algorithm.
     * On systems that support the required encryption algorithm, the name is
     * listed in the output of "openssl list-cipher-algorithms".
     * 
     * When an encryption algorithm is not available at the given key size but
     * the corresponding OpenSSL cipher-suite contains ciphers that have have
     * this key size, the problem ciphers are explicitly disabled in Postfix.
     * The list is cached in the static "exclude" array.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>exclude</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>exclude</name> <operator>=</operator> <call><name>acl_argv_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_pthread_atexit_add</name><argument_list>(<argument><expr><name>exclude</name></expr></argument>, <argument><expr><name>free_argv_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Iterate over the probe list
	 */</comment>
	<for>for <control>(<init><expr><name>probe</name> <operator>=</operator> <name>cipher_probes</name></expr>;</init> <condition><expr><name><name>probe</name><operator>-&gt;</operator><name>ssl_name</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>probe</name></expr></incr>)</control> <block>{<block_content>
	    <comment type="block">/* No exclusions if evp_name is a valid algorithm */</comment>
	    <if_stmt><if>if <condition>(<expr><call><name>EVP_get_cipherbyname</name><argument_list>(<argument><expr><name><name>probe</name><operator>-&gt;</operator><name>evp_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<continue>continue;</continue></block_content></block></if></if_stmt>

	    <comment type="block">/*
	     * Sadly there is no SSL_CTX_get_ciphers() interface, so we are
	     * forced to allocate and free an SSL object. Fatal error if we
	     * can't allocate the SSL object.
	     */</comment>
	    <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>s</name> <operator>=</operator> <call><name>SSL_new</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: error allocating SSL object"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if></if_stmt>

	    <comment type="block">/*
	     * Cipher is not supported by libcrypto, nothing to do if also
	     * not supported by libssl. Flush the OpenSSL error stack.
	     * 
	     * XXX: There may be additional places in pre-existing code where
	     * SSL errors are generated and ignored, that require a similar
	     * "flush". Better yet, is to always flush before calls that run
	     * tls_print_errors() on failure.
	     * 
	     * Contrary to documentation, on SunOS 5.10 SSL_set_cipher_list()
	     * returns success with no ciphers selected, when this happens
	     * SSL_get_ciphers() produces a stack with 0 elements!
	     */</comment>
	    <if_stmt><if>if <condition>(<expr><call><name>SSL_set_cipher_list</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>probe</name><operator>-&gt;</operator><name>ssl_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
		<operator>||</operator> <operator>(</operator><name>ciphers</name> <operator>=</operator> <call><name>SSL_get_ciphers</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
		<operator>||</operator> <operator>(</operator><name>num</name> <operator>=</operator> <call><name>sk_SSL_CIPHER_num</name><argument_list>(<argument><expr><name>ciphers</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* flush any generated errors */</comment>
		<continue>continue;</continue>
	    </block_content>}</block></if></if_stmt>
	    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>sk_SSL_CIPHER_value</name><argument_list>(<argument><expr><name>ciphers</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SSL_CIPHER_get_bits</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>alg_bits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>alg_bits</name> <operator>==</operator> <name><name>probe</name><operator>-&gt;</operator><name>alg_bits</name></name></expr>)</condition><block type="pseudo"><block_content>
		    <expr_stmt><expr><call><name>acl_argv_add</name><argument_list>(<argument><expr><name>exclude</name></expr></argument>, <argument><expr><call><name>SSL_CIPHER_get_name</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ACL_ARGV_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    </block_content>}</block></for>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>exclude</name><operator>-&gt;</operator><name>argc</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_vstring_sprintf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">":!%s"</literal></expr></argument>, <argument><expr><name><name>exclude</name><operator>-&gt;</operator><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
    <return>return <expr><operator>(</operator><call><name>acl_vstring_str</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_apply_cipher_list - update SSL_CTX cipher list */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_apply_cipher_list</name><parameter_list>(<parameter><decl><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>app_ctx</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>, <parameter><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>spec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>tls_exclude_missing</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>ERR_clear_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>SSL_CTX_set_cipher_list</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>tls_print_errors</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_vstring_sprintf</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name></expr></argument>, <argument><expr><literal type="string">"invalid %s cipher list: \"%s\""</literal></expr></argument>,
			<argument><expr><name>context</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>new</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_protocol_mask - Bitmask of protocols to exclude */</comment>

<function><type><name>int</name></type>     <name>tls_protocol_mask</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>plist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>code</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>exclude</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>include</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name>save</name> <operator>=</operator> <name>cp</name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>plist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>tok</name> <operator>=</operator> <call><name>acl_mystrtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><literal type="string">"\t\n\r ,:"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tok</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>exclude</name> <operator>|=</operator> <name>code</name> <operator>=</operator>
		<call><name>name_code</name><argument_list>(<argument><expr><name>protocol_table</name></expr></argument>, <argument><expr><name>NAME_CODE_FLAG_NONE</name></expr></argument>, <argument><expr><operator>++</operator><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><name>include</name> <operator>|=</operator> <name>code</name> <operator>=</operator>
		<call><name>name_code</name><argument_list>(<argument><expr><name>protocol_table</name></expr></argument>, <argument><expr><name>NAME_CODE_FLAG_NONE</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>code</name> <operator>==</operator> <name>TLS_PROTOCOL_INVALID</name></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><name>TLS_PROTOCOL_INVALID</name></expr>;</return></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * When the include list is empty, use only the explicit exclusions.
     * Otherwise, also exclude the complement of the include list from the
     * built-in list of known protocols. There is no way to exclude protocols
     * we don't know about at compile time, and this is unavoidable because
     * the OpenSSL API works with compile-time *exclusion* bit-masks.
     */</comment>
    <return>return <expr><operator>(</operator><ternary><condition><expr><name>include</name></expr> ?</condition><then> <expr><operator>(</operator><name>exclude</name> <operator>|</operator> <operator>(</operator><name>TLS_KNOWN_PROTOCOLS</name> <operator>&amp;</operator> <operator>~</operator><name>include</name><operator>)</operator><operator>)</operator></expr> </then><else>: <expr><name>exclude</name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_vstring_fn</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><operator>(</operator><name>ACL_VSTRING</name><operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_set_ciphers - Set SSL context cipher list */</comment>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_set_ciphers</name><parameter_list>(<parameter><decl><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>app_ctx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>grade</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>exclusions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_set_ciphers"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>static</specifier> <name>__thread</name> <name>ACL_VSTRING</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>new_grade</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>tok</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_list</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>new_grade</name> <operator>=</operator> <call><name>tls_cipher_grade</name><argument_list>(<argument><expr><name>grade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>new_grade</name> <operator>==</operator> <name>TLS_CIPHER_NONE</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_vstring_sprintf</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name></expr></argument>, <argument><expr><literal type="string">"invalid %s cipher grade: \"%s\""</literal></expr></argument>,
			<argument><expr><name>context</name></expr></argument>, <argument><expr><name>grade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>acl_vstring_alloc</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_pthread_atexit_add</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>free_vstring_fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>ACL_VSTRING_RESET</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Given cached state and identical input, we return the same result.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>new_grade</name> <operator>==</operator> <name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_grade</name></name>
	    <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name></expr></argument>, <argument><expr><name>exclusions</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <return>return <expr><operator>(</operator><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Change required, flush cached state */</comment>
	<expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_grade</name></name> <operator>=</operator> <name>TLS_CIPHER_NONE</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <switch>switch <condition>(<expr><name>new_grade</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TLS_CIPHER_HIGH</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_vstring_strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>var_tls_high_clist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>TLS_CIPHER_MEDIUM</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_vstring_strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>var_tls_medium_clist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>TLS_CIPHER_LOW</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_vstring_strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>var_tls_low_clist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>TLS_CIPHER_EXPORT</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_vstring_strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>var_tls_export_clist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <case>case <expr><name>TLS_CIPHER_NULL</name></expr>:</case>
	<expr_stmt><expr><call><name>acl_vstring_strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>var_tls_null_clist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<break>break;</break>
    <default>default:</default>

	<comment type="block">/*
	 * The caller MUST provide a valid cipher grade
	 */</comment>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"invalid %s cipher grade: %d"</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>new_grade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>

    <comment type="block">/*
     * The base lists for each grade can't be empty.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>ACL_VSTRING_LEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_panic</name><argument_list>(<argument><expr><literal type="string">"%s: empty \"%s\" cipherlist"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>grade</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Apply locally-specified exclusions.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CIPHER_SEP</name></cpp:macro> <cpp:value>"\t\n\r ,:"</cpp:value></cpp:define>
    <if_stmt><if>if <condition>(<expr><name>exclusions</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>cp</name> <operator>=</operator> <name>save</name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>exclusions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tok</name> <operator>=</operator> <call><name>acl_mystrtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cp</name></expr></argument>, <argument><expr><name>CIPHER_SEP</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

	    <comment type="block">/*
	     * Can't exclude ciphers that start with modifiers.
	     */</comment>
	    <if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"!+-@"</literal></expr></argument>, <argument><expr><operator>*</operator><name>tok</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_vstring_sprintf</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name></expr></argument>,
				<argument><expr><literal type="string">"invalid unary '!+-@' in %s cipher "</literal>
				<literal type="string">"exclusion: \"%s\""</literal></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
	    </block_content>}</block></if></if_stmt>
	    <expr_stmt><expr><call><name>acl_vstring_sprintf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">":!%s"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>new_list</name> <operator>=</operator> <call><name>tls_apply_cipher_list</name><argument_list>(<argument><expr><name>app_ctx</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Cache new state */</comment>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_grade</name></name> <operator>=</operator> <name>new_grade</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>exclusions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>new_list</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_alloc_app_context - allocate TLS application context */</comment>

<function><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>tls_alloc_app_context</name><parameter_list>(<parameter><decl><type><name>SSL_CTX</name> <modifier>*</modifier></type><name>ssl_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>app_ctx</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>app_ctx</name> <operator>=</operator> <operator>(</operator><name>TLS_APPL_STATE</name> <operator>*</operator><operator>)</operator> <call><name>acl_mymalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>app_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>app_ctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>app_ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name> <operator>=</operator> <name>ssl_ctx</name></expr>;</expr_stmt>

    <comment type="block">/* See also: cache purging code in tls_set_ciphers(). */</comment>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_grade</name></name> <operator>=</operator> <name>TLS_CIPHER_NONE</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cache_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name> <operator>=</operator> <call><name>acl_vstring_alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>app_ctx</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_free_app_context - Free TLS application context */</comment>

<function><type><name>void</name></type>    <name>tls_free_app_context</name><parameter_list>(<parameter><decl><type><name>TLS_APPL_STATE</name> <modifier>*</modifier></type><name>app_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>app_ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>SSL_CTX_free</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>ssl_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cache_type</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cache_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <comment type="block">/* See also: cache purging code in tls_set_ciphers(). */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_exclusions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>cipher_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name><name>app_ctx</name><operator>-&gt;</operator><name>why</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>app_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_alloc_sess_context - allocate TLS session context */</comment>

<function><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>tls_alloc_sess_context</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>log_level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namaddr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl>;</decl_stmt>

    <comment type="block">/*
     * PORTABILITY: Do not assume that null pointers are all-zero bits. Use
     * explicit assignments to initialize pointers.
     * 
     * See the C language FAQ item 5.17, or if you have time to burn,
     * http://www.google.com/search?q=zero+bit+null+pointer
     * 
     * However, it's OK to use memset() to zero integer values.
     */</comment>
    <expr_stmt><expr><name>TLScontext</name> <operator>=</operator> <operator>(</operator><name>TLS_SESS_STATE</name> <operator>*</operator><operator>)</operator> <call><name>acl_mymalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TLS_SESS_STATE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>TLScontext</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>TLScontext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>internal_bio</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>network_bio</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cache_type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>serverid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_CN</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>issuer_CN</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_fingerprint</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>protocol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>cipher_name</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>log_level</name></name> <operator>=</operator> <name>log_level</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name> <operator>=</operator> <call><name>acl_lowercase</name><argument_list>(<argument><expr><call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>namaddr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>TLScontext</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_free_context - deallocate TLScontext and members */</comment>

<function><type><name>void</name></type>    <name>tls_free_context</name><parameter_list>(<parameter><decl><type><name>TLS_SESS_STATE</name> <modifier>*</modifier></type><name>TLScontext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/*
     * Free the SSL structure and the BIOs. Warning: the internal_bio is
     * connected to the SSL structure and is automatically freed with it. Do
     * not free it again (core dump)!! Only free the network_bio.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>SSL_free</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>con</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>network_bio</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>BIO_free</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>network_bio</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>namaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>serverid</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>serverid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_CN</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_CN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>issuer_CN</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>issuer_CN</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_fingerprint</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>TLScontext</name><operator>-&gt;</operator><name>peer_fingerprint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>TLScontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_version_split - Split OpenSSL version number into major, minor, ... */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tls_version_split</name><parameter_list>(<parameter><decl><type><name>long</name></type> <name>version</name></decl></parameter>, <parameter><decl><type><name>TLS_VINFO</name> <modifier>*</modifier></type><name>info</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <comment type="block">/*
     * OPENSSL_VERSION_NUMBER(3):
     * 
     * OPENSSL_VERSION_NUMBER is a numeric release version identifier:
     * 
     * MMNNFFPPS: major minor fix patch status
     * 
     * The status nibble has one of the values 0 for development, 1 to e for
     * betas 1 to 14, and f for release. Parsed OpenSSL version number. for
     * example
     * 
     * 0x000906000 == 0.9.6 dev 0x000906023 == 0.9.6b beta 3 0x00090605f ==
     * 0.9.6e release
     * 
     * Versions prior to 0.9.3 have identifiers &lt; 0x0930.  Versions between
     * 0.9.3 and 0.9.5 had a version identifier with this interpretation:
     * 
     * MMNNFFRBB major minor fix final beta/patch
     * 
     * for example
     * 
     * 0x000904100 == 0.9.4 release 0x000905000 == 0.9.5 dev
     * 
     * Version 0.9.5a had an interim interpretation that is like the current
     * one, except the patch level got the highest bit set, to keep continu-
     * ity.  The number was therefore 0x0090581f.
     */</comment>

    <if_stmt><if>if <condition>(<expr><name>version</name> <operator>&lt;</operator> <literal type="number">0x0930</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>patch</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>micro</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>minor</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0x0f</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>version</name> <operator>&lt;</operator> <literal type="number">0x00905800L</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>patch</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>micro</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>minor</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xf</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>patch</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>micro</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>minor</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>version</name> <operator>&gt;&gt;=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>major</name></name> <operator>=</operator> <name>version</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>version</name> <operator>&lt;</operator> <literal type="number">0x00906000L</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>patch</name></name> <operator>&amp;=</operator> <operator>~</operator><literal type="number">0x80</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_check_version - Detect mismatch between headers and library. */</comment>

<function><type><name>void</name></type>    <name>tls_check_version</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_check_version"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_VINFO</name></type> <name>hdr_info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_VINFO</name></type> <name>lib_info</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>tls_version_split</name><argument_list>(<argument><expr><name>OPENSSL_VERSION_NUMBER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hdr_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tls_version_split</name><argument_list>(<argument><expr><call><name>SSLeay</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>lib_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>lib_info</name><operator>.</operator><name>major</name></name> <operator>!=</operator> <name><name>hdr_info</name><operator>.</operator><name>major</name></name>
	<operator>||</operator> <name><name>lib_info</name><operator>.</operator><name>minor</name></name> <operator>!=</operator> <name><name>hdr_info</name><operator>.</operator><name>minor</name></name>
	<operator>||</operator> <name><name>lib_info</name><operator>.</operator><name>micro</name></name> <operator>!=</operator> <name><name>hdr_info</name><operator>.</operator><name>micro</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: run-time library vs. compile-time header version mismatch: "</literal>
	     <literal type="string">"OpenSSL %d.%d.%d may not be compatible with OpenSSL %d.%d.%d"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>lib_info</name><operator>.</operator><name>major</name></name></expr></argument>, <argument><expr><name><name>lib_info</name><operator>.</operator><name>minor</name></name></expr></argument>, <argument><expr><name><name>lib_info</name><operator>.</operator><name>micro</name></name></expr></argument>,
		 <argument><expr><name><name>hdr_info</name><operator>.</operator><name>major</name></name></expr></argument>, <argument><expr><name><name>hdr_info</name><operator>.</operator><name>minor</name></name></expr></argument>, <argument><expr><name><name>hdr_info</name><operator>.</operator><name>micro</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_bug_bits - SSL bug compatibility bits for this OpenSSL version */</comment>

<function><type><name>long</name></type>    <name>tls_bug_bits</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>long</name></type>    <name>bits</name> <init>= <expr><name>SSL_OP_ALL</name></expr></init></decl>;</decl_stmt>		<comment type="block">/* Work around all known bugs */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>OPENSSL_VERSION_NUMBER</name> <operator>&gt;=</operator> <literal type="number">0x00908000L</literal></expr></cpp:if>
    <decl_stmt><decl><type><name>long</name></type>    <name>lib_version</name> <init>= <expr><call><name>SSLeay</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * In OpenSSL 0.9.8[ab], enabling zlib compression breaks the padding bug
     * work-around, leading to false positives and failed connections. We may
     * not interoperate with systems with the bug, but this is better than
     * breaking on all 0.9.8[ab] systems that have zlib support enabled.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>lib_version</name> <operator>&gt;=</operator> <literal type="number">0x00908000L</literal> <operator>&amp;&amp;</operator> <name>lib_version</name> <operator>&lt;=</operator> <literal type="number">0x0090802fL</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>STACK_OF</name><argument_list>(<argument><expr><name>SSL_COMP</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>comp_methods</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>comp_methods</name> <operator>=</operator> <call><name>SSL_COMP_get_compression_methods</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>comp_methods</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>sk_SSL_COMP_num</name><argument_list>(<argument><expr><name>comp_methods</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name>bits</name> <operator>&amp;=</operator> <operator>~</operator><name>SSL_OP_TLS_BLOCK_PADDING_BUG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <return>return <expr><operator>(</operator><name>bits</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_print_errors - print and clear the error stack */</comment>

<function><type><name>void</name></type>    <name>tls_print_errors</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_print_errors"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>buffer</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* XXX */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>line</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>flags</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>thread</name></decl>;</decl_stmt>

    <comment type="block">/*
    while ((err = ERR_get_error()) != 0) {
	ERR_error_string(err, buffer);
	acl_msg_warn("%s: TLS library warning: %lu|%s", __FUNCTION__, err, buffer);
    }
    */</comment>

    <expr_stmt><expr><name>thread</name> <operator>=</operator> <call><name>CRYPTO_thread_id</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><operator>(</operator><name>err</name> <operator>=</operator> <call><name>ERR_get_error_line_data</name><argument_list>(<argument><expr><operator>&amp;</operator><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>ERR_error_string_n</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ERR_TXT_STRING</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: TLS library problem: %lu|%s|%s|%d|%s|"</literal></expr></argument>,
		     <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: TLS library problem: %lu|%s|%s|%d|"</literal></expr></argument>,
		     <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>thread</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/* tls_info_callback - callback for logging SSL events via Postfix */</comment>

<function><type><name>void</name></type>    <name>tls_info_callback</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>SSL</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>w</name></decl>;</decl_stmt>

    <comment type="block">/* Adapted from OpenSSL apps/s_cb.c. */</comment>

    <expr_stmt><expr><name>w</name> <operator>=</operator> <name>where</name> <operator>&amp;</operator> <operator>~</operator><name>SSL_ST_MASK</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>w</name> <operator>&amp;</operator> <name>SSL_ST_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"SSL_connect"</literal></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>w</name> <operator>&amp;</operator> <name>SSL_ST_ACCEPT</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"SSL_accept"</literal></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <literal type="string">"unknown"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>where</name> <operator>&amp;</operator> <name>SSL_CB_LOOP</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s:%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>SSL</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>&amp;</operator> <name>SSL_CB_ALERT</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>where</name> <operator>&amp;</operator> <name>SSL_CB_READ</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"read"</literal></expr> </then><else>: <expr><literal type="string">"write"</literal></expr></else></ternary></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ret</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>!=</operator> <name>SSL3_AD_CLOSE_NOTIFY</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"SSL3 alert %s:%s:%s"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>,
		     <argument><expr><call><name>SSL_alert_type_string_long</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>,
		     <argument><expr><call><name>SSL_alert_desc_string_long</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>where</name> <operator>&amp;</operator> <name>SSL_CB_EXIT</name></expr>)</condition> <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s:failed in %s"</literal></expr></argument>,
		     <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>SSL</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOG_NON_ERROR_STATES</name></cpp:ifndef>
	    <switch>switch <condition>(<expr><call><name>SSL_get_error</name><argument_list>(<argument><expr><operator>(</operator><name>SSL</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
	    <case>case <expr><name>SSL_ERROR_WANT_READ</name></expr>:</case>
	    <case>case <expr><name>SSL_ERROR_WANT_WRITE</name></expr>:</case>
		<comment type="block">/* Don't log non-error states. */</comment>
		<break>break;</break>
	    <default>default:</default>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s:error in %s"</literal></expr></argument>,
			 <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>SSL_state_string_long</name><argument_list>(<argument><expr><operator>(</operator><name>SSL</name> <operator>*</operator><operator>)</operator> <name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>LOG_NON_ERROR_STATES</name></cpp:ifndef>
	    </block_content>}</block></switch>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

 <comment type="block">/*
  * taken from OpenSSL crypto/bio/b_dump.c.
  * 
  * Modified to save a lot of strcpy and strcat by Matti Aarnio.
  * 
  * Rewritten by Wietse to elimate fixed-size stack buffer, array index
  * multiplication and division, sprintf() and strcpy(), and lots of strlen()
  * calls. We could make it a little faster by using a fixed-size stack-based
  * buffer.
  * 
  * 200412 - use %lx to print pointers, after casting them to unsigned long.
  */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRUNCATE_SPACE_NULL</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_WIDTH</name></cpp:macro>	<cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERT_SPLIT</name></cpp:macro>	<cpp:value>7</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tls_dump_buffer</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>acl_vstring_alloc</name><argument_list>(<argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name>start</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>row</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>col</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>ch</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRUNCATE_SPACE_NULL</name></cpp:ifdef>
    <while>while <condition>(<expr><name>last</name> <operator>&gt;=</operator> <name>start</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>last</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>last</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><name>last</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <for>for <control>(<init><expr><name>row</name> <operator>=</operator> <name>start</name></expr>;</init> <condition><expr><name>row</name> <operator>&lt;=</operator> <name>last</name></expr>;</condition> <incr><expr><name>row</name> <operator>+=</operator> <name>DUMP_WIDTH</name></expr></incr>)</control> <block>{<block_content>
	<expr_stmt><expr><call><name>ACL_VSTRING_RESET</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_vstring_sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%04lx "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>(</operator><name>row</name> <operator>-</operator> <name>start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <name>row</name></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name>row</name> <operator>+</operator> <name>DUMP_WIDTH</name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name>col</name> <operator>&gt;</operator> <name>last</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_vstring_strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"   "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>col</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>acl_vstring_sprintf_append</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%02x%c"</literal></expr></argument>,
				   <argument><expr><name>ch</name></expr></argument>, <argument><expr><ternary><condition><expr><name>col</name> <operator>-</operator> <name>row</name> <operator>==</operator> <name>VERT_SPLIT</name></expr> ?</condition><then> <expr><literal type="char">'|'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    </block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ACL_VSTRING_ADDCH</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>col</name> <operator>=</operator> <name>row</name></expr>;</init> <condition><expr><name>col</name> <operator>&lt;</operator> <name>row</name> <operator>+</operator> <name>DUMP_WIDTH</name></expr>;</condition> <incr><expr><name>col</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
	    <if_stmt><if>if <condition>(<expr><name>col</name> <operator>&gt;</operator> <name>last</name></expr>)</condition><block type="pseudo"><block_content>
		<break>break;</break></block_content></block></if></if_stmt>
	    <expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>col</name></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ACL_ISPRINT</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	    <expr_stmt><expr><call><name>ACL_VSTRING_ADDCH</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	    <if_stmt><if>if <condition>(<expr><name>col</name> <operator>-</operator> <name>row</name> <operator>==</operator> <name>VERT_SPLIT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ACL_VSTRING_ADDCH</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ACL_VSTRING_TERMINATE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>acl_vstring_str</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRUNCATE_SPACE_NULL</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><name>last</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>start</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%04lx - &lt;SPACES/NULLS&gt;"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>last</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>-</operator> <name>start</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* taken from OpenSSL apps/s_cb.c */</comment>

<function><type><name>long</name></type>    <name>tls_bio_dump_cb</name><parameter_list>(<parameter><decl><type><name>BIO</name> <modifier>*</modifier></type><name>bio</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cmd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>argp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argi</name></decl></parameter>,
			        <parameter><decl><type><name>long</name> <name>unused_argl</name></type> <name>acl_unused</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <operator>(</operator><name>BIO_CB_READ</name> <operator>|</operator> <name>BIO_CB_RETURN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"read from %08lX [%08lX] (%d bytes =&gt; %ld (0x%lX))"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>bio</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>argp</name></expr></argument>, <argument><expr><name>argi</name></expr></argument>,
		 <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_dump_buffer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>argp</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmd</name> <operator>==</operator> <operator>(</operator><name>BIO_CB_WRITE</name> <operator>|</operator> <name>BIO_CB_RETURN</name><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"write to %08lX [%08lX] (%d bytes =&gt; %ld (0x%lX))"</literal></expr></argument>,
		 <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>bio</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>argp</name></expr></argument>, <argument><expr><name>argi</name></expr></argument>,
		 <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_dump_buffer</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>argp</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>ret</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

 <comment type="block">/*
  * Broken linker workaround.
  */</comment>
<decl_stmt><decl><type><name>int</name></type>     <name>tls_dummy_for_broken_linkers</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
