<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/workspace/acl/lib_tls/tls/tls_scache.c"><comment type="block">/*++
 * NAME
 *	tls_scache 3
 * SUMMARY
 *	TLS session cache manager
 * SYNOPSIS
 *	#include &lt;tls_scache.h&gt;
 *
 *	TLS_SCACHE *tls_scache_open(dbname, cache_label, verbose, timeout)
 *	const char *dbname
 *	const char *cache_label;
 *	int	verbose;
 *	int	timeout;
 *
 *	void	tls_scache_close(cache)
 *	TLS_SCACHE *cache;
 *
 *	int	tls_scache_lookup(cache, cache_id, out_session)
 *	TLS_SCACHE *cache;
 *	const char *cache_id;
 *	ACL_VSTRING	*out_session;
 *
 *	int	tls_scache_update(cache, cache_id, session, session_len)
 *	TLS_SCACHE *cache;
 *	const char *cache_id;
 *	const char *session;
 *	ssize_t	session_len;
 *
 *	int	tls_scache_sequence(cache, first_next, out_cache_id,
 *				ACL_VSTRING *out_session)
 *	TLS_SCACHE *cache;
 *	int	first_next;
 *	char	**out_cache_id;
 *	ACL_VSTRING	*out_session;
 *
 *	int	tls_scache_delete(cache, cache_id)
 *	TLS_SCACHE *cache;
 *	const char *cache_id;
 * DESCRIPTION
 *	This module maintains Postfix TLS session cache files.
 *	each session is stored under a lookup key (hostname or
 *	session ID).
 *
 *	tls_scache_open() opens the specified TLS session cache
 *	and returns a handle that must be used for subsequent
 *	access.
 *
 *	tls_scache_close() closes the specified TLS session cache
 *	and releases memory that was allocated by tls_scache_open().
 *
 *	tls_scache_lookup() looks up the specified session in the
 *	specified cache, and applies session timeout restrictions.
 *	Entries that are too old are silently deleted.
 *
 *	tls_scache_update() updates the specified TLS session cache
 *	with the specified session information.
 *
 *	tls_scache_sequence() iterates over the specified TLS session
 *	cache and either returns the first or next entry that has not
 *	timed out, or returns no data. Entries that are too old are
 *	silently deleted. Specify TLS_SCACHE_SEQUENCE_NOTHING as the
 *	third and last argument to disable saving of cache entry
 *	content or cache entry ID information. This is useful when
 *	purging expired entries. A result value of zero means that
 *	the end of the cache was reached.
 *
 *	tls_scache_delete() removes the specified cache entry from
 *	the specified TLS session cache.
 *
 *	Arguments:
 * .IP dbname
 *	The base name of the session cache file.
 * .IP cache_label
 *	A string that is used in logging and error messages.
 * .IP verbose
 *	Do verbose logging of cache operations? (zero == no)
 * .IP timeout
 *	The time after wich a session cache entry is considered too old.
 * .IP first_next
 *	One of DICT_SEQ_FUN_FIRST (first cache element) or DICT_SEQ_FUN_NEXT
 *	(next cache element).
 * .IP cache_id
 *	Session cache lookup key.
 * .IP session
 *	Storage for session information.
 * .IP session_len
 *	The size of the session information in bytes.
 * .IP out_cache_id
 * .IP out_session
 *	Storage for saving the cache_id or session information of the
 *	current cache entry.
 *
 *	Specify TLS_SCACHE_DONT_NEED_CACHE_ID to avoid saving
 *	the session cache ID of the cache entry.
 *
 *	Specify TLS_SCACHE_DONT_NEED_SESSION to avoid
 *	saving the session information in the cache entry.
 * DIAGNOSTICS
 *	These routines terminate with a fatal run-time error
 *	for unrecoverable database errors. This allows the
 *	program to restart and reset the database to an
 *	empty initial state.
 *
 *	tls_scache_open() never returns on failure. All other
 *	functions return non-zero on success, zero when the
 *	operation could not be completed.
 * LICENSE
 * .ad
 * .fi
 *	The Secure Mailer license must be distributed with this software.
 * AUTHOR(S)
 *	Wietse Venema
 *	IBM T.J. Watson Research
 *	P.O. Box 704
 *	Yorktown Heights, NY 10598, USA
 *--*/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StdAfx.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_TLS</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dict.h"</cpp:file></cpp:include>

<comment type="block">/* Global library. */</comment>

<comment type="block">/* TLS library. */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tls_scache.h"</cpp:file></cpp:include>

<comment type="block">/* Application-specific. */</comment>

 <comment type="block">/*
  * Session cache entry format.
  */</comment>
<typedef>typedef <type><struct>struct <block>{
    <decl_stmt><decl><type><name>time_t</name></type>  <name>timestamp</name></decl>;</decl_stmt>			<comment type="block">/* time when saved */</comment>
    <decl_stmt><decl><type><name>char</name></type>    <name><name>session</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>			<comment type="block">/* actually a bunch of bytes */</comment>
}</block></struct></type> <name>TLS_SCACHE_ENTRY</name>;</typedef>

 <comment type="block">/*
  * SLMs.
  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>acl_vstring_str(x)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEN</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>ACL_VSTRING_LEN(x)</cpp:value></cpp:define>

<comment type="block">/* tls_scache_encode - encode TLS session cache entry */</comment>

<function><type><specifier>static</specifier> <name>ACL_VSTRING</name> <modifier>*</modifier></type><name>tls_scache_encode</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cache_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>session</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>session_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>TLS_SCACHE_ENTRY</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>hex_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>binary_data_len</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Assemble the TLS session cache entry.
     * 
     * We could eliminate some copying by using incremental encoding, but
     * sessions are so small that it really does not matter.
     */</comment>
    <expr_stmt><expr><name>binary_data_len</name> <operator>=</operator> <name>session_len</name> <operator>+</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TLS_SCACHE_ENTRY</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TLS_SCACHE_ENTRY</name> <operator>*</operator><operator>)</operator> <call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>binary_data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><operator>(</operator><name>time_t</name> <operator>*</operator><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>session</name></name></expr></argument>, <argument><expr><name>session</name></expr></argument>, <argument><expr><name>session_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Encode the TLS session cache entry.
     */</comment>
    <expr_stmt><expr><name>hex_data</name> <operator>=</operator> <call><name>acl_vstring_alloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <name>binary_data_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_hex_encode</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>entry</name></expr></argument>, <argument><expr><name>binary_data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"write %s TLS cache entry %s: time=%ld [data %ld bytes]"</literal></expr></argument>,
		<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>,
		<argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>session_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Clean up.
     */</comment>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>hex_data</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_scache_decode - decode TLS session cache entry */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>tls_scache_decode</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cache_id</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hex_data</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>hex_data_len</name></decl></parameter>, <parameter><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>out_session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls+scache_decode"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_SCACHE_ENTRY</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>bin_data</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Sanity check.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>hex_data_len</name> <operator>&lt;</operator> <operator>(</operator><name>ssize_t</name><operator>)</operator> <operator>(</operator><literal type="number">2</literal> <operator>*</operator> <operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>TLS_SCACHE_ENTRY</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s TLS cache: truncated entry for %s: %.100s"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Disassemble the TLS session cache entry.
     * 
     * No early returns or we have a memory leak.
     */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_AND_RETURN</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ acl_vstring_free(ptr); return (x); }</cpp:value></cpp:define>

    <expr_stmt><expr><name>bin_data</name> <operator>=</operator> <call><name>acl_vstring_alloc</name><argument_list>(<argument><expr><name>hex_data_len</name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><call><name>acl_hex_decode</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>, <argument><expr><name>hex_data</name></expr></argument>, <argument><expr><name>hex_data_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>acl_msg_warn</name><argument_list>(<argument><expr><literal type="string">"%s: %s TLS cache: malformed entry for %s: %.100s"</literal></expr></argument>,
		 <argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREE_AND_RETURN</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TLS_SCACHE_ENTRY</name> <operator>*</operator><operator>)</operator> <call><name>STR</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"read %s TLS cache entry %s: time=%ld [data %ld bytes]"</literal></expr></argument>,
		 <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>entry</name><operator>-&gt;</operator><name>timestamp</name></name></expr></argument>,
	      <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><call><name>LEN</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TLS_SCACHE_ENTRY</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Other mandatory restrictions.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>timestamp</name></name> <operator>+</operator> <name><name>cp</name><operator>-&gt;</operator><name>timeout</name></name> <operator>&lt;</operator> <call><name>time</name><argument_list>(<argument><expr><operator>(</operator><name>time_t</name> <operator>*</operator><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>FREE_AND_RETURN</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Optional output.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>out_session</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_vstring_memcpy</name><argument_list>(<argument><expr><name>out_session</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>session</name></name></expr></argument>,
	       <argument><expr><call><name>LEN</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>TLS_SCACHE_ENTRY</name></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Clean up.
     */</comment>
    <expr_stmt><expr><call><name>FREE_AND_RETURN</name><argument_list>(<argument><expr><name>bin_data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_scache_lookup - load session from cache */</comment>

<function><type><name>int</name></type>     <name>tls_scache_lookup</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cache_id</name></decl></parameter>, <parameter><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hex_data</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"lookup %s session id=%s"</literal></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Initialize. Don't leak data.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>session</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>ACL_VSTRING_RESET</name><argument_list>(<argument><expr><name>session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Search the cache database.
     */</comment>
    <if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>DICT_GET</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>hex_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Decode entry and delete if expired or malformed.
     */</comment>
    <if_stmt><if>if <condition>(<expr><call><name>tls_scache_decode</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name>hex_data</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>session</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><call><name>tls_scache_delete</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">0</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
    </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_scache_update - save session to cache */</comment>

<function><type><name>int</name></type>     <name>tls_scache_update</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cache_id</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>ssize_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>hex_data</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"put %s session id=%s [data %ld bytes]"</literal></expr></argument>,
		 <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Encode the cache entry.
     */</comment>
    <expr_stmt><expr><name>hex_data</name> <operator>=</operator> <call><name>tls_scache_encode</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Store the cache entry.
     * 
     * XXX Berkeley DB supports huge database keys and values. SDBM seems to
     * have a finite limit, and DBM simply can't be used at all.
     */</comment>
    <expr_stmt><expr><call><name>DICT_PUT</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>STR</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>LEN</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Clean up.
     */</comment>
    <expr_stmt><expr><call><name>acl_vstring_free</name><argument_list>(<argument><expr><name>hex_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_scache_sequence - get first/next TLS session cache entry */</comment>

<function><type><name>int</name></type>     <name>tls_scache_sequence</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>first_next</name></decl></parameter>,
	<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>out_cache_id</name></decl></parameter>, <parameter><decl><type><name>ACL_VSTRING</name> <modifier>*</modifier></type><name>out_session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>saved_cursor</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>found_entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>     <name>keep_entry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>saved_member</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type>  <name>key_size</name></decl>, <decl><type ref="prev"/><name>val_size</name></decl>;</decl_stmt>

    <comment type="block">/*
     * XXX Deleting entries while enumerating a map can he tricky. Some map
     * types have a concept of cursor and support a "delete the current
     * element" operation. Some map types without cursors don't behave well
     * when the current first/next entry is deleted (example: with Berkeley
     * DB &lt; 2, the "next" operation produces garbage). To avoid trouble, we
     * delete an expired entry after advancing the current first/next
     * position beyond it, and ignore client requests to delete the current
     * entry.
     */</comment>

    <comment type="block">/*
     * Find the first or next database entry. Activate the passivated entry
     * and check the time stamp. Schedule the entry for deletion if it is too
     * old.
     * 
     * Save the member (cache id) so that it will not be clobbered by the
     * tls_scache_lookup() call below.
     */</comment>
    <expr_stmt><expr><name>found_entry</name> <operator>=</operator> <operator>(</operator><call><name>DICT_SEQ</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>first_next</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>member</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_size</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found_entry</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name>keep_entry</name> <operator>=</operator> <call><name>tls_scache_decode</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>member</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
				       <argument><expr><name>out_session</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keep_entry</name> <operator>&amp;&amp;</operator> <name>out_cache_id</name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><operator>*</operator><name>out_cache_id</name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>saved_member</name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>member</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/*
     * Delete behind. This is a no-op if an expired cache entry was updated
     * in the mean time. Use the saved lookup criteria so that the "delete
     * behind" operation works as promised.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>TLS_SCACHE_FLAG_DEL_SAVED_CURSOR</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TLS_SCACHE_FLAG_DEL_SAVED_CURSOR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_cursor</name> <operator>=</operator> <name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tls_scache_lookup</name><argument_list>(<argument><expr><name>cp</name></expr></argument>, <argument><expr><name>saved_cursor</name></expr></argument>, <argument><expr><operator>(</operator><name>ACL_VSTRING</name> <operator>*</operator><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>saved_cursor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>

    <comment type="block">/*
     * Otherwise, clean up if this is not the first iteration.
     */</comment>
    <else>else <block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/*
     * Protect the current first/next entry against explicit or implied
     * client delete requests, and schedule a bad or expired entry for
     * deletion. Save the lookup criteria so that the "delete behind"
     * operation will work as promised.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>found_entry</name></expr>)</condition> <block>{<block_content>
	<expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name> <operator>=</operator> <name>saved_member</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>keep_entry</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>TLS_SCACHE_FLAG_DEL_SAVED_CURSOR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><operator>(</operator><name>found_entry</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_scache_delete - delete session from cache */</comment>

<function><type><name>int</name></type>     <name>tls_scache_delete</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cache_id</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"delete %s session id=%s"</literal></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Do it, unless we would delete the current first/next entry. Some map
     * types don't have cursors, and some of those don't behave when the
     * "current" entry is deleted.
     */</comment>
    <return>return <expr><operator>(</operator><operator>(</operator><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
	    <operator>||</operator> <call><name>DICT_DEL</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>cache_id</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cache_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_scache_init - init dict */</comment>

<function><type><name>void</name></type> <name>tls_scache_init</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>dict_open_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* tls_scache_open - open TLS session cache file */</comment>

<function><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>tls_scache_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cache_label</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>timeout</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_scache_open"</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>DICT</name>   <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"open %s TLS cache %s"</literal></expr></argument>, <argument><expr><name>cache_label</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Open the dictionary with O_TRUNC, so that we never have to worry about
     * opening a damaged file after some process terminated abnormally.
     */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SINGLE_UPDATER</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICT_FLAGS</name></cpp:macro> <cpp:value>(DICT_FLAG_DUP_REPLACE)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ACL_UNIX</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICT_FLAGS</name></cpp:macro> \
	<cpp:value>(DICT_FLAG_DUP_REPLACE | DICT_FLAG_LOCK | DICT_FLAG_SYNC_UPDATE)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICT_FLAGS</name></cpp:macro> \
	<cpp:value>(DICT_FLAG_DUP_REPLACE | DICT_FLAG_SYNC_UPDATE)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

    <expr_stmt><expr><name>dict</name> <operator>=</operator> <call><name>dict_open</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>O_RDWR</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>, <argument><expr><name>DICT_FLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/*
     * Sanity checks.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>lock_fd</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: dictionary %s is not a regular file"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SINGLE_UPDATER</name></cpp:ifdef>
    <if_stmt><if>if <condition>(<expr><call><name>acl_myflock</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>lock_fd</name></name></expr></argument>, <argument><expr><name>INTERNAL_LOCK</name></expr></argument>,
		<argument><expr><name>MYFLOCK_OP_EXCLUSIVE</name> <operator>|</operator> <name>MYFLOCK_OP_NOWAIT</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: cannot lock dictionary %s for exclusive use: %s"</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><call><name>acl_last_serror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
    <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>update</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: dictionary %s does not support update operations"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>delete_it</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: dictionary %s does not support delete operations"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>dict</name><operator>-&gt;</operator><name>sequence</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: dictionary %s does not support sequence operations"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Create the TLS_SCACHE object.
     */</comment>
    <expr_stmt><expr><name>cp</name> <operator>=</operator> <operator>(</operator><name>TLS_SCACHE</name> <operator>*</operator><operator>)</operator> <call><name>acl_mymalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>cp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name> <operator>=</operator> <call><name>acl_mystrdup</name><argument_list>(<argument><expr><name>cache_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>verbose</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>timeout</name></name> <operator>=</operator> <name>timeout</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

    <return>return <expr><operator>(</operator><name>cp</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* tls_scache_close - close TLS session cache file */</comment>

<function><type><name>void</name></type>    <name>tls_scache_close</name><parameter_list>(<parameter><decl><type><name>TLS_SCACHE</name> <modifier>*</modifier></type><name>cp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_scache_close"</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Logging.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s: close %s TLS cache %s"</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>, <argument><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * Destroy the TLS_SCACHE object.
     */</comment>
    <expr_stmt><expr><call><name>DICT_CLOSE</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>cache_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name></expr>)</condition><block type="pseudo"><block_content>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>cp</name><operator>-&gt;</operator><name>saved_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
