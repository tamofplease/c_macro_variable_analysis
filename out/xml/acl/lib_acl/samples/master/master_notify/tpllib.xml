<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/acl/lib_acl/samples/master/master_notify/tpllib.c"><comment type="block">/*
 * tpllib
 *
 * C library of functions for text template processing.
 * Copyright (C) 2003-2007 Niels Wojciech Tadeusz Andersen &lt;haj@zhat.dk&gt;
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>                 <comment type="block">/* write() */</comment>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>             <comment type="block">/* write() */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include> 		<comment type="block">/* exit() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include> 		<comment type="block">/* fopen(), sprintf() ... */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>		<comment type="block">/* va_start(), va_end() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include> 		<comment type="block">/* memset(), memcmp() ... */</comment>

<comment type="block">/* Define ZTS when building a PHP extension */</comment>
<comment type="block">/* Define WIN32 when compiling under MS Windows */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:define># <cpp:directive>define</cpp:directive> <cpp:macro><name>vsnprintf</name></cpp:macro> <cpp:value>_vsnprintf</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib_tpl.h"</cpp:file></cpp:include>

<comment type="block">/* Length defines for markup elements */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELIM_LEN_LEFT</name></cpp:macro> <cpp:value>(sizeof(DELIMITER_LEFT) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELIM_LEN_RIGHT</name></cpp:macro> <cpp:value>(sizeof(DELIMITER_RIGHT) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEC_HEAD_LEN</name></cpp:macro> <cpp:value>(sizeof(SECTIONTAG_HEAD) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SEC_TAIL_LEN</name></cpp:macro> <cpp:value>(sizeof(SECTIONTAG_TAIL) - 1)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MIN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a) &lt; (b)) ? (a) : (b))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_MAX</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((a) &gt; (b)) ? (a) : (b))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_NODE_LEN</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n)-&gt;val) ? (n)-&gt;len : (n)-&gt;fval-&gt;len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_NODE_TEXT</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((n)-&gt;val) ? (n)-&gt;val : (n)-&gt;fval-&gt;val)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>M_INT_TO_STRING</name><parameter_list>(<parameter><type><name>buffer</name></type></parameter>, <parameter><type><name>buffer_len</name></type></parameter>, <parameter><type><name>val</name></type></parameter>, <parameter><type><name>signed_v</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do \
    { \
        char rev[5 * sizeof(int) / 2]; \
        int i = 0, digits = 0; \
        if ((signed_v) &amp;&amp; (val) &lt; 0) \
        { \
            buffer[i] = '-'; \
            i++; \
        } \
        do \
        { \
            rev[digits++] = '0' + abs((val) % 10); \
            (val) /= 10; \
        } \
        while ((val) != 0); \
        for (; digits &gt; 0 &amp;&amp; i &lt; (buffer_len); i++) \
            buffer[i] = rev[--digits]; \
        buffer[i] = 0; \
        (buffer_len) = i; \
    } while (0)</cpp:value></cpp:define>


<comment type="block">/* Binary safe string search */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tpl_strstr</name><parameter_list>(<parameter><decl><type><specifier>register</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>haystack</name></decl></parameter>,
                              <parameter><decl><type><name>ssize_t</name></type> <name>haystack_len</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>needle</name></decl></parameter>,
                              <parameter><decl><type><name>int</name></type> <name>needle_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_toofar</name> <init>= <expr><name>haystack</name> <operator>+</operator> <name>haystack_len</name> <operator>-</operator> <name>needle_len</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>p_toofar</name> <operator>&lt;=</operator> <name>haystack</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

    <do>do
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><operator>*</operator><name>haystack</name> <operator>==</operator> <operator>*</operator><name>needle</name></expr>)</condition>
        <block>{<block_content>
            <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>!=</operator> <name>needle_len</name> <operator>&amp;&amp;</operator> <name><name>haystack</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>needle</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

            <if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>needle_len</name></expr>)</condition><block type="pseudo"><block_content>
                <return>return <expr><name>haystack</name></expr>;</return></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
        
        <expr_stmt><expr><name>haystack</name><operator>++</operator></expr>;</expr_stmt>
    </block_content>}</block>
    while <condition>(<expr><name>haystack</name> <operator>!=</operator> <name>p_toofar</name></expr>)</condition>;</do>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>tpl_node_t</name><modifier>*</modifier></type> <name>create_node</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_node_t</name><modifier>*</modifier></type> <name>node</name> <init>= <expr><operator>(</operator><name>tpl_node_t</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal><operator>+</operator><sizeof>sizeof<argument_list>(<argument><expr><name>tpl_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>(</operator><name>node</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>destroy_node</name><parameter_list>(<parameter><decl><type><name>tpl_node_t</name><modifier>*</modifier></type> <name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>tpl_fcell_t</name><modifier>*</modifier></type> <name>create_fcell</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>data_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name><modifier>*</modifier></type> <name>field</name> <init>= <expr><operator>(</operator><name>tpl_fcell_t</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>key_len</name> <operator>+</operator> <literal type="number">1</literal>
                                                <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tpl_fcell_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>field</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>key</name><index>[<expr><name>key_len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><call><name>M_MAX</name><argument_list>(<argument><expr><name>data_len</name></expr></argument>, <argument><expr><name>INITIAL_FIELD_LEN</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>field</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>destroy_fcell</name><parameter_list>(<parameter><decl><type><name>tpl_fcell_t</name><modifier>*</modifier></type> <name>field</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>tpl_tcell_t</name><modifier>*</modifier></type> <name>create_tcell</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name><modifier>*</modifier></type> <name>section</name> <init>= <expr><operator>(</operator><name>tpl_tcell_t</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>key_len</name> <operator>+</operator> <literal type="number">1</literal>
                                                  <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tpl_tcell_t</name></expr></argument>)</argument_list></sizeof>
                                                  <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tpl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <operator>(</operator><name>tpl_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>section</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>tpl_init</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>key</name><index>[<expr><name>key_len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <return>return <expr><name>section</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>destroy_tcell</name><parameter_list>(<parameter><decl><type><name>tpl_tcell_t</name><modifier>*</modifier></type> <name>section</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tpl_release</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>section</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* Hash function using multipy by 31 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>tpl_hash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_key_end</name> <init>= <expr><name>key</name> <operator>+</operator> <name>key_len</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>register</specifier> <name>unsigned</name> <name>int</name></type> <name>h</name> <init>= <expr><operator>*</operator><name>key</name><operator>++</operator></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><name>key</name> <operator>!=</operator> <name>p_key_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>key</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>g</name></decl>;</decl_stmt>
        <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name> <operator>&lt;&lt;</operator> <literal type="number">5</literal><operator>)</operator> <operator>+</operator> <operator>*</operator><name>key</name><operator>++</operator></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><operator>(</operator><name>g</name> <operator>=</operator> <name>h</name> <operator>&amp;</operator> <literal type="number">0xf0000000</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>h</name> <operator>=</operator> <operator>(</operator><name>h</name> <operator>^</operator> <operator>(</operator><name>g</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>^</operator> <name>g</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
    </block_content>}</block></while>
    <return>return <expr><name>h</name> <operator>%</operator> <name>HASH_TABLE_SIZE</name></expr>;</return>
</block_content>}</block></function>
 
<function><type><specifier>static</specifier> <name>tpl_fcell_t</name><modifier>*</modifier></type> <name>tpl_produce_field</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>,
                                      <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>data_len</name></decl></parameter>,
                                      <parameter><decl><type><name>int</name></type> <name>may_create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>pfield</name> <init>= <expr><operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>fields</name><index>[<expr><call><name>tpl_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>pfield</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>pfield</name><operator>)</operator><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name>data_len</name> <operator>&gt;</operator> <name>INITIAL_FIELD_LEN</name> <operator>&amp;&amp;</operator> <name>data_len</name> <operator>&gt;</operator> <name><operator>(</operator><operator>*</operator><name>pfield</name><operator>)</operator><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>pfield</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>acl_myrealloc</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>pfield</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <return>return <expr><operator>*</operator><name>pfield</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><name>pfield</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>pfield</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>pfield</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>may_create</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>pfield</name> <operator>=</operator> <call><name>create_fcell</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>, <argument><expr><name>data_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><operator>*</operator><name>pfield</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tpl_get_field</name><parameter_list>(<parameter><type><name>tpl</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>tpl_produce_field((tpl), (key), strlen((key)), 0, 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tpl_new_field</name><parameter_list>(<parameter><type><name>tpl</name></type></parameter>, <parameter><type><name>key</name></type></parameter>, <parameter><type><name>key_len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>tpl_produce_field((tpl), (key), (key_len), 0, 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tpl_cpy_field</name><parameter_list>(<parameter><type><name>field</name></type></parameter>, <parameter><type><name>tpl</name></type></parameter>, <parameter><type><name>key</name></type></parameter>, <parameter><type><name>key_len</name></type></parameter>, <parameter><type><name>data</name></type></parameter>, <parameter><type><name>data_len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>do \
    { \
        (field) = tpl_produce_field((tpl), (key), (key_len), (data_len), 1); \
        if ((field)-&gt;len == 0 &amp;&amp; (data_len) != 0) \
        { \
            (void)memcpy((field)-&gt;val, (data), (data_len));\
            (field)-&gt;val[(data_len)] = 0; \
            (field)-&gt;len = (data_len); \
        } \
    } while (0)</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name>tpl_tcell_t</name><modifier>*</modifier></type> <name>tpl_produce_section</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>,
                                        <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>,
                                        <parameter><decl><type><name>int</name></type> <name>key_len</name></decl></parameter>,
                                        <parameter><decl><type><name>int</name></type> <name>must_create</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>psection</name> <init>= <expr><operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>sections</name><index>[<expr><call><name>tpl_hash</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><operator>*</operator><name>psection</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>psection</name><operator>)</operator><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><ternary><condition><expr><operator>(</operator><name>must_create</name><operator>)</operator></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>*</operator><name>psection</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>psection</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>psection</name><operator>)</operator><operator>-&gt;</operator><name>_next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
    <if_stmt><if>if <condition>(<expr><operator>*</operator><name>psection</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>must_create</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>*</operator><name>psection</name> <operator>=</operator> <call><name>create_tcell</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>psection</name><operator>)</operator><operator>-&gt;</operator><name><name>tpl</name><operator>-&gt;</operator><name>parent</name></name></name> <operator>=</operator> <name>tpl</name></expr>;</expr_stmt>
        <return>return <expr><operator>*</operator><name>psection</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tpl_get_section</name><parameter_list>(<parameter><type><name>tpl</name></type></parameter>, <parameter><type><name>key</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>tpl_produce_section(tpl, key, strlen(key), 0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tpl_make_section</name><parameter_list>(<parameter><type><name>tpl</name></type></parameter>, <parameter><type><name>key</name></type></parameter>, <parameter><type><name>key_len</name></type></parameter>)</parameter_list></cpp:macro> \
    <cpp:value>tpl_produce_section(tpl, key, key_len, 1)</cpp:value></cpp:define>


<comment type="block">/* Big, ugly, horrible, quite possibly buggy...
   live with it or correct it and let me know */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tpl_construct</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_last</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p_begin</name> <init>= <expr><name>p_last</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_curr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_next</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>last_section</name> <init>= <expr><operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>

    <comment type="block">/* While a field delimiter can be found in what is left */</comment>
    <while>while <condition>(<expr><operator>(</operator><name>p_curr</name> <operator>=</operator> <call><name>tpl_strstr</name><argument_list>(<argument><expr><name>p_last</name></expr></argument>, <argument><expr><name>p_end</name> <operator>-</operator> <name>p_last</name></expr></argument>, 
                                <argument><expr><name>DELIMITER_LEFT</name></expr></argument>, <argument><expr><name>DELIM_LEN_LEFT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Advance to beginning of field/section name */</comment>
        <expr_stmt><expr><name>p_curr</name> <operator>+=</operator> <name>DELIM_LEN_LEFT</name></expr>;</expr_stmt>

        <comment type="block">/* Find end delimiter of identifier or fail with syntax error */</comment>
        <expr_stmt><expr><name>p_next</name> <operator>=</operator> <call><name>tpl_strstr</name><argument_list>(<argument><expr><name>p_curr</name></expr></argument>, <argument><expr><name>p_end</name> <operator>-</operator> <name>p_curr</name></expr></argument>, <argument><expr><name>DELIMITER_RIGHT</name></expr></argument>, <argument><expr><name>DELIM_LEN_RIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>p_next</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <return>return <expr><name>TPL_SYNTAX_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>

        <comment type="block">/* Section */</comment>
        <if_stmt><if>if <condition>(<expr><name>p_curr</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>p_begin</name> <operator>+</operator> <name>SEC_HEAD_LEN</name>
             <operator>&amp;&amp;</operator> <name>p_end</name> <operator>-</operator> <name>p_next</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>SEC_TAIL_LEN</name>
             <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>SECTIONTAG_HEAD</name></expr></argument>, <argument><expr><name>p_curr</name> <operator>-</operator> <name>SEC_HEAD_LEN</name></expr></argument>, 
                        <argument><expr><name>SEC_HEAD_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
             <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>SECTIONTAG_TAIL</name></expr></argument>, <argument><expr><name>p_next</name></expr></argument>, <argument><expr><name>SEC_TAIL_LEN</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name></decl>;</decl_stmt>

            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p_curr</name> <operator>-</operator> <name>SEC_HEAD_LEN</name> <operator>-</operator> <name>p_last</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>val_len</name> <init>= <expr><name>p_curr</name> <operator>-</operator> <name>SEC_HEAD_LEN</name> <operator>-</operator> <name>p_last</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name><index>[<expr><name>val_len</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>p_last</name></expr></argument>, <argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        
            <comment type="block">/* Create and chain in entry for section */</comment>
            <expr_stmt><expr><name>section</name> <operator>=</operator> <call><name>tpl_make_section</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>p_curr</name></expr></argument>, <argument><expr><name>p_next</name> <operator>-</operator> <name>p_curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>code</name></decl>;</decl_stmt>
                <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>beginning</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ending</name></decl>;</decl_stmt>

                <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <name>section</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>last_section</name> <operator>=</operator> <operator>&amp;</operator><name><name>section</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>preceding</name></name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>

                <comment type="block">/* Advance past the section tag */</comment>
                <expr_stmt><expr><name>p_last</name> <operator>=</operator> <name>p_next</name> <operator>+</operator> <name>SEC_TAIL_LEN</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>beginning</name> <operator>=</operator> <name>p_next</name> <operator>+</operator> <name>SEC_TAIL_LEN</name></expr>;</expr_stmt>

                <comment type="block">/* Find next occurrence of this section tag */</comment>
                <expr_stmt><expr><name>ending</name> <operator>=</operator> <call><name>tpl_strstr</name><argument_list>(<argument><expr><name>beginning</name></expr></argument>, 
                                    <argument><expr><name>p_end</name> <operator>-</operator> <name>beginning</name></expr></argument>,
                                    <argument><expr><name>p_curr</name> <operator>-</operator> <name>SEC_HEAD_LEN</name></expr></argument>,
                                    <argument><expr><name>beginning</name> <operator>-</operator> <name>p_curr</name> <operator>+</operator> <name>SEC_HEAD_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>p_last</name> <operator>=</operator> <name>ending</name> <operator>+</operator> <operator>(</operator><name>SEC_HEAD_LEN</name> <operator>+</operator> <name>p_last</name> <operator>-</operator> <name>p_curr</name><operator>)</operator></expr>;</expr_stmt>
        
                <comment type="block">/* If found and found before p_end */</comment>
                <if_stmt><if>if <condition>(<expr><name>ending</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p_last</name> <operator>&lt;=</operator> <name>p_end</name></expr>)</condition>
                <block>{<block_content>
                    <comment type="block">/* Construct recursively */</comment>
                    <expr_stmt><expr><name>code</name> <operator>=</operator> <call><name>tpl_construct</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>beginning</name></expr></argument>, <argument><expr><name>ending</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></if>
                <else>else<block type="pseudo"><block_content>
                    <expr_stmt><expr><name>code</name> <operator>=</operator> <name>TPL_SYNTAX_ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
            
                <if_stmt><if>if <condition>(<expr><name>code</name> <operator>!=</operator> <name>TPL_OK</name></expr>)</condition>
                <block>{<block_content>
                    <expr_stmt><expr><call><name>tpl_release</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><call><name>tpl_init</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                    <return>return <expr><name>TPL_SYNTAX_ERROR</name></expr>;</return>
                </block_content>}</block></if></if_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <return>return <expr><name>TPL_SYNTAX_ERROR</name></expr>;</return>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Field */</comment>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><operator>(</operator><name>p_curr</name> <operator>-</operator> <name>DELIM_LEN_LEFT</name> <operator>-</operator> <name>p_last</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>int</name></type> <name>val_len</name> <init>= <expr><name>p_curr</name> <operator>-</operator> <name>DELIM_LEN_LEFT</name> <operator>-</operator> <name>p_last</name></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name><index>[<expr><name>val_len</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>p_last</name></expr></argument>, <argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>

            <expr_stmt><expr><name>p_last</name> <operator>=</operator> <name>p_next</name> <operator>+</operator> <name>DELIM_LEN_RIGHT</name></expr>;</expr_stmt>

            <comment type="block">/* Create node and set fval to new field cell */</comment>
            <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>fval</name></name> <operator>=</operator> <call><name>tpl_new_field</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>p_curr</name></expr></argument>, <argument><expr><name>p_next</name> <operator>-</operator> <name>p_curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></while>

    <comment type="block">/* Store rest of the text */</comment>
    <if_stmt><if>if <condition>(<expr><name>p_last</name> <operator>&lt;</operator> <name>p_end</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>val_len</name> <init>= <expr><name>p_end</name> <operator>-</operator> <name>p_last</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>p_last</name></expr></argument>, <argument><expr><name>val_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name><index>[<expr><name>val_len</name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

    <return>return <expr><name>TPL_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_init</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <comment type="block">/* Set everything to NULL */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memset</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tpl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name>tpl</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_release</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>register</specifier> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Free nodes */</comment>
    <while>while <condition>(<expr><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>deleted</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>destroy_node</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    
    </block_content>}</block></while>

    <comment type="block">/* Free any added content */</comment>
    <while>while <condition>(<expr><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>deleted</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>destroy_node</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <comment type="block">/* Free field cells */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>HASH_TABLE_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>fc</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>fields</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

        <while>while <condition>(<expr><name>fc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>deleted</name> <init>= <expr><name>fc</name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name>fc</name> <operator>=</operator> <name><name>fc</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>destroy_fcell</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></for>
    <comment type="block">/* Free sections including added content */</comment>
    <while>while <condition>(<expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>deleted</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>first</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

        <comment type="block">/* This will call tpl_release() recursively */</comment>
        <expr_stmt><expr><call><name>destroy_tcell</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl_alloc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name> <init>= <expr><operator>(</operator><name>tpl_t</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tpl_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tpl_init</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>tpl</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_free</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tpl_release</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Load template file */</comment>
<function><type><name>int</name></type> <name>tpl_load</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TPL_OPEN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Find length of file content */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>rewind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <comment type="block">/* Allocate buffer for data + 0 byte */</comment>
    <expr_stmt><expr><name>buffer</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>len</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TPL_READ_ERROR</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    
    <comment type="block">/* Use data in buffer to construct template */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>tpl_construct</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>TPL_OK</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>tpl_release</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>tpl_init</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Load from a string */</comment>
<function><type><name>int</name></type> <name>tpl_from_string</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>tpl_construct</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buffer</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Recursively clear added content */</comment>
<function><type><name>void</name></type> <name>tpl_reset</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>HASH_TABLE_SIZE</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name><modifier>*</modifier></type> <name>section</name></decl>;</decl_stmt>
    
    <comment type="block">/* Clear fields */</comment>
    <while>while <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_fcell_t</name><modifier>*</modifier></type> <name>field</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>fields</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <while>while <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><operator>*</operator><name><name>field</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name>field</name> <operator>=</operator> <name><name>field</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>
    </block_content>}</block></while>
    <comment type="block">/* Clear sections */</comment>
    <for>for <control>(<init><expr><name>section</name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr>;</init> <condition><expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>section</name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Clear added content */</comment>
        <while>while <condition>(<expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>tpl_node_t</name><modifier>*</modifier></type> <name>n</name> <init>= <expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>destroy_node</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</expr_stmt>
    
        <comment type="block">/* Clear this section */</comment>
        <expr_stmt><expr><call><name>tpl_reset</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/* Set up the selected section pointer to correspond to 
   that of the copied template */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>tpl_adjust_selection</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>srctpl</name></decl></parameter>,
                                 <parameter><decl><type><name>tpl_tcell_t</name><modifier>*</modifier></type> <name>sec</name></decl></parameter>,
                                 <parameter><decl><type><specifier>const</specifier> <name>tpl_tcell_t</name><modifier>*</modifier></type> <name>srcsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>tpl_tcell_t</name> <modifier>*</modifier></type><name>sec1</name> <init>= <expr><name>srcsec</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>sec2</name> <init>= <expr><name>sec</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>srctpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>!=</operator> <name>srctpl</name></expr>)</condition>
    <block>{<block_content>
        <for>for <control>(<init>;</init> <condition><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>==</operator> <name>tpl</name> <operator>&amp;&amp;</operator> <name>sec1</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
               <incr><expr><name>sec1</name> <operator>=</operator> <name><name>sec1</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>sec2</name> <operator>=</operator> <name><name>sec2</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>srctpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>==</operator> <name><name>sec1</name><operator>-&gt;</operator><name>tpl</name></name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name><name>sec2</name><operator>-&gt;</operator><name>tpl</name></name></expr>;</expr_stmt></block_content></block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><call><name>tpl_adjust_selection</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>,
                                     <argument><expr><name>srctpl</name></expr></argument>, 
                                     <argument><expr><name><name>sec2</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></argument>,
                                     <argument><expr><name><name>sec1</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* Recursive copy */</comment>
<function><type><name>void</name></type> <name>tpl_copy</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>srctpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name> <init>= <expr><operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>curr_node</name> <init>= <expr><name><name>srctpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier><modifier>*</modifier></type><name>last_section</name> <init>= <expr><operator>&amp;</operator><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>curr_section</name> <init>= <expr><name><name>srctpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>

    <for>for <control>(<init>;</init> <condition><expr><name>curr_section</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>curr_section</name> <operator>=</operator> <name><name>curr_section</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <comment type="block">/* Copy text and fields until the current section's position */</comment>
        <while>while <condition>(<expr><name>curr_node</name> <operator>!=</operator> <operator>*</operator><name><name>curr_section</name><operator>-&gt;</operator><name>preceding</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Text */</comment>
            <if_stmt><if>if <condition>(<expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name><index>[<expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr>]</index> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
            </block_content>}</block></if>
            <comment type="block">/* Field */</comment>
            <else>else
            <block>{<block_content>
                <comment type="block">/* Create node and set fval to field cell */</comment>
                <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

                <expr_stmt><expr><call><name>tpl_cpy_field</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>fval</name></name></expr></argument>, 
                              <argument><expr><name>tpl</name></expr></argument>,
                              <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                              <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
                              <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            </block_content>}</block></else></if_stmt>

            <expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name>curr_node</name> <operator>=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        </block_content>}</block></while>

        <comment type="block">/* Create emtpy section entry for current section */</comment>
        <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <call><name>tpl_make_section</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>,
                                         <argument><expr><name><name>curr_section</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                                         <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>curr_section</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name>preceding</name></name> <operator>=</operator> <name>tail</name></expr>;</expr_stmt>


        <comment type="block">/* Consolidate added content into a single node in newly created
           section entry so that only one memory allocation is needed */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>curr_section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>some_node</name> <init>= <expr><name><name>curr_section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr></init></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>
            <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

            <comment type="block">/* Get length of added content */</comment>
            <for>for <control>(<init>;</init> <condition><expr><name>some_node</name><operator>!=</operator><name>NULL</name></expr>;</condition> <incr><expr><name>some_node</name><operator>=</operator><name><name>some_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
                <expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>some_node</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></for>

            <comment type="block">/* Create node for added content */</comment>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name></name> <operator>=</operator> 
                <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name></name></expr>;</expr_stmt>

            <comment type="block">/* Copy added content into new node */</comment>

            <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>val</name></name></name></expr>;</expr_stmt>

            <for>for <control>(<init><expr><name>some_node</name> <operator>=</operator> <name><name>curr_section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</init>
                 <condition><expr><name>some_node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
                 <incr><expr><name>some_node</name> <operator>=</operator> <name><name>some_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>some_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>some_node</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>some_node</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            </block_content>}</block></for>
            <expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>


        <comment type="block">/* Recursively copy section */</comment>
        <expr_stmt><expr><call><name>tpl_copy</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name><name>curr_section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>last_section</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>last_section</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Copy the rest */</comment>
    <while>while <condition>(<expr><name>curr_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Text */</comment>
        <if_stmt><if>if <condition>(<expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if>
        <comment type="block">/* Field */</comment>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>tpl_cpy_field</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>fval</name></name></expr></argument>, 
                          <argument><expr><name>tpl</name></expr></argument>,
                          <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>key</name></name></expr></argument>,
                          <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>key</name></name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
                          <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <expr_stmt><expr><name>tail</name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name>tail</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>curr_node</name> <operator>=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>

    <expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>*</operator><name>last_section</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name>tpl</name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>tpl_adjust_selection</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>srctpl</name></expr></argument>, <argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></argument>, <argument><expr><name><name>srctpl</name><operator>-&gt;</operator><name>first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>tpl_set_field</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><call><name>tpl_get_field</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>INITIAL_FIELD_LEN</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <name><name>field</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>acl_myrealloc</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_fmt</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><call><name>tpl_get_field</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>INITIAL_FIELD_LEN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>INITIAL_FIELD_LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <name><name>field</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
                <break>break;</break></block_content></block></if></if_stmt>

            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>acl_myrealloc</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>
        <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_int</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><call><name>tpl_get_field</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>INITIAL_FIELD_LEN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>INITIAL_FIELD_LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>M_INT_TO_STRING</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt> 
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_uint</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><call><name>tpl_get_field</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>  <name>v</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>INITIAL_FIELD_LEN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>INITIAL_FIELD_LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><call><name>M_INT_TO_STRING</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt> 
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_double</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><call><name>tpl_get_field</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <name>INITIAL_FIELD_LEN</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>INITIAL_FIELD_LEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tpl_set_field_from_file</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_fcell_t</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><call><name>tpl_get_field</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>field</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
            <return>return <expr><name>TPL_OPEN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

        <comment type="block">/* Find length of file content */</comment>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rewind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>INITIAL_FIELD_LEN</name> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <name><name>field</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>acl_myrealloc</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name><name>field</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>TPL_READ_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
    
        <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>field</name><operator>-&gt;</operator><name>val</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TPL_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_global</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tpl_set_field</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recursively set in all sections */</comment>
        <expr_stmt><expr><call><name>tpl_set_field_global</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>section</name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_fmt_global</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>

        <expr_stmt><expr><name>len</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>acl_myrealloc</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></while>
    <expr_stmt><expr><call><name>tpl_set_field_global</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_int_global</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tpl_set_field_int</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recursively set in all sections */</comment>
        <expr_stmt><expr><call><name>tpl_set_field_int_global</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>section</name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_uint_global</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tpl_set_field_uint</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recursively set in all sections */</comment>
        <expr_stmt><expr><call><name>tpl_set_field_uint_global</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>section</name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_set_field_double_global</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>tpl_set_field_double</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* Recursively set in all sections */</comment>
        <expr_stmt><expr><call><name>tpl_set_field_double_global</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>section</name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tpl_select_section</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>tpl_get_section</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr>;</expr_stmt>
        <return>return <expr><name>TPL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TPL_SECTION_NOT_FOUND_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tpl_deselect_section</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>!=</operator> <name>tpl</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr>;</expr_stmt>
        <return>return <expr><name>TPL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TPL_NO_SECTION_SELECTED_ERROR</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Set or replace added content in section with supplied value */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>tpl_set_section_ex</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>,
                              <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>val</name></decl></parameter>,
                              <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
                              <parameter><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>existing_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>tpl_get_section</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>section</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>first</name></name> <operator>!=</operator> <name>NULL</name>
            <operator>||</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name></name> <operator>==</operator> <name>NULL</name>
            <operator>||</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name>
            <operator>||</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name>len</name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* Destroy the contents of this section */</comment>
            <expr_stmt><expr><call><name>tpl_release</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>tpl_init</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>

        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>val</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name>existing_node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
             <expr_stmt><expr><name><name>existing_node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</expr_stmt>
             <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>=</operator> <name>existing_node</name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>!=</operator> <name>NULL</name>
                <operator>&amp;&amp;</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name>len</name></expr>)</condition>
            <block>{<block_content>
                <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <if type="elseif">else if <condition>(<expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>val</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>

        <while>while <condition>(<expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
        <block>{<block_content>
            <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>deleted</name> <init>= <expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
            <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>deleted</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>destroy_node</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></while>

        <expr_stmt><expr><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>section</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

        <return>return <expr><name>TPL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>TPL_SECTION_NOT_FOUND_ERROR</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tpl_set_section</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>tpl_set_section_ex</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tpl_set_section_from_file</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TPL_OPEN_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <comment type="block">/* Find length of file content */</comment>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>rewind</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <name>TPL_READ_ERROR</name></expr>;</expr_stmt></block_content></block></if>
    <else>else<block type="pseudo"><block_content>
        <expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>tpl_set_section_ex</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>TPL_OK</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>destroy_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>tpl_append_section</name><parameter_list>(<parameter><decl><type><name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name> <operator>!=</operator> <name>tpl</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>curr_sect</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>curr_node</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>some_node</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>

        <for>for <control>(<init>;</init> <condition><expr><name>curr_sect</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>curr_sect</name> <operator>=</operator> <name><name>curr_sect</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>curr_sect</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
            <block>{<block_content>

                <for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>some_node</name> <operator>=</operator> <name>curr_node</name></expr>;</init> 
                     <condition><expr><name>some_node</name> <operator>!=</operator> <operator>*</operator><name><name>curr_sect</name><operator>-&gt;</operator><name>preceding</name></name></expr>;</condition>
                     <incr><expr><name>some_node</name> <operator>=</operator> <name><name>some_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
                <block>{<block_content>
                    <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>M_NODE_LEN</name><argument_list>(<argument><expr><name>some_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

                <for>for <control>(<init>;</init> 
                     <condition><expr><name>curr_node</name> <operator>!=</operator> <operator>*</operator><name><name>curr_sect</name><operator>-&gt;</operator><name>preceding</name></name></expr>;</condition>
                     <incr><expr><name>curr_node</name> <operator>=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
                <block>{<block_content>
                    <if_stmt><if>if <condition>(<expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
                    <block>{<block_content>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
                    </block_content>}</block></if>
                    <else>else
                    <block>{<block_content>
                        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, 
                                     <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
                                     <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
                    </block_content>}</block></else></if_stmt>
                </block_content>}</block></for>

                <expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

                <comment type="block">/* Cut 'n paste added content chain from section */</comment>
                <expr_stmt><expr><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <name><name>curr_sect</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <name><name>curr_sect</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curr_sect</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>curr_sect</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>curr_sect</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></if></if_stmt>
        </block_content>}</block></for>

        <for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>some_node</name> <operator>=</operator> <name>curr_node</name></expr>;</init>
             <condition><expr><name>some_node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
             <incr><expr><name>some_node</name> <operator>=</operator> <name><name>some_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>M_NODE_LEN</name><argument_list>(<argument><expr><name>some_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></for>


        <expr_stmt><expr><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <call><name>create_node</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>buffer</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name><operator>)</operator><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <operator>&amp;</operator><name><operator>(</operator><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

        <for>for <control>(<init>;</init> <condition><expr><name>curr_node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>curr_node</name> <operator>=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
                             <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
                             <argument><expr><name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>curr_node</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>
        <expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <expr_stmt><expr><operator>*</operator><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_tail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

        <return>return <expr><name>TPL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TPL_NO_SECTION_SELECTED_ERROR</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>tpl_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
        <expr_stmt><expr><name>len</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>val</name></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></else></ternary></expr>;</expr_stmt></block_content></block></for>

    <for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr>;</init> <condition><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
            <expr_stmt><expr><name>len</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></for>
    </block_content>}</block></for>

    <return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>tpl_section_length</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><call><name>tpl_length</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_get_content</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>tpl_tcell_t</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name><name>tpl</name><operator>-&gt;</operator><name>first</name></name></expr></init></decl>;</decl_stmt>
    
    <for>for <control>(<init>;</init> <condition><expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <decl_stmt><decl><type><name>tpl_node_t</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>tpl</name><operator>-&gt;</operator><name>added_head</name></name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Copy part until beginning of section */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>!=</operator> <operator>*</operator><name><name>s</name><operator>-&gt;</operator><name>preceding</name></name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></for>

        <comment type="block">/* Copy content appended in section */</comment>
        <for>for <control>(<init>;</init> <condition><expr><name>an</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>an</name> <operator>=</operator> <name><name>an</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>an</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>an</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>an</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></for>
    </block_content>}</block></for>

    <comment type="block">/* Copy the rest */</comment>
    <for>for <control>(<init>;</init> <condition><expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>n</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>val</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>fval</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>
        </block_content>}</block></else></if_stmt>
    </block_content>}</block></for>
    <expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_get_section_content</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>tpl_get_content</name><argument_list>(<argument><expr><name><name>tpl</name><operator>-&gt;</operator><name>tpl</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>tpl_save_as</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"wb"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>tpl_length</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>content</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>tpl_get_content</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>TPL_WRITE_ERROR</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <return>return <expr><name>TPL_OK</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    <return>return <expr><name>TPL_OPEN_ERROR</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>tpl_write</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>tpl_length</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>content</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>tpl_get_content</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>content</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TPL_WRITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>TPL_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>tpl_http_write</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>tpl_t</name><modifier>*</modifier></type> <name>tpl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>  
    <comment type="block">/* Assumption: the content length can be max a 10 digit number */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>length_digits</name> <init>= <expr><literal type="number">10</literal></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>header_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>TPL_NPH_HTTP_HEADER_START</name></expr></argument>)</argument_list></sizeof>
                   <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TPL_NPH_HTTP_HEADER_END</name></expr></argument>)</argument_list></sizeof>
                   <operator>+</operator> <name>length_digits</name></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>int</name></type> <name>content_len</name> <init>= <expr><call><name>tpl_length</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>tmp_len</name> <init>= <expr><name>content_len</name></expr></init></decl>;</decl_stmt>
    
    <comment type="block">/* Long enough for both the HTTP header and content */</comment>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>response</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>content_len</name> <operator>+</operator> <name>header_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str_p</name> <init>= <expr><name>response</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>str_p</name></expr></argument>, 
                <argument><expr><name>TPL_NPH_HTTP_HEADER_START</name></expr></argument>,
                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TPL_NPH_HTTP_HEADER_START</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>str_p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TPL_NPH_HTTP_HEADER_START</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
    
    <expr_stmt><expr><call><name>M_INT_TO_STRING</name><argument_list>(<argument><expr><name>str_p</name></expr></argument>, <argument><expr><name>length_digits</name></expr></argument>, <argument><expr><name>tmp_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>str_p</name> <operator>+=</operator> <name>length_digits</name></expr>;</expr_stmt>

    <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>memcpy</name><argument_list>(<argument><expr><name>str_p</name></expr></argument>,
                 <argument><expr><name>TPL_NPH_HTTP_HEADER_END</name></expr></argument>,
                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TPL_NPH_HTTP_HEADER_END</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>str_p</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TPL_NPH_HTTP_HEADER_END</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>tpl_get_content</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>str_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>content_len</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>response</name></expr></argument>, <argument><expr><name>content_len</name> <operator>+</operator> <operator>(</operator><name>str_p</name> <operator>-</operator> <name>response</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>response</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>content_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><name>TPL_WRITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

    <return>return <expr><name>TPL_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>tpl_out</name><parameter_list>(<parameter><decl><type><name>tpl_t</name> <modifier>*</modifier></type><name>tpl</name></decl></parameter>, <parameter><decl><type><name>ACL_VSTREAM</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>tpl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>out</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <name>ACL_VSTREAM_OUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>tpl_length</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>acl_mymalloc</name><argument_list>(<argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>tpl_get_content</name><argument_list>(<argument><expr><name>tpl</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_vstream_writen</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_myfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
