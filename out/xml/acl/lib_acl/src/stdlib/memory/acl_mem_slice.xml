<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/acl/lib_acl/src/stdlib/memory/acl_mem_slice.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StdAfx.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ACL_PREPARE_COMPILE</name></cpp:ifndef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_define.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>     <comment type="block">/* for offsetof */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"init/acl_init.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_mem_hook.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_malloc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_mem_slice.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_meter_time.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../private/private_array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"malloc_vars.h"</cpp:file></cpp:include>

<comment type="block">/* xxx: Èç¹ûÏëÒªÊ¹ÓÃ pthread_spinlock_t Ôò²»¿É½« stdlib.h ·ÅÔÚÇ°Ãæ,
 * ·ñÔò±àÒë±¨´í
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ACL_UNIX</name></cpp:ifdef>
<cpp:ifndef># <cpp:directive>ifndef</cpp:directive>  <name>_GNU_SOURCE</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro></cpp:define>
<cpp:endif># <cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include># <cpp:directive>include</cpp:directive> <cpp:file>&lt;pthread.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive>  <expr><call><name>defined</name><argument_list>(<argument><expr><name>ACL_HAS_SPINLOCK</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MINGW</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>pthread_spinlock_t</name></type> <name>mylock_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>pthread_spin_init(&amp;(x)-&gt;lock, PTHREAD_PROCESS_PRIVATE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_DESTROY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>pthread_spin_destroy(&amp;(x)-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_LOCK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>pthread_spin_lock(&amp;(x)-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_UNLOCK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>pthread_spin_unlock(&amp;(x)-&gt;lock)</cpp:value></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../private/thread.h"</cpp:file></cpp:include>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../private/thread.h"</cpp:file></cpp:include>

<typedef>typedef <type><name>acl_pthread_mutex_t</name></type> <name>mylock_t</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>thread_mutex_init(&amp;(x)-&gt;lock, NULL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_DESTROY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>thread_mutex_destroy(&amp;(x)-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_LOCK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>thread_mutex_lock(&amp;(x)-&gt;lock)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUTEX_UNLOCK</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>thread_mutex_unlock(&amp;(x)-&gt;lock)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thread/acl_pthread.h"</cpp:file></cpp:include>

<struct>struct <name>ACL_MEM_SLICE</name> <block>{
	<decl_stmt><decl><type><name>ACL_SLICE_POOL</name> <modifier>*</modifier></type><name>slice_pool</name></decl>;</decl_stmt>	<comment type="block">/* ÄÚ´æÇÐÆ¬³Ø */</comment>
	<decl_stmt><decl><type><name>mylock_t</name></type>  <name>lock</name></decl>;</decl_stmt>			<comment type="block">/* »¥³âËø */</comment>
	<decl_stmt><decl><type><name>ACL_ARRAY</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>		<comment type="block">/* ½Ó¹ÜÆäËüÏß³ÌµÄÊÍ·ÅÄÚ´æµÄ¶ÓÁÐ */</comment>
	<decl_stmt><decl><type><name>acl_pthread_key_t</name></type>  <name>tls_key</name></decl>;</decl_stmt>	<comment type="block">/* Ïß³Ì¾Ö²¿´æ´¢¶ÔÓ¦µÄ¼ü */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>tid</name></decl>;</decl_stmt>		<comment type="block">/* ÓµÓÐ´ËÏß³Ì³Ø¶ÔÏóµÄÏß³ÌIDºÅ */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>  <name>nalloc</name></decl>;</decl_stmt>		<comment type="block">/* µ÷ÓÃÄÚ´æ·ÖÅäµÄ´ÎÊý */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>  <name>nalloc_gc</name></decl>;</decl_stmt>	<comment type="block">/* ·ÖÅä¶àÉÙ´ÎÄÚ´æºó×Ô¶¯µ÷ÓÃÄÚ´æÀ¬»ø»ØÊÕ */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type>  <name>slice_flag</name></decl>;</decl_stmt>	<comment type="block">/* ÄÚ´æÇÐÆ¬´´½¨Ê±µÄ±êÖ¾Î», Èç ACL_SLICE_FLAG_GC2 | ACL_SLICE_FLAG_RTGC_OFF */</comment>
	<decl_stmt><decl><type><name>ACL_ARRAY</name> <modifier>*</modifier></type><name>slice_list</name></decl>;</decl_stmt>		<comment type="block">/* ËùÓÐÏß³ÌµÄÄÚ´æ³ØµÄ¼¯ºÏ */</comment>
	<decl_stmt><decl><type><name>acl_pthread_mutex_t</name> <modifier>*</modifier></type><name>slice_list_lock</name></decl>;</decl_stmt> <comment type="block">/* ²Ù×÷È«¾Ö __mem_slice_list µÄ»¥³âËø */</comment>
	<decl_stmt><decl><type><name>int</name></type>  <name>delay_free</name></decl>;</decl_stmt>		<comment type="block">/* µ±±¾Ïß³ÌÍË³öÊ±£¬ÒòÎª»¹ÓÐÄÚ´æÆ¬±»ÆäËüÏß³ÌÕ¼ÓÃ×Å£¬
					 * ËùÒÔ²»ÄÜÁ¢¼´ÊÍ·Å£¬ÐèÒªÓÉÖ÷Ïß³Ì»òÆäËüÏß³ÌÐ­ÖúÊÍ·Å
					 */</comment>
}</block>;</struct>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_msg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<comment type="block">/*----------------------------------------------------------------------------*/</comment>

<typedef>typedef <type><struct>struct <block>{
	<decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>			<comment type="block">/* µ÷ÓÃÕßÏ£Íû·ÖÅäµÄÄÚ´æ´óÐ¡ */</comment>
	<decl_stmt><decl><type><name>int</name></type>    <name>signature</name></decl>;</decl_stmt>		<comment type="block">/* Ç©Ãû */</comment>
	<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl>;</decl_stmt>	<comment type="block">/* ËùÊôµÄÄÚ´æÇÐÆ¬¶ÔÏó */</comment>
	<union>union <block>{
		<decl_stmt><decl><type><name>ALIGN_TYPE</name></type> <name>align</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>  <name><name>payload</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	}</block> <decl><name>u</name></decl>;</union>
}</block></struct></type> <name>MBLOCK</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGNATURE</name></cpp:macro>       <cpp:value>0xdead</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILLER</name></cpp:macro>          <cpp:value>0x0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_PTR</name><parameter_list>(<parameter><type><name>_ptr</name></type></parameter>, <parameter><type><name>_real_ptr</name></type></parameter>, <parameter><type><name>_len</name></type></parameter>, <parameter><type><name>_fname</name></type></parameter>, <parameter><type><name>_line</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
  if (_ptr == 0) { \
    acl_msg_panic("%s(%d), %s: in %s(%d), null pointer input", \
      __FILE__, __LINE__, __FUNCTION__, _fname, _line); \
  } \
  _real_ptr = (MBLOCK *) ((char *) _ptr - offsetof(MBLOCK, u.payload[0])); \
  if (_real_ptr-&gt;signature != SIGNATURE) { \
    acl_msg_panic("%s(%d), %s: in %s(%d), corrupt or unallocated memory block(%d, 0x%x, 0x%x)", \
      __FILE__, __LINE__, __FUNCTION__, _fname, _line, \
      (int) _real_ptr-&gt;length, _real_ptr-&gt;signature, SIGNATURE); \
  } \
  if ((_len = _real_ptr-&gt;length) &lt; 1) { \
    acl_msg_panic("%s(%d), %s: in %s(%d), corrupt memory block length", \
      __FILE__, __LINE__, __FUNCTION__, _fname, _line); \
  } \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_IN_PTR</name><parameter_list>(<parameter><type><name>_ptr</name></type></parameter>, <parameter><type><name>_real_ptr</name></type></parameter>, <parameter><type><name>_len</name></type></parameter>, <parameter><type><name>_fname</name></type></parameter>, <parameter><type><name>_line</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
    if (_ptr == 0) { \
      acl_msg_panic("%s(%d), %s: in %s(%d), null pointer input", \
        __FILE__, __LINE__, __FUNCTION__, _fname, _line); \
    } \
    _real_ptr = (MBLOCK *) ((char *) _ptr - offsetof(MBLOCK, u.payload[0])); \
    if (_real_ptr-&gt;signature != SIGNATURE) { \
      acl_msg_panic("%s(%d), %s: in %s(%d), corrupt or unallocated memory block(%d, 0x%x, 0x%x)", \
        __FILE__, __LINE__, __FUNCTION__, _fname, _line, \
        (int) _real_ptr-&gt;length, _real_ptr-&gt;signature, SIGNATURE); \
    } \
    _real_ptr-&gt;signature = 0; \
    if ((_len = _real_ptr-&gt;length) &lt; 1) { \
      acl_msg_panic("%s(%d), %s: in %s(%d), corrupt memory block length", \
        __FILE__, __LINE__, __FUNCTION__, _fname, _line); \
    } \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_IN_PTR2</name><parameter_list>(<parameter><type><name>_ptr</name></type></parameter>, <parameter><type><name>_real_ptr</name></type></parameter>, <parameter><type><name>_len</name></type></parameter>, <parameter><type><name>_fname</name></type></parameter>, <parameter><type><name>_line</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
    if (_ptr == 0) { \
      acl_msg_panic("%s(%d), %s: in %s(%d), null pointer input", \
        __FILE__, __LINE__, __FUNCTION__, _fname, _line); \
    } \
    _real_ptr = (MBLOCK *) ((char *) _ptr - offsetof(MBLOCK, u.payload[0])); \
    if (_real_ptr-&gt;signature != SIGNATURE) { \
      acl_msg_panic("%s(%d)(CHECK_IN_PTR2): corrupt or unallocated memory block(%d, 0x%x, 0x%x)", \
        _fname, _line, (int) _real_ptr-&gt;length, _real_ptr-&gt;signature, SIGNATURE); \
    } \
    if ((_len = _real_ptr-&gt;length) &lt; 1) { \
      acl_msg_panic("%s(%d), %s: in %s(%d) corrupt memory block length", \
        __FILE__, __LINE__, __FUNCTION__, _fname, _line); \
    } \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_OUT_PTR</name><parameter_list>(<parameter><type><name>_ptr</name></type></parameter>, <parameter><type><name>_real_ptr</name></type></parameter>, <parameter><type><name>_mem_slice</name></type></parameter>, <parameter><type><name>_len</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ \
  _real_ptr-&gt;signature = SIGNATURE; \
  _real_ptr-&gt;mem_slice = _mem_slice; \
  _real_ptr-&gt;length = _len; \
  _ptr = _real_ptr-&gt;u.payload; \
}</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPACE_FOR</name><parameter_list>(<parameter><type><name>_len</name></type></parameter>)</parameter_list></cpp:macro>  <cpp:value>(offsetof(MBLOCK, u.payload[0]) + _len)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>acl_pthread_key_t</name></type> <name>__mem_slice_key</name></decl>;</decl_stmt> <comment type="line">// = (acl_pthread_key_t) -1;</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>__mem_base</name> <init>= <expr><literal type="number">8</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>__mem_nslice</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>__mem_nalloc_gc</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>__mem_list_init_size</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>__mem_slice_flag</name> <init>= <expr><name>ACL_SLICE_FLAG_GC2</name> <operator>|</operator> <name>ACL_SLICE_FLAG_RTGC_OFF</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ACL_ARRAY</name> <modifier>*</modifier></type><name>__mem_slice_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>acl_pthread_mutex_t</name> <modifier>*</modifier></type><name>__mem_slice_list_lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mem_slice_gc</name><parameter_list>(<parameter><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Ïß³ÌÍË³öÇ°ÐèÒªµ÷ÓÃ´Ëº¯ÊýÊÍ·Å×Ô¼ºµÄÏß³Ì¾Ö²¿ÄÚ´æ´æ´¢³Ø */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mem_slice_free</name><parameter_list>(<parameter><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"mem_slice_free"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): mem_slice null"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ÏÈ»ØÊÕ±¾ÉíÏß³ÌµÄÀ¬»øÄÚ´æÆ¬ */</comment>
	<expr_stmt><expr><call><name>mem_slice_gc</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>n</name> <operator>=</operator> <call><name>acl_slice_pool_used</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): thread(%ld) mem slice busy slices: %d, delay free it"</literal></expr></argument>,
			<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>thread_mutex_lock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>delay_free</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>thread_mutex_unlock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* ¾¡Á¿»ØÊÕÒ»Ð©ÒÑ¾­ÍêÈ«ÊÍ·ÅµÄÄÚ´æ */</comment>
		<expr_stmt><expr><call><name>acl_slice_pool_gc</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): thread(%ld) free mem slice now"</literal></expr></argument>,
			<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>acl_slice_pool_destroy</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>private_array_destroy</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* ½«×ÓÏß³ÌµÄÏß³Ì¾Ö²¿´æ´¢ÄÚ´æ³Ø´ÓÈ«¾ÖÄÚ´æ³Ø¾ä±ú¼¯ºÏÖÐÉ¾³ý */</comment>
		<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>thread_mutex_lock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>private_array_delete_obj</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>thread_mutex_unlock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>acl_default_free</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>__main_mem_slice</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_NO_ATEXIT</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>main_thread_slice_free</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>__main_mem_slice</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>mem_slice_free</name><argument_list>(<argument><expr><name>__main_mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>__main_mem_slice</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_NO_ATEXIT</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>free_global_ctx</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>__mem_slice_list</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>private_array_destroy</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>__mem_slice_list</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>thread_mutex_destroy</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>__mem_slice_list_lock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>slice_key_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>curr_tid</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_pthread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>main_tid</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_main_thread_self</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>curr_tid</name> <operator>==</operator> <name>main_tid</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>__mem_slice_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_NO_ATEXIT</name></cpp:ifndef>
		<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>main_thread_slice_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_pthread_key_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>__mem_slice_key</name></expr></argument>, <argument><expr><operator>(</operator><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name><operator>*</operator></expr></argument>)</argument_list></call><operator>)</operator> <name>mem_slice_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>acl_pthread_once_t</name></type> <name>once_control</name> <init>= <expr><name>ACL_PTHREAD_ONCE_INIT</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice_create</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"mem_slice_create"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>acl_pthread_once</name><argument_list>(<argument><expr><operator>&amp;</operator><name>once_control</name></expr></argument>, <argument><expr><name>slice_key_init</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>__mem_slice_key</name> <operator>==</operator> <operator>(</operator><name>acl_pthread_key_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s(%d): __mem_slice_key(%ld) invalid,"</literal>
			<literal type="string">" call acl_mem_slice_init or acl_mem_slice_set first"</literal></expr></argument>,
			<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>int</name><operator>)</operator> <name>__mem_slice_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mem_slice</name> <operator>=</operator> <call><name>acl_pthread_getspecific</name><argument_list>(<argument><expr><name>__mem_slice_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>mem_slice</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>mem_slice</name> <operator>=</operator> <operator>(</operator><name>ACL_MEM_SLICE</name><operator>*</operator><operator>)</operator>
		<call><name>acl_default_calloc</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ACL_MEM_SLICE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s(%d): can't alloc for mem_slice(%s)"</literal></expr></argument>,
			<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><call><name>acl_last_serror</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name> <operator>=</operator> <call><name>acl_slice_pool_create</name><argument_list>(<argument><expr><name>__mem_base</name></expr></argument>,
			<argument><expr><name>__mem_nslice</name></expr></argument>, <argument><expr><name>__mem_slice_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_pthread_self</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <call><name>private_array_create</name><argument_list>(<argument><expr><name>__mem_list_init_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MUTEX_INIT</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>tls_key</name></name> <operator>=</operator> <name>__mem_slice_key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>nalloc_gc</name></name> <operator>=</operator> <name>__mem_nalloc_gc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_flag</name></name> <operator>=</operator> <name>__mem_slice_flag</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>acl_pthread_setspecific</name><argument_list>(<argument><expr><name>__mem_slice_key</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_pthread_self</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>acl_main_thread_self</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>__main_mem_slice</name> <operator>=</operator> <name>mem_slice</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): thread(%ld) set myown mem_slice(%p)"</literal></expr></argument>,
		<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>mem_slice</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tls_mem_free</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MBLOCK</name> <modifier>*</modifier></type><name>real_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECK_IN_PTR2</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>real_ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>
	<if_stmt><if>if <condition>(<expr><name><name>real_ptr</name><operator>-&gt;</operator><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_pthread_self</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name><name>real_ptr</name><operator>-&gt;</operator><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name> <operator>!=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name></expr>)</condition> <block>{<block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name><name>real_ptr</name><operator>-&gt;</operator><name>mem_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PRIVATE_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>real_ptr</name><operator>-&gt;</operator><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>real_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name><name>real_ptr</name><operator>-&gt;</operator><name>mem_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_slice_pool_free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>real_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>tls_mem_alloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"tls_mem_alloc"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name> <init>= <expr><call><name>acl_pthread_getspecific</name><argument_list>(<argument><expr><name>__mem_slice_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MBLOCK</name> <modifier>*</modifier></type><name>real_ptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Ã¿¸ö×ÓÏß³Ì»ñµÃ×Ô¼ºµÄÏß³Ì¾Ö²¿´æ´¢ÄÚ´æ³Ø */</comment>
		<expr_stmt><expr><name>mem_slice</name> <operator>=</operator> <call><name>mem_slice_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_list</name></name> <operator>=</operator> <name>__mem_slice_list</name></expr>;</expr_stmt>

		<comment type="block">/* ½«×ÓÏß³ÌµÄÏß³Ì¾Ö²¿´æ´¢ÄÚ´æ³ØÖÃÈëÈ«¾ÖÄÚ´æ³Ø¾ä±ú¼¯ºÏÖÐ */</comment>
		<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>thread_mutex_lock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>private_array_push</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>thread_mutex_unlock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name><operator>-&gt;</operator><name>nslice</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
			<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"slice=%p\r\n"</literal></expr></argument>, <argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name><operator>-&gt;</operator><name>slices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><name>real_ptr</name> <operator>=</operator> <operator>(</operator><name>MBLOCK</name> <operator>*</operator><operator>)</operator> <call><name>acl_slice_pool_alloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>,
			<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>, <argument><expr><call><name>SPACE_FOR</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>real_ptr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_msg_error</name><argument_list>(<argument><expr><literal type="string">"%s(%d): malloc: insufficient memory"</literal></expr></argument>,
			<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>nalloc</name></name><operator>++</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>mem_slice</name><operator>-&gt;</operator><name>nalloc</name></name> <operator>==</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>nalloc_gc</name></name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>nalloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mem_slice_gc</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>CHECK_OUT_PTR</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>real_ptr</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>tls_mem_calloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nmemb</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>tls_mem_alloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>nmemb</name> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nmemb</name> <operator>*</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>ptr</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>tls_mem_realloc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>tls_mem_alloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MBLOCK</name> <modifier>*</modifier></type><name>old_real_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>old_len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>buf</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>CHECK_IN_PTR2</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>old_real_ptr</name></expr></argument>, <argument><expr><name>old_len</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><ternary><condition><expr><name>old_len</name> <operator>&gt;</operator> <name>size</name></expr> ?</condition><then> <expr><name>size</name></expr> </then><else>: <expr><name>old_len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>old_real_ptr</name><operator>-&gt;</operator><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name> <operator>!=</operator> <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_pthread_self</name><argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name><name>old_real_ptr</name><operator>-&gt;</operator><name>mem_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PRIVATE_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>old_real_ptr</name><operator>-&gt;</operator><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>old_real_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name><name>old_real_ptr</name><operator>-&gt;</operator><name>mem_slice</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_slice_pool_free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>old_real_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>tls_mem_memdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>tls_mem_alloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_mem_strdup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>tls_mem_alloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>tls_mem_strndup</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>line</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name>size</name> <operator>&gt;</operator> <name>len</name></expr> ?</condition><then> <expr><name>len</name></expr> </then><else>: <expr><name>size</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>tls_mem_alloc</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mem_slice_gc</name><parameter_list>(<parameter><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>   <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* ÊÍ·ÅÓÉÆäËüÏß³Ì½»»¹µÄÄÚ´æÆ¬ */</comment>

	<expr_stmt><expr><call><name>MUTEX_LOCK</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>PRIVATE_ARRAY_POP</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>acl_slice_pool_free</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>MUTEX_UNLOCK</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* ÊµÊ±½øÐÐÀ¬»ø»ØÊÕ? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_flag</name></name> <operator>&amp;</operator> <name>ACL_SLICE_FLAG_RTGC_OFF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_slice_pool_gc</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>acl_mem_slice_gc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name> <init>= <expr><call><name>acl_pthread_getspecific</name><argument_list>(<argument><expr><name>__mem_slice_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mem_slice</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><call><name>mem_slice_gc</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>acl_mem_slice_destroy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name> <init>= <expr><call><name>acl_pthread_getspecific</name><argument_list>(<argument><expr><name>__mem_slice_key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<comment type="block">/* ÊÍ·Å¸ÃÏß³ÌËùÓµÓÐµÄÄÚ´æÇÐÆ¬³Ø¶ÔÏó */</comment>
	<expr_stmt><expr><call><name>mem_slice_free</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_pthread_setspecific</name><argument_list>(<argument><expr><name>__mem_slice_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <call><name>acl_pthread_self</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>acl_main_thread_self</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>__main_mem_slice</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>acl_mem_slice_delay_destroy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"acl_mem_slice_delay_destroy"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>thread_mutex_lock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>private_array_size</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name> <init>= <expr><operator>(</operator><name>ACL_MEM_SLICE</name><operator>*</operator><operator>)</operator>
			<call><name>private_array_index</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>mem_slice</name><operator>-&gt;</operator><name>delay_free</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>acl_slice_pool_used</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): thread(%ld) free mem slice now"</literal></expr></argument>,
				<argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>tid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>acl_slice_pool_destroy</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>private_array_destroy</name><argument_list>(<argument><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>list</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/* ½«×ÓÏß³ÌµÄÏß³Ì¾Ö²¿´æ´¢ÄÚ´æ³Ø´ÓÈ«¾ÖÄÚ´æ³Ø¾ä±ú¼¯ºÏÖÐÉ¾³ý */</comment>
			<expr_stmt><expr><call><name>private_array_delete_obj</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>acl_default_free</name><argument_list>(<argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> <else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>mem_slice_gc</name><argument_list>(<argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>thread_mutex_unlock</name><argument_list>(<argument><expr><name>__mem_slice_list_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>acl_mem_slice_init</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nslice</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>nalloc_gc</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>slice_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"acl_mem_slice_init"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>__mem_slice_key</name> <operator>!=</operator> <operator>(</operator><name>acl_pthread_key_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>acl_msg_error</name><argument_list>(<argument><expr><literal type="string">"%s(%d): has been init"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>__mem_base</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_nslice</name> <operator>=</operator> <name>nslice</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_nalloc_gc</name> <operator>=</operator> <ternary><condition><expr><name>nalloc_gc</name> <operator>&lt;</operator> <literal type="number">10</literal></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><name>nalloc_gc</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_slice_flag</name> <operator>=</operator> <name>slice_flag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_list_init_size</name> <operator>=</operator> <name>nalloc_gc</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>__mem_list_init_size</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>__mem_list_init_size</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>__mem_list_init_size</name> <operator>&gt;</operator> <literal type="number">1000000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>__mem_list_init_size</name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Ö÷Ïß³Ì»ñµÃ×Ô¼ºµÄÏß³Ì¾Ö²¿´æ´¢ÄÚ´æ³Ø */</comment>
	<expr_stmt><expr><name>mem_slice</name> <operator>=</operator> <call><name>mem_slice_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>mem_slice</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s(%d): mem_slice null"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* ´´½¨½ø³Ì¿Õ¼äÄÚÈ«¾ÖµÄÄÚ´æ³Ø¼¯ºÏ¶ÔÏó, Æä´æ´¢ËùÓÐÏß³ÌµÄ´æ´¢ÄÚ´æ³Ø¾ä±ú */</comment>
	<expr_stmt><expr><name>__mem_slice_list</name> <operator>=</operator> <call><name>private_array_create</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_slice_list_lock</name> <operator>=</operator> <call><name>thread_mutex_create</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>private_array_push</name><argument_list>(<argument><expr><name>__mem_slice_list</name></expr></argument>, <argument><expr><name>mem_slice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_list</name></name> <operator>=</operator> <name>__mem_slice_list</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>slice_list_lock</name></name> <operator>=</operator> <name>__mem_slice_list_lock</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>__mem_slice_list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s(%d): __mem_slice_list null"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>__mem_slice_list_lock</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>acl_msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s(%d): __mem_slice_list_lock null"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_NO_ATEXIT</name></cpp:ifndef>
	<expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>free_global_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>mem_slice</name><operator>-&gt;</operator><name>tls_key</name></name>  <operator>=</operator> <name>__mem_slice_key</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>acl_mem_hook</name><argument_list>(<argument><expr><name>tls_mem_alloc</name></expr></argument>,
		<argument><expr><name>tls_mem_calloc</name></expr></argument>,
		<argument><expr><name>tls_mem_realloc</name></expr></argument>,
		<argument><expr><name>tls_mem_strdup</name></expr></argument>,
		<argument><expr><name>tls_mem_strndup</name></expr></argument>,
		<argument><expr><name>tls_mem_memdup</name></expr></argument>,
		<argument><expr><name>tls_mem_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): use ACL_MEM_SLICE, with tls"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>mem_slice</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>acl_mem_slice_set</name><parameter_list>(<parameter><decl><type><name>ACL_MEM_SLICE</name> <modifier>*</modifier></type><name>mem_slice</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"acl_mem_slice_set"</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>__mem_slice_key</name> <operator>!=</operator> <operator>(</operator><name>acl_pthread_key_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>__mem_slice_key</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>tls_key</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_base</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name><operator>-&gt;</operator><name>base</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_nslice</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>slice_pool</name><operator>-&gt;</operator><name>nslice</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_nalloc_gc</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>nalloc_gc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_slice_flag</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>slice_flag</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_slice_list</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>slice_list</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>__mem_slice_list_lock</name> <operator>=</operator> <name><name>mem_slice</name><operator>-&gt;</operator><name>slice_list_lock</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>__mem_list_init_size</name> <operator>=</operator> <name>__mem_nalloc_gc</name> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>__mem_list_init_size</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>__mem_list_init_size</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>__mem_list_init_size</name> <operator>&gt;</operator> <literal type="number">1000000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>__mem_list_init_size</name> <operator>=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>acl_mem_hook</name><argument_list>(<argument><expr><name>tls_mem_alloc</name></expr></argument>,
		<argument><expr><name>tls_mem_calloc</name></expr></argument>,
		<argument><expr><name>tls_mem_realloc</name></expr></argument>,
		<argument><expr><name>tls_mem_strdup</name></expr></argument>,
		<argument><expr><name>tls_mem_strndup</name></expr></argument>,
		<argument><expr><name>tls_mem_memdup</name></expr></argument>,
		<argument><expr><name>tls_mem_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>acl_msg_info</name><argument_list>(<argument><expr><literal type="string">"%s(%d): set ACL_MEM_SLICE, with tls"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function></block_content></block></function>
</unit>
