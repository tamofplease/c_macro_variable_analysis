<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/acl/lib_acl/src/stdlib/common/acl_avl.c"><comment type="block">/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */</comment>
<comment type="block">/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */</comment>


<comment type="block">/*
 * AVL - generic AVL tree implementation for kernel use
 *
 * A complete description of AVL trees can be found in many CS textbooks.
 *
 * Here is a very brief overview. An AVL tree is a binary search tree that is
 * almost perfectly balanced. By "almost" perfectly balanced, we mean that at
 * any given node, the left and right subtrees are allowed to differ in height
 * by at most 1 level.
 *
 * This relaxation from a perfectly balanced binary tree allows doing
 * insertion and deletion relatively efficiently. Searching the tree is
 * still a fast operation, roughly O(log(N)).
 *
 * The key to insertion and deletion is a set of tree maniuplations called
 * rotations, which bring unbalanced subtrees back into the semi-balanced state.
 *
 * This implementation of AVL trees has the following peculiarities:
 *
 *	- The AVL specific data structures are physically embedded as fields
 *	  in the "using" data structures.  To maintain generality the code
 *	  must constantly translate between "avl_node_t *" and containing
 *	  data structure "void *"s by adding/subracting the avl_offset.
 *
 *	- Since the AVL data is always embedded in other structures, there is
 *	  no locking or memory allocation in the AVL routines. This must be
 *	  provided for by the enclosing data structure's semantics. Typically,
 *	  avl_insert()/_add()/_remove()/avl_insert_here() require some kind of
 *	  exclusive write lock. Other operations require a read lock.
 *
 *      - The implementation uses iteration instead of explicit recursion,
 *	  since it is intended to run on limited size kernel stacks. Since
 *	  there is no recursion stack present to move "up" in the tree,
 *	  there is an explicit "parent" link in the avl_node_t.
 *
 *      - The left/right children pointers of a node are in an array.
 *	  In the code, variables (instead of constants) are used to represent
 *	  left and right indices.  The implementation is written as if it only
 *	  dealt with left handed manipulations.  By changing the value assigned
 *	  to "left", the code also works for right handed trees.  The
 *	  following variables/terms are frequently used:
 *
 *		int left;	// 0 when dealing with left children,
 *				// 1 for dealing with right children
 *
 *		int left_heavy;	// -1 when left subtree is taller at some node,
 *				// +1 when right subtree is taller
 *
 *		int right;	// will be the opposite of left (0 or 1)
 *		int right_heavy;// will be the opposite of left_heavy (-1 or 1)
 *
 *		int direction;  // 0 for "&lt;" (ie. left child); 1 for "&gt;" (right)
 *
 *	  Though it is a little more confusing to read the code, the approach
 *	  allows using half as much code (and hence cache footprint) for tree
 *	  manipulations and eliminates many conditional branches.
 *
 *	- The avl_index_t is an opaque "cookie" used to find nodes at or
 *	  adjacent to where a new value would be inserted in the tree. The value
 *	  is a modified "avl_node_t *".  The bottom bit (normally 0 for a
 *	  pointer) is set to indicate if that the new node has a value greater
 *	  than the value of the indicated "avl_node_t *".
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"StdAfx.h"</cpp:file></cpp:include>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ACL_PREPARE_COMPILE</name></cpp:ifndef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_define.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdlib/acl_avl.h"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASSERT</name></cpp:macro>	<cpp:value>acl_assert</cpp:value></cpp:define>

<comment type="block">/*
 * Small arrays to translate between balance (or diff) values and child indeces.
 *
 * Code that deals with binary tree data structures will randomly use
 * left and right children when examining a tree.  C "if()" statements
 * which evaluate randomly suffer from very poor hardware branch prediction.
 * In this code we avoid some of the branch mispredictions by using the
 * following translation arrays. They replace random branches with an
 * additional memory reference. Since the translation arrays are both very
 * small the data should remain efficiently in cache.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>  <name><name>avl_child2balance</name><index>[<expr><literal type="number">2</literal></expr>]</index></name>	<init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type>  <name><name>avl_balance2child</name><index>[]</index></name>	<init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Walk from one node to the previous valued node (ie. an infix walk
 * towards the left). At any given node we do one of 2 things:
 *
 * - If there is a left child, go to it, then to it's rightmost descendant.
 *
 * - otherwise we return thru parent nodes until we've come from a right child.
 *
 * Return Value:
 * NULL - if at the end of the nodes
 * otherwise next node
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>avl_walk</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>void</name>	<modifier>*</modifier></type><name>oldnode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>AVL_DATA2NODE</name><argument_list>(<argument><expr><name>oldnode</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>right</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <name>left</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>was_child</name></decl>;</decl_stmt>


	<comment type="block">/*
	 * nowhere to walk to if tree is empty
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Visit the previous valued node. There are two possibilities:
	 *
	 * If this node has a left child, go down one left, then all
	 * the way right.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name></expr>;</init>
		    <condition><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		    <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></for>
	<comment type="block">/*
	 * Otherwise, return thru left children as far as we can.
	 */</comment>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
			<expr_stmt><expr><name>was_child</name> <operator>=</operator> <call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>was_child</name> <operator>==</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the lowest valued node in a tree or NULL.
 * (leftmost child from root of tree)
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>avl_first</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name></expr>;</init> <condition><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the highest valued node in a tree or NULL.
 * (rightmost child from root of tree)
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>avl_last</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name></expr>;</init> <condition><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Access the node immediately before or after an insertion point.
 *
 * "avl_index_t" is a (avl_node_t *) with the bottom bit indicating a child
 *
 * Return value:
 *	NULL: no node in the given direction
 *	"void *"  of the found tree node
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>avl_nearest</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_index_t</name></type> <name>where</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>child</name> <init>= <expr><call><name>AVL_INDEX2CHILD</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>AVL_INDEX2NODE</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>child</name> <operator>!=</operator> <name>direction</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>data</name><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><call><name>avl_walk</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Search for the node which contains "value".  The algorithm is a
 * simple binary tree search.
 *
 * return value:
 *	NULL: the value is not in the AVL tree
 *		*where (if not NULL)  is set to indicate the insertion point
 *	"void *"  of the found tree node
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>avl_find</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>avl_index_t</name> <modifier>*</modifier></type><name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>child</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name></expr>;</init> <condition><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
	    <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name></expr></incr>)</control> <block>{<block_content>

		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name><name>tree</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>&lt;=</operator> <name>diff</name> <operator>&amp;&amp;</operator> <name>diff</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
			<if_stmt><if>if <condition>(<expr><name>where</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>where</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<return>return <expr><operator>(</operator><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <name><name>avl_balance2child</name><index>[<expr><literal type="number">1</literal> <operator>+</operator> <name>diff</name></expr>]</index></name></expr>;</expr_stmt>

	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>where</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>where</name> <operator>=</operator> <call><name>AVL_MKINDEX</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Perform a rotation to restore balance at the subtree given by depth.
 *
 * This routine is used by both insertion and deletion. The return value
 * indicates:
 *	 0 : subtree did not change height
 *	!0 : subtree was reduced in height
 *
 * The code is written as if handling left rotations, right rotations are
 * symmetric and handled by swapping values of variables right/left[_heavy]
 *
 * On input balance is the "new" balance at "node". This value is either
 * -2 or +2.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>avl_rotation</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>balance</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><operator>!</operator><operator>(</operator><name>balance</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr></init></decl>;</decl_stmt>	<comment type="block">/* when balance = -2, left will be 0 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>right</name> <init>= <expr><literal type="number">1</literal> <operator>-</operator> <name>left</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>left_heavy</name> <init>= <expr><name>balance</name> <operator>&gt;&gt;</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>right_heavy</name> <init>= <expr><operator>-</operator><name>left_heavy</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>cright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>gchild</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>gright</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>gleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>which_child</name> <init>= <expr><call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>child_bal</name> <init>= <expr><call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* BEGIN CSTYLED */</comment>
	<comment type="block">/*
	 * case 1 : node is overly left heavy, the left child is balanced or
	 * also left heavy. This requires the following rotation.
	 *
	 *                   (node bal:-2)
	 *                    /           \
	 *                   /             \
	 *              (child bal:0 or -1)
	 *              /    \
	 *             /      \
	 *                     cright
	 *
	 * becomes:
	 *
	 *              (child bal:1 or 0)
	 *              /        \
	 *             /          \
	 *                        (node bal:-1 or 0)
	 *                         /     \
	 *                        /       \
	 *                     cright
	 *
	 * we detect this situation by noting that child's balance is not
	 * right_heavy.
	 */</comment>
	<comment type="block">/* END CSTYLED */</comment>
	<if_stmt><if>if <condition>(<expr><name>child_bal</name> <operator>!=</operator> <name>right_heavy</name></expr>)</condition> <block>{<block_content>

		<comment type="block">/*
		 * compute new balance of nodes
		 *
		 * If child used to be left heavy (now balanced) we reduced
		 * the height of this sub-tree -- used in "return...;" below
		 */</comment>
		<expr_stmt><expr><name>child_bal</name> <operator>+=</operator> <name>right_heavy</name></expr>;</expr_stmt> <comment type="block">/* adjust towards right */</comment>

		<comment type="block">/*
		 * move "cright" to be node's left child
		 */</comment>
		<expr_stmt><expr><name>cright</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name> <operator>=</operator> <name>cright</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cright</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>cright</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>cright</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * move node to be child's right child
		 */</comment>
		<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>-</operator><name>child_bal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * update the pointer into this subtree
		 */</comment>
		<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>child_bal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>which_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<return>return <expr><operator>(</operator><name>child_bal</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* BEGIN CSTYLED */</comment>
	<comment type="block">/*
	 * case 2 : When node is left heavy, but child is right heavy we use
	 * a different rotation.
	 *
	 *                   (node b:-2)
	 *                    /   \
	 *                   /     \
	 *                  /       \
	 *             (child b:+1)
	 *              /     \
	 *             /       \
	 *                   (gchild b: != 0)
	 *                     /  \
	 *                    /    \
	 *                 gleft   gright
	 *
	 * becomes:
	 *
	 *              (gchild b:0)
	 *              /       \
	 *             /         \
	 *            /           \
	 *        (child b:?)   (node b:?)
	 *         /  \          /   \
	 *        /    \        /     \
	 *            gleft   gright
	 *
	 * computing the new balances is more complicated. As an example:
	 *	 if gchild was right_heavy, then child is now left heavy
	 *		else it is balanced
	 */</comment>
	<comment type="block">/* END CSTYLED */</comment>
	<expr_stmt><expr><name>gchild</name> <operator>=</operator> <name><name>child</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>gleft</name> <operator>=</operator> <name><name>gchild</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>gright</name> <operator>=</operator> <name><name>gchild</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * move gright to left child of node and
	 *
	 * move gleft to right child of node
	 */</comment>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name> <operator>=</operator> <name>gright</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gright</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>gright</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>gright</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name> <operator>=</operator> <name>gleft</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>gleft</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>gleft</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>gleft</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * move child to left child of gchild and
	 *
	 * move node to right child of gchild and
	 *
	 * fixup parent of all this to point to gchild
	 */</comment>
	<expr_stmt><expr><name>balance</name> <operator>=</operator> <call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>gchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gchild</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>balance</name> <operator>==</operator> <name>right_heavy</name></expr> ?</condition><then> <expr><name>left_heavy</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>gchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gchild</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name>balance</name> <operator>==</operator> <name>left_heavy</name></expr> ?</condition><then> <expr><name>right_heavy</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>gchild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>gchild</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>gchild</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>gchild</name></expr></argument>, <argument><expr><name>which_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name> <operator>=</operator> <name>gchild</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>gchild</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><operator>(</operator><literal type="number">1</literal><operator>)</operator></expr>;</return>	<comment type="block">/* the new tree is always shorter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Insert a new node into an AVL tree at the specified (from avl_find()) place.
 *
 * Newly inserted nodes are always leaf nodes in the tree, since avl_find()
 * searches out to the leaf positions.  The avl_index_t indicates the node
 * which will be the parent of the new node.
 *
 * After the node is inserted, a single rotation further up the tree may
 * be necessary to maintain an acceptable AVL balance.
 */</comment>
<function><type><name>void</name></type>
<name>avl_insert</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_data</name></decl></parameter>, <parameter><decl><type><name>avl_index_t</name></type> <name>where</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>parent</name> <init>= <expr><call><name>AVL_INDEX2NODE</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>old_balance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>new_balance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>which_child</name> <init>= <expr><call><name>AVL_INDEX2CHILD</name><argument_list>(<argument><expr><name>where</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_LP64</name></cpp:ifdef>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>new_data</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>AVL_DATA2NODE</name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, add the node to the tree at the indicated position.
	 */</comment>
	<expr_stmt><expr><operator>++</operator><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>which_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/*
	 * Now, back up the tree modifying the balance of all nodes above the
	 * insertion point. If we get to a highly unbalanced ancestor, we
	 * need to do a rotation.  If we back out of the tree we are done.
	 * If we brought any subtree into perfect balance (0), we are also done.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Compute the new balance
		 */</comment>
		<expr_stmt><expr><name>old_balance</name> <operator>=</operator> <call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_balance</name> <operator>=</operator> <name>old_balance</name> <operator>+</operator> <name><name>avl_child2balance</name><index>[<expr><name>which_child</name></expr>]</index></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we introduced equal balance, then we are done immediately
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_balance</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If both old and new are not zero we went
		 * from -1 to -2 balance, do a rotation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_balance</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_balance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>which_child</name> <operator>=</operator> <call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * perform a rotation to fix the tree and return
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>avl_rotation</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_balance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert "new_data" in "tree" in the given "direction" either after or
 * before (AVL_AFTER, AVL_BEFORE) the data "here".
 *
 * Insertions can only be done at empty leaf points in the tree, therefore
 * if the given child of the node is already present we move to either
 * the AVL_PREV or AVL_NEXT and reverse the insertion direction. Since
 * every other node in the tree is a leaf, this always works.
 *
 * To help developers using this interface, we assert that the new node
 * is correctly ordered at every step of the way in DEBUG kernels.
 */</comment>
<function><type><name>void</name></type>
<name>avl_insert_here</name><parameter_list>(
	<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>,
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_data</name></decl></parameter>,
	<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>here</name></decl></parameter>,
	<parameter><decl><type><name>int</name></type> <name>direction</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>child</name> <init>= <expr><name>direction</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* rely on AVL_BEFORE == 0, AVL_AFTER == 1 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> <name>diff</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>new_data</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>here</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>direction</name> <operator>==</operator> <name>AVL_BEFORE</name> <operator>||</operator> <name>direction</name> <operator>==</operator> <name>AVL_AFTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If corresponding child of node is not NULL, go to the neighboring
	 * node and reverse the insertion direction.
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>AVL_DATA2NODE</name><argument_list>(<argument><expr><name>here</name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name><name>tree</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>new_data</name></expr></argument>, <argument><expr><name>here</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>&lt;=</operator> <name>diff</name> <operator>&amp;&amp;</operator> <name>diff</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>diff</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><ternary><condition><expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>child</name> <operator>==</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>child</name> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name>child</name></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name><name>tree</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>new_data</name></expr></argument>,
			    <argument><expr><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>&lt;=</operator> <name>diff</name> <operator>&amp;&amp;</operator> <name>diff</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>diff</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><ternary><condition><expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>child</name> <operator>==</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>child</name> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></while>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name><name>tree</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>new_data</name></expr></argument>,
		    <argument><expr><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal> <operator>&lt;=</operator> <name>diff</name> <operator>&amp;&amp;</operator> <name>diff</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>diff</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><ternary><condition><expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>child</name> <operator>==</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>child</name> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>avl_insert</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>new_data</name></expr></argument>, <argument><expr><call><name>AVL_MKINDEX</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new node to an AVL tree.
 */</comment>
<function><type><name>void</name></type>
<name>avl_add</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>new_node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_index_t</name></type> <name>where</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is unfortunate.  We want to call panic() here, even for
	 * non-DEBUG kernels.  In userland, however, we can't depend on anything
	 * in libc or else the rtld build process gets confused.  So, all we can
	 * do in userland is resort to a normal ASSERT().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>avl_find</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>where</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_KERNEL</name></cpp:ifdef>
		<expr_stmt><expr><call><name>panic</name><argument_list>(<argument><expr><literal type="string">"avl_find() succeeded inside avl_add()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>avl_insert</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>where</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete a node from the AVL tree.  Deletion is similar to insertion, but
 * with 2 complications.
 *
 * First, we may be deleting an interior node. Consider the following subtree:
 *
 *     d           c            c
 *    / \         / \          / \
 *   b   e       b   e        b   e
 *  / \	        / \          /
 * a   c       a            a
 *
 * When we are deleting node (d), we find and bring up an adjacent valued leaf
 * node, say (c), to take the interior node's place. In the code this is
 * handled by temporarily swapping (d) and (c) in the tree and then using
 * common code to delete (d) from the leaf position.
 *
 * Secondly, an interior deletion from a deep tree may require more than one
 * rotation to fix the balance. This is handled by moving up the tree through
 * parents and applying rotations as needed. The return value from
 * avl_rotation() is used to detect when a subtree did not change overall
 * height due to a rotation.
 */</comment>
<function><type><name>void</name></type>
<name>avl_remove</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>delete</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name></type> <name>tmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>old_balance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>new_balance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>which_child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>delete</name> <operator>=</operator> <call><name>AVL_DATA2NODE</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Deletion is easiest with a node that has at most 1 child.
	 * We swap a node with 2 children with a sequentially valued
	 * neighbor node. That node will have at most 1 child. Note this
	 * has no effect on the ordering of the remaining nodes.
	 *
	 * As an optimization, we choose the greater neighbor if the tree
	 * is right heavy, otherwise the left neighbor. This reduces the
	 * number of rotations needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

		<comment type="block">/*
		 * choose node to swap from whichever side is taller
		 */</comment>
		<expr_stmt><expr><name>old_balance</name> <operator>=</operator> <call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>left</name> <operator>=</operator> <name><name>avl_balance2child</name><index>[<expr><name>old_balance</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>right</name> <operator>=</operator> <literal type="number">1</literal> <operator>-</operator> <name>left</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * get to the previous value'd node
		 * (down 1 left, as far as possible right)
		 */</comment>
		<for>for <control>(<init><expr><name>node</name> <operator>=</operator> <name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name></expr>;</init>
		    <condition><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		    <incr><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name></expr></incr>)</control><block type="pseudo"><block_content>
			<empty_stmt>;</empty_stmt></block_content></block></for>

		<comment type="block">/*
		 * create a temp placeholder for 'node'
		 * move 'node' to delete's spot in the tree
		 */</comment>
		<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>*</operator><name>node</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>node</name> <operator>=</operator> <operator>*</operator><name>delete</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>left</name></expr>]</index></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>right</name></expr>]</index></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Put tmp where node used to be (just temporary).
		 * It always has a parent and at most 1 child.
		 */</comment>
		<expr_stmt><expr><name>delete</name> <operator>=</operator> <operator>&amp;</operator><name>tmp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>delete</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name>delete</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>which_child</name> <operator>=</operator> <operator>(</operator><name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name></expr></argument>, <argument><expr><name>delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * Here we know "delete" is at least partially a leaf node. It can
	 * be easily removed from the tree.
	 */</comment>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>--</operator><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>which_child</name> <operator>=</operator> <call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>delete</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Connect parent directly to node (leaving out delete).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_SETPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AVL_SETCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>which_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>which_child</name></expr>]</index></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>


	<comment type="block">/*
	 * Since the subtree is now shorter, begin adjusting parent balances
	 * and performing any needed rotations.
	 */</comment>
	<do>do <block>{<block_content>

		<comment type="block">/*
		 * Move up the tree and adjust the balance
		 *
		 * Capture the parent and which_child values for the next
		 * iteration before any rotations occur.
		 */</comment>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>old_balance</name> <operator>=</operator> <call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_balance</name> <operator>=</operator> <name>old_balance</name> <operator>-</operator> <name><name>avl_child2balance</name><index>[<expr><name>which_child</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>which_child</name> <operator>=</operator> <call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If a node was in perfect balance but isn't anymore then
		 * we can stop, since the height didn't change above this point
		 * due to a deletion.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>old_balance</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_balance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the new balance is zero, we don't need to rotate
		 * else
		 * need a rotation to fix the balance.
		 * If the rotation doesn't change the height
		 * of the sub-tree we have finished adjusting.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_balance</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AVL_SETBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_balance</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>avl_rotation</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>new_balance</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>parent</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>AVL_REINSERT</name><parameter_list>(<parameter><type><name>tree</name></type></parameter>, <parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro>		\
	<cpp:value>avl_remove((tree), (obj));	\
	avl_add((tree), (obj))</cpp:value></cpp:define>

<function><type><name>acl_boolean_t</name></type>
<name>avl_update_lt</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>neighbor</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>neighbor</name> <operator>=</operator> <call><name>AVL_NEXT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><call><name><name>t</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <call><name>AVL_PREV</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>neighbor</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>t</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_REINSERT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>B_TRUE</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>B_FALSE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>acl_boolean_t</name></type>
<name>avl_update_gt</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>neighbor</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>neighbor</name> <operator>=</operator> <call><name>AVL_PREV</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>||</operator>
	    <operator>(</operator><call><name><name>t</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <call><name>AVL_NEXT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>neighbor</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>t</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_REINSERT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>B_TRUE</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>B_FALSE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>acl_boolean_t</name></type>
<name>avl_update</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>t</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>neighbor</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <call><name>AVL_PREV</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>neighbor</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>t</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_REINSERT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>B_TRUE</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>neighbor</name> <operator>=</operator> <call><name>AVL_NEXT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>neighbor</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name><name>t</name><operator>-&gt;</operator><name>avl_compar</name></name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>neighbor</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>AVL_REINSERT</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>(</operator><name>B_TRUE</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>B_FALSE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * initialize a new AVL tree
 */</comment>
<function><type><name>void</name></type>
<name>avl_create</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>compar</name>) <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,
    <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>compar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;=</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>avl_node_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>_LP64</name></cpp:ifdef>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><operator>(</operator><name>offset</name> <operator>&amp;</operator> <literal type="number">0x7</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_compar</name></name> <operator>=</operator> <name>compar</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Delete a tree.
 */</comment>
<comment type="block">/* ARGSUSED */</comment>
<function><type><name>void</name></type>
<name>avl_destroy</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier><name>tree</name></type> <name>acl_unused</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Return the number of nodes in an AVL tree.
 */</comment>
<function><type><name>ulong_t</name></type>
<name>avl_numnodes</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><name>acl_boolean_t</name></type>
<name>avl_is_empty</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive>	<cpp:macro><name>CHILDBIT</name></cpp:macro>	<cpp:value>(1L)</cpp:value></cpp:define>

<comment type="block">/*
 * Post-order tree walk used to visit all tree nodes and destroy the tree
 * in post order. This is used for destroying a tree w/o paying any cost
 * for rebalancing it.
 *
 * example:
 *
 *	void *cookie = NULL;
 *	my_data_t *node;
 *
 *	while ((node = avl_destroy_nodes(tree, &amp;cookie)) != NULL)
 *		free(node);
 *	avl_destroy(tree);
 *
 * The cookie is really an avl_node_t to the current node's parent and
 * an indication of which child you looked at last.
 *
 * On input, a cookie value of CHILDBIT indicates the tree is done.
 */</comment>
<function><type><name>void</name> <modifier>*</modifier></type>
<name>avl_destroy_nodes</name><parameter_list>(<parameter><decl><type><name>avl_tree_t</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>cookie</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>avl_node_t</name>	<modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avl_node_t</name>	<modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>child</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>		<modifier>*</modifier></type><name>first</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>off</name> <init>= <expr><name><name>tree</name><operator>-&gt;</operator><name>avl_offset</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initial calls go to the first node or it's right descendant.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cookie</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>first</name> <operator>=</operator> <call><name>avl_first</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * deal with an empty tree
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>first</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>cookie</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>CHILDBIT</name></expr>;</expr_stmt>
			<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>AVL_DATA2NODE</name><argument_list>(<argument><expr><name>first</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>check_right_side</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If there is no parent to return to we are done.
	 */</comment>
	<expr_stmt><expr><name>parent</name> <operator>=</operator> <operator>(</operator><name>avl_node_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>cookie</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>CHILDBIT</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><operator>(</operator><name>NULL</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove the child pointer we just visited from the parent and tree.
	 */</comment>
	<expr_stmt><expr><name>child</name> <operator>=</operator> <operator>(</operator><name>uintptr_t</name><operator>)</operator><operator>(</operator><operator>*</operator><name>cookie</name><operator>)</operator> <operator>&amp;</operator> <name>CHILDBIT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><name>child</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>--</operator><name><name>tree</name><operator>-&gt;</operator><name>avl_numnodes</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we just did a right child or there isn't one, go up to parent.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>AVL_XPARENT</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>done</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do parent's right child, then leftmost descendent.
	 */</comment>
	<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>parent</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * If here, we moved to a left child. It may have one
	 * child on the right (when balance == +1).
	 */</comment>
<label><name>check_right_side</name>:</label>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		    <name><name>node</name><operator>-&gt;</operator><name>avl_child</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><call><name>AVL_XBALANCE</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<label><name>done</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cookie</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>CHILDBIT</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ASSERT</name><argument_list>(<argument><expr><name>node</name> <operator>==</operator> <name><name>tree</name><operator>-&gt;</operator><name>avl_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cookie</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>uintptr_t</name><operator>)</operator><name>parent</name> <operator>|</operator> <call><name>AVL_XCHILD</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><operator>(</operator><call><name>AVL_NODE2DATA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>
</unit>
