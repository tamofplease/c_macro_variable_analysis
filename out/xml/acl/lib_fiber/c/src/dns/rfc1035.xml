<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/builded_projects/acl/lib_fiber/c/src/dns/rfc1035.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stdafx.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive>	<name>SYS_UNIX</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/socket.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;netinet/in.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;arpa/inet.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYS_WIN</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> <name>comment</name><name>(</name><name>lib</name><name>,</name> <cpp:literal>"Iphlpapi.lib"</cpp:literal><name>)</name></cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/strops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/msg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/argv.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rfc1035.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RFC1035_MAXLABELSZ</name></cpp:macro>	<cpp:value>63</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RFC1035_UNPACK_ERROR</name></cpp:macro>	<cpp:value>15</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RFC1035_UNPACK_DEBUG</name></cpp:macro>  <cpp:value>msg_error("unpack error at %s:%d", __FILE__,__LINE__)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RFC1035_UNPACK_DEBUG</name></cpp:macro>  <cpp:value>(void)0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block" format="doxygen">/**
 * rfc1035_header_pack()
 *
 * Packs a RFC1035_header structure into a buffer.
 * Returns number of octets packed (should always be 12)
 */</comment>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>rfc1035_header_pack</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>RFC1035_MESSAGE</name> <modifier>*</modifier></type> <name>hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_header_pack"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>t</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: sz(%d) &lt; 12"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>qr</name></name> <operator>&lt;&lt;</operator> <literal type="number">15</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>opcode</name></name> <operator>&lt;&lt;</operator> <literal type="number">11</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>aa</name></name> <operator>&lt;&lt;</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>tc</name></name> <operator>&lt;&lt;</operator> <literal type="number">9</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>rd</name></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>ra</name></name> <operator>&lt;&lt;</operator> <literal type="number">7</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>t</name> <operator>|=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>rcode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>qdcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>ancount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>nscount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>arcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>off</name> <operator>!=</operator> <literal type="number">12</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: off(%d) != 12"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>off</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * rfc1035_label_pack()
 *
 * Packs a label into a buffer.  The format of
 * a label is one octet specifying the number of character
 * bytes to follow.  Labels must be smaller than 64 octets.
 * Returns number of octets packed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rfc1035_label_pack</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>label</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_label_pack"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name>label</name></expr> ?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>label</name></expr>)</condition> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>label</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: '.' exist in label(%s)"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>RFC1035_MAXLABELSZ</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name>RFC1035_MAXLABELSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: sz(%d) &lt; len(%d) + 1"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>buf</name> <operator>+</operator> <name>off</name><operator>)</operator> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>off</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * rfc1035_name_pack()
 *
 * Packs a name into a buffer.  Names are packed as a
 * sequence of labels, terminated with NULL label.
 * Note message compression is not supported here.
 * Returns number of octets packed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rfc1035_name_pack</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_name_pack"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>copy</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SYS_WIN</name></cpp:ifdef>
	<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>_strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>copy</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * NOTE: use of strtok here makes names like foo....com valid.
	 */</comment>
	<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>copy</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <call><name>mystrtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>t</name></expr>;</condition> <incr><expr><name>t</name> <operator>=</operator> <call><name>mystrtok</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
		<expr_stmt><expr><name>off</name> <operator>+=</operator> <call><name>rfc1035_label_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>sz</name> <operator>-</operator> <name>off</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <call><name>rfc1035_label_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>sz</name> <operator>-</operator> <name>off</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: off(%d) &gt; sz(%d)"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>off</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * rfc1035_question_pack()
 *
 * Packs a QUESTION section of a message.
 * Returns number of octets packed.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rfc1035_question_pack</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>tclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_question_pack"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>s</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>off</name> <operator>+=</operator> <call><name>rfc1035_name_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>sz</name> <operator>-</operator> <name>off</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>tclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>off</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_error</name><argument_list>(<argument><expr><literal type="string">"%s: off(%d) &gt; sz(%d)"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>off</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * rfc1035_name_unpack()
 *
 * Unpacks a Name in a message buffer into a char*.
 * Note 'buf' points to the beginning of the whole message,
 * 'off' points to the spot where the Name begins, and 'sz'
 * is the size of the whole message.  'name' must be allocated
 * by the caller.
 *
 * Supports the RFC1035 message compression through recursion.
 *
 * Updates the new buffer offset.
 *
 * Returns 0 (success) or 1 (error)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rfc1035_name_unpack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>off</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>short</name> <modifier>*</modifier></type><name>rdlength</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>ns</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rdepth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_name_unpack"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ns</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_error</name><argument_list>(<argument><expr><literal type="string">"%s: ns(%d) &lt;= 0"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><name>RFC1035_UNPACK_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<do>do <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>off</name> <operator>&gt;=</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><call><name>msg_error</name><argument_list>(<argument><expr><literal type="string">"%s: *off(%d) &gt;= sz(%d)"</literal></expr></argument>,
				<argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><name>RFC1035_UNPACK_ERROR</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>buf</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>off</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">191</literal></expr>)</condition> <block>{<block_content>
			<comment type="block">/* blasted compression */</comment>
			<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>s</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> <name>ptr</name></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>rdepth</name> <operator>&gt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>	<comment type="block">/* infinite pointer loop */</comment>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>off</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>ntohs</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
			<comment type="block">/* Sanity check */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>&gt;=</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>s</name> <operator>&amp;</operator> <literal type="number">0x3FFF</literal></expr>;</expr_stmt>
			<comment type="block">/* Make sure the pointer is inside this message */</comment>
			<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><call><name>rfc1035_name_unpack</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>rdlength</name></expr></argument>,
				<argument><expr><name>name</name> <operator>+</operator> <name>no</name></expr></argument>, <argument><expr><name>ns</name> <operator>-</operator> <name>no</name></expr></argument>, <argument><expr><name>rdepth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>RFC1035_MAXLABELSZ</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/*
			 * "(The 10 and 01 combinations are reserved for future use.)"
			 */</comment>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if> <else>else <block>{<block_content>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>c</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <operator>(</operator><name>ns</name> <operator>-</operator> <name>no</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content> <comment type="block">/* label won't fit */</comment>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+</operator> <name>len</name> <operator>&gt;=</operator> <name>sz</name></expr>)</condition>	<block>{<block_content> <comment type="block">/* message is too short */</comment>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>no</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>off</name><operator>)</operator></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>off</name><operator>)</operator> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>no</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>len</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>name</name> <operator>+</operator> <operator>(</operator><name>no</name><operator>++</operator><operator>)</operator><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>rdlength</name></expr>)</condition> <block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>rdlength</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>no</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ns</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>no</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name>name</name> <operator>+</operator> <name>no</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<comment type="block">/* make sure we didn't allow someone to overflow the name buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>no</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>ns</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_error</name><argument_list>(<argument><expr><literal type="string">"%s: no(%d) &gt; ns(%d)"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>no</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><name>RFC1035_UNPACK_ERROR</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rfc1035_strerror</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<struct>struct <name>__ERRMSG</name><block>{
		<decl_stmt><decl><type><name>int</name></type>   <name>errnum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>
	}</block>;</struct>
	<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>__ERRMSG</name></name></type> <name><name>errmsg</name><index>[]</index></name> <init>= <expr><block>{
		<expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"No error condition"</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">1</literal></expr>, <expr><literal type="string">"Format Error: The name server was unable to "</literal>
			 <literal type="string">"interpret the query."</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">2</literal></expr>, <expr><literal type="string">"Server Failure: The name server was "</literal>
			 <literal type="string">"unable to process this query."</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">3</literal></expr>, <expr><literal type="string">"Name Error: The domain name does not exist."</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">4</literal></expr>, <expr><literal type="string">"Not Implemented: The name server does "</literal>
				<literal type="string">"not support the requested kind of query."</literal></expr> }</block></expr>,
		<expr><block>{ <expr><literal type="number">5</literal></expr>, <expr><literal type="string">"Refused: The name server refuses to "</literal>
				<literal type="string">"perform the specified operation."</literal></expr> }</block></expr>,
		<expr><block>{ <expr><name>RFC1035_UNPACK_ERROR</name></expr>, <expr><literal type="string">"The DNS reply message is corrupt or could "</literal>
			<literal type="string">"not be safely parsed."</literal></expr> }</block></expr>,
		<expr><block>{ <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NULL</name></expr> }</block></expr>,
	}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unknown</name> <init>= <expr><literal type="string">"Unknown Error"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>   <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>errmsg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>msg</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>errmsg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>errnum</name> <operator>==</operator> <operator>-</operator><name>errnum</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><operator>(</operator><name><name>errmsg</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>msg</name><operator>)</operator></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>unknown</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rfc1035_set_errno</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>rfc1035_query_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RFC1035_QUERY</name> <modifier>*</modifier></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RFC1035_QUERY</name> <modifier>*</modifier></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>la</name></decl>, <decl><type ref="prev"/><name>lb</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>qtype</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>qtype</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>qclass</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>qclass</name></name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>la</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lb</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>la</name> <operator>!=</operator> <name>lb</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* Trim root label(s) */</comment>
		<while>while <condition>(<expr><name>la</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>la</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>la</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<while>while <condition>(<expr><name>lb</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>lb</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>lb</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>la</name> <operator>!=</operator> <name>lb</name></expr>)</condition> <block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>strncasecmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>la</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * rfc1035_rr_pack()
 *
 * Unpacks a RFC1035 Resource Record into 'RR' from a message buffer.
 * The caller must free RR-&gt;rdata!
 *
 * Updates the new message buffer offset.
 *
 * Returns &gt; 0 (success) or 0 (error)
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>rfc1035_rr_pack</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RFC1035_RR</name> <modifier>*</modifier></type><name>rr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_rr_pack"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>off_saved</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>rfc1035_name_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>rr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>rr</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>rr</name><operator>-&gt;</operator><name>tclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument> ,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>rr</name><operator>-&gt;</operator><name>ttl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument> ,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>rr</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>
	<case>case <expr><name>RFC1035_TYPE_PTR</name></expr>:</case>
	<case>case <expr><name>RFC1035_TYPE_NS</name></expr>:</case>
	<case>case <expr><name>RFC1035_TYPE_CNAME</name></expr>:</case>
	<case>case <expr><name>RFC1035_TYPE_TXT</name></expr>:</case>
		<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>rr</name><operator>-&gt;</operator><name>rdata</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>RFC1035_MAXHOSTNAMESZ</name></expr>)</condition> <block>{<block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>off_saved</name> <operator>=</operator> <name>off</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name> <operator>+=</operator> <call><name>rfc1035_name_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>rr</name><operator>-&gt;</operator><name>rdata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <name>off</name> <operator>-</operator> <name>off_saved</name> <operator>-</operator> <operator>(</operator><name>unsigned</name> <name>short</name><operator>)</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off_saved</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument> ,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<break>break;</break>
	<default>default:</default>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>htons</name><argument_list>(<argument><expr><name><name>rr</name><operator>-&gt;</operator><name>rdlength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument> ,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>off</name></expr></argument>, <argument><expr><name><name>rr</name><operator>-&gt;</operator><name>rdata</name></name></expr></argument>, <argument><expr><name><name>rr</name><operator>-&gt;</operator><name>rdlength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>off</name> <operator>+=</operator> <name><name>rr</name><operator>-&gt;</operator><name>rdlength</name></name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name><operator>)</operator> <name>off</name> <operator>&gt;</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: off(%d) &gt; sz(%d)"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>off</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>rfc1035_build_query</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qid</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qtype</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qclass</name></decl></parameter>,
	<parameter><decl><type><name>RFC1035_QUERY</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"rfc1035_build_query"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RFC1035_MESSAGE</name></type> <name>h</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">512</literal></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_error</name><argument_list>(<argument><expr><literal type="string">"%s: sz(%d) &lt; 512, too small"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>.</operator><name>id</name></name> <operator>=</operator> <name>qid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>.</operator><name>qr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>.</operator><name>rd</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>h</name><operator>.</operator><name>opcode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* QUERY */</comment>
	<expr_stmt><expr><name><name>h</name><operator>.</operator><name>qdcount</name></name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>rfc1035_header_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>-</operator> <name>offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>+=</operator> <call><name>rfc1035_question_pack</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>sz</name> <operator>-</operator> <name>offset</name></expr></argument>,
			<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>qtype</name></expr></argument>, <argument><expr><name>qclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>query</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>qtype</name></name>  <operator>=</operator> <name>qtype</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>qclass</name></name> <operator>=</operator> <name>qclass</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SAFE_STRNCPY</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name>sz</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>msg_fatal</name><argument_list>(<argument><expr><literal type="string">"%s: offset(%d) &gt; sz(%d)"</literal></expr></argument>, <argument><expr><name>myname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>offset</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>rfc1035_build_query4a</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qid</name></decl></parameter>, <parameter><decl><type><name>RFC1035_QUERY</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>rfc1035_build_query</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>qid</name></expr></argument>, <argument><expr><name>RFC1035_TYPE_A</name></expr></argument>,
			 <argument><expr><name>RFC1035_CLASS_IN</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>rfc1035_build_query4aaaa</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qid</name></decl></parameter>, <parameter><decl><type><name>RFC1035_QUERY</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>rfc1035_build_query</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>qid</name></expr></argument>, <argument><expr><name>RFC1035_TYPE_AAAA</name></expr></argument>,
			<argument><expr><name>RFC1035_CLASS_IN</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>rfc1035_build_query4mx</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>,
	<parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qid</name></decl></parameter>, <parameter><decl><type><name>RFC1035_QUERY</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>rfc1035_build_query</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name>qid</name></expr></argument>, <argument><expr><name>RFC1035_TYPE_MX</name></expr></argument>,
			<argument><expr><name>RFC1035_CLASS_IN</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>rfc1035_build_query4ptr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>in_addr</name></name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
	<parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>short</name></type> <name>qid</name></decl></parameter>, <parameter><decl><type><name>RFC1035_QUERY</name> <modifier>*</modifier></type> <name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>myname</name> <init>= <expr><literal type="string">"RFC1035BuildPTRQuery"</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RFC1035_MESSAGE</name></type> <name>h</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>rev</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name><name>addr</name><operator>.</operator><name>s_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SYS_WIN</name></cpp:ifdef>
	<macro><name>_snprintf</name><argument_list>(<argument>rev</argument>, <argument><literal type="number">32</literal></argument>, <argument><literal type="string">"%u.%u.%u.%u.in-addr.arpa."</literal></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<argument>snprintf(rev, <literal type="number">32</literal>, <literal type="string">"%u.%u.%u.%u.in-addr.arpa."</literal>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		i &amp; <literal type="number">255</literal>, (i &gt;&gt; <literal type="number">8</literal>) &amp; <literal type="number">255</literal>, (i &gt;&gt; <literal type="number">16</literal>) &amp; <literal type="number">255</literal>, (i &gt;&gt; <literal type="number">24</literal>) &amp; <literal type="number">255</literal>);

	h.id = qid;
	h.qr = <literal type="number">0</literal>;
	h.rd = <literal type="number">1</literal>;
	h.opcode = <literal type="number">0</literal>;		<comment type="block">/* QUERY */</comment>
	h.qdcount = (unsigned int) <literal type="number">1</literal>;

	offset += rfc1035_header_pack(buf + offset, sz - offset, &amp;h);
	offset += rfc1035_question_pack(buf + offset, sz - offset, rev,
			RFC1035_TYPE_PTR, RFC1035_CLASS_IN);

	if (query) {
		query-&gt;qtype = RFC1035_TYPE_PTR;
		query-&gt;qclass = RFC1035_CLASS_IN;
		SAFE_STRNCPY(query-&gt;name, rev, sizeof(query-&gt;name));
	}

	if (offset &gt; sz) {
		msg_fatal(<literal type="string">"%s: offset(%d) &gt; sz(%d)"</literal>,
			myname, (int) offset, (int) sz);
	}

	return offset;
}

void rfc1035_set_query_id(char *buf, size_t sz, unsigned short qid)
{
	unsigned short s = htons(qid);

	if (sz &gt; sizeof(s)) {
		sz = sizeof(s);
	}
	memcpy(buf, &amp;s, sz);
}

<comment type="block" format="doxygen">/****************************************************************************/</comment>

<comment type="block" format="doxygen">/**
 * rfc1035_header_unpack()
 *
 * Unpacks a RFC1035 message header buffer into the header fields
 * of the RFC1035_MESSAGE structure.
 *
 * Updates the buffer offset, which is the same as number of
 * octects unpacked since the header starts at offset 0.
 *
 * Returns 0 (success) or 1 (error)
 */</comment>
static int rfc1035_header_unpack(const char *buf, size_t sz, size_t *off,
	RFC1035_MESSAGE *h)
{
	const char *myname = <literal type="string">"rfc1035_header_unpack"</literal>;
	unsigned short s;
	unsigned short t;

	assert(h);

	if (*off != <literal type="number">0</literal>) {
		msg_error(<literal type="string">"%s: *off(%d) != 0"</literal>, myname, (int) *off);
		return -RFC1035_UNPACK_ERROR;
	}

	<comment type="block">/*
	 * The header is 12 octets.  This is a bogus message if the size
	 * is less than that.
	 */</comment>
	if (sz &lt; <literal type="number">12</literal>) {
		return <literal type="number">1</literal>;
	}

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);

	h-&gt;id = ntohs(s);
	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);

	t = ntohs(s);
	h-&gt;qr = (t &gt;&gt; <literal type="number">15</literal>) &amp; <literal type="number">0x01</literal>;
	h-&gt;opcode = (t &gt;&gt; <literal type="number">11</literal>) &amp; <literal type="number">0x0F</literal>;
	h-&gt;aa = (t &gt;&gt; <literal type="number">10</literal>) &amp; <literal type="number">0x01</literal>;
	h-&gt;tc = (t &gt;&gt; <literal type="number">9</literal>) &amp; <literal type="number">0x01</literal>;
	h-&gt;rd = (t &gt;&gt; <literal type="number">8</literal>) &amp; <literal type="number">0x01</literal>;
	h-&gt;ra = (t &gt;&gt; <literal type="number">7</literal>) &amp; <literal type="number">0x01</literal>;

	<comment type="block">/* We might want to check that the reserved 'Z' bits (6-4) are
	 * all zero as per RFC 1035.  If not the message should be
	 * rejected.
	 */</comment>
	h-&gt;rcode = t &amp; <literal type="number">0x0F</literal>;

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	h-&gt;qdcount = ntohs(s);

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	h-&gt;ancount = ntohs(s);

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	h-&gt;nscount = ntohs(s);

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	h-&gt;arcount = ntohs(s);

	if (*off != <literal type="number">12</literal>) {
		msg_error(<literal type="string">"%s: *off(%d) != 12"</literal>, myname, (int) *off);
		return -RFC1035_UNPACK_ERROR;
	}
	return <literal type="number">0</literal>;
}

<comment type="block" format="doxygen">/**
 * rfc1035_query_unpack()
 *
 * Unpacks a RFC1035 Query Record into 'query' from a message buffer.
 *
 * Updates the new message buffer offset.
 *
 * Returns 0 (success) or 1 (error)
*/</comment>
static int rfc1035_query_unpack(const char *buf, size_t sz, size_t *off,
	RFC1035_QUERY *query)
{
	unsigned short s;

	if (rfc1035_name_unpack(buf, sz, off, NULL, query-&gt;name,
		RFC1035_MAXHOSTNAMESZ, <literal type="number">0</literal>)) {

		RFC1035_UNPACK_DEBUG;
		memset(query, <literal type="char">'\0'</literal>, sizeof(*query));
		return <literal type="number">1</literal>;
	}

	if (*off + <literal type="number">4</literal> &gt; sz) {
		RFC1035_UNPACK_DEBUG;
		memset(query, <literal type="char">'\0'</literal>, sizeof(*query));
		return <literal type="number">1</literal>;
	}

	memcpy(&amp;s, buf + *off, <literal type="number">2</literal>);
	*off += <literal type="number">2</literal>;
	query-&gt;qtype = ntohs(s);

	memcpy(&amp;s, buf + *off, <literal type="number">2</literal>);
	*off += <literal type="number">2</literal>;
	query-&gt;qclass = ntohs(s);

	return <literal type="number">0</literal>;
}

<comment type="block" format="doxygen">/**
 * rfc1035_rr_unpack()
 *
 * Unpacks a RFC1035 Resource Record into 'RR' from a message buffer.
 * The caller must free RR-&gt;rdata!
 *
 * Updates the new message buffer offset.
 *
 * Returns 0 (success) or 1 (error)
 */</comment>
static int rfc1035_rr_unpack(const char *buf, size_t sz, size_t *off, RFC1035_RR *rr)
{
	const char *myname = <literal type="string">"rfc1035_rr_unpack"</literal>;
	unsigned short s;
	unsigned int i;
	unsigned short rdlength;
	size_t rdata_off;

	if (rfc1035_name_unpack(buf, sz, off, NULL, rr-&gt;name,
		RFC1035_MAXHOSTNAMESZ, <literal type="number">0</literal>)) {

		RFC1035_UNPACK_DEBUG;
		memset(rr, <literal type="char">'\0'</literal>, sizeof(*rr));
		return <literal type="number">1</literal>;
	}

	<comment type="block">/* Make sure the remaining message has enough octets for the
	* rest of the RR fields.
	*/</comment>
	if ((*off) + <literal type="number">10</literal> &gt; sz) {
		RFC1035_UNPACK_DEBUG;
		memset(rr, <literal type="char">'\0'</literal>, sizeof(*rr));
		return <literal type="number">1</literal>;
	}

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	rr-&gt;type = ntohs(s);

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	rr-&gt;tclass = ntohs(s);

	memcpy(&amp;i, buf + (*off), sizeof(i));
	(*off) += sizeof(i);
	rr-&gt;ttl = ntohl(i);

	memcpy(&amp;s, buf + (*off), sizeof(s));
	(*off) += sizeof(s);
	rdlength = ntohs(s);

	if ((*off) + rdlength &gt; sz) {
		<comment type="block">/* We got a truncated packet.  'dnscache' truncates UDP
		 * replies at 512 octets, as per RFC 1035.
		 */</comment>
		RFC1035_UNPACK_DEBUG;
		memset(rr, <literal type="char">'\0'</literal>, sizeof(*rr));
		return <literal type="number">1</literal>;
	}

	rr-&gt;rdlength = rdlength;

	switch (rr-&gt;type) {
	case RFC1035_TYPE_CNAME:
	case RFC1035_TYPE_NS:
	case RFC1035_TYPE_TXT:
	case RFC1035_TYPE_PTR:
	case RFC1035_TYPE_WKS:
		rr-&gt;rdata = (char*) malloc(RFC1035_MAXHOSTNAMESZ);
		rdata_off = *off;
		rr-&gt;rdlength = <literal type="number">0</literal>;	<comment type="block">/* Filled in by rfc1035_name_unpack */</comment>

		if (rfc1035_name_unpack(buf, sz, &amp;rdata_off, &amp;rr-&gt;rdlength,
			rr-&gt;rdata, RFC1035_MAXHOSTNAMESZ, <literal type="number">0</literal>)) {
			return <literal type="number">1</literal>;
		}

		if (rdata_off &gt; ((*off) + rdlength)) {
			<comment type="block">/* This probably doesn't happen for valid packets, but
			 * I want to make sure that NameUnpack doesn't go beyond
			 * the RDATA area.
			 */</comment>
			RFC1035_UNPACK_DEBUG;
			free(rr-&gt;rdata);
			memset(rr, <literal type="char">'\0'</literal>, sizeof(*rr));
			return <literal type="number">1</literal>;
		}
		break;
	case RFC1035_TYPE_A:
	case RFC1035_TYPE_AAAA:
	case RFC1035_TYPE_MX:
	default:
		rr-&gt;rdata = (char*) malloc(rdlength);
		memcpy(rr-&gt;rdata, buf + (*off), rdlength);
		break;
	}

	(*off) += rdlength;
	if (*off &gt; sz) {
		msg_error(<literal type="string">"%s: *off(%d) &gt; sz(%d)"</literal>,
			myname, (int) *off, (int) sz);
		return -RFC1035_UNPACK_ERROR;
	}

	return <literal type="number">0</literal>;
}

static RFC1035_RR *rfc1035_unpack2rr(const char *buf, size_t sz,
	size_t *off, size_t count, int *nr)
{
	size_t i;
	RFC1035_RR *rr;

	*nr = <literal type="number">0</literal>;

	if (count == <literal type="number">0</literal>) {
		return NULL;
	}

	rr = (RFC1035_RR*) calloc(count, sizeof(RFC1035_RR));
	for (i = <literal type="number">0</literal>; i &lt; count; i++) {
		if (*off &gt;= sz) {	<comment type="block">/* corrupt packet */</comment>
			RFC1035_UNPACK_DEBUG;
			break;
		}

		if (rfc1035_rr_unpack(buf, sz, off, &amp;rr[i])) {
			RFC1035_UNPACK_DEBUG;
			break;
		}
		(*nr)++;
	}

	if (*nr == <literal type="number">0</literal>) {
		free(rr);
		return NULL;
	}

	return rr;
}

RFC1035_MESSAGE *rfc1035_response_unpack(const char *buf, size_t sz)
{
	int i</argument>, <argument>nr;
	size_t off = <literal type="number">0</literal>;
	RFC1035_MESSAGE *msg;

	errno = <literal type="number">0</literal>;
	msg = (RFC1035_MESSAGE*) calloc(<literal type="number">1</literal>, sizeof(*msg));

	if (rfc1035_header_unpack(buf + off, sz - off, &amp;off, msg)) {
		RFC1035_UNPACK_DEBUG;
		rfc1035_set_errno(RFC1035_UNPACK_ERROR);
		rfc1035_message_destroy(msg);
		return NULL;
	}

	if (msg-&gt;rcode) {
		RFC1035_UNPACK_DEBUG;
		rfc1035_set_errno((int) msg-&gt;rcode);
		rfc1035_message_destroy(msg);
		return NULL;
	}

	if (msg-&gt;ancount == <literal type="number">0</literal>) {
		rfc1035_message_destroy(msg);
		return NULL;
	}

	if (msg-&gt;qdcount != <literal type="number">1</literal>) {
		<comment type="block">/* This can not be an answer to our queries.. */</comment>
		RFC1035_UNPACK_DEBUG;
		rfc1035_set_errno(RFC1035_UNPACK_ERROR);
		rfc1035_message_destroy(msg);
		return NULL;
	}

	msg-&gt;query = (RFC1035_QUERY*) calloc((int) msg-&gt;qdcount,
			sizeof(RFC1035_QUERY));

	for (i = <literal type="number">0</literal>; i &lt; (int) msg-&gt;qdcount; i++) {
		if (rfc1035_query_unpack(buf, sz, &amp;off, &amp;msg-&gt;query[i])) {
			RFC1035_UNPACK_DEBUG;
			rfc1035_set_errno(RFC1035_UNPACK_ERROR);
			rfc1035_message_destroy(msg);
			return NULL;
		}
	}

	msg-&gt;answer = rfc1035_unpack2rr(buf, sz, &amp;off, msg-&gt;ancount, &amp;nr);
	msg-&gt;ancount = (unsigned short) nr;  <comment type="block">/* reset the valid ancount */</comment>

	if (msg-&gt;answer == NULL) {
		<comment type="block">/* we expected to unpack some answers (ancount != 0), but
		 * didn't actually get any.
		 */</comment>
		RFC1035_UNPACK_DEBUG;
		rfc1035_message_destroy(msg);
		rfc1035_set_errno(RFC1035_UNPACK_ERROR);
		return NULL;
	}

	if (msg-&gt;nscount &gt; <literal type="number">0</literal>) {
		msg-&gt;authority = rfc1035_unpack2rr(buf, sz, &amp;off,
			msg-&gt;nscount, &amp;nr);
		msg-&gt;nscount = (unsigned short) nr;
		if (msg-&gt;authority == NULL) {
			RFC1035_UNPACK_DEBUG;
			rfc1035_message_destroy(msg);
			rfc1035_set_errno(RFC1035_UNPACK_ERROR);
			return NULL;
		}
	}

	if (msg-&gt;arcount &gt; <literal type="number">0</literal>) {
		msg-&gt;additional = rfc1035_unpack2rr(buf, sz, &amp;off,
			msg-&gt;arcount, &amp;nr);
		msg-&gt;arcount = (unsigned short) nr;
		if (msg-&gt;additional == NULL) {
			RFC1035_UNPACK_DEBUG;
			rfc1035_message_destroy(msg);
			rfc1035_set_errno(RFC1035_UNPACK_ERROR);
			return NULL;
		}
	}

	return msg;
}

RFC1035_MESSAGE *rfc1035_request_unpack(const char *buf, size_t sz)
{
	int i;
	size_t off = <literal type="number">0</literal>;
	RFC1035_MESSAGE *msg;

	errno = <literal type="number">0</literal>;
	msg = (RFC1035_MESSAGE*) calloc(<literal type="number">1</literal>, sizeof(*msg));

	if (rfc1035_header_unpack(buf + off, sz - off, &amp;off, msg)) {
		RFC1035_UNPACK_DEBUG;
		rfc1035_set_errno(RFC1035_UNPACK_ERROR);
		rfc1035_message_destroy(msg);
		return NULL;
	}

	if (msg-&gt;rcode) {
		RFC1035_UNPACK_DEBUG;
		rfc1035_set_errno((int) msg-&gt;rcode);
		rfc1035_message_destroy(msg);
		return NULL;
	}

	if (msg-&gt;qdcount != <literal type="number">1</literal>) {
		<comment type="block">/* This can not be an answer to our queries.. */</comment>
		RFC1035_UNPACK_DEBUG;
		rfc1035_set_errno(RFC1035_UNPACK_ERROR);
		rfc1035_message_destroy(msg);
		return NULL;
	}

	msg-&gt;query = (RFC1035_QUERY*) calloc((int) msg-&gt;qdcount,
			sizeof(RFC1035_QUERY));

	for (i = <literal type="number">0</literal>; i &lt; (int) msg-&gt;qdcount; i++) {
		if (rfc1035_query_unpack(buf, sz, &amp;off, &amp;msg-&gt;query[i])) {
			RFC1035_UNPACK_DEBUG;
			rfc1035_set_errno(RFC1035_UNPACK_ERROR);
			rfc1035_message_destroy(msg);
		}
	}

	return msg;
}

<comment type="block" format="doxygen">/****************************************************************************/</comment>

static void rfc1035_rr_destroy(RFC1035_RR *rr, int n)
{
	const char *myname = <literal type="string">"rfc1035_rr_destroy"</literal>;

	if (rr == NULL) {
		return;
	}

	if (n &lt;= <literal type="number">0</literal>) {
		msg_error(<literal type="string">"%s: n(%d) &lt;= 0"</literal>, myname, n);
		free(rr);
		return;
	}

	while (n--) {
		if (rr[n].rdata) {
			free(rr[n].rdata);
		}
	}

	free(rr);
}

void rfc1035_message_destroy(RFC1035_MESSAGE *msg)
{
	if (!msg) {
		return;
	}

	if (msg-&gt;query) {
		free(msg-&gt;query);
	}

	if (msg-&gt;answer) {
		rfc1035_rr_destroy(msg-&gt;answer, msg-&gt;ancount);
	}

	if (msg-&gt;authority) {
		rfc1035_rr_destroy(msg-&gt;authority, msg-&gt;nscount);
	}

	if (msg-&gt;additional) {
		rfc1035_rr_destroy(msg-&gt;additional, msg-&gt;arcount);
	}

	free(msg);
}

<comment type="block" format="doxygen">/****************************************************************************/</comment>

size_t rfc1035_build_reply4a(const char *hostname, const ARGV *ips,
	const char *domain_root, const char *dnsname, const char *dnsip,
	unsigned short qid, char *buf, size_t sz)
{
	RFC1035_REPLY reply;

	memset(&amp;reply, <literal type="number">0</literal>, sizeof(reply));
	reply.hostname = hostname;
	reply.ips = ips;
	reply.domain_root = domain_root;
	reply.dns_name = dnsname;
	reply.dns_ip = dnsip;
	reply.ip_type = RFC1035_TYPE_A;
	reply.ttl = <literal type="number">600</literal>;
	reply.qid = qid;

	return rfc1035_build_reply(&amp;reply, buf, sz);
}

size_t rfc1035_build_reply4aaaa(const char *hostname, const ARGV *ips,
	const char *domain_root, const char *dnsname, const char *dnsip,
	unsigned short qid, char *buf, size_t sz)
{
	RFC1035_REPLY reply;

	memset(&amp;reply, <literal type="number">0</literal>, sizeof(reply));
	reply.hostname = hostname;
	reply.ips = ips;
	reply.domain_root = domain_root;
	reply.dns_name = dnsname;
	reply.dns_ip = dnsip;
	reply.ip_type = RFC1035_TYPE_AAAA;
	reply.ttl = <literal type="number">600</literal>;
	reply.qid = qid;

	return rfc1035_build_reply(&amp;reply, buf, sz);
}

static size_t save_addr2rr(int type, const char *src, RFC1035_RR *rr)
{
	if (type == RFC1035_TYPE_A) {
		unsigned int nip;
		rr-&gt;rdlength = <literal type="number">4</literal>;
		nip = inet_addr(src);
		rr-&gt;rdata = (char*) calloc(<literal type="number">1</literal>, rr-&gt;rdlength);
		memcpy(rr-&gt;rdata, &amp;nip, rr-&gt;rdlength);

		return rr-&gt;rdlength;
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>AF_INET6</name></cpp:ifdef>
	} else if (type == RFC1035_TYPE_AAAA) {
		char buf[<literal type="number">256</literal>]</argument>, <argument>*ptr;
		struct sockaddr_in6 in6;

		SAFE_STRNCPY(buf, src, sizeof(buf));
		<comment type="block">/* when '%' was appended to the IPV6's addr */</comment>
		if ((ptr = strrchr(buf, <literal type="char">'%'</literal>))) {
			*ptr++ = <literal type="number">0</literal>;
		}

		memset(&amp;in6, <literal type="number">0</literal>, sizeof(struct sockaddr_in6));
		in6.sin6_family = AF_INET6;
		in6.sin6_port   = htons(<literal type="number">0</literal>);

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SYS_UNIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>SYS_WIN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>_MSC_VER</name> <operator>&gt;=</operator> <literal type="number">1600</literal><operator>)</operator></expr></cpp:if>
		if (ptr &amp;&amp; *ptr &amp;&amp; !(in6.sin6_scope_id = if_nametoindex(ptr))) {
			msg_error(<literal type="string">"%s(%d): if_nametoindex error %s"</literal>,
				__FUNCTION__, __LINE__, last_serror());
			return <literal type="number">0</literal>;
		}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		if (inet_pton(AF_INET6, buf, &amp;in6.sin6_addr) == <literal type="number">0</literal>) {
			msg_error(<literal type="string">"%s(%d): invalid addr=%s"</literal>,
				__FUNCTION__, __LINE__, src);
			return <literal type="number">0</literal>;
		}

		rr-&gt;rdlength = sizeof(in6.sin6_addr);
		rr-&gt;rdata = (char*) calloc(<literal type="number">1</literal>, rr-&gt;rdlength);
		memcpy(rr-&gt;rdata, &amp;in6.sin6_addr, rr-&gt;rdlength);

		return rr-&gt;rdlength;
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	else {
		msg_error(<literal type="string">"%s(%d): not support type=%d"</literal>,
		      __FUNCTION__, __LINE__, type);
		return <literal type="number">0</literal>;
	}
}

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAFE_FREE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { if ((x)) free ((x)); } while(0)</cpp:value></cpp:define>

size_t rfc1035_build_reply(const RFC1035_REPLY *reply, char *buf, size_t sz)
{
	RFC1035_MESSAGE h;
	RFC1035_RR rr;
	size_t offset = <literal type="number">0</literal>;
	int   i;

	if (reply-&gt;ips == NULL || reply-&gt;ips-&gt;argc &lt;= <literal type="number">0</literal>) {
		msg_error(<literal type="string">"ips null"</literal>);
		return <literal type="number">0</literal>;
	}

	memset(&amp;h, <literal type="char">'\0'</literal>, sizeof(h));
	h.id = reply-&gt;qid;
	h.qr = <literal type="number">1</literal>;		<comment type="block">/* response */</comment>
	h.opcode = <literal type="number">0</literal>;		<comment type="block">/* QUERY */</comment>
	h.aa = <literal type="number">0</literal>;
	h.tc = <literal type="number">0</literal>;
	h.rd = <literal type="number">1</literal>;
	h.ra = <literal type="number">0</literal>;
	h.rcode = <literal type="number">0</literal>;
	h.qdcount = <literal type="number">1</literal>;
	h.ancount = reply-&gt;ips-&gt;argc;
	h.nscount = (reply-&gt;dns_name &amp;&amp; *reply-&gt;dns_name) ? <literal type="number">1</literal> : <literal type="number">0</literal>;
	h.arcount = (h.nscount &amp;&amp; reply-&gt;dns_ip &amp;&amp; *reply-&gt;dns_ip) ? <literal type="number">1</literal> : <literal type="number">0</literal>;

	offset += rfc1035_header_pack(buf + offset, sz - offset, &amp;h);
	offset += rfc1035_question_pack(buf + offset, sz - offset,
			reply-&gt;hostname, reply-&gt;ip_type, RFC1035_CLASS_IN);

	for (i = <literal type="number">0</literal>; i &lt; reply-&gt;ips-&gt;argc; i++) {
		memset(&amp;rr, <literal type="number">0</literal>, sizeof(rr));
		SAFE_STRNCPY(rr.name, reply-&gt;hostname, sizeof(rr.name));
		rr.type = reply-&gt;ip_type;
		rr.tclass = RFC1035_CLASS_IN;
		rr.ttl = reply-&gt;ttl;

		if (!save_addr2rr(reply-&gt;ip_type, reply-&gt;ips-&gt;argv[i], &amp;rr)) {
			msg_error(<literal type="string">"%s(%d): invalid ip=%s"</literal>,
				__FUNCTION__ , __LINE__, reply-&gt;ips-&gt;argv[i]);
			return <literal type="number">0</literal>;
		}

		offset += rfc1035_rr_pack(&amp;rr, buf + offset, sz - offset);
		SAFE_FREE(rr.rdata);
	}

	if (h.nscount) {
		memset(&amp;rr, <literal type="number">0</literal>, sizeof(rr));
		SAFE_STRNCPY(rr.name, reply-&gt;domain_root, sizeof(rr.name));
		rr.type = RFC1035_TYPE_NS;
		rr.tclass = RFC1035_CLASS_IN;
		rr.ttl = reply-&gt;ttl;
		rr.rdlength = (unsigned short) strlen(reply-&gt;dns_name);
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SYS_WIN</name></cpp:ifdef>
		rr.rdata = _strdup(reply-&gt;dns_name);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		rr.rdata = strdup(reply-&gt;dns_name);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		offset += rfc1035_rr_pack(&amp;rr, buf + offset, sz - offset);
		SAFE_FREE(rr.rdata);
	}

	if (h.arcount) {
		memset(&amp;rr, <literal type="number">0</literal>, sizeof(rr));
		SAFE_STRNCPY(rr.name, reply-&gt;dns_name, sizeof(rr.name));
		rr.type = reply-&gt;ip_type;
		rr.tclass = RFC1035_CLASS_IN;
		rr.ttl = reply-&gt;ttl;

		if (!save_addr2rr(reply-&gt;ip_type, reply-&gt;dns_ip, &amp;rr)) {
			msg_error(<literal type="string">"%s(%d): invalid ip=%s"</literal>,
				__FUNCTION__ , __LINE__, reply-&gt;dns_ip);
			return <literal type="number">0</literal>;
		}

		offset += rfc1035_rr_pack(&amp;rr, buf + offset, sz - offset);
		SAFE_FREE(rr.rdata);
	}

	return offset;
}</argument></argument_list></macro></block_content></block></function>

<comment type="block" format="doxygen">/****************************************************************************/</comment>
</unit>
