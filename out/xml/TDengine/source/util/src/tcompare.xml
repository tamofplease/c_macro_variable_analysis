<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/TDengine/source/util/src/tcompare.c"><comment type="block">/*
 * Copyright (c) 2019 TAOS Data, Inc. &lt;jhtao@taosdata.com&gt;
 *
 * This program is free software: you can use, redistribute, and/or modify
 * it under the terms of the GNU Affero General Public License, version 3
 * or later ("AGPL"), as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_BSD_SOURCE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_GNU_SOURCE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_XOPEN_SOURCE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DEFAULT_SOURCE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcompare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regex.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"thash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"types.h"</cpp:file></cpp:include>

<function><type><name>int32_t</name></type> <name>setChkInBytes1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkInBytes2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkInBytes4</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkInBytes8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkNotInBytes1</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkNotInBytes2</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkNotInBytes4</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>setChkNotInBytes8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareChkInString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>!=</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareChkNotInString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><name>NULL</name> <operator>==</operator> <call><name>taosHashGet</name><argument_list>(<argument><expr><operator>(</operator><name>SHashObj</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>, <argument><expr><call><name>varDataTLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareInt8Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareInt16Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareInt32Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareInt64Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareUint32Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareUint64Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareUint16Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8ValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareUint8Val</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type> <name>p1</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type> <name>p2</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><call><name>FLT_GREATER</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareFloatVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>p1</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>p2</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><call><name>FLT_GREATER</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareDoubleVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareLenPrefixedStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len1</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len2</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>minLen</name> <init>= <expr><call><name>TMIN</name><argument_list>(<argument><expr><name>len1</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>minLen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>len1</name> <operator>==</operator> <name>len2</name></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><ternary><condition><expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareLenPrefixedStrDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>compareLenPrefixedStr</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareLenPrefixedWStr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len1</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>len2</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>len1</name> <operator>!=</operator> <name>len2</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>len1</name> <operator>&gt;</operator> <name>len2</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><name>pLeft</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
      <return>return <expr><literal type="number">0</literal></expr>;</return>
    </block_content>}</block></if> <else>else <block>{<block_content>
      <return>return <expr><ternary><condition><expr><name>ret</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block></else></if_stmt>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareLenPrefixedWStrDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><call><name>compareLenPrefixedWStr</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// string &gt; number &gt; bool &gt; null</comment>
<comment type="line">// ref: https://dev.mysql.com/doc/refman/8.0/en/json.html#json-comparison</comment>
<function><type><name>int32_t</name></type> <name>compareJsonVal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>leftType</name> <init>= <expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pLeft</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>rightType</name> <init>= <expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pRight</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>!=</operator> <name>rightType</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><ternary><condition><expr><name>leftType</name> <operator>&gt;</operator> <name>rightType</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>realDataLeft</name> <init>= <expr><call><name>POINTER_SHIFT</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>CHAR_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>realDataRight</name> <init>= <expr><call><name>POINTER_SHIFT</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>CHAR_BYTES</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>leftType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_BOOL</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>realDataLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>realDataRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>leftType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_DOUBLE</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>DEFAULT_DOUBLE_COMP</name><argument_list>(<argument><expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>realDataLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>realDataRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>leftType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NCHAR</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><call><name>compareLenPrefixedWStr</name><argument_list>(<argument><expr><name>realDataLeft</name></expr></argument>, <argument><expr><name>realDataRight</name></expr></argument>)</argument_list></call></expr>;</return>
  </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>leftType</name> <operator>==</operator> <name>TSDB_DATA_TYPE_NULL</name></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if> <else>else <block>{<block_content>
    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>  <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt8Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>left</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>   <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt16Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int16_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>   <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt32Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>   <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareInt64Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatInt8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>  <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatInt16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>   <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatInt32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>   <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>   <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatDouble</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>  <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type> <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><call><name>FLT_GREATER</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatUint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>   <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatUint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>    <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatUint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>    <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareFloatUint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>float</name></type>    <name>left</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleInt8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleInt16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>  <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleInt32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>  <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleInt64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>  <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleFloat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type> <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>  <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isnan</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><call><name>FLT_EQUAL</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
    <return>return <expr><literal type="number">0</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>
  <return>return <expr><ternary><condition><expr><call><name>FLT_GREATER</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleUint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>  <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleUint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>   <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleUint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>   <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareDoubleUint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>double</name></type>   <name>left</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>   <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>  <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint8Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>left</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>    <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>   <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint16Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>    <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>   <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint32Uint64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Int8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int8_t</name></type>   <name>right</name> <init>= <expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Int16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int16_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Int32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Int64</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int64_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Float</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>float</name></type>    <name>right</name> <init>= <expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Double</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>double</name></type>   <name>right</name> <init>= <expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Uint8</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint8_t</name></type>  <name>right</name> <init>= <expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Uint16</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint16_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareUint64Uint32</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>uint64_t</name></type> <name>left</name> <init>= <expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>uint32_t</name></type> <name>right</name> <init>= <expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&gt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>right</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
  <return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareJsonValDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareJsonVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>, <argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>
<comment type="block">/*
 * Compare two strings
 *    TSDB_MATCH:            Match
 *    TSDB_NOMATCH:          No match
 *    TSDB_NOWILDCARDMATCH:  No match in spite of having * or % wildcards.
 * Like matching rules:
 *      '%': Matches zero or more characters
 *      '_': Matches one character
 *
 */</comment>
<function><type><name>int32_t</name></type> <name>patternMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patterStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SPatternCompareInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c1</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>o</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>m</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>patterStr</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>matchAll</name></name></expr>)</condition> <block>{<block_content> <comment type="block">/* Match "*" */</comment>

      <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>patterStr</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>matchAll</name></name> <operator>||</operator> <name>c</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>matchOne</name></name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>matchOne</name></name></expr>)</condition> <block>{<block_content>
          <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>size</name> <operator>||</operator> <name><name>str</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
            <comment type="line">// empty string, return not match</comment>
            <return>return <expr><name>TSDB_PATTERN_NOWILDCARDMATCH</name></expr>;</return>
          </block_content>}</block></if> <else>else <block>{<block_content>
            <expr_stmt><expr><operator>++</operator><name>o</name></expr>;</expr_stmt>
          </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>

      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>TSDB_PATTERN_MATCH</name></expr>;</return> <comment type="block">/* "*" at the end of the pattern matches */</comment>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>char</name></type> <name><name>next</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>m</name> <operator>=</operator> <name>o</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>strcspn</name><argument_list>(<argument><expr><name>str</name> <operator>+</operator> <name>m</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>str</name> <operator>+=</operator> <name>m</name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>

        <if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>n</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>patternMatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>patterStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>++</operator><name>str</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_PATTERN_NOMATCH</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>ret</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
        <expr_stmt><expr><name>m</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
      </block_content>}</block></while>
      <return>return <expr><name>TSDB_PATTERN_NOWILDCARDMATCH</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>c1</name> <operator>=</operator> <name><name>str</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><operator>++</operator><name>o</name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>patterStr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name>c1</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>c1</name> <operator>||</operator> <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>tolower</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name><name>pInfo</name><operator>-&gt;</operator><name>matchOne</name></name> <operator>&amp;&amp;</operator> <name>c1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>TSDB_PATTERN_NOMATCH</name></expr>;</return>
  </block_content>}</block></while>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator></expr> ?</condition><then> <expr><name>TSDB_PATTERN_MATCH</name></expr> </then><else>: <expr><name>TSDB_PATTERN_NOMATCH</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>WCSPatternMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>TdUcs4</name> <modifier>*</modifier></type><name>patterStr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TdUcs4</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>SPatternCompareInfo</name> <modifier>*</modifier></type><name>pInfo</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>TdUcs4</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TdUcs4</name></type> <name>matchOne</name> <init>= <expr><name>L</name><literal type="char">'_'</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// "_"</comment>
  <decl_stmt><decl><type><name>TdUcs4</name></type> <name>matchAll</name> <init>= <expr><name>L</name><literal type="char">'%'</literal></expr></init></decl>;</decl_stmt>  <comment type="line">// "%"</comment>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>patterStr</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>matchAll</name></expr>)</condition> <block>{<block_content> <comment type="block">/* Match "%" */</comment>

      <while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>patterStr</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator> <operator>==</operator> <name>matchAll</name> <operator>||</operator> <name>c</name> <operator>==</operator> <name>matchOne</name></expr>)</condition> <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>matchOne</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>j</name> <operator>&gt;=</operator> <name>size</name> <operator>||</operator> <name><name>str</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>TSDB_PATTERN_NOWILDCARDMATCH</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>TSDB_PATTERN_MATCH</name></expr>;</return>
      </block_content>}</block></if></if_stmt>

      <decl_stmt><decl><type><name>TdUcs4</name></type> <name><name>accept</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><call><name>towupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>, <expr><call><name>towlower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>size_t</name></type> <name>n</name> <init>= <expr><call><name>wcscspn</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>accept</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><name>str</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>
        <if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>n</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator></expr>)</condition> <block>{<block_content>
          <break>break;</break>
        </block_content>}</block></if></if_stmt>

        <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>WCSPatternMatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>patterStr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>++</operator><name>str</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>n</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>pInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>TSDB_PATTERN_NOMATCH</name></expr>)</condition> <block>{<block_content>
          <return>return <expr><name>ret</name></expr>;</return>
        </block_content>}</block></if></if_stmt>
      </block_content>}</block></while>

      <return>return <expr><name>TSDB_PATTERN_NOWILDCARDMATCH</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

    <expr_stmt><expr><name>c1</name> <operator>=</operator> <name><name>str</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;=</operator> <name>size</name></expr>)</condition> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>c1</name> <operator>||</operator> <call><name>towlower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>towlower</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <name>matchOne</name> <operator>&amp;&amp;</operator> <name>c1</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
        <continue>continue;</continue>
      </block_content>}</block></if></if_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>TSDB_PATTERN_NOMATCH</name></expr>;</return>
  </block_content>}</block></while>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name><name>str</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>j</name> <operator>&gt;=</operator> <name>size</name><operator>)</operator></expr> ?</condition><then> <expr><name>TSDB_PATTERN_MATCH</name></expr> </then><else>: <expr><name>TSDB_PATTERN_NOMATCH</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareStrRegexCompMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content> <return>return <expr><call><name>compareStrRegexComp</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr>;</return> </block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareStrRegexCompNMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><call><name>compareStrRegexComp</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareStrRegexComp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>sz</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>pattern</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>varDataLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>sz</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>errCode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>regex_t</name></type> <name>regex</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type>    <name><name>msgbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>cflags</name> <init>= <expr><name>REG_EXTENDED</name></expr></init></decl>;</decl_stmt>
  <if_stmt><if>if <condition>(<expr><operator>(</operator><name>errCode</name> <operator>=</operator> <call><name>regcomp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>cflags</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>errCode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>uError</name><argument_list>(<argument><expr><literal type="string">"Failed to compile regex pattern %s. reason %s"</literal></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><literal type="number">1</literal></expr>;</return>
  </block_content>}</block></if></if_stmt>

  <expr_stmt><expr><name>errCode</name> <operator>=</operator> <call><name>regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if_stmt><if>if <condition>(<expr><name>errCode</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errCode</name> <operator>!=</operator> <name>REG_NOMATCH</name></expr>)</condition> <block>{<block_content>
    <expr_stmt><expr><call><name>regerror</name><argument_list>(<argument><expr><name>errCode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>, <argument><expr><name>msgbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>msgbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <macro><name>uDebug</name><argument_list>(<argument><literal type="string">"Failed to match %s with pattern %s, reason %s"</literal></argument>, <argument>str</argument>, <argument>pattern</argument>, <argument>msgbuf</argument>)</argument_list></macro>
  </block_content>}</block></if></if_stmt>
  <decl_stmt><decl><type><name>int32_t</name></type> <name>result</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>errCode</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>regfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>taosArrayCompareString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>x</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>y</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>b</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>compareLenPrefixedStr</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareStrPatternMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SPatternCompareInfo</name></type> <name>pInfo</name> <init>= <expr><block>{<expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'_'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>TSDB_MAX_FIELD_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name>  <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>taosMemoryMalloc</name><argument_list>(<argument><expr><name>sz</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buf</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>patternMatch</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><ternary><condition><expr><operator>(</operator><name>ret</name> <operator>==</operator> <name>TSDB_PATTERN_MATCH</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareStrPatternNotMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><call><name>compareStrPatternMatch</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareWStrPatternMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>SPatternCompareInfo</name></type> <name>pInfo</name> <init>= <expr><block>{<expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'_'</literal></expr>}</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <name>TSDB_MAX_FIELD_LEN</name> <operator>*</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name> <init>= <expr><call><name>taosMemoryCalloc</name><argument_list>(<argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><call><name>varDataVal</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>=
      <expr><call><name>WCSPatternMatch</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><name>pattern</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><call><name>varDataVal</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>varDataLen</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>)</argument_list></call> <operator>/</operator> <name>TSDB_NCHAR_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pInfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>taosMemoryFree</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><ternary><condition><expr><operator>(</operator><name>ret</name> <operator>==</operator> <name>TSDB_PATTERN_MATCH</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>compareWStrPatternNotMatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pLeft</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>pRight</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <return>return <expr><ternary><condition><expr><call><name>compareWStrPatternMatch</name><argument_list>(<argument><expr><name>pLeft</name></expr></argument>, <argument><expr><name>pRight</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>
<function><type><name>__compar_fn_t</name></type> <name>getComparFunc</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>optr</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <decl_stmt><decl><type><name>__compar_fn_t</name></type> <name>comparFn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if_stmt><if>if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_IN</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_BINARY</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_NCHAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
        <return>return <expr><name>setChkInBytes1</name></expr>;</return>
      <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
        <return>return <expr><name>setChkInBytes2</name></expr>;</return>
      <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
        <return>return <expr><name>setChkInBytes4</name></expr>;</return>
      <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
        <return>return <expr><name>setChkInBytes8</name></expr>;</return>
      <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

  <if_stmt><if>if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NOT_IN</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>type</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_BINARY</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <name>TSDB_DATA_TYPE_NCHAR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
    <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
      <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
        <return>return <expr><name>setChkNotInBytes1</name></expr>;</return>
      <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
        <return>return <expr><name>setChkNotInBytes2</name></expr>;</return>
      <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
        <return>return <expr><name>setChkNotInBytes4</name></expr>;</return>
      <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
        <return>return <expr><name>setChkNotInBytes8</name></expr>;</return>
      <default>default:</default>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></switch>
  </block_content>}</block></if></if_stmt>

  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareInt8Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareInt16Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareInt32Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareInt64Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareFloatVal</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareDoubleVal</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_BINARY</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_MATCH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareStrRegexCompMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NMATCH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareStrRegexCompNMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_LIKE</name></expr>)</condition> <block>{<block_content> <comment type="block">/* wildcard query using like operator */</comment>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareStrPatternMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NOT_LIKE</name></expr>)</condition> <block>{<block_content> <comment type="block">/* wildcard query using like operator */</comment>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareStrPatternNotMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_IN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareChkInString</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NOT_IN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareChkNotInString</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content> <comment type="block">/* normal relational comparFn */</comment>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareLenPrefixedStr</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>

      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case> <block>{<block_content>
      <if_stmt><if>if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_MATCH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareStrRegexCompMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NMATCH</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareStrRegexCompNMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_LIKE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareWStrPatternMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NOT_LIKE</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareWStrPatternNotMatch</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_IN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareChkInString</name></expr>;</expr_stmt>
      </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>optr</name> <operator>==</operator> <name>OP_TYPE_NOT_IN</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareChkNotInString</name></expr>;</expr_stmt>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareLenPrefixedWStr</name></expr>;</expr_stmt>
      </block_content>}</block></else></if_stmt>
      <break>break;</break>
    </block_content>}</block>

    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareUint8Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareUint16Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareUint32Val</name></expr>;</expr_stmt>
      <break>break;</break>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareUint64Val</name></expr>;</expr_stmt>
      <break>break;</break>

    <default>default:</default>
      <expr_stmt><expr><name>comparFn</name> <operator>=</operator> <name>compareInt32Val</name></expr>;</expr_stmt>
      <break>break;</break>
  </block_content>}</block></switch>

  <return>return <expr><name>comparFn</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>__compar_fn_t</name></type> <name>getKeyComparFunc</name><parameter_list>(<parameter><decl><type><name>int32_t</name></type> <name>keyType</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>order</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>keyType</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareInt8Val</name></expr> </then><else>: <expr><name>compareInt8ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareInt16Val</name></expr> </then><else>: <expr><name>compareInt16ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareInt32Val</name></expr> </then><else>: <expr><name>compareInt32ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_TIMESTAMP</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareInt64Val</name></expr> </then><else>: <expr><name>compareInt64ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareFloatVal</name></expr> </then><else>: <expr><name>compareFloatValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareDoubleVal</name></expr> </then><else>: <expr><name>compareDoubleValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareUint8Val</name></expr> </then><else>: <expr><name>compareUint8ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareUint16Val</name></expr> </then><else>: <expr><name>compareUint16ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareUint32Val</name></expr> </then><else>: <expr><name>compareUint32ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareUint64Val</name></expr> </then><else>: <expr><name>compareUint64ValDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_BINARY</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareLenPrefixedStr</name></expr> </then><else>: <expr><name>compareLenPrefixedStrDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareLenPrefixedWStr</name></expr> </then><else>: <expr><name>compareLenPrefixedWStrDesc</name></expr></else></ternary></expr>;</return>
    <case>case <expr><name>TSDB_DATA_TYPE_JSON</name></expr>:</case>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareJsonVal</name></expr> </then><else>: <expr><name>compareJsonValDesc</name></expr></else></ternary></expr>;</return>
    <default>default:</default>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>order</name> <operator>==</operator> <name>TSDB_ORDER_ASC</name><operator>)</operator></expr> ?</condition><then> <expr><name>compareInt32Val</name></expr> </then><else>: <expr><name>compareInt32ValDesc</name></expr></else></ternary></expr>;</return>
  </block_content>}</block></switch>
</block_content>}</block></function>

<function><type><name>int32_t</name></type> <name>doCompare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>f2</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>
  <switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>
    <case>case <expr><name>TSDB_DATA_TYPE_INT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_INT32_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_DOUBLE</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_DOUBLE_COMP</name><argument_list>(<argument><expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_DOUBLE_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_FLOAT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_FLOAT_COMP</name><argument_list>(<argument><expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_FLOAT_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_BIGINT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_INT64_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_SMALLINT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_INT16_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_TINYINT</name></expr>:</case>
    <case>case <expr><name>TSDB_DATA_TYPE_BOOL</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_INT8_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_UTINYINT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_UINT8_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_USMALLINT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_UINT16_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_UINT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_UINT32_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_UBIGINT</name></expr>:</case>
      <expr_stmt><expr><call><name>DEFAULT_COMP</name><argument_list>(<argument><expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>f1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GET_UINT64_VAL</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <case>case <expr><name>TSDB_DATA_TYPE_NCHAR</name></expr>:</case> <block>{<block_content>
      <decl_stmt><decl><type><name>tstr</name> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><name>tstr</name> <operator>*</operator><operator>)</operator><name>f1</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tstr</name> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><name>tstr</name> <operator>*</operator><operator>)</operator><name>f2</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>t2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name><name>t1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>t2</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>memcmp</name><argument_list>(<argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><name>t1</name></expr></argument>, <argument><expr><operator>(</operator><name>TdUcs4</name> <operator>*</operator><operator>)</operator><name>t2</name></expr></argument>, <argument><expr><name><name>t2</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>ret</name></expr>;</return>
      </block_content>}</block></if></if_stmt>
      <return>return <expr><ternary><condition><expr><operator>(</operator><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
    </block_content>}</block>
    <default>default:</default> <block>{<block_content>  <comment type="line">// todo refactor</comment>
      <decl_stmt><decl><type><name>tstr</name> <modifier>*</modifier></type><name>t1</name> <init>= <expr><operator>(</operator><name>tstr</name> <operator>*</operator><operator>)</operator><name>f1</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>tstr</name> <modifier>*</modifier></type><name>t2</name> <init>= <expr><operator>(</operator><name>tstr</name> <operator>*</operator><operator>)</operator><name>f2</name></expr></init></decl>;</decl_stmt>

      <if_stmt><if>if <condition>(<expr><name><name>t1</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <name><name>t2</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition> <block>{<block_content>
        <return>return <expr><ternary><condition><expr><name><name>t1</name><operator>-&gt;</operator><name>len</name></name> <operator>&gt;</operator> <name><name>t2</name><operator>-&gt;</operator><name>len</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
      </block_content>}</block></if> <else>else <block>{<block_content>
        <decl_stmt><decl><type><name>int32_t</name></type> <name>ret</name> <init>= <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>t1</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>t2</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>t1</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
          <return>return <expr><literal type="number">0</literal></expr>;</return>
        </block_content>}</block></if> <else>else <block>{<block_content>
          <return>return <expr><ternary><condition><expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>
        </block_content>}</block></else></if_stmt>
      </block_content>}</block></else></if_stmt>
    </block_content>}</block>
  </block_content>}</block></switch>
</block_content>}</block></function>
</unit>
